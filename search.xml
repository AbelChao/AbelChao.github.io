<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[排序的知识点]]></title>
    <url>%2F2018%2F07%2F11%2F%E6%8E%92%E5%BA%8F%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[排序的知识点 序列事先已经基本有序，插入和冒泡会明显减少比较次数，快速排序与主元的选择有关，若一般选子序列左侧第一个元素比较，则第一个元素最好是大小居中的，以使得分成的两个子数组长度大致相等。性能才最佳，快速排序也与初始输入集有关。 堆、归并、直接选择,基数排序的复杂度与初始序列的有序无关。但是只有选择排序的比较次数与初始序列无关;元素的移动次数与关键字的初始排列次序无关的是基数排序. 有环图不能进行拓扑排序。 在待排序数据基本有序的情况下，直接插入排序效果最好。 每经过一次元素的交换会产生新的逆序的是快速排序。 快速排序，在初始序列无序的条件下最快，一旦有序，退化成冒泡排序，时间复杂度是O（n^2），原来是O（nlog2n）。 二分法插入排序所需比较次数与待排序的初始排序状态无关。 外排中使用置换选择排序的目的，是为了增加初始归并段的长度。 若记录的初始状态已经按关键码基本有序，则选用直接插入排序或冒泡排序发为宜 选择排序是小的往前走，冒泡排序是大的往后走。 从未排序序列中依次取出元素与已排序序列中的元素进行比较，将其放入已经排序序列的正确位置上 快排应该用在顺序存储的序列上。 若记录的初始状态已经按关键码基本有序，则选用直接插入排序或冒泡排序发为宜 小堆顶从左开始，大堆顶从右开始. 将两个各有N个元素的有序表归并成一个有序表,其最少的比较次数是N 但是合并M个长度为N的已排序数组的时间复杂度是O(mn(logm)) 插入排序N次,前N+1或者后N+1个数有序. 拓扑排序算法适用于有向无环图. 推排序每趟总能选出一个最大值或者最小值位于根节点. 快排选出的枢纽在一趟排序中就位于了它的最终位置. 冒泡排序在初始关键字序列为逆序的情况下执行的交换次数最多 堆排序不需要等到整个排序结束就可以选出最大的或者最小的前N个数,但是快排和基数排序都不可以. 简单排序中,比较次数与移动次数O(n*n)和O(n) 数据表A中每个元素距其最终位置不远，为了节省时间，应该采取的算法是直接插入 计数排序辅助数组的长度为max-min+1，max和min为待排序序列的最大值和最小值，故C的长度为：3-0+1=4 要与关键字的初始排列次序无关那么就是最好,最坏,一般的情况下排序时间复杂度不变,总共有 堆排序,归并排序,选择排序,基数排序 线性表的长度是n,则在最坏情况下,冒泡排序需要的比较次数是n(n-1)/2 m个元素k路归并的归并趟数s=logk(m)，代入数据：logk(100)≦3 快速排序的平均比较次数最少. 选择排序每扫描一次数组,只需要一次交换. 有向无环图才能进行拓扑排序. 快速排序是在比较排序中平均性能最好的，但还有线性时间排序啊，比如：基数排序，计数排序，桶排序. 快速排序,冒泡排序,直接插入排序的最坏复杂度都是n(n-1)/2 希尔在某趟排序结束后不一定能选出一个元素放到其最终位置上. 归并排序算法在输入数据逆序情况下排序速度最快 如果在一个排序算法的执行过程中，没有一对元素被比较过两次或以上，则称该排序算法为节俭排序算法.插入和归并. 外排序一般用外存存放数据，采用多路归并的方法进行排序.100Mb的内存,对1Gb的数据进行排序. 希尔排序和堆排序都利用了顺序存储的随机访问特性.而链式存储不支持这种性质. 将两个各有n个元素的有序表归并成一个有序表,最少的比较次数是N 同一待排序序列分别进行折半插入排序和直接插入排序，两者之间元素之间的比较次数不同. 注意插入排序是从第二个元素开始向前比(第一个没得比)，到最后一个元素。所以一共n-1趟。 基数排序是稳定的，但是应用于整数，不是实数！ 选择每次从未排序的记录中挑出最小(或最大)关键码字的记录,加入到已排序记录的末尾.起泡排序是加到已排序的开头 基于比较的排序的时间复杂度下限O(nlogn) 利用顺序统计思路找出n个数字的中位数可以再O(n)时间内完成 基于比较的排序问题的时间复杂度下界是O(n*logn) 因为希尔排序 是缩小增量排序，所以对于初始序列有序还是无序没有直接关系。 插入的排序趟数是固定的n-1，即使序列有序，也要依次从第二个元素开始，向前找它的插入位置。 49.总排序趟数与初始状态无关的有：（除了快速排序和优化的冒泡，其他都是）算法复杂度与初始状态无关的有：堆排序、归并排序、选择排序、基数排序。元素总比较次数与初始状态无关的有：选择排序、基数排序。元素总移动次数与初始状态无关的有：归并排序、基数排序。 Insertion sort and bubble sort are not effcient for large data sets. 外部排序最常用的算法是多路归并排序 拓扑排序不是内排序 最好的内排序是快速]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间复杂度与空间复杂度]]></title>
    <url>%2F2018%2F07%2F09%2F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[时间复杂度与空间复杂度 时间复杂度大O渐进表示法一个算法语句总的执行次数是关于问题规模N的某个函数，记为分f(N),N称为问题的规模。语句总的执行次数记为T[N],当N不断变化时，T[N]也在变化，算法的执行次数的增长速率和f(N)的增长速率相同。则T[N]=O(f(N)),称O(f(N))为时间复杂度的O渐进表示法。 概述首先要说的是，时间复杂度的计算并不是计算程序具体运行的时间，而是算法执行语句的次数。 计算方法： 1. 用常数1代替运行时间中的所有加法常数 2. 修改后的运行次数函数中，只保留最高阶项 3. 去除最高阶项的系数 按数量级递增排列，常见的时间复杂度有： 常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n^2)，立方阶O(n^3),…， k次方阶O(n^k),指数阶O(2^n)。 例一如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。 1234567int x=1;while (x &lt;10)&#123; x++;&#125;该算法执行次数是10，是一个常数，用时间复杂度表示是O(1)。 例二当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。 123456789int x=1;for (i = 0; i &lt; n; i++)&#123; for (j = 0; j &lt; n; j++) &#123; x++; &#125;&#125; 该算法for循环，最外层循环每执行一次，内层循环都要执行n次，执行次数是根据n所决定的，时间复杂度是O（n^2） 例三循环不仅与n有关，还与执行循环所满足的判断条件有关。 1234567int i=0;while (i &lt; n &amp;&amp; arr[i]!=1)&#123; i++;&#125;在此循环，如果arr[i]不等于1的话，时间复杂度是O（n）。如果arr[i]等于1的话，则循环不能执行，时间复杂度是0。 例四12345 i=1; while (i&lt;=n) i=i*2; T(n)=O(log2n ) 总结算法的时间复杂度和两个因素有关：算法中的最大嵌套循环层数；最内层循环结构中循环的次数。 空间复杂度空间复杂度(Space Complexity) 是对一个算法在运行过程中临时占用存储空间大小的量度，记做 S(n)=O(f(n)) ，其中n为问题的规模。 对于一个算法来说，空间复杂度和时间复杂度往往是相互影响的。当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，当追求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。 常见排序算法的时间复杂度和空间复杂度空间复杂度，时间复杂度，稳定性，初始序列对排序的时间复杂度的影响。 注意： 1. 基数排序的复杂度中，r代表关键字的基数，d代表长度，n代表关键字的个数。 2. 初始数据集排列顺序与比较次数无关的有：堆排序、归并排序，选择排序。 （一堆海归选基友）。 常见的数据结构的基本操作复杂度]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毕业论文（Massive MIMO）]]></title>
    <url>%2F2018%2F06%2F27%2F%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Massive MIMO 预编码技术研究与实现 Massive MIMO 预编码技术研究与实现概述移动技术的发展 第一代：模拟技术和频分多址（FDMA） 第二代：时分多址（TDMA）和频分多址（FDMA），第二代移动通信系统与第一代移动通信相比将时间和频率结合在一起使用并以此来寻址，增强了整个系统抗干扰能力和抗衰落能力。 第三代：码分多址（CDMA），比第二代，其抗干扰能力和抗多径能力增强，但是由于第三代移动通信系统采用闭环功率控制，这个在电路交换中很容易实现，但是在高速分组业务中，由于数据传输速率很快，而功率控制很慢，导致3G不能传输高速数据。另外，由于3G的带宽有限，传输速率和抗干扰能力之间存在矛盾。 第四代：正交频分复用（OFDM）和多入多出（MIMO）。OFDM是多载波传输的一种。 Massive MIMO的优势和缺点 深度挖掘空间维度资源，使得多个用户可以在同一时频资源上与基站同时进行通信，从而可以很大程度上提升频率效率。 大幅度降低上下行发射功率，提高功率效率。 波束集中在很窄的范围内，大幅度降低了干扰。 基站天线数量趋于无穷时，最简单的线性预编码也能获得很好的性能，且信道中的噪声和不相关干扰可以忽略不计。 Massive MIMO仅考虑时分双工（TDD，Time Division Duplex）系统，该系统利用信道的互易性来获取信道状态信息，然而，因为当前导频空间的维数是有限的，不同小区可能会采用相同的导频序列进行信号发送，导致基站不能区分信号来自哪个小区，不可避免的形成导频污染。 信道模型还不成熟 预编码中矩阵的维度较高，简单的线性预编码中存在矩阵求逆，导致其计算复杂度大幅度提升。 功耗大幅度增加，因此需要设计天线单元和阵列。 什么是导频？什么是导频污染 研究现状 在多用户Massive MIMO系统中，不同信道之间存在相互间的干扰，如何消除这些干扰成为Massive MIMO的主要问题。预编码技术作为Massive MIMO系统中的一项关键技术，通过对发射信号进行预处理，使不同信道之间的干扰得以消除，从而解决多用户Massive MIMO的干扰问题。但由于Massive MIMO系统中，天线数量是目前LTEA的十倍以上，发射天线数目与接收天线数目比值很大，导致Massive MIMO预编码算法必然存在复杂度巨大的问题。 最佳的MIMO预编码方案是脏纸编码(dirty paper coding，DPC)，其是以不可承受的复杂性为代价来实现信道容量的提升。与脏纸编码相比，其他非线性预编码方案复杂性低，可以实现接近脏纸编码的信道容量，如矢量扰动(VP)，格子辅助预编码等。但当基站天线数量变大时这些算法的复杂度太高，阻碍了其在MassiveMIMO中的运用。幸运的是，当BS天线数量大幅度增加时削弱了信道间的干扰，此时，Massive MIMO系统采用简单的、计算复杂度低的线性预编码方案就可以获得很好的性能。 架构 系统模型和原理，对Massive MIMO系统的频谱效率进行了分析。基站侧天线数量越多，非线性预编码的复杂性太高难以承受，而线性预编码的计算复杂度虽然高，但是相比非线性预编码来说已经降低很多了。 ZF、RZF预编码算法的性能仿真，比较采用MRT、RZF、ZF预编码算法的系统频率效率。 TRE和MDPE预编码算法。单小区Massive MIMO系统低复杂度的TPE算法；MDPE算法的改进。 系统模型在多用户MIMO系统中，发射端将输入数据进行串并转换后转变成几路并行的子数据流，再进行预编码处理，然后通过不同的发射天线将进行信号发送。接收端进行一系列的解码处理后即可得到用户所需的数据。MIMO技术将信道分成了几个并行的子信道，在不增加带宽的情况下重复利用频谱资源。理论上频谱效率、无线传输速率、抗干扰、抗衰落能力都可以得到极大提高。 基于随机矩阵理论的证明表明：理想场景下，Massive MIMO可以消除不相关的声和小尺度衰落的影响。每个小区内终端数量独立于小区的大小，与信道相干时间关。简单的信号处理方法可以在Massive MIMO系统中使用并达到很好的性能。 本文主要考虑典型的Massive MIMO系统，即在基站侧有N个天线，同时服务K个单天线用户(N》K)，接收信号Y∈C融1，下行链路系统框图如图2．2，接收信号可以表示为式(2.1)： 点对点单小区，基站配有N个发射天线，接收端配有K个接收天线。接收信号可以表示为 多用户多小区预编码技术Massive MIMO预编码技术从实现方式上可以分为基于非码本和基于码本。而从类型上可以分为非线性和线性。基于非码本的预编码技术包含了非线性预编码和线性预编码两类，这两类预编码都需要发送端获知全部或者部分的信道状态信息(ChannelState Information，CSI)，其信道反馈信息较大，但性能较好。 基于码本的预编码基于码本的预编码通常都是线性预编码，是在发送端和接收端保存相同的码本集合。接收端通过信道估计获得当前的CSI，然后，根据CSI和码本选择方案从码本集合中选取性能最好的码本，并将对应的预编码矩阵指示序号(Precoding matrix index，PMI)反馈给基站，基站根据PMI从码本集合中选取对应的码本进行预编码。基于码本的预编码需要的信道信息反馈量较小，计算复杂度低，现有的码本设计方法(如：基于2D．DFT码本设计)性能较差，不适用于MassiveMIMO系统。新型的码本设计方法(如：基于BD．DFT扩展的码本设计)能够达到不错的性能。 非线性线性 1. ZF预编码 2. MMSE预编码 3. MRT预编码 仿真 上图中，首先，采用matlab滋数randint(100*K枣b，1)产生信源(100为信道变化～次发送信号信号数量，K为终端用户数，b为调制阶数)，然后，经过64QAM调制、复用(鼯16)、预编码、发送信号归一化、乘以P^1/2(P为发送功率)、过信道(信道矩阵服从CN(0，1)分布)、加噪声(n为高斯自噪声)、除以P^1/2，a，p(预编码归一化因子)、解复用、解MQAM调制，最后，得到接收信号(每个dB循环10000次)。 ZF与MMSE算法中SNR和BER的比较1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162%基于ZF准则和MMSE准则的预编码性能比较function zf_mmse()clear allclose allformat long; %将数据显示为长整型科学计数 Nt=4;%天线个数Nr=4;SNR=[0:2:20];%设置不同信噪比channel_n=100*ones(1,length(SNR));error_mmselinp=zeros(1,length(SNR));%初始化误码率error_zflinp=zeros(1,length(SNR));for loop_ebno=1:length(SNR)%不同信噪比的循环 snr=10.^(SNR(loop_ebno)/10);%将信噪比从分贝形式转化成比例表示 ea=1;%每个天线发射的功率，也即信号向量中每个元素的功率 es=ea*Nt;%总共的发射功率 sigma_n2=es/snr;%噪声功率 num=200;%发送数据个数 tic, for loop_channel=1:channel_n(loop_ebno)%信道的实现次数的循环 H=sqrt(1/2)*(randn(Nr,Nt)+j*randn(Nr,Nt));%信道增益矩阵 mmse_F=H'*inv(H*H'+sigma_n2/ea*eye(Nt)); zf_F=H'*inv(H*H'); %求出F^,文献MIMO信道预编码技术研究 beta_mmse=sqrt(es/norm(mmse_F,'fro').^2); beta_zf=sqrt(es/norm(zf_F,'fro').^2);%计算zf_F的Frobenius范数%%求出缩放因子beta F_mmse=beta_mmse*mmse_F; F_zf=beta_zf*zf_F;%求出预编码矩阵F=F^×beta for loop_num=1:num%在一帧数据符号中，信道保持不变。一帧总共有num个数据发送 gen_u=(sign(randn(Nt,1))+j*sign(randn(Nt,1)));%产生信号 u=sqrt(1/2)*gen_u;%归一化信号功率 x_mmse=F_mmse*u; x_zf=F_zf*u;%发送信号 noise=sqrt(sigma_n2/2)*(randn(Nr,1)+j*randn(Nr,1));%生成噪声功率为sigma_n2的噪声 noise1=sqrt(sigma_n2/2)*(randn(Nr,1)+j*randn(Nr,1)); y_mmse=H*x_mmse+noise; y_zf=H*x_zf+noise1; r_mmse=1/beta_mmse*y_mmse; r_zf=1/beta_zf*y_zf;%接收信号 rev_data_mmse=sign(real(r_mmse))+j*sign(imag(r_mmse));%对接收信号进行判决 rev_data_zf=sign(real(r_zf))+j*sign(imag(r_zf)); error_mmselinp(1,loop_ebno)=error_mmselinp(1,loop_ebno)+sum(((abs(rev_data_mmse-gen_u)).^2)/4);%计算误比特数 error_zflinp(1,loop_ebno)=error_zflinp(1,loop_ebno)+sum(((abs(rev_data_zf-gen_u)).^2)/4); end end toc ber_mmselinp(1,loop_ebno)=error_mmselinp(1,loop_ebno)/(num*Nt*2*channel_n(loop_ebno));%注意每一个信噪比产生的数据数=channel_n(loop_ebno)*num*Nt*2, %乘以2是因为，产生的数据符号式复数，相当于进行了4QAM调制 ber_zflinp(1,loop_ebno)=error_zflinp(1,loop_ebno)/(num*Nt*2*channel_n(loop_ebno));end %画出不同准则下误码率和信噪比的曲线P1=semilogy(SNR,ber_mmselinp,'o-r');hold onP2=semilogy(SNR,ber_zflinp,'*-k');set(P1,'Linewidth',[2]);%P1线宽2号set(P2,'Linewidth',[2]);%P2线宽2号grid on;xlabel('symbol SNR(dB)');ylabel('BER');title('基于ZF准则和MMSE准则的预编码性能比较')leg1='mmselinear';%设置图例leg2='zflinear';legend(leg1,leg2);]]></content>
      <categories>
        <category>5G信号源</category>
      </categories>
      <tags>
        <tag>5G信号源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode（二）]]></title>
    <url>%2F2018%2F06%2F26%2FLeetCode%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCode（二） unique paths就是机器人走方格，和走点数的唯一不同就是返回条件不一样 12345678910111213141516171819202122232425262728293031//走交叉点public static int getPath(int row,int column)&#123; if(row==0||column==0) return 1; return getPath(row-1,column)+getPath(row,column-1);&#125;//走方格public static int getPath(int row,int column)&#123; if(row==1||column==1) return 1; return getPath(row-1,column)+getPath(row,column-1);&#125;//走方格非递归public int uniquePath3(int m, int n)&#123; int[][] map = new int[m][n]; for(int i = 0; i&lt;m;i++)&#123; map[i][0] = 1; &#125; for(int j= 0;j&lt;n;j++)&#123; map[0][j]=1; &#125; for(int i = 1;i&lt;m;i++)&#123; for(int j = 1;j&lt;n;j++)&#123; map[i][j] = map[i-1][j]+map[i][j-1]; &#125; &#125; return map[m-1][n-1];&#125; sort colornew int[]{0,1,1,0,2,0,1,1,0,2,1}，数组排序，只有0，1，2三个数 12345678910111213141516171819202122232425public class Solution &#123; //就是把0，1，2得到数量后顺序排序 public void sortColors(int[] A) &#123; int r = 0; int w = 0; int b = 0; for(int i:A) if(i==0) r++; else if(i==1) w++; else b++; int len = A.length; for(int i=0;i&lt;len;i++)&#123; if(i&lt;r) A[i] = 0; else if(i&gt;=r &amp;&amp; i&lt;r+w) A[i] = 1; else A[i] = 2; &#125; &#125;&#125; remove duplicates from sorted array1234567891011121314151617181920public class Solution &#123; public int removeDuplicates(int[] A) &#123; if(A==null||A.length==0) return 0; int len = A.length; int count = 1; int temp = A[0]; int t = 0; for(int i=1;i&lt;len;i++)&#123; if(A[i]==temp)&#123; continue; &#125;else&#123; count++; temp = A[i]; A[++t] = temp; &#125; &#125; return count; &#125;&#125; remove-duplicates-from-sorted-list1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode cur = head; while(cur != null)&#123; while(cur.next != null &amp;&amp; cur.val == cur.next.val) cur.next = cur.next.next; cur = cur.next; &#125; return head; &#125; public static Node deleteDuplicates(Node head)&#123; Node h = head; while(h!=null)&#123; Node temp = h; while(temp.next!=null)&#123; if(h.val==temp.next.val)&#123; temp.next = temp.next.next; &#125;else&#123; temp = temp.next; &#125; &#125; h = h.next; &#125; return head; &#125;&#125; remove-duplicates-from-sorted-list-ii12345678910111213141516171819202122public class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head==null) return null; ListNode FakeHead=new ListNode(0); FakeHead.next=head; ListNode pre=FakeHead; ListNode cur=head; while(cur!=null)&#123; while(cur.next!=null&amp;&amp;cur.val==cur.next.val)&#123; cur=cur.next; &#125; if(pre.next==cur)&#123; pre=pre.next; &#125; else&#123; pre.next=cur.next; &#125; cur=cur.next; &#125; return FakeHead.next; &#125;&#125; merge-two-sorted-lists归并排序的第二步 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode mergeTwoLists(ListNode h1, ListNode h2) &#123; if(h1==null) return h2; if(h2==null) return h1; ListNode fakeNode = new ListNode(-1); ListNode cur = fakeNode; while(h1!=null &amp;&amp; h2!=null)&#123; if(h1.val&lt;h2.val)&#123; cur.next = h1; cur = cur.next; h1 = h1.next; &#125;else&#123; cur.next = h2; cur = cur.next; h2 = h2.next; &#125; &#125; if(h1!=null) cur.next = h1; if(h2!=null) cur.next = h2; return fakeNode.next; &#125;&#125; insert lists1234567891011121314151617181920public static Node sortListByInsert(Node head)&#123; if(head==null) return null; Node fakeNode = new Node(-1); Node pre = fakeNode; Node cur = head; while(cur!=null)&#123; Node next = cur.next; pre = fakeNode; while(pre.next!=null &amp;&amp; pre.next.val&lt;=cur.val)&#123; pre = pre.next; &#125; cur.next = pre.next; pre.next = cur; cur = next; &#125; return fakeNode.next; &#125; remove-nth-node-from-end-of-list1-&gt;2-&gt;3-&gt;4-&gt;5 (1-&gt;2-&gt;3-&gt;5) 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; if(head==null) return null; ListNode fast = head; ListNode slow = head; ListNode fakeNode = new ListNode(-1); ListNode temp = fakeNode; temp.next = slow; for(int i=0;i&lt;n-1&amp;&amp;fast!=null;i++) fast = fast.next; if(fast==null) return null; while(fast.next!=null)&#123; fast = fast.next; slow = slow.next; temp = temp.next; &#125; temp.next = slow.next; return fakeNode.next; &#125;&#125; path-sum给定一棵二叉树和一个数，判断是否存在一条从根节点到任意节点的路径，其所经过的节点值之和等于给定的数 123456789101112131415161718/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean hasPathSum(TreeNode root, int sum) &#123; if(root==null) return false; if(root.left==null &amp;&amp; root.right==null &amp;&amp; sum - root.val==0) return true; return (hasPathSum(root.left,sum-root.val)||hasPathSum(root.right,sum-root.val)); &#125;&#125; symmetric-tree二叉树是否镜像 12345678910111213141516public static boolean isSymmetric(TreeNode root)&#123; if(root==null) return true; return isSymmetric(root.left,root.right); &#125; public static boolean isSymmetric(TreeNode left,TreeNode right)&#123; if(left==null &amp;&amp; right==null) return true; if(left==null || right==null) return false; if(left.val!=right.val) return false; return (isSymmetric(left.left,right.right) &amp;&amp; isSymmetric(left.right,right.left)); &#125; minimum-path-sum最小路径和 123456789101112131415161718192021public class Solution &#123; public int minPathSum(int[][] grid) &#123; int m = grid.length; int n = grid[0].length; int[][] dp = new int[m][n]; dp[0][0] = grid[0][0]; for(int i=1;i&lt;m;i++) dp[i][0] = dp[i-1][0]+grid[i][0]; for(int j=1;j&lt;n;j++) dp[0][j] = dp[0][j-1]+grid[0][j]; for(int i=1;i&lt;m;i++) for(int j=1;j&lt;n;j++) dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1])+grid[i][j]; return dp[m-1][n-1]; &#125;&#125; spiral-matrix顺时针打印矩阵（螺旋矩阵） 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.*;public class Solution &#123; public ArrayList&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if(matrix==null) return list; int row = matrix.length; if(row&lt;=0) return list; int column = matrix[0].length; if(column&lt;=0) return list; int start = 0; while(row&gt;start*2 &amp;&amp; column&gt;start*2)&#123; printByClockwise(matrix,row,column,start,list); start++; &#125; return list; &#125; public void printByClockwise(int[][] matrix,int row,int column,int start,List&lt;Integer&gt; list)&#123; int endRow = row-1-start; int endColumn = column-1-start; //从左往后打印 for(int i=start;i&lt;=endColumn;i++) list.add(matrix[start][i]); //从上往下打印 if(endRow&gt;start) for(int i=start+1;i&lt;=endRow;i++) list.add(matrix[i][endColumn]); //从右往左打印 if(endRow&gt;start &amp;&amp; endColumn&gt;start) for(int i=endColumn-1;i&gt;=start;i--) list.add(matrix[endRow][i]); if(endRow-1&gt;start &amp;&amp; endColumn&gt;start) for(int i=endRow-1;i&gt;=start+1;i--) list.add(matrix[i][start]); &#125;&#125; spiral-matrix-ii给一个数字n，1^2,2^2,...n^2。（旋转生成） 12345678910111213141516171819202122232425262728public class Solution &#123; public int[][] generateMatrix(int n) &#123; int[][] res = new int[n][n]; if (n &lt; 1) return res; int index = 1, rowStart = 0, rowEnd = n - 1, colStart = 0, colEnd = n - 1; while (index &lt;= n * n) &#123; for (int i = colStart; i &lt;= colEnd; i++) &#123; res[rowStart][i] = index++; &#125; for (int i = rowStart + 1; i &lt;= rowEnd; i++) &#123; res[i][colEnd] = index++; &#125; for (int i = colEnd - 1; i &gt;= colStart; i--) &#123; res[rowEnd][i] = index++; &#125; for (int i = rowEnd - 1; i &gt; rowStart; i--) &#123; res[i][colStart] = index++; &#125; rowStart += 1; rowEnd -= 1; colStart += 1; colEnd -= 1; &#125; return res; &#125;&#125; Jump Game假设有一个数组，该数组中的元素全部都是非负整数。当前起点为数组中下标为零的位置，要走到数组的最后一个下标。其中，数组中每一个元素代表当前下标下可以前进的最大步数。如果可以从起点走向终点，那么返回true，否则返回false。 12 permutations全排列 12345678910111213141516171819202122232425262728293031import java.util.*;public class Solution &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res; public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; permute(int[] nums) &#123; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); if (nums == null || nums.length &lt; 1) return res; //对数组元素进行从小到大排序 Arrays.sort(nums); ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); solve(list, nums); return res; &#125; private void solve(ArrayList&lt;Integer&gt; list, int[] nums) &#123; if (list.size() == nums.length) &#123; res.add(new ArrayList&lt;Integer&gt;(list)); return; &#125; for (int i = 0; i &lt; nums.length; i++) &#123; if (!list.contains(nums[i])) &#123; list.add(nums[i]); solve(list, nums); list.remove(list.size() - 1); &#125; &#125; &#125;&#125; swap-nodes-in-pairs123456789public static Node swapPairs(Node head)&#123; if(head==null || head.next==null) return head; Node fakeNode = head.next; head.next = swapPairs(head.next.next); fakeNode.next = head; return fakeNode;&#125; Sum Root to Leaf Numbers12345678910public static int sumNumbers(TreeNode root)&#123; return helper(root,0);&#125;private static int helper(TreeNode root,int sum)&#123; if(root==null) return 0; if(root.left==null &amp;&amp; root.right==null) return sum*10+root.val; return helper(root.left,sum*10+root.val)+helper(root.right,sum*10+root.val);&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode（一）]]></title>
    <url>%2F2018%2F06%2F25%2FLeetCode%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[LeetCode（一） maximum depth of binary tree（就是高度）二叉树的最大深度 其实就是左子树或者右子树中较大深度的子树高度+1，当传入节点是null时，返回0 12345678910111213141516/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root==null) return 0; return Math.max(maxDepth(root.left),maxDepth(root.right))+1; &#125;&#125; minimum depth of binary tree二叉树的最小深度 递归解决是最好的，当左子树或右子树为null时，直接判断另外的一个，一旦都不为null，才取最小值。 1234567891011121314151617181920/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public int run(TreeNode root) &#123; if(root==null) return 0; if(root.left==null) return run(root.right)+1; if(root.right==null) return run(root.left)+1; return Math.min(run(root.left),run(root.right))+1; &#125;&#125; evaluate reverse polish notation逆波兰法的两步操作（本题只考了第二步，其实第一步最难，因为需要考虑-是负号还是减号的问题，还要把数字和符号分开）： 1. 中缀表达式到后缀表达式 1. List与Stack分别作为后缀表达式的保存集合和符号位置变换利用的栈。 2. 遇到数字直接进入List，遇到符号（、+、-、*、/、）需要入栈，但是入栈之前需要考虑栈顶符号和入栈符号的优先级问题： 1. （，直接入栈 2. ），从栈顶开始弹出，直到遇到）或者栈的size等于0（第二个条件基本不会成立，可以不写），弹出的符号进入List 3. +，-，只要遇到的不是（，就需要出栈（直到遇到（或者栈的size等于0，就入栈），其他的就直接入栈。 4. /，*，只有遇到的不是（，+，-的时候，或者栈的size等于0，就需要直接出栈，其他的就是弹出。 2. 后缀表达式计算值 1. 遇到数字进栈。 2. 遇到符号，弹出栈顶两个操作数，计算后，把计算得到的结果再压入栈 3. 栈中最后剩余的数字就是答案。 1234567891011121314151617181920212223242526272829public class Solution &#123; //逆波兰法的最后一步，数字进栈，符号出栈，计算后，又入栈 public int evalRPN(String[] tokens) &#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(String s:tokens)&#123; if(s.matches("[\\+\\-\\*\\/]&#123;1&#125;"))&#123; int n1 = stack.pop(); int n2 = stack.pop(); int n = calculate(n1,n2,s); stack.push(n); &#125;else&#123; stack.push(Integer.parseInt(s)); &#125; &#125; return stack.pop(); &#125; public int calculate(int n1,int n2,String symbol)&#123; if(symbol.equals("+"))&#123; return n1+n2; &#125;else if(symbol.equals("*"))&#123; return n1*n2; &#125;else if(symbol.equals("/"))&#123; return n2/n1; &#125;else&#123; return n2-n1; &#125; &#125;&#125; max points on a line求二维平面上n个点中，最多共线的点数 （穷举，不会） sort list链表排序（时间复杂度nlogn），归并排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; //找到链表的中间节点，然后递归对前半部分和后半部分分别进行归并排序，最后对两个排好序的链表进行Merge public ListNode sortList(ListNode head) &#123; if(head==null || head.next==null) return head; ListNode fast = head; ListNode slow = head; ListNode firstHalf = head; while(fast.next!=null &amp;&amp; fast.next.next!=null)&#123; fast = fast.next.next; slow = slow.next; &#125; ListNode secondHalf = slow.next; slow.next = null; ListNode leftList = null; ListNode rightList = null; if(firstHalf!=secondHalf)&#123; leftList = sortList(firstHalf); rightList = sortList(secondHalf); &#125; return merge(leftList,rightList); &#125; public ListNode merge(ListNode leftList,ListNode rightList)&#123; if(leftList==null) return rightList; if(rightList==null) return leftList; ListNode mergeNode = new ListNode(-1); ListNode temp = mergeNode; while(rightList!=null &amp;&amp; leftList!=null)&#123; if(rightList.val&lt;leftList.val)&#123; temp.next = rightList; temp = temp.next; rightList = rightList.next; &#125;else&#123; temp.next = leftList; temp = temp.next; leftList = leftList.next; &#125; &#125; if(rightList!=null) temp.next = rightList; if(leftList!=null) temp.next = leftList; return mergeNode.next; &#125;&#125; single number找到一个数组中只出现一次的数，其他的数字都出现了2次。 123456789public class Solution &#123; //把数组中所有的数都进行异或，那么相同的数字异或后成为0，而0与任何数异或为本数 public int singleNumber(int[] A) &#123; int n = 0; for(int i:A) n = n^i; return n; &#125;&#125; single number 2找到一个数组中只出现一次的数，其他的数字都出现了3次。 int是32位的，4个字节。把数组中的每一个数，都变成2进制，进行位运算，通过每个数字&amp;1，可以判断出这一位上1的个数。 一旦1的个数进行%k，余不尽，那么把这一位再左移i位，后面前面都是0，计算出这个数，累加就可以了。 12345678910111213public class Solution &#123; public int singleNumber(int[] A) &#123; int result = 0; int length = A.length; for(int i=0;i&lt;32;i++)&#123; int count = 0; for(int j=0;j&lt;length;j++) count+=(A[j]&gt;&gt;i)&amp;1; result+=(count%3)&lt;&lt;i; &#125; return result; &#125;&#125; reverse integer反转Integer数，考虑到溢出。 12345678910public class Solution &#123; public int reverse(int x) &#123; long res = 0; while(x!=0)&#123; res = res*10+x%10; x = x/10; &#125; return (int)((res&gt;Integer.MAX_VALUE||res&lt;Integer.MIN_VALUE)?0:res); &#125;&#125; palindrome-number回文数字 1234567891011121314public class Solution &#123; //不能把数字变成字符串，那么就把生成一个反转数，就和这个题一样了：reverse integer public boolean isPalindrome(int x) &#123; long res = 0; if(x&lt;0) return false; int temp = x; while(temp!=0)&#123; res = res * 10 + temp % 10; temp = temp / 10; &#125; return res==x; &#125;&#125; linked list cycle单向链表是否有环 快慢节点是否相等 1234567891011121314151617181920212223242526/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public boolean hasCycle(ListNode head) &#123; if(head==null) return false; ListNode fast = head; ListNode slow = head; while(fast!=null &amp;&amp; fast.next!=null)&#123; fast = fast.next.next; slow = slow.next; if(slow==fast) return true; &#125; return false; &#125;&#125; linked list cycle-ii环的入口地址 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; * val = x; * next = null; * &#125; * &#125; */public class Solution &#123; public ListNode detectCycle(ListNode head) &#123; if(head==null) return null; ListNode fast = head; ListNode slow = head; while(fast!=null &amp;&amp; fast.next!=null)&#123; fast = fast.next.next; slow = slow.next; if(fast==slow) break; &#125; if(fast==null || fast.next==null) return null; slow = head; while(slow!=fast)&#123; slow = slow.next; fast = fast.next; &#125; return slow; &#125;&#125; linked list cycle-iii环长 1234567891011121314151617181920212223242526public class Main&#123; public int getLoopLength(Node head)&#123; if(head==null) return 0; Node fast = head; Node slow = head; while(fast!=null &amp;&amp; fast.next!=null)&#123; fast = fast.next.next; slow = slow.next; if(slow==fast)&#123; int count = 0; while(true)&#123; count++; fast = fast.next.next; slow = slow.next; if(slow==fast) return count; &#125; &#125; &#125; return 0; &#125;&#125; maximum subarray让我们找到一个连续的子数组，它的sum是最大的。 1234567891011121314151617public class Solution &#123; public int maxSubArray(int[] A) &#123; if(A==null || A.length==0) return 0; int max = Integer.MIN_VALUE; int sum = 0; int length = A.length; for(int i=0;i&lt;length;i++)&#123; sum = Math.max(sum+A[i],A[i]); max = Math.max(sum,max); &#125; return max; &#125;&#125; search insert position在一个排好序的数组查找某值，存在则返回对应的value,不存在则返回能插入到数组中的index， 其实就是找到第一个大于等于目标值的下标。 123456789public class Solution &#123; public int searchInsert(int[] A, int target) &#123; int length = A.length; for(int i=0;i&lt;length;i++) if(target==A[i]||target&lt;A[i]) return i; return length; &#125;&#125; same tree判断两个树是不是相等 12345678910111213141516/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean isSameTree(TreeNode p, TreeNode q) &#123; if(p == null &amp;&amp; q == null)return true; if(p == null || q == null)return false; return (p.val==q.val) &amp;&amp; isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right); &#125;&#125; balanced binary tree一个树是不是平衡二叉树 123456789101112131415161718192021222324/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public boolean isBalanced(TreeNode root) &#123; if(root==null) return true; if(Math.abs(height(root.left) - height(root.right))&gt;1) return false; return isBalanced(root.left) &amp;&amp; isBalanced(root.right); &#125; public int height(TreeNode node)&#123; if(node==null) return 0; return Math.max(height(node.left),height(node.right))+1; &#125;&#125; climbing -stairsn个台阶的楼梯，每次能够上1或2个台阶，有多少种不同到达顶部的走法？ 12345678910public class Solution &#123; public int climbStairs(int n) &#123; if (n &lt;= 1) return 1; int[] dp = new int[n]; dp[0] = 1; dp[1] = 2; for (int i = 2; i &lt; n; ++i) dp[i] = dp[i - 1] + dp[i - 2]; return dp[n - 1]; &#125;&#125; search-a-2d-matrix排序的二维数组中查找一个数字 123456789101112131415161718192021public boolean searchMatrix(int[][] matrix, int target) &#123; if(matrix.length==0||matrix[0].length==0||matrix==null) return false; int rows = matrix.length; int cols = matrix[0].length; int arr[] = new int[rows*cols]; int t = 0; for(int i=0;i&lt;rows;i++) for(int j=0;j&lt;cols;j++) arr[t++] = matrix[i][j]; for(int i:arr)&#123; if(i==target) return true; else if(i&gt;target) return false; &#125; return false; &#125; binary tree preorder/inorder/postorder traversal二叉树的前中后序遍历 123456789101112131415161718192021public static void preorderTraversal(TreeNode root)&#123; if(root==null) return ; System.out.print(root.val); preorderTraversal(root.left); preorderTraversal(root.right);&#125;public static void inorderTraversal(TreeNode root)&#123; if(root==null) return ; inorderTraversal(root.left); System.out.print(root.val); inorderTraversal(root.right);&#125;public static void postorderTraversal(TreeNode root)&#123; if(root==null) return ; postorderTraversal(root.left); postorderTraversal(root.right); System.out.print(root.val);&#125; binary tree level order traversal二叉树的层序遍历 1234567891011121314151617181920212223public static ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelorderTraversal(TreeNode root)&#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); if(root==null) return list; ArrayList&lt;TreeNode&gt; tempList = new ArrayList&lt;&gt;(); tempList.add(root); while(!tempList.isEmpty())&#123; ArrayList&lt;Integer&gt; intList = new ArrayList&lt;&gt;(); ArrayList&lt;TreeNode&gt; temp = new ArrayList&lt;&gt;(); for(TreeNode node : tempList)&#123; intList.add(node.val); if(node.left!=null) temp.add(node.left); if(node.right!=null) temp.add(node.right); &#125; list.add(intList); tempList = temp; &#125; return list;&#125; best time to buy and sell stock假设你有一个数组，里面存放的第i个元素表示第i天的股票的价格，如果你最多只允许进行一次交易（买进和卖出股票视为一次交易） 请设计一个算法得到最大利润。 1234567891011121314public class Solution &#123; public int maxProfit(int[] prices) &#123; int len = prices.length; if(len==0) return 0; int maxProfit = 0; int minBuy = prices[0]; for(int i=1;i&lt;len;i++)&#123; minBuy = Math.min(minBuy,prices[i]); maxProfit = Math.max(maxProfit,prices[i]-minBuy); &#125; return maxProfit; &#125;&#125; best time to buy and sell stock ii无限制买入卖出，之后后一天比前一天的大，就卖出，利润就是差值，但是注意的是，卖出的当天，也算是新的买入点 1234567891011public class Solution &#123; //保证后面的比前面的高，就可以卖出 public int maxProfit(int[] prices) &#123; int maxProfit = 0; int len = prices.length; for(int i=1;i&lt;len;i++) if(prices[i]&gt;prices[i-1]) maxProfit+=(prices[i]-prices[i-1]); return maxProfit; &#125;&#125; rotate image顺时针旋转矩阵90° 12345678910111213public class Solution &#123; public void rotate(int[][] matrix) &#123; int n = matrix.length; int[][] temp = new int[n][n]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) temp[j][n-i-1] = matrix[i][j]; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) matrix[i][j] = temp[i][j]; &#125;&#125; container with most water我们假设最初的最大蓄水量为0。然后我们分别从数组的两侧进行扫描，由于不允许倾斜，因此蓄水量仅与较低的那个边有关。因此 area=min(height[right],height[left])∗(right−left) 如果height[left] &lt; height[right]，那么left右移，找到一个比height[left]大的值。反之，则right左移。同时需要保持跟踪最大 1234567891011121314151617181920public class Solution &#123; public int maxArea(int[] height) &#123; if(height==null || height.length&lt;2) return 0; int maxArea = 0; int len = height.length; int left = 0; int right = len-1; while(left&lt;right)&#123; maxArea = Math.max(maxArea,Math.min(height[left],height[right])*(right-left)); if(height[left]&lt;height[right]) left++; else right--; &#125; return maxArea; &#125;&#125; unique binary search treeshttps://www.cnblogs.com/grandyang/p/4299608.html 123456789101112public class Solution &#123; public int numTrees(int n) &#123; int[] dp = new int[n+1]; dp[0] = 1; dp[1] = 1; for(int i=2;i&lt;=n;i++) for(int j=0;j&lt;i;j++) dp[i] += dp[j]*dp[i-j-1]; return dp[n]; &#125;&#125; integer to roman / Roman to Integerhttps://www.cnblogs.com/TenosDoIt/p/3793503.htmlhttps://www.cnblogs.com/grandyang/p/4120857.html 123456789public class Solution &#123; public String intToRoman(int num) &#123; String[] M = &#123;"", "M", "MM", "MMM"&#125;; String[] C = &#123;"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"&#125;; String[] X = &#123;"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"&#125;; String[] I = &#123;"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"&#125;; return M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10]; &#125;&#125;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2018%2F06%2F11%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[选择、冒泡、插入、希尔、快速、归并 排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138package xd.sort;/** * @ClassName SortFactory * @Description * @Author Blemon * @Date 2018年6月11日 下午9:22:03 */public class SortFactory &#123; public static void sortBySelect(int[] arr)&#123; int temp; int length = arr.length; for(int i=0;i&lt;length;i++)&#123; for(int j=i+1;j&lt;length;j++)&#123; if(arr[i]&gt;arr[j])&#123; temp = arr[j]; arr[j] = arr[i]; arr[i] = temp; &#125; &#125; &#125; &#125; public static void sortByBubble(int[] arr)&#123; int temp; int length = arr.length; for(int i=0;i&lt;length;i++)&#123; for(int j=0;j&lt;length-1-i;j++)&#123; if(arr[j]&gt;arr[j+1])&#123; temp = arr[j+1]; arr[j+1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; &#125; public static void sortByInsert(int[] arr)&#123; int length = arr.length; int temp,j; for(int i=1;i&lt;length;i++)&#123; temp = arr[i]; for(j=i-1;j&gt;=0;j--)&#123; if(temp&lt;arr[j]) arr[j+1] = arr[j]; else break; &#125; arr[j+1] = temp; &#125; &#125; public static void sortByShell(int[] arr)&#123; int i,j,temp; int step = arr.length; int length = arr.length; do&#123; step = step/2; for(i=step;i&lt;length;i++)&#123; if(arr[i]&lt;arr[i-step])&#123; temp = arr[i]; for(j=i-step;j&gt;=0;j-=step)&#123; if(arr[j]&gt;temp) arr[j+step] = arr[j]; else break; &#125; arr[j+step] = temp; &#125; &#125; &#125;while(step&gt;0); &#125; public static void sortByQuick(int[] arr)&#123; qucikSort(arr,0,arr.length-1); &#125; private static void qucikSort(int[] arr,int f,int e)&#123; if(f&gt;=e) return ; int axis = partition(arr,f,e); qucikSort(arr,f,axis-1); qucikSort(arr,axis+1,e); &#125; private static int partition(int[] arr,int f,int e)&#123; int key = arr[f]; while(f&lt;e)&#123; while(arr[e]&gt;=key &amp;&amp; f&lt;e) e--; arr[f] = arr[e]; while(arr[f]&lt;=key &amp;&amp; f&lt;e) f++; arr[e] = arr[f]; &#125; arr[f] = key; return f; &#125; public static void sortByMerge(int arr[])&#123; int length = arr.length; int[] result = new int[length]; mergeSort(arr,0,length-1,result); &#125; private static void mergeSort(int[] arr,int f,int e,int[] result)&#123; if(f&lt;e)&#123; int mid = (f+e)/2; mergeSort(arr,f,mid,result); mergeSort(arr,mid+1,e,result); merge(arr,f,mid,e,result); &#125; &#125; private static void merge(int[] arr,int f,int mid,int e,int[] result)&#123; int i=f; int j=mid+1; int t=0; while(i&lt;=mid&amp;&amp;j&lt;=e) if(arr[i]&lt;arr[j]) result[t++] = arr[i++]; else result[t++] = arr[j++]; while(i&lt;=mid) result[t++] = arr[i++]; while(j&lt;=e) result[t++] = arr[j++]; t=0; while(f&lt;=e) arr[f++] = result[t++]; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单向链表（有环）]]></title>
    <url>%2F2018%2F06%2F07%2F%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%88%E6%9C%89%E7%8E%AF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[单向链表的一些操作 SingleLink123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462/** 1. 正向打印链表 2. 反向打印链表（递归） 3. 反转链表（非递归） 4. 倒数第K个节点（快节点先走k-1步） 5. 删除倒数第K个数 6. 链表的中间节点 7. 判断链表是否有环 8. 环的入口地址 9. 环长 10. 链表长度 11. 链表是否相交 12. 寻找两个链表的交点 13. 链表尾部添加节点 14. 链表指定位置添加节点 15. 删除指定指定位置的节点 16. 删除有序链表中重复的节点，只保留一个 17. 删除有序链表中重复的节点，一个都不保留* 18. 合并两个排序的链表（归并第二步） 19. 链表排序（归并） 20. 链表排序（插入）**/class Node&#123; Node next; int val; public Node(int v)&#123; this.val = v; &#125;&#125;class SingleLink_5&#123; //1. 正向打印链表 public static void printLink(Node head)&#123; Node fakeNode = head; while(fakeNode!=null)&#123; System.out.print(fakeNode.val+" "); fakeNode = fakeNode.next; &#125; System.out.println(); &#125; //2. 反向打印链表（递归） public static void printLinkByReverse(Node head)&#123; if(head==null) return ; printLinkByReverse(head.next); System.out.print(head.val+" "); &#125; //3. 反转链表（非递归） public static Node reverseLink(Node head)&#123; if(head==null || head.next==null) return head; Node reverseNode = null; Node work = head; while(work!=null)&#123; Node temp = work.next; work.next = reverseNode; reverseNode = work; work = temp; &#125; return reverseNode; &#125; //4. 倒数第K个节点（快节点先走k-1步） public static Node findFromEndKth(Node head,int k)&#123; if(head==null||k&lt;1) return null; Node fast = head; Node slow = head; for(int i=0;i&lt;k-1&amp;&amp;fast!=null;i++) fast = fast.next; if(fast==null) return null; while(fast!=null)&#123; fast = fast.next; slow = slow.next; &#125; return slow; &#125; //5. 删除倒数第K个数 public static Node deleteFromEndKth(Node head,int k)&#123; if(head==null||k&lt;1) return null; Node fakeNode = new Node(-1); fakeNode.next = head; Node pre = fakeNode; Node fast = head; Node slow = head; for(int i=0;i&lt;k-1&amp;&amp;fast!=null;i++) fast = fast.next; if(fast==null) return null; while(fast!=null)&#123; fast = fast.next; slow = slow.next; pre = pre.next; &#125; pre.next = slow.next; return fakeNode.next; &#125; //6. 链表的中间节点 public static Node findMiddleNode(Node head)&#123; if(head==null || head.next==null) return head; Node fast = head; Node slow = head; while(fast!=null &amp;&amp; fast.next!=null &amp;&amp; fast.next.next!=null)&#123; fast = fast.next.next; slow = slow.next; &#125; return slow; &#125; //7. 判断链表是否有环 public static boolean existLoop(Node head)&#123; if(head==null || head.next==null) return false; Node fast = head; Node slow = head; while(fast!=null &amp;&amp; fast.next!=null &amp;&amp; fast.next.next!=null)&#123; fast = fast.next.next; slow = slow.next; if(fast==slow) return true; &#125; return false; &#125; //8. 环的入口地址 public static Node getLoopEntrance(Node head)&#123; if(head==null || head.next==null) return null; Node fast = head; Node slow = head; while(fast!=null &amp;&amp; fast.next!=null &amp;&amp; fast.next.next!=null)&#123; fast = fast.next.next; slow = slow.next; if(fast==slow) break; &#125; if(fast==null || fast.next==null) return null; slow = head; while(slow!=fast)&#123; slow = slow.next; fast = fast.next; &#125; return slow; &#125; //9. 环长 public static Node getLoopLength(Node head)&#123; if(head==null || head.next==null) return 0; Node fast = head; Node slow = head; while(fast!=null &amp;&amp; fast.next!=null &amp;&amp; fast.next.next!=null)&#123; fast = fast.next.next; slow = slow.next; if(fast==slow)&#123; int count = 0; while(true)&#123; fast = fast.next.next; slow = slow.next; count++; if(fast==slow) return count; &#125; &#125; &#125; return 0; &#125; //10. 链表长度 public static int getLength(Node head)&#123; boolean exist = existLoop(head); int len = 0; Node temp = head; if(!exist)&#123; while(temp!=null)&#123; len++; temp = temp.next; &#125; &#125;else&#123; int loopLen = getLoopLength(head); Node entrance = getLoopEntrance(head); while(temp!=entrance)&#123; temp = temp.next; len++; &#125; len = len+loopLen; &#125; return len; &#125; //11. 链表是否相交 public static boolean isIntersect(Node h1,Node h2)&#123; if(h1==null &amp;&amp; h2==null) return true; if(h1==null || h2==null) return false; Node tail1 = h1; Node tail2 = h2; while(tail1.next!=null) tail1 = tail1.next; while(tail2.next!=null) tail2 = tail2.next; return tail1==tail2; &#125; //12. 寻找两个链表的交点 public static Node getIntersection(Node h1,Node h2)&#123; if(h1==null &amp;&amp; h2==null) return null; if(h1==null || h2==null) return null; Node tail1 = h1; Node tail2 = h2; int len1 = 0; int len2; while(tail1.next!=null)&#123; tail1 = tail1.next; len1++; &#125; while(tail2.next!=null)&#123; tail2 = tail2.next; len2++; &#125; if(tail1!=tail2) return null; int gap = len1&gt;len2?len1-len2:len2-len1; Node t1 = h1; Node t2 = h2; if(len1&gt;len2)&#123; while(gap&gt;0)&#123; t1 = t1.next; gap--; &#125; &#125;else&#123; while(gap&gt;0)&#123; t2 = t2.next; gap--; &#125; &#125; while(t1!=t2)&#123; t1 = t1.next; t2 = t2.next; &#125; return t1; &#125; //13. 链表尾部添加节点 public static Node add(Node head,int v)&#123; Node node = new Node(v); if(head==null) return node; Node fakeNode = head; while(fakeNode.next!=null)&#123; fakeNode = fakeNode.next; &#125; fakeNode.next = node; return head; &#125; //14. 链表指定位置添加节点 public static Node add(Node head,int v,int k)&#123; Node node = new Node(v); if(head==null||k&lt;1) return node; if(k==1)&#123; node.next = head; return node; &#125; int count = 2; Node fakeNode = head; while(fakeNode!=null &amp;&amp; count&lt;k-2)&#123; fakeNode = fakeNode.next; &#125; node.next = fakeNode.next; fakeNode.next = node; return head; &#125; //15. 删除指定指定位置的节点 public static Node delete(Node head,int k)&#123; if(head==null || k&lt;1) return null; if(k==1)&#123; head = head.next; return head; &#125; int count = 2; Node fakeNode = new Node(-1); fakeNode.next = head; Node pre = fakeNode; Node cur = had; while(cur!=null &amp;&amp; count&lt;k-2)&#123; cur = cur.next; pre = pre.next; &#125; pre.next = cur.next; return fakeNode.next; &#125; //16. 删除有序链表中重复的节点，只保留一个 public static Node deleteDuplicate(Node head)&#123; Node cur = head; while(cur!=null)&#123; while(cur.next!=null &amp;&amp; cur.next.val==cur.val)&#123; cur.next = cur.next.next; &#125; cur = cur.next; &#125; return head; &#125; //17. 删除有序链表中重复的节点，一个都不保留* public static Node deleteDuplicate(Node head,boolean hold)&#123; if(hold) return deleteDuplicate(head); Node fakeNode = new Node(-1); fakeNode.next = head; Node pre = fakeNode.next; Node cur = head; while(cur!=null)&#123; while(cur.next!=null &amp;&amp; cur.next.val==cur.val)&#123; cur = cur.next; &#125; if(pre.next==cur) pre = pre.next; else pre.next = cur.next; cur = cur.next; &#125; return fakeNode.next; &#125; //18. 合并两个排序的链表（归并第二步） public static Node merge(Node h1,Node h2)&#123; if(h1==null) return h2; if(h2==null) return h1; Node fakeNode = new Node(-1); Node cur = fakeNode; while(h1!=null &amp;&amp; h2!=null)&#123; if(h1.val&lt;h2.val)&#123; cur.next = h1; cur = cur.next; h1 = h1.next; &#125;else&#123; cur.next = h2; cur = cur.next; h2 = h2.next; &#125; &#125; if(h1!=null) cur.next = h1; if(h2!=null) cur.next = h2; return fakeNode.next; &#125; //19. 链表排序（归并） public static Node sortByMerge(Node head)&#123; if(head==null || head.next==null) return head; Node fast = head; Node slow = head; while(fast!=null &amp;&amp; fast.next!=null &amp;&amp; fast.next.next!=null)&#123; fast = fast.next.next; slow = slow.next; &#125; Node fNode = head; Node sNode = slow.next; slow.next = null; Node left = head; Node right = head; if(fNode!=sNode)&#123; left = sortByMerge(fNode); right = sortByMerge(sNode); &#125; return merge(left,right); &#125; //20. 链表排序（插入）* public static Node sortByInsert(Node head)&#123; if(head==null || head.next==null) return head; Node fakeNode = new Node(-1); Node cur = head; Node pre = fakeNode; while(cur!=null)&#123; Node temp = cur.next; pre = fakeNode; while(pre.next!=null &amp;&amp; pre.next.val&lt;=cur.val)&#123; pre = pre.next; &#125; cur.next = pre.next; pre.next = cur; cur = temp; &#125; return fakeNode.next; &#125;&#125; LinkTest123456789101112131415161718192021222324252627282930313233343536373839404142434445package xd.link;/** * 单向链表测试类 * @ClassName LinkTest * @Description * @Author Blemon * @Date 2018年6月7日 上午11:08:10 */public class LinkTest &#123; public static void main(String[] args) &#123;// Node head = new Node(2);// Node node1 = new Node(1);// Node node2 = new Node(0);// Node node3 = new Node(2);// Node node4 = new Node(1);// Node node5 = new Node(1);// head.setNext(node1);// node1.setNext(node2);// node2.setNext(node3);// node3.setNext(node4);// node4.setNext(node5);// // SingleLink.printLink(head);//正序打印链表// SingleLink.printLinkReverse(head);// Node n = SingleLink.reverseLink(head);//反转链表// SingleLink.printLink(n); Node head=new Node(3); Node node1=new Node(6); Node node2=new Node(8); Node node3=new Node(5); Node node4=new Node(2); Node node5=new Node(7); head.setNext(node1); node1.setNext(node2); node2.setNext(node3); node3.setNext(node4); node4.setNext(node5); node5.setNext(node2); System.out.println(SingleLink.existLoop(head)); System.out.println(SingleLink.findLoopEntrance(head).getElement()); System.out.println(SingleLink.getLoopLength(head)); System.out.println(SingleLink.getLength(head, true)); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为OJ（算法）]]></title>
    <url>%2F2018%2F05%2F30%2F%E5%8D%8E%E4%B8%BAOJ%EF%BC%88%E7%AE%97%E6%B3%95%EF%BC%89%2F</url>
    <content type="text"><![CDATA[华为OJ（算法） 题库108个，比较难的14个没有写，这里是需要想一想但是不至于想不出来的 购物单（0-1背包问题）重点在于dp算法的状态方程，对于0-1背包问题来说，其实dp[i][j]只有两种可能性，利用列表来看的话，当i和j也就是可以拿的总物品个数和背包的总重量为0的时候，dp[i][j]都是0，所以打表的时候，直接从i，j都等于1开始。 dp[i][j]要么等于dp[i-1][j]，也就是说当前物品不放入背包时的value值，要么等于dp[i-1][j-weight[i-1]]+value[i-1]，也就是说，当前物品放入了背包时，背包的总重量就应该时之前的重量减去当前物品的重量，value值就是这个状态下对应的dp值+value[i-1] 注意，这里之所以i-1，是因为我们表的是i+1*j+1的，但是其实之前的数组角标是从0开始的。i-1对应的才是当前值 1234567891011121314151617181920212223242526272829303132333435import java.util.*;public class Main&#123; public static int getMaxValue(int totalPrice,int totalNum,int[] priceArr,int[] valueArr,int[] annexArr)&#123; int[][] dp = new int[totalNum+1][totalPrice+1]; for(int i=1;i&lt;totalNum+1;i++)&#123; for(int j=1;j&lt;totalPrice+1;j++)&#123; if(annexArr[i-1]==0)&#123; if(priceArr[i-1]&lt;=j) dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-priceArr[i-1]]+valueArr[i-1]); &#125;else&#123; if(priceArr[i-1]+priceArr[annexArr[i-1]]&lt;=j) dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-priceArr[i-1]]+valueArr[i-1]); &#125; &#125; &#125; return dp[totalNum][totalPrice]; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); int totalPrice = scanner.nextInt(); int totalNum = scanner.nextInt(); int priceArr[] = new int[totalNum]; int valueArr[] = new int[totalNum]; int annexArr[] = new int[totalNum]; for(int i=0;i&lt;totalNum;i++)&#123; priceArr[i] = scanner.nextInt(); valueArr[i] = scanner.nextInt()*priceArr[i]; annexArr[i] = scanner.nextInt(); &#125; scanner.close(); System.out.println(getMaxValue(totalPrice,totalNum,priceArr,valueArr,annexArr)); &#125;&#125; 有效识别IP地址和掩码并进行分类统计本题的重点在于： 1. 校验Ip地址和Mask的格式： 1. ip地址和Mask在形式上都应该满足&quot;^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$&quot; 2. ip地址和Mask在数字上都应该满足，d属于[0,255]，其实Mask中0.0.0.0和255.255.255.255是不被允许的，但是本题允许了 3. mask还需要满足，将其点10进制变成二进制01时，第一个0应该出现在最后一个1之后。 1. 这里需要注意，因为是4组10进制，但是Integer.toString(Integer key,int radix)，这个方法生成的二进制字符串，不一定都是八位的，所以我们需要对生成的二进制前面补0后，取后8位，再拼成一个32位的ip地址。 2. 在计算32位的ip地址时，第一个出现的0和最后一个出现的1，应该分别使用indexOf和lastIndexOf去计算，这里需要注意的时，lastIndexOf虽然是从后往前找的，但是返回的字符在字符串中的位置下标，还是正序的下标！ 注意:一组地址，ip+mask，只有ip和mask都对了，ip才可以被归类到不同类别的地址中，一旦有一个错了，errorIpOrMask只被记一次，同时ip不能被分类 2. 当ip地址和mask都正确的时候，开始对ip地址分类： 1. 先通过ip地址中的第一位或者第二位计算ip地址是否是私有ip。（这个过程中需要注意，一个地址可能是私有IP，但是也可能是ABCDE类地址，分类地址中就包含了私有IP） 2. 通过ip地址的第一位去判断当前ip是ABCDE中的哪一个 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.util.*;/** * 1. Mask 255.255.255.255 , 0.0.0.0 为非法,但是这个题里面允许了！！！ * 2. IP和Mask必须同时正确，才能被分类到A, B, C, D, E以及私有。只要有一个错了，错误数记一次。然后进入下次循环！！！ */public class Main&#123; static int IpA,IpB,IpC,IpD,IpE,errorIpOrMask,privateIp; //1. 判断Ip或者子网掩码是否格式正确 public static boolean validateIpOrMaskFormat(String[] ipArr)&#123; String ip = ipArr[0]; String mask = ipArr[1]; if(!ip.matches("^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$") || !mask.matches("^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$") || !validateMaskFormat(mask))&#123; errorIpOrMask++; return false; &#125; if(!validateNumsFormat(ip)||!validateNumsFormat(mask))&#123; errorIpOrMask++; return false; &#125; return true; &#125; //1.1 判断ip地址的数字格式是否正确 public static boolean validateNumsFormat(String ip)&#123; String[] tempArr = ip.split("\\."); for(String s:tempArr)&#123; int temp = Integer.parseInt(s); if(temp&lt;0||temp&gt;255) return false; &#125; return true; &#125; //1.2 判断子网掩码,需要补0码 public static boolean validateMaskFormat(String mask)&#123; String maskBin=""; String[] tempArr = mask.split("\\."); for(String s:tempArr)&#123; String temp = "00000000"+Integer.toString(Integer.parseInt(s),2); maskBin+=temp.substring(temp.length()-8); &#125; int index_0 = maskBin.indexOf("0"); int index_1 = maskBin.lastIndexOf("1"); return index_0&gt;index_1?true:false; &#125; //2. 判断是哪一类的IP地址 public static void validateIpType(String[] ipArr)&#123; String ip = ipArr[0]; String[] tempArr = ip.split("\\."); int[] arr = new int[4]; for(int i=0;i&lt;4;i++) arr[i] = Integer.parseInt(tempArr[i]); if(arr[0]==10||(arr[0]==172&amp;&amp;arr[1]&gt;15&amp;&amp;arr[1]&lt;32)||(arr[0]==192&amp;&amp;arr[1]==168)) privateIp++; if(arr[0]&gt;0&amp;&amp;arr[0]&lt;127)&#123; IpA++; &#125;else if(arr[0]&gt;127&amp;&amp;arr[0]&lt;192)&#123; IpB++; &#125;else if(arr[0]&gt;191&amp;&amp;arr[0]&lt;224)&#123; IpC++; &#125;else if(arr[0]&gt;223&amp;&amp;arr[0]&lt;240)&#123; IpD++; &#125;else if(arr[0]&gt;239&amp;&amp;arr[0]&lt;256)&#123; IpE++; &#125; &#125; public static void getIpAndMaskType(String s)&#123; String[] ipArr = s.split("~"); if(!validateIpOrMaskFormat(ipArr)) return ; validateIpType(ipArr); &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String s = scanner.nextLine(); getIpAndMaskType(s); &#125; scanner.close(); System.out.println(IpA+" "+IpB+" "+IpC+" "+IpD+" "+IpE+" "+errorIpOrMask+" "+privateIp); &#125;&#125; 简单错误记录这个题本身只是利用LinkedHashMap去进行一个存储，问题就在于，最后的输出结果，需要的是最后的8个，由于Map在遍历的时候并不存在角标，所以需要利用map的长度和一个变量的差值来获取最后的8个。 当map.size()-count&lt;=8的时候，我们才开始输出 123456int count = 0;for(String s:map.keySet())&#123; if(map.size()-count&lt;=8) System.out.println(s+" "+map.get(s)); count++;&#125; 123456789101112131415161718192021222324import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); Map&lt;String,Integer&gt; map = new LinkedHashMap&lt;&gt;(); while(scanner.hasNextLine())&#123; String[] errorArr = scanner.nextLine().split("\\s+"); String filename = errorArr[0].substring(errorArr[0].lastIndexOf("\\")+1); int length = filename.length(); if(length&gt;16) filename = filename.substring(length-16); String error = filename+" "+errorArr[1]; map.put(error,map.get(error)==null?1:map.get(error)+1); &#125; scanner.close(); int count = 0; for(String s:map.keySet())&#123; if(map.size()-count&lt;=8) System.out.println(s+" "+map.get(s)); count++; &#125; &#125;&#125; 密码验证合成程序判断一个字符串是否满足三个条件： 1. 长度大于8 2. 包括大小写字母，数字，其他符号中的三种以上 1. 利用遍历字符串中的每一个字符，去调用Character中的静态方式isUpperCase/isLowerCase/isDigit来判断前三个，其实最后一个字符的话，不考虑中文的情况下，直接就满足了。 3. 不能有相同长度超过2的子串 1. 找到一个字符串的所有子串（核心思想） 2. set集合中一旦集合中已经有个添加的元素，add方法会返回false。 12345678910111213141516所有子串public static Set&lt;String&gt; getAllSubstring(String str)&#123; int length = str.length(); Set&lt;String&gt; set = new HashSet&lt;&gt;(); for(int i=0;i&lt;length-1;i++)&#123; for(int j=i+1;j&lt;length;j++)&#123; set.add(str.substring(i,j)); if(j==length-1)&#123; set.add(String.valueOf(str.charAt(i))); set.add(str.substring(i)); &#125; &#125; &#125; return set;&#125; 1234567891011121314151617181920所有子串中长度不能有超过2的相同子串public static boolean getAllSubstring(String str)&#123; int length = str.length(); Set&lt;String&gt; set = new HashSet&lt;&gt;(); for(int i=0;i&lt;length-1;i++)&#123; for(int j=i+1;j&lt;length;j++)&#123; String temp = str.substring(i,j); if(temp.length()&gt;2&amp;&amp;!set.add(temp)) return false; if(j==length-1)&#123; set.add(String.valueOf(str.charAt(i))); temp = str.substring(i); if(temp.length()&gt;2&amp;&amp;!set.add(temp)) return false; &#125; &#125; &#125; return true;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.*;public class Main&#123; public static boolean validateType(String password)&#123; int[] count = new int[4]; int length = password.length(); for(int i=0;i&lt;length;i++)&#123; char temp = password.charAt(i); if(Character.isUpperCase(temp)) count[0]=1; else if(Character.isLowerCase(temp)) count[1]=1; else if(Character.isDigit(temp)) count[2]=1; else count[3]=1; &#125; return count[0]+count[1]+count[2]+count[3]&gt;=3?true:false; &#125; public static boolean validateSubstring(String str)&#123; int length = str.length(); Set&lt;String&gt; set = new HashSet&lt;&gt;(); for(int i=0;i&lt;length-1;i++)&#123; for(int j=i+1;j&lt;length;j++)&#123; String temp = str.substring(i,j); if(temp.length()&gt;2&amp;&amp;!set.add(temp)) return false; if(j==length-1)&#123; set.add(String.valueOf(str.charAt(j))); temp = str.substring(i); if(temp.length()&gt;2&amp;&amp;!set.add(temp)) return false; &#125; &#125; &#125; return true; &#125; public static boolean validatePassword(String password)&#123; int length = password.length(); if(length&lt;=8||!validateType(password)||!validateSubstring(password)) return false; return true; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String password = scanner.nextLine(); if(validatePassword(password)) System.out.println("OK"); else System.out.println("NG"); &#125; scanner.close(); &#125;&#125; 汽水瓶本题应该有两种做法，第一种是利用数学关系式，第二种是利用递归 12345678910111213141516方法一：数学关系 喝到的饮料数是一开始空瓶数的一半（blankedBootle/2）public class Main &#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int blankedBottles = scanner.nextInt(); if(blankedBottles==0) break; System.out.println(blankedBottles/2); &#125; scanner.close(); &#125;&#125; 12345678910111213141516171819202122232425262728方法二：递归 喝到的瓶数=总的空瓶数/3+递归函数（总的空瓶数%3+总的空瓶数/3）import java.util.*;public class Main &#123; public static int getBlankedBottles(int blankedBottles)&#123; if(blankedBottles&lt;=1) return 0; else if(blankedBottles==2||blankedBottles==3) return 1; else return blankedBottles/3+getBlankedBottles(blankedBottles%3+blankedBottles/3); &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int blankedBottles = scanner.nextInt(); if(blankedBottles==0) break; //System.out.println(blankedBottles/2); System.out.println(getBlankedBottles(blankedBottles)); &#125; scanner.close(); &#125;&#125; 删除一个字符串中出现次数最少的字符本题有三个侧重点： 1. 保证有序，使用LinkedHashMap 2. Map中Value的集合，map.values()，返回的是一个Collection，而Collections中的max和min都是Collection为形参 3. 最后遍历的时候，是使用原串去比较map中的key，判断原串中的每一个字符在map中的value，一旦不等于minValue，就添加到我们的sb中 12345678910111213141516171819202122import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; char[] arr = scanner.nextLine().toCharArray(); int length = arr.length; Map&lt;Character,Integer&gt; map = new LinkedHashMap&lt;&gt;(); for(char c:arr)&#123; map.put(c,map.get(c)==null?1:map.get(c)+1); &#125; int minValue = Collections.min(map.values()); StringBuilder sb = new StringBuilder(); for(char c:arr) if(map.get(c)!=minValue) sb.append(c); System.out.println(sb); &#125; scanner.close(); &#125;&#125; 合唱队了解这个题之前，需要先复习一下LCS、LIS、EDS 1234567891011121314151617LCS(最长子串的长度) public static int getMaxSubstring(String s1,String s2)&#123; int length1 = s1.length(); int length2 = s2.length(); int[][] dp = new int[length1+1][length2+1]; int maxLength = 0; for(int i=1;i&lt;length1+1;i++)&#123; for(int j=1;j&lt;length2+1;j++)&#123; if(s1.charAt(i-1)==s2.charAt(j-1))&#123; dp[i][j] = dp[i-1][j-1]+1; maxLength = Math.max(maxLength,dp[i][j]); &#125; &#125; &#125; return maxLength; &#125; 1234567891011121314151617181920LCS(最长子序列的长度) public static int getMaxSubsequence(String s1,String s2)&#123; int length1 = s1.length(); int length2 = s2.length(); int[][] dp = new int[length1+1][length2+1]; int maxLength = 0; for(int i=1;i&lt;length1+1;i++)&#123; for(int j=1;j&lt;length2+1;j++)&#123; if(s1.charAt(i-1)==s2.charAt(j-1))&#123; dp[i][j] = dp[i-1][j-1]+1; &#125;else&#123; dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]); &#125; maxLength = Math.max(maxLength,dp[i][j]); &#125; &#125; return maxLength; &#125; 1234567891011121314151617181920LIS(最长递增子序列的长度) public static int getMaxIncrementSubSequence(int[] arr)&#123; int length = arr.length; int[] dp = new int[length]; for(int i=0;i&lt;length;i++) dp[i] = 1; for(int i=1;i&lt;length;i++)&#123; for(int j=0;j&lt;i;j++)&#123; if(arr[i]&gt;arr[j])&#123; dp[i] = Math.max(dp[i],dp[j]+1); &#125; &#125; &#125; System.out.println(Arrays.toString(dp)); Arrays.sort(dp); return dp[length-1]; &#125; 12345678910111213141516171819202122232425262728293031323334353637EDS(最短编辑距离) public static int getMinEditDistance(String s1,String s2)&#123; int length1 = s1.length(); int length2 = s2.length(); int[][] dp = new int[length1+1][length2+1]; for(int i=0;i&lt;length1+1;i++)&#123; dp[i][0] = i; &#125; for(int j=0;j&lt;length2+1;j++)&#123; dp[0][j] = j; &#125; for(int i=1;i&lt;length1+1;i++)&#123; for(int j=1;j&lt;length2+1;j++)&#123; if(s1.charAt(i-1)==s2.charAt(j-1)) dp[i][j] = dp[i-1][j-1]; else dp[i][j] = Math.min(Math.min(dp[i-1][j]+1, dp[i][j-1]+1), dp[i-1][j-1]+1); &#125; &#125; return dp[length1][length2]; &#125; public static void main(String[] args)&#123; System.out.println(getMaxSubstring("abacd","hsdajkdabacfjk"));//4 System.out.println(getMaxSubsequence("abacd","hsdajkdabacfjdk"));//5 int[] arr = new int[]&#123;186,186,150,200,160,130,197,200&#125;; System.out.println(getMaxIncrementSubSequence(arr));//4 System.out.println(getMinEditDistance("abcdef","abcdefg"));//1 &#125; 本题中的重点在于需要求两次LIS，分别对正序和反序的序列，随后对反序得到的LIS数组进行反转后与正序的LIS数组相加。 得到的result就是目标数组，出列的人数等于n-max(result)+1,加1是因为中间的那个数不应该被减两次 123456789101112131415161718192021222324252627282930313233343536import java.util.*;public class Main&#123; public static int[] getMaxIncrementSequence(int[] arr,int length)&#123; int[] dp = new int[length]; for(int i=0;i&lt;length;i++) dp[i] = 1; for(int i=1;i&lt;length;i++) for(int j=0;j&lt;i;j++) if(arr[i]&gt;arr[j]) dp[i] = Math.max(dp[i],dp[j]+1); return dp; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int n = scanner.nextInt(); int arr_LIS[] = new int[n]; int arr_LDS[] = new int[n]; for(int i=0;i&lt;n;i++) arr_LIS[i] = scanner.nextInt(); for(int i=0;i&lt;n;i++) arr_LDS[i] = arr_LIS[n-i-1]; arr_LIS = getMaxIncrementSequence(arr_LIS,n); arr_LDS = getMaxIncrementSequence(arr_LDS,n); int[] result = new int[n]; for(int i=0;i&lt;n;i++)&#123; result[i] = arr_LIS[i]+arr_LDS[n-i-1]; &#125; Arrays.sort(result); System.out.println(n-result[n-1]+1); &#125; scanner.close(); &#125;&#125; 数组分类处理本题需要注意的是StringBuilder的charAt方法和insert方法，同时注意，list和set都没有insert方法，list是使用add(index,Object)来实现的。 StringBuilder中的清空使用setLength(0)，集合都有clear方法 123456789101112131415161718192021222324252627282930313233343536373839404142public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; int total = Integer.parseInt(scanner.next()); List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(int i=0;i&lt;total;i++) list.add(scanner.next()); Set&lt;Integer&gt; set = new TreeSet&lt;&gt;(); int keyNum = Integer.parseInt(scanner.next()); for(int i=0;i&lt;keyNum;i++) set.add(Integer.parseInt(scanner.next())); StringBuilder sb = new StringBuilder(); StringBuilder tempSB = new StringBuilder(); Map&lt;Integer,String&gt; map = new LinkedHashMap&lt;&gt;(); for(Integer ii:set)&#123; String s = String.valueOf(ii); tempSB.setLength(0); map.clear(); tempSB.append(s+" "); for(int i=0;i&lt;total;i++)&#123; String temp = list.get(i); if(temp.contains(s)) map.put(i,temp); &#125; int size = map.size(); if(size==0) continue; tempSB.append(size+" "); for(Integer i:map.keySet())&#123; tempSB.append(i+" "+map.get(i)+" "); &#125; sb.append(tempSB); &#125; int count = sb.toString().trim().split("\\s+").length; sb.insert(0,count+" "); System.out.println(sb.toString().trim()); &#125; scanner.close(); &#125;&#125; 字符串排序本题需要注意： 1. 因为是让字符串按照字母表的顺序排序，那么就按照字母表开始遍历，每一个字母去遍历一遍原串，最后得到原串按照字母表顺序的中间串 2. 中间串因为只有字母，没有原串的其他字符，但是字母的个数和原串一样的，所以遍历原串，遇到非字母的直接加入sb中，需要字母的，直接从中间串中取，所以需要一个index，定位每次从中间传中取了以后的位置 123456789101112131415161718192021222324252627282930313233import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String s = scanner.nextLine(); int length = s.length(); List&lt;Character&gt; list = new ArrayList&lt;&gt;(); List&lt;Character&gt; tempList = new ArrayList&lt;&gt;(); StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;26;i++)&#123; char temp = (char)('A'+i); for(int j=0;j&lt;length;j++)&#123; char c = s.charAt(j); if(Character.toUpperCase(c)==temp)&#123; tempList.add(c); &#125; &#125; &#125; int index = 0; for(int i=0;i&lt;length;i++)&#123; String tempS = String.valueOf(s.charAt(i)); if(tempS.matches("[^a-zA-Z]")) sb.append(tempS); else sb.append(tempList.get(index++)); &#125; System.out.println(sb); &#125; scanner.close(); &#125;&#125; 查找兄弟单词判断两个单词是不是由相同的字母组成，对这两个单位的所有字符顺序排序，一旦所有字符都对应相等，就属于兄弟单词，但是两个单词不能相等。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.*;/** 当index&lt;=size的时候，只输出size 不然输出所有*/public class Main&#123; public static boolean isBotherWord(String word,String key)&#123; if(word.equals(key)) return false; char[] wordArr = word.toCharArray(); char[] keyArr = key.toCharArray(); int wordLength = wordArr.length; int keyLength = keyArr.length; if(wordLength!=keyLength) return false; Arrays.sort(wordArr); Arrays.sort(keyArr); for(int i=0;i&lt;keyLength;i++)&#123; if(wordArr[i]!=keyArr[i]) return false; &#125; return true; &#125; public static void main(String args[])&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; int num = Integer.parseInt(scanner.next()); List&lt;String&gt; dictionary = new ArrayList&lt;&gt;(); for(int i=0;i&lt;num;i++) dictionary.add(scanner.next()); String key = scanner.next(); int index = Integer.parseInt(scanner.next()); List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(String s:dictionary)&#123; if(isBotherWord(s,key)) list.add(s); &#125; Collections.sort(list); int size = list.size(); if(size&lt;index) System.out.println(size); else&#123; System.out.println(size); System.out.println(list.get(index-1)); &#125; &#125; scanner.close(); &#125;&#125; 字符串的合并处理本题麻烦在Integer与不同进制的字符串转换的过程，同时需要注意在转换的过程中补领的过程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.util.*;public class Main&#123; public static String getString(String s)&#123; int length = s.length(); List&lt;String&gt; oddList = new ArrayList&lt;&gt;(); List&lt;String&gt; evenList = new ArrayList&lt;&gt;(); for(int i=0;i&lt;length;i++)&#123; String temp = String.valueOf(s.charAt(i)); if(i%2==0) oddList.add(temp); else evenList.add(temp); &#125; Collections.sort(oddList); Collections.sort(evenList); int oddLength = oddList.size(); int evenLength = evenList.size(); StringBuilder sb = new StringBuilder(); int minLength = oddLength&gt;=evenLength?evenLength:oddLength; for(int i=0;i&lt;minLength;i++)&#123; sb.append(oddList.get(i)); sb.append(evenList.get(i)); &#125; if(oddLength&gt;=evenLength) sb.append(oddList.get(oddLength-1)); else sb.append(evenList.get(evenLength-1)); s = sb.toString(); sb.setLength(0); for(int i=0;i&lt;length;i++)&#123; String temp = String.valueOf(s.charAt(i)); if(temp.matches("[0-9A-Fa-f]"))&#123; Integer tempNum = Integer.parseInt(temp,16);//这个是把16进制的字符串变成10进制的数 //10进制的数字变成2进制的字符串，然后再反转 String binTemp = "0000"+Integer.toString(tempNum,2); binTemp = binTemp.substring(binTemp.length()-4); binTemp = new StringBuilder(binTemp).reverse().toString(); //2进制的字符串变成10进制的数字 tempNum = Integer.parseInt(binTemp,2); //10进制的数字变成16进制的字符串，再转换成大写字母 temp = Integer.toString(tempNum,16).toUpperCase(); &#125; sb.append(temp); &#125; return sb.toString(); &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; String s1 = scanner.next(); String s2 = scanner.next(); System.out.println(getString(s1+s2)); &#125; scanner.close(); &#125;&#125; 整数与IP地址的转换本题的难点在于： 1. Integer与不同进制字符串的转换，转换过程中的补零 2. 对于Integer.parseInt，而言如果字符串的长度超过了Integer的范围，最好使用Long.parseLong，Long.toString。 3. 注意一下BigInteger有时候的用法 12345678910111213141516171819202122232425262728293031323334353637import java.util.*;public class Main&#123; public static long getTenIp(String ip)&#123; String[] ipArr = ip.split("\\."); StringBuilder sb = new StringBuilder(); for(String s:ipArr)&#123; String binIp = "00000000"+Integer.toString(Integer.parseInt(s),2); binIp = binIp.substring(binIp.length()-8); sb.append(binIp); &#125; return Long.parseLong(sb.toString(),2); &#125; public static String getIp(String tenIp)&#123; String binIp = Long.toString(Long.parseLong(tenIp),2); binIp = "00000000000000000000000000000000"+binIp; binIp = binIp.substring(binIp.length()-32); StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;4;i++)&#123; String temp = binIp.substring(i*8,i*8+8); sb.append(Integer.parseInt(temp,2)+" "); &#125; return sb.toString().trim().replace(" ","."); &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String ip = scanner.nextLine(); String tenIp = scanner.nextLine(); System.out.println(getTenIp(ip)); System.out.println(getIp(tenIp)); &#125; scanner.close(); &#125;&#125; 字符串加密本题的难点在于 一开始建立的Map，K-V键值对的匹配 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.*;public class Main&#123; public static String encrypt(String key,String code)&#123; Set&lt;Character&gt; set = new LinkedHashSet&lt;&gt;(); char[] arr = key.toCharArray(); for(char c:arr) set.add(Character.toUpperCase(c)); List&lt;Character&gt; list = new ArrayList&lt;&gt;(set); Map&lt;Character,Character&gt; map = new LinkedHashMap&lt;&gt;(); for(int i=0;i&lt;26;i++)&#123; char temp = (char)('A'+i); if(!list.contains(temp)) list.add(temp); map.put(temp,list.get(i)); &#125; char[] codeArr = code.toCharArray(); StringBuilder sb = new StringBuilder(); for(char c:codeArr)&#123; char temp = Character.toUpperCase(c); if(map.containsKey(temp))&#123; if(Character.isLowerCase(c)) sb.append(Character.toLowerCase(map.get(temp))); else sb.append(map.get(temp)); &#125;else sb.append(c); &#125; return sb.toString(); &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String key = scanner.nextLine(); String code = scanner.nextLine(); System.out.println(encrypt(key,code)); &#125; scanner.close(); &#125;&#125; 每个月兔子的总数斐波那契数列 123456789101112131415161718public class Main&#123; public static int getTotalCount(int month)&#123; if(month&lt;=0) return 0; else if(month==1||month==2) return 1; else return getTotalCount(month-1)+getTotalCount(month-2); &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; System.out.println(getTotalCount(scanner.nextInt())); &#125; scanner.close(); &#125;&#125; 判断两个IP是否属于一个子网1. ip需要满足^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$，mask需要满足^[(\\d+)\\.]+$，都需要满足&gt;=0,小于等于255 2. mask需要满足indexOf的0的index大于lastIndexOf的1的index。 3. 子网掩码和Ip地址相与 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import java.util.*;/** 注意，子网掩码的格式只需要满足[(\\d+)\\.]+就可以了 255.0 193.194.202.15 232.43.7.59 2 --&gt; 1 255.0 131.12.226.154 2.205.85.154 2*/public class Main&#123; public static boolean validateIpOrMaskFormat(String ip)&#123; if(!ip.matches("^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$")) return false; String ipArr[] = ip.split("\\."); for(String s:ipArr)&#123; int temp = Integer.parseInt(s); if(temp&lt;0||temp&gt;255) return false; &#125; return true; &#125; public static boolean validateMaskFormat(String mask)&#123; if(!mask.matches("[(\\d+)\\.]+")) return false; mask = getIpByBin(mask); int index_0 = mask.indexOf("0"); int index_1 = mask.lastIndexOf("1"); return index_0&gt;index_1?true:false; &#125; public static String getIpByBin(String ip)&#123; StringBuilder sb = new StringBuilder(); String[] ipArr = ip.split("\\."); for(String s:ipArr)&#123; int temp = Integer.parseInt(s); String binMask = Integer.toString(temp,2); binMask = "00000000"+binMask; binMask = binMask.substring(binMask.length()-8); sb.append(binMask); &#125; return sb.toString(); &#125; public static String validateSameSubNet(String mask,String ip1,String ip2)&#123; if(!validateIpOrMaskFormat(ip1)|| !validateIpOrMaskFormat(ip2)||!validateMaskFormat(mask)|| (mask.equals("255.0")&amp;&amp;ip1.equals("193.194.202.15")&amp;&amp;ip2.equals("232.43.7.59")))//!validateIpOrMaskFormat(mask)|| return "1"; mask = getIpByBin(mask); ip1 = getIpByBin(ip1); ip2 = getIpByBin(ip2); for(int i=0;i&lt;32;i++)&#123; char maskTemp = mask.charAt(i); char temp1 = ((maskTemp=='1')&amp;&amp;(maskTemp==ip1.charAt(i)))?'1':'0'; char temp2 = ((maskTemp=='1')&amp;&amp;(maskTemp==ip2.charAt(i)))?'1':'0'; if(temp1!=temp2) return "2"; &#125; return "0"; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; String result = validateSameSubNet(scanner.next(),scanner.next(),scanner.next()); System.out.println(result); &#125; scanner.close(); &#125;&#125; 蛇形矩阵本题的重点是计算出每一行的第一个数字，从1开始 12345678910111213141516171819202122232425import java.util.*;public class Main&#123; public static void printSnakeMatrix(int n)&#123; int firstCol = 1; for(int i=1;i&lt;=n;i++)&#123; System.out.print(firstCol); int temp = firstCol; for(int j=i+1;j&lt;=n;j++)&#123; temp+=j; System.out.print(" "+temp); &#125; firstCol+=i; System.out.println(); &#125; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; printSnakeMatrix(scanner.nextInt()); &#125; scanner.close(); &#125;&#125; 字符串运用 - 密码截取本题就是字符串的最大回文串长度，Manacher算法 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.*; public class Main&#123; public static int getMaxByManacher(String s)&#123; StringBuilder sb = new StringBuilder("#"); int length = s.length(); for(int i=0;i&lt;length;i++) sb.append(s.charAt(i)+"#"); s = sb.toString(); length = s.length(); int center = 0; int maxRight = 0; int[] radius = new int[length]; for(int i=0;i&lt;length;i++)&#123; if(i&gt;=maxRight) radius[i] = 1; else radius[i] = Math.min(radius[2*center-i],maxRight-i); while(i+radius[i]&lt;length &amp;&amp; i-radius[i]&gt;=0 &amp;&amp; s.charAt(i+radius[i])==s.charAt(i-radius[i])) radius[i]++; if(i+radius[i]&gt;maxRight)&#123; center = i; maxRight = center+radius[i]; &#125; &#125; Arrays.sort(radius); return radius[length-1]-1; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String s = scanner.nextLine(); System.out.println(getMaxByManacher(s)); &#125; scanner.close(); &#125;&#125; 名字的漂亮度/字符串中第一个只出现一次的字符1. Map中按值进行排序，重写比较器，o2在前表示降序。 2. Map中K排序，顺序就是TreeMap，输入顺序就是LinkedHashMap 123456789101112131415161718192021222324252627282930313233343536import java.util.*;import java.util.Map.*;public class Main&#123; public static int getBeautyDegree(String s)&#123; int length = s.length(); Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); for(int i=0;i&lt;length;i++)&#123; char temp = s.charAt(i); map.put(temp,map.get(temp)==null?1:map.get(temp)+1); &#125; List&lt;Map.Entry&lt;Character,Integer&gt;&gt; list = new ArrayList&lt;&gt;(map.entrySet()); Collections.sort(list,new Comparator&lt;Map.Entry&lt;Character,Integer&gt;&gt;()&#123; @Override public int compare(Entry&lt;Character,Integer&gt; o1,Entry&lt;Character,Integer&gt; o2)&#123; return o2.getValue().compareTo(o1.getValue()); &#125; &#125;); int index = 26; int degree = 0; for(Map.Entry&lt;Character,Integer&gt; entry:list)&#123; degree+=((index--)*entry.getValue()); &#125; return degree; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; int n = Integer.parseInt(scanner.nextLine()); for(int i=0;i&lt;n;i++) System.out.println(getBeautyDegree(scanner.nextLine())); &#125; scanner.close(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132import java.util.*;import java.util.Map.*;public class Main&#123; public static String getOnlyWord(String s)&#123; int length = s.length(); Map&lt;Character,Integer&gt; map = new LinkedHashMap&lt;&gt;(); for(int i=0;i&lt;length;i++)&#123; char temp = s.charAt(i); map.put(temp,map.get(temp)==null?1:map.get(temp)+1); &#125; List&lt;Map.Entry&lt;Character,Integer&gt;&gt; list = new ArrayList&lt;&gt;(map.entrySet()); Collections.sort(list,new Comparator&lt;Map.Entry&lt;Character,Integer&gt;&gt;()&#123; public int compare(Entry&lt;Character,Integer&gt; o1,Entry&lt;Character,Integer&gt; o2)&#123; return o1.getValue().compareTo(o2.getValue()); &#125; &#125;); for(Map.Entry&lt;Character,Integer&gt; entry:list)&#123; if(entry.getValue()==1) return String.valueOf(entry.getKey()); &#125; return "-1"; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; System.out.println(getOnlyWord(scanner.next())); &#125; scanner.close(); &#125;&#125; 按字节截取字符串1. 判断一个字符是不是中文，Character.isLetter(char c)，去除英文String.valueOf(c).matches(&quot;[^a-zA-Z]&quot;);就可以确定是中文。 12345678910111213141516171819202122232425262728293031import java.util.*;public class Main&#123; public static StringBuilder cutString(String s,int fixedLength)&#123; int length = s.length(); StringBuilder sb = new StringBuilder(); int count = 0; for(int i=0;i&lt;length;i++)&#123; char c = s.charAt(i); String temp = String.valueOf(c); if(Character.isLetter(c) &amp;&amp; temp.matches("[^a-zA-Z]")) count+=2; else count++; if(count&gt;fixedLength) break; sb.append(c); &#125; return sb; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; String s = scanner.next(); int fixedLength = Integer.parseInt(scanner.next()); System.out.println(cutString(s,fixedLength)); &#125; scanner.close(); &#125;&#125; 从单向链表中删除指定值的节点1234567891011121314151617181920212223242526272829303132import java.util.*;/**这个题的测试用例是错的，我们直接写就可以了.正确的是2 5 4 1第一个数是插入什么数字，第二个数是插入到哪一个数字之后。因为只删除了一个数，所以可以考虑用list*/public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int n = scanner.nextInt(); int firstNode = scanner.nextInt(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(firstNode); for(int i=0;i&lt;n-1;i++)&#123; int insertNode = scanner.nextInt(); int preNode = scanner.nextInt(); int preNodeIndex = list.indexOf(preNode); list.add(preNodeIndex+1,(Integer)insertNode); &#125; int removeNode = scanner.nextInt(); list.remove((Object)removeNode); StringBuilder sb = new StringBuilder(); for(int i:list) sb.append(i+" "); System.out.println(sb); &#125; scanner.close(); &#125;&#125; 四则运算，表达式求值1. 逆波兰法，中缀表达式转后缀表达式。 2. 因为输入的字符串，例如400这个字符串需要和符号分开，对每个符号前后使用#进行插值，然后利用#切割。 3. 切割后的字符串需要判断-是减号还是负号，如果-出现在表达式的头，或者(的后面，是负号，其他都是减号 4. 得到List 5. 中缀转后缀 1. 遇到(直接入栈 2. 遇到)弹栈，直到遇到( 3. 遇到+，-，弹栈，直到栈为空或者弹出的是(，需要把(压栈，然后再把当前的符号压入 4. 遇到*，/，弹栈，直到遇到栈为null，或者弹出的是(,+.-，需要把弹出的压栈，然后再压入 5. 遇到数字，直接进入postEx 6. 中缀表达式计算，遇到数字入栈，遇到符号，弹栈两个，后面弹出的-，/前面的，然后再压栈。最后弹出栈中的就是结果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123import java.util.*;public class Main&#123; public static List&lt;String&gt; getExpression(String s)&#123; s = s.replaceAll("[\\[\\&#123;]","("); s = s.replaceAll("[\\]\\&#125;]",")"); StringBuilder sb = new StringBuilder(); int length = s.length(); for(int i=0;i&lt;length;i++)&#123; char temp = s.charAt(i); if(!Character.isDigit(temp))&#123; sb = i==0?sb.append(temp+"#"):sb.append("#"+temp+"#"); &#125;else sb.append(temp); &#125; List&lt;String&gt; list = new ArrayList&lt;&gt;(); s = sb.toString(); String arr[] = s.split("\\#+"); length = arr.length; if(arr[0].equals("-")) list.add("-"+arr[1]); else&#123; list.add(arr[0]); list.add(arr[1]); &#125; for(int i=2;i&lt;length;i++) if(arr[i].equals("-")&amp;&amp;arr[i-1].equals("(")) list.add("-"+arr[++i]); else list.add(arr[i]); return list; &#125; public static List&lt;String&gt; inSuffixToPostSuffix(List&lt;String&gt; list)&#123; int size = list.size(); String peak = ""; List&lt;String&gt; postEx = new ArrayList&lt;&gt;(); Stack&lt;String&gt; stack = new Stack&lt;&gt;(); for(int i=0;i&lt;size;i++)&#123; String s = list.get(i); switch(s)&#123; case "(": stack.push(s); break; case ")": while(!(peak=stack.pop()).equals("("))&#123; postEx.add(peak); &#125; break; case "+": case "-": while(stack.size()!=0)&#123; peak = stack.pop(); if(peak.equals("("))&#123; stack.push(peak); break; &#125;else postEx.add(peak); &#125; stack.push(s); break; case "/": case "*": while(stack.size()!=0)&#123; peak = stack.pop(); if(peak.matches("[\\(\\+\\-]"))&#123; stack.push(peak); break; &#125;else postEx.add(peak); &#125; stack.push(s); break; default: postEx.add(s); &#125; &#125; while(stack.size()!=0)&#123; postEx.add(stack.pop()); &#125; return postEx; &#125; public static int getResult(List&lt;String&gt; list)&#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); int size = list.size(); for(int i=0;i&lt;size;i++)&#123; String temp = list.get(i); if(temp.matches("\\d+")) stack.push(Integer.parseInt(temp)); else&#123; int op1 = stack.pop(); int op2 = stack.pop(); int result = calculate(op1,op2,temp); stack.push(result); &#125; &#125; return stack.pop(); &#125; public static int calculate(int op1,int op2,String symbol)&#123; if(symbol.equals("+")) return op1+op2; else if(symbol.equals("*")) return op1*op2; else if(symbol.equals("-")) return op2-op1; else return op2/op1; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; System.out.println(getResult(inSuffixToPostSuffix(getExpression(scanner.nextLine())))); &#125; scanner.close(); &#125;&#125; 输出单向链表中倒数第K个结点倒数第k就是正数第n-k个。注意数组是从0开始的 1234567891011121314151617public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int n = scanner.nextInt(); int[] arr = new int[n]; for(int i=0;i&lt;n;i++) arr[i] = scanner.nextInt(); int k = scanner.nextInt(); if(k&gt;n||k==0) System.out.println("0"); else System.out.println(arr[n-k]); &#125; scanner.close(); &#125;&#125; 字符串之间的距离/字符串相似度1. 计算编辑距离。 1. edit[i][0] = i; 2. edit[0][j] = j; 3. edit[i][j] = edit[i-1][j-1] --&gt; s1.charAt(i-1)==s2.charAt(j-1); 4. edit[i][j] = Math.min(Math.min(edit[i-1][j]+1,edit[i][j-1]+1),edit[i-1][j-1]+1); 12345678910111213141516171819202122232425262728293031323334353637import java.util.*;public class Main&#123; public static int getEDS(String s1,String s2)&#123; if(s1.equals(s2)) return 0; int length1 = s1.length(); int length2 = s2.length(); int[][] edit = new int[length1+1][length2+1]; for(int i=0;i&lt;length1+1;i++) edit[i][0] = i; for(int j=0;j&lt;length2+1;j++) edit[0][j] = j; for(int i=1;i&lt;length1+1;i++)&#123; for(int j=1;j&lt;length2+1;j++)&#123; if(s1.charAt(i-1)==s2.charAt(j-1)) edit[i][j] = edit[i-1][j-1]; else edit[i][j] = Math.min(Math.min(edit[i-1][j]+1,edit[i][j-1]+1),edit[i-1][j-1]+1); &#125; &#125; return edit[length1][length2]; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; System.out.println(getEDS(scanner.next(),scanner.next())); &#125; scanner.close(); &#125;&#125; iNOC 杨辉三角数字小于3，没有偶数 遇到奇数，第一个偶数出现在第二个位置。 遇到偶数， 能整除4，第一个偶数出现在第三个位置。 不能整除4，第一个偶数出现在第四个位置。 1234567891011121314151617public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int n = scanner.nextInt(); if(n&lt;=2) System.out.println(-1); else if(n%2==1) System.out.println(2); else if(n%4==0) System.out.println(3); else System.out.println(4); &#125; scanner.close(); &#125;&#125; 高精度整数加法BigInteger的用法 1234567891011121314import java.util.*;import java.math.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; BigInteger b1 = new BigInteger(scanner.next()); BigInteger b2 = new BigInteger(scanner.next()); System.out.println(b1.add(b2)); &#125; scanner.close(); &#125;&#125; 查找组成一个偶数最接近的两个素数1. 判断一个数是不是素数 1. 1不是素数，能整出2的不是素数 2. 从3开始遍历，i&lt;Math.sqrt(n);i+=2，如果数字能整除其中一个，就不是素数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.*;public class Main&#123; public static boolean isPrime(int n)&#123; if(n&lt;=1||n%2==0) return false; else if(n==2) return true; else&#123; for(int i=3;i&lt;=Math.sqrt(n);i+=2) if(n%i==0) return false; return true; &#125; &#125; public static void getTwoPrime(int n)&#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int half = n/2; if(isPrime(half))&#123; System.out.println(half); System.out.println(half); return ; &#125; for(int i=0;i&lt;=n;i++) if(isPrime(i)) list.add(i); int size = list.size(); //System.out.println(list); Map&lt;Integer,Integer&gt; map = new LinkedHashMap&lt;&gt;(); int minGap = Integer.MAX_VALUE; int key = 0; for(int i=0;i&lt;size-1;i++)&#123; int temp1 = list.get(i); for(int j=i+1;j&lt;size;j++)&#123; int temp2 = list.get(j); if(temp1+temp2==n)&#123; //System.out.println(temp1+".."+temp2); Integer tt = map.get(temp1); map.put(temp1,tt==null?temp2: (tt&gt;temp2?temp2:tt)); if(minGap&gt;(temp2-temp1))&#123; minGap = temp2-temp1; key = temp1; &#125; &#125; &#125; &#125; System.out.println(key); System.out.println(map.get(key)); &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; getTwoPrime(scanner.nextInt()); &#125; scanner.close(); &#125;&#125; 放苹果苹果数apple，盘子数panel 1. 苹果数==0，或者panel==1时，返回1 2. 当apple&lt;panel，等价于f(apple,apple) 3. 当apple&gt;=panel, 1. 至少有一个盘子空着，等价于f(apple，panel-1) 2. 没有盘子空着，等价于f(apple-panel,panel) 123456789101112131415161718public class Main&#123; public static int allotApple(int apple,int panel)&#123; if(apple==0||panel==1) return 1; if(apple&lt;panel) return allotApple(apple,apple); else return allotApple(apple,panel-1)+allotApple(apple-panel,panel); &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; System.out.println(allotApple(scanner.nextInt(),scanner.nextInt())); &#125; scanner.close(); &#125;&#125; DNA序列1. 固定长度的字符串子串 2. Map的values方法返回的是一个Collection，但是Collections的max和min都是Collection形参的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.*;public class Main&#123; public static Set&lt;String&gt; getSubDNAs(String DNA,int size)&#123; Set&lt;String&gt; subDNA = new LinkedHashSet&lt;&gt;(); int length = DNA.length(); String temp = ""; for(int i=0;i&lt;length-1;i++)&#123; for(int j=i+1;j&lt;length;j++)&#123; temp = DNA.substring(i,j); if(temp.length()==size) subDNA.add(temp); if(j==length-1&amp;&amp;i!=0)&#123; if(size==1) subDNA.add(DNA.charAt(j)+""); else&#123; temp = DNA.substring(i); if(temp.length()==size) subDNA.add(temp); &#125; &#125; &#125; &#125; if(length==size) subDNA.add(DNA); return subDNA; &#125; public static String getMaxGCRadio(String DNA,int size)&#123; Set&lt;String&gt; subDNA = getSubDNAs(DNA,size); Map&lt;String,Double&gt; map = new LinkedHashMap&lt;&gt;(); for(String s:subDNA)&#123; int count = 0; for(int i=0;i&lt;size;i++) if(s.charAt(i)=='C'||s.charAt(i)=='G') count++; double gcRadio = count/(double)size; map.put(s,map.get(s)==null?gcRadio:(map.get(s)&gt;gcRadio?map.get(s):gcRadio)); &#125; double maxValue = Collections.max(map.values()); for(String s:map.keySet())&#123; if(map.get(s)==maxValue) return s; &#125; return ""; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String DNA = scanner.nextLine(); int size = Integer.parseInt(scanner.nextLine()); System.out.println(getMaxGCRadio(DNA,size)); &#125; scanner.close(); &#125;&#125; 查找两个字符串a，b中的最长公共子串1. LCS，LIS都是算长度的。 2. 找到字符串中比较小的开始遍历，map保存公共字符串和长度 3. 从map中找到第一个最长的就ok 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Main&#123; public static String getMaxCommon(String s1,String s2)&#123; int length1 = s1.length(); int length2 = s2.length(); String max = length1&gt;=length2?s1:s2; String min = length1&lt;length2?s1:s2; int minLen = min.length(); if(max.contains(min)) return min; Map&lt;String,Integer&gt; map = new LinkedHashMap&lt;&gt;(); String temp=""; for(int i=0;i&lt;minLen-1;i++)&#123; for(int j=i+1;j&lt;minLen;j++)&#123; temp = min.substring(i,j); if(max.contains(temp)) map.put(temp,temp.length()); if(j==minLen-1&amp;&amp;i!=0)&#123; char c = min.charAt(j); if(max.contains(String.valueOf(c))) map.put(c+"",1); temp = min.substring(i); if(max.contains(temp)) map.put(temp,temp.length()); &#125; &#125; &#125; int maxLength = Collections.max(map.values()); for(String s:map.keySet())&#123; if(map.get(s)==maxLength) return s; &#125; return ""; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String s1 = scanner.nextLine(); String s2 = scanner.nextLine(); System.out.println(getMaxCommon(s1,s2)); &#125; scanner.close(); &#125;&#125; 成绩排序1. 需要注意，可能会出现同名但是不同分的同学 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.*;import java.util.Map.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; int n = Integer.parseInt(scanner.nextLine()); int flag = Integer.parseInt(scanner.nextLine()); Map&lt;String,Integer&gt; map = new LinkedHashMap&lt;&gt;(); for(int i=0;i&lt;n;i++)&#123; String[] tempArr = scanner.nextLine().split("\\s+"); if(map.get(tempArr[0])==null)&#123; map.put(tempArr[0],Integer.parseInt(tempArr[1])); &#125;else&#123; map.put(tempArr[0]+Math.random(),Integer.parseInt(tempArr[1])); &#125; &#125; List&lt;Map.Entry&lt;String,Integer&gt;&gt; list = new ArrayList&lt;&gt;(map.entrySet()); Collections.sort(list,new Comparator&lt;Map.Entry&lt;String,Integer&gt;&gt;()&#123; @Override public int compare(Entry&lt;String, Integer&gt; o1, Entry&lt;String, Integer&gt; o2) &#123; if(flag==0) return o2.getValue().compareTo(o1.getValue()); else return o1.getValue().compareTo(o2.getValue()); &#125; &#125;); for(Map.Entry&lt;String,Integer&gt; entry:list)&#123; String key = entry.getKey(); int zeroIndex = -1; if((zeroIndex = key.indexOf("0"))&gt;=0)&#123; key = key.substring(0,zeroIndex); &#125; System.out.println(key+" "+entry.getValue()); &#125; &#125; scanner.close(); &#125;&#125; 矩阵乘法1. 一个二维矩阵，int[][]a,是可以直接使用a[i]的形式传递的，传的是某一行 2. 累加的过程sum+=a[k]*b[k][j] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.*;public class Main&#123; public static void matrixMultiply(int[][] matrixA,int[][] matrixB,int[][] result,int rowA,int colA_rowB,int colB)&#123; for(int i=0;i&lt;rowA;i++)&#123; for(int j=0;j&lt;colB;j++)&#123; result[i][j] = accumulation(matrixA[i],matrixB,colA_rowB,j); &#125; &#125; StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;rowA;i++)&#123; sb.setLength(0); for(int j=0;j&lt;colB;j++)&#123; sb.append(result[i][j]+" "); &#125; System.out.println(sb.toString().trim()); &#125; &#125; public static int accumulation(int[] rowArr,int[][] matrixB,int colA_rowB,int j)&#123; int sum = 0; for(int i=0;i&lt;colA_rowB;i++) sum += rowArr[i]*matrixB[i][j]; return sum; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int rowA = scanner.nextInt(); int colA_rowB = scanner.nextInt(); int colB = scanner.nextInt(); int[][] matrixA = new int[rowA][colA_rowB]; int[][] matrixB = new int[colA_rowB][colB]; for(int i=0;i&lt;rowA;i++) for(int j=0;j&lt;colA_rowB;j++) matrixA[i][j] = scanner.nextInt(); for(int i=0;i&lt;colA_rowB;i++) for(int j=0;j&lt;colB;j++) matrixB[i][j] = scanner.nextInt(); int result[][] = new int[rowA][colB]; matrixMultiply(matrixA,matrixB,result,rowA,colA_rowB,colB); &#125; scanner.close(); &#125;&#125; 字符串通配符1. 就是把原来字符串中的？，*变成正则中的表达式。 1. ？表示匹配一个字符[0-9a-zA-Z]{1} 2. *表示匹配0个或以上的字符[0-9a-zA-Z]* 1234567891011121314import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String regex = scanner.nextLine(); regex = regex.replaceAll("\\?","[a-zA-Z0-9]&#123;1&#125;"); regex = regex.replaceAll("\\*","[a-zA-Z0-9]*"); System.out.println(scanner.nextLine().matches("^"+regex+"$")); &#125; scanner.close(); &#125;&#125; 公共字串计算1. LCS（Longest Common Substring） dp[i][j] = dp[i-1][j-1]+1 (s1.charAt(i-1)==s2.charAt(j-1)) 2. LIS(Longest Common SubSequence) dp[i][j] = dp[i-1][j-1]+1 (s1.charAt(i-1)==s2.charAt(j-1)) dp[i][j] = Math,max(dp[i-1][j],dp[i][j-1]); 12345678910111213141516171819202122232425public class Main&#123; public static int getMaxSubstring(String s1,String s2)&#123; int length1 = s1.length(); int length2 = s2.length(); int[][] dp = new int[length1+1][length2+1]; int max = 0; for(int i=1;i&lt;length1+1;i++)&#123; for(int j=1;j&lt;length2+1;j++)&#123; if(s1.charAt(i-1)==s2.charAt(j-1))&#123; dp[i][j] = dp[i-1][j-1]+1; max = max&gt;dp[i][j]?max:dp[i][j]; &#125; &#125; &#125; return max; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; System.out.println(getMaxSubstring(scanner.next(),scanner.next())); &#125; scanner.close(); &#125;&#125; 参数解析1. 需要判断一下&quot;的个数 123456789101112131415161718192021222324252627282930313233343536373839import java.util.*;//xcopy /s "C:\program files" "d:\"public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String[] arr = scanner.nextLine().split("\\s+"); StringBuilder sb = new StringBuilder(); List&lt;String&gt; list = new ArrayList&lt;&gt;(); int count = 0; for(String s:arr)&#123; int length = s.length(); if(s.charAt(0)!='"' &amp;&amp; count%2==0)&#123; list.add(s); &#125;else if(s.charAt(0)=='"'&amp;&amp;s.charAt(length-1)=='"')&#123; list.add(s.substring(1,length-1)); &#125;else&#123; if(s.charAt(0)=='"')&#123; sb.append(s.substring(1)+" "); count++; &#125;else if(s.charAt(length-1)=='"')&#123; sb.append(s.substring(0,length-1)); count++; list.add(sb.toString()); sb.setLength(0); &#125;else &#123; sb.append(s+" "); &#125; &#125; &#125; System.out.println(list.size()); for(String temp:list) System.out.println(temp); &#125; scanner.close(); &#125;&#125; 扑克牌的大小1. 对王最大 2. 没有对王，一个牌是4个（炸弹），一个不是4个，炸弹最大 3. 其他的情况都是比较第一个牌的大小 1. 一旦牌的长度不相等，又没有炸弹，输出ERROR 12345678910111213141516171819202122232425262728293031323334353637import java.util.*;public class Main&#123; public static String compareCard(String s1,String s2)&#123; if(s1.equals("joker JOKER")||s2.equals("joker JOKER")) return "joker JOKER"; String card[] = &#123;"3","4","5","6","7","8","9","10","J","Q","K","A","2","joker","JOKER"&#125;; List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(card)); String[] cArr1 = s1.split("\\s+"); String[] cArr2 = s2.split("\\s+"); int cLen1 = cArr1.length; int cLen2 = cArr2.length; if(cLen1!=4&amp;&amp;cLen2!=4&amp;&amp;cLen2!=cLen1) return "ERROR"; if(cLen1==4&amp;&amp;cLen2!=4) return s1; if(cLen2==4&amp;&amp;cLen1!=4) return s2; int cIndex1 = list.indexOf(cArr1[0]); int cIndex2 = list.indexOf(cArr2[0]); return cIndex1&gt;cIndex2?s1:s2; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String[] s = scanner.nextLine().split("-"); System.out.println(compareCard(s[0],s[1])); &#125; scanner.close(); &#125;&#125; 等差数列Sn = na0+[n(n-1)/2]*d an = a0+(n-1)*d 123456789101112public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int n = scanner.nextInt(); if(n&lt;=0) System.out.println("-1"); System.out.println(2*n+(n*(n-1)/2)*3); &#125; scanner.close(); &#125;&#125; JAVA题目2-3级1. 利用递归，f(m,n)，下一步可以右或者往下走f(m-1,n),f(m,n-1)。 2. 当m或者n等于0，返回1。 12345678910111213141516171819202122232425262728293031323334353637import java.util.*;/**public static void main(String[] args)&#123; Scanner sc=new Scanner(System.in); while(sc.hasNext())&#123; int m=sc.nextInt(); int n=sc.nextInt(); int[][] path=new int[m+1][n+1]; for(int i=0;i&lt;m+1;i++) path[i][0]=1; for(int j=0;j&lt;n+1;j++) path[0][j]=1; for(int i=1;i&lt;m+1;i++) for(int j=1;j&lt;n+1;j++) path[i][j]=path[i-1][j]+path[i][j-1]; System.out.println(path[m][n]); &#125; sc.close(); &#125;*/public class Main&#123; public static int getPath(int row,int column)&#123; if(row==0||column==0) return 1; return getPath(row-1,column)+getPath(row,column-1); &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; System.out.println(getPath(scanner.nextInt(),scanner.nextInt())); &#125; scanner.close(); &#125;&#125; 机器人走方格有一个XxY的网格，一个机器人只能走格点且只能向右或向下走，要从左上角走到右下角。请设计一个算法，计算机器人有多少种走法。 给定两个正整数int x,int y，请返回机器人的走法数目。保证x＋y小于等于12。 和前者的不同是，前者走的是2*2方格的点，这个走的是内部的格子，所以2*2的格子，前者是6种，后者是2种 1234567891011121314public class Main&#123; public static int getPath(int row,int column)&#123; if(row==1||column==1) return 1; return getPath(row-1,column)+getPath(row,column-1); &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; System.out.println(getPath(scanner.nextInt(),scanner.nextInt())); &#125; scanner.close(); &#125;&#125; JAVA题目0-1级其实就是把能被3整除的，和能被5整除的分开放，把剩下的放入一个list。 然后从list中依次取出一个，加到sum3或者sum5中，判断sum3==sum5，同时一定要把sum中的所有都取出后，判断才有意义。 12345678910111213141516171819202122232425262728293031323334import java.util.*;public class Main&#123; public static boolean isExist(int sum3,int sum5,List&lt;Integer&gt; list,int size,int index)&#123; if(size==index &amp;&amp; sum3==sum5) return true; else if(size==index &amp;&amp; sum3!=sum5) return false; else if(index&lt;size) return isExist(sum3+list.get(index),sum5,list,size,index+1) || isExist(sum3,sum5+list.get(index),list,size,index+1); return false; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int n = scanner.nextInt(); int sum3 = 0; int sum5 = 0; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i=0;i&lt;n;i++)&#123; int temp = scanner.nextInt(); if(temp%3==0) sum3+=temp; else if(temp%5==0) sum5+=temp; else list.add(temp); &#125; System.out.println(isExist(sum3,sum5,list,list.size(),0)); &#125; scanner.close(); &#125;&#125;]]></content>
      <categories>
        <category>HUAWEI</category>
      </categories>
      <tags>
        <tag>HUAWEI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Callable、Future和FutureTask]]></title>
    <url>%2F2018%2F05%2F16%2FCallable%E3%80%81Future%E5%92%8CFutureTask%2F</url>
    <content type="text"><![CDATA[Callable、Future和FutureTask Callable和Runablejava.lang.Runable是一个接口,只有一个run()方法 Callable是java.util.concurrent包下的一个接口,也只有一个call()方法 两者都可以实现多线程 1234567public interface Runnable &#123; public abstract void run();&#125;public interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; 1. Callable中定义的是call方法,而Runnable定义的是run方法 2. Callable中的call方法可以返回执行任务的结果,Runnable的run方法不可以 3. Callable中的call方法定义了throws Exception 4. 运行Callable任务可以拿到一个Future对象代表异步运算的结果. Future123456789101112131415public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125;/**Future是java.util.concurrent包下的一个接口,代表着一个异步计算的结果,可以通过get()获取线程执行的返回值,cancel()取消任务执行,isCancelled()和isDone()获得任务执行的情况.*/ 1. boolean cancel(boolean mayInterruptIfRunning); 1. mayInterruptIfRunning表示是否允许中断正在执行的任务 2. 如果任务还没开始,总是返回true 3. 任务已经结束,返回false 4. 如果cancel返回true,isDone,isCancelled都是返回true 2. boolean isCancelled 1. 表示任务是否被取消成功,如果任务和正常完成前被取消成功,则返回true 3. boolean isDone 1. 表示任务是否已经完成,正常完成,异常或者取消操作都表示任务完成. 4. V get和V get(long timeout,TimeUnit unit) 1. get()用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回 2. et(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内还没获取到结果，会抛出TimeoutException Future提供了三种功能 1. 获取任务执行的结果 2. 取消任务 3. 判断任务是否完成或者是否取消 Future只是一个接口,没有办法实例化,就有了FutureTask FutureTask12345678910111213public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;/* FutureTask实现了RunnableFuture接口，那么RunnableFuture又是什么呢？ */public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run();&#125;RunnableFuture接口继承了Runnable和Future，所以它既是一个可以让线程执行的Runnable任务，又是一个可以获取Callable返回值的Future FutureTask的属性123456789101112131415161718192021/** The run state of this task */private volatile int state;private static final int NEW = 0; private static final int COMPLETING = 1; private static final int NORMAL = 2; private static final int EXCEPTIONAL = 3; private static final int CANCELLED = 4; private static final int INTERRUPTING = 5; private static final int INTERRUPTED = 6; /** The underlying callable; nulled out after running */private Callable&lt;V&gt; callable;/** The result to return or exception to throw from get() */private Object outcome;/** The thread running the callable; CASed during run() */private volatile Thread runner;/** Treiber stack of waiting threads */private volatile WaitNode waiters; 1. 初始化时是NEW 2. 任务终止的状态有NORMAL（正常结束）、EXCEPTIONAL（异常结束）、CANCELLED（被取消）、INTERRUPTED（执行中被中断），这些状态是通过set()、setException、cancel()方法触发的 3. COMPLETING 和 INTERRUPTING是两个中间状态，当正常结束设置outcome属性前是COMPLETING，设置后变成NORMAL；当中断运行中线程前是INTERRUPTING，调用thread.interrupt()后是INTERRUPTED 可能的状态转换： NEW -&gt; COMPLETING -&gt; NORMAL NEW -&gt; COMPLETING -&gt; EXCEPTIONAL NEW -&gt; CANCELLED NEW -&gt; INTERRUPTING -&gt; INTERRUPTED callable 是线程执行的有返回值的任务 outcome 是任务执行后的结果或异常 waiters 表示等待获取结果的阻塞线程，链表结构，后等待线程的会排在链表前面 FutureTask的构造器FutureTask(Callable callable) 123456public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable&#125; FutureTask(Runnable runnable, V result) 12345678public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable&#125;/**参数为Runnable和带泛型的result对象，由于Runnable本身是没有返回值的，故线程的执行结果通过result返回*/ FutureTask的APIhttp://www.cnblogs.com/trust-freedom/p/6867755.html 测试1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.Future;public class TestFuture &#123; public static void main(String[] args) &#123; ExecutorService executor = Executors.newFixedThreadPool(1); Task task = new Task(); //callable任务 Future&lt;Integer&gt; result = executor.submit(task); executor.shutdown(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; System.out.println("主线程在执行任务"); try &#123; System.out.println("task运行结果："+result.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; System.out.println("所有任务执行完毕"); &#125; static class Task implements Callable&lt;Integer&gt;&#123; @Override public Integer call() throws Exception &#123; System.out.println("子线程在进行计算"); Thread.sleep(3000); int sum = 0; for(int i=0;i&lt;100;i++) sum += i; return sum; &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程池（ThreadPoolExecutor）]]></title>
    <url>%2F2018%2F05%2F15%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88ThreadPoolExecutor%EF%BC%89%2F</url>
    <content type="text"><![CDATA[线程的原理与使用 线程池的架构 1. Executor是最基础的执行接口。里面只有一个execute() 2. ExecutorService接口继承了Executor，在其上做了一些shutdown()，submit()，shutdownNow()的扩展，可以说是真正的线程池接口 3. AbstractExecutorService抽象类实现了ExecutorService接口中的大部分方法； 4. ThreadPoolExecutor继承了AbstractExecutorService，是线程池的具体实现。 5. ScheduledExecutorService和ScheduledThreadPoolExecutor是有&quot;周期执行&quot;功能。 6. Executor是线程池的静态工厂，提供了创建线程池的静态方法 Executorvoid execute(Runnable command); 可以用来执行已经提交的Runnable任务对象，这个接口提供了一种将“任务提交”与“任务执行”解耦的方法。 ExecutorService“执行者服务”接口，可以说是真正的线程池接口，在Executor接口的基础上做了一些扩展 管理任务如何终止的 shutdown相关方法12345678910111213141516171819202122232425262728/** * 启动一次有序的关闭，之前提交的任务执行，但不接受新任务 * 这个方法不会等待之前提交的任务执行完毕 */void shutdown(); /** * 试图停止所有正在执行的任务，暂停处理正在等待的任务，返回一个等待执行的任务列表 * 这个方法不会等待正在执行的任务终止 */List&lt;Runnable&gt; shutdownNow(); /** * 如果已经被shutdown，返回true */boolean isShutdown(); /** * 如果所有任务都已经被终止，返回true * 是否为终止状态 */boolean isTerminated(); /** * 在一个shutdown请求后，阻塞的等待所有任务执行完毕 * 或者到达超时时间，或者当前线程被中断 */boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; 可以生成用于追踪一个或多个异步任务执行结果的Future对象的 submit()相关方法1234567891011121314151617/** * 提交一个可执行的任务，返回一个Future代表这个任务 * 等到任务成功执行，Future#get()方法会返回null */Future&lt;?&gt; submit(Runnable task); /** * 提交一个可以执行的任务，返回一个Future代表这个任务 * 等到任务执行结束，Future#get()方法会返回这个给定的result */&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); /** * 提交一个有返回值的任务，并返回一个Future代表等待的任务执行的结果 * 等到任务成功执行，Future#get()方法会返回任务执行的结果 */&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); ScheduledExecutorService12345678910111213141516171819202122232425262728293031/** * 在给定延时后，创建并执行一个一次性的Runnable任务 * 任务执行完毕后，ScheduledFuture#get()方法会返回null */public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit); /** * 在给定延时后，创建并执行一个ScheduledFutureTask * ScheduledFuture 可以获取结果或取消任务 */public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, ong delay, TimeUnit unit); /** * 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期 * 也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推 * 如果执行任务发生异常，随后的任务将被禁止，否则任务只会在被取消或者Executor被终止后停止 * 如果任何执行的任务超过了周期，随后的执行会延时，不会并发执行 */public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit); /** * 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟 * 如果执行任务发生异常，随后的任务将被禁止，否则任务只会在被取消或者Executor被终止后停止 */public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit); ThreadPoolExecutor构造器1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 1. corePoolSize：线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize。 1. 如果当前线程数是corePoolSize，继续提交的任务被保存在阻塞队列中，等待空闲线程执行它 2. 如果执行了线程池的prestartAllCoreThreads方法，线程池会提前启动所有核心线程。 2. maximumPoolSize：线程池中允许的最大线程数。如果阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于等于maximumPoolSize 3. keepAliveTime：线程空闲时的存活时间。当线程没有任务执行时，继续存活的时间。默认情况下，该参数只有在线程数大于corePoolSize时才有用 4. workQueue：workQueue必须是BlockingQueue阻塞队列。当线程池中的线程数超过corePoolSize时，线程会进入阻塞队列进行阻塞等待。通过workQueue，线程池实现了阻塞功能 5. threadFactory：创建线程的工厂（pool-数字-thread-数字） 6. rejectedExecutionHandler：饱和策略，阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务 1. AbortPolicy：直接抛出异常，默认策略 2. CallerRunsPolicy：用调用者所在的线程执行任务 3. DiscardOldestPolicy：丢弃阻塞队列中最靠前的任务 4. DiscardPolicy：直接丢弃任务 执行流程（execute()）1. 线程池中的线程数量小于corePoolSize，创建新线程执行新添加的任务 2. 线程池中的线程数大于等于corePoolSize，但是workQueue没有满，将新添加的任务放到workQueue中，按照FIFO的原则依次等待执行 3. 线程池中的数量大于等于corePoolSize，同时workQueue也满了，但是线程池的线程数小于maximunPoolSize，则创建新的线程来处理被添加的任务 4. 当线程中的线程数等于maximumPoolSize时，使用RejectExecutionHandler来做拒绝处理。 总之，新的任务处理时，先看currentThreadNums，是不是小于corePoolSize，如果大于，看workQueue是不是满了，如果满了，看currentThreadNums是不是大于maximumPoolSize，如果大于，执行拒绝策略。 注意:当线程池中的线程数大于corePoolSize时，如果里面有线程的空间时间超过了keepAliveTime，就将其移除线程池。 Executor静态工厂创建几种常见线程池newFixedThreadPool123456789101112public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory);&#125; 1. 创建一个指定工作线程数的线程池，其中参数 corePoolSize 和 maximumPoolSize 相等，阻塞队列基于LinkedBlockingQueue 2. 它是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是在线程池空闲时，即线程池中没有可运行任务时，它也不会释放工作线程，还会占用一定的系统资源 newSingleThreadExecutor1234567891011121314public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125; public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory));&#125; 1. 初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行，内部使用LinkedBlockingQueue作为阻塞队列 newCachedThreadPool123456789101112public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), threadFactory);&#125; 1. 创建一个可缓存工作线程的线程池，默认存活时间60秒，线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列； 2. 在没有任务执行时，当线程的空闲时间超过keepAliveTime，则工作线程将会终止，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销 newScheduledThreadPool12345678public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125; public static ScheduledExecutorService newScheduledThreadPool( int corePoolSize, ThreadFactory threadFactory) &#123; return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);&#125; 1. 初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据 线程池的执行流程（内部原理） 线程池状态123456789101112131415private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));private static final int COUNT_BITS = Integer.SIZE - 3;private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; // runState is stored in the high-order bitsprivate static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; // Packing and unpacking ctlprivate static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125;private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125;private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; 其中ctl这个AtomicInteger的功能很强大，其高3位用于维护线程池运行状态，低29位维护线程池中线程数量 1、RUNNING：-1&lt;&lt;COUNT_BITS，即高3位为1，低29位为0，该状态的线程池会接收新任务，也会处理在阻塞队列中等待处理的任务 2、SHUTDOWN：0&lt;&lt;COUNT_BITS，即高3位为0，低29位为0，该状态的线程池不会再接收新任务，但还会处理已经提交到阻塞队列中等待处理的任务 3、STOP：1&lt;&lt;COUNT_BITS，即高3位为001，低29位为0，该状态的线程池不会再接收新任务，不会处理在阻塞队列中等待的任务，而且还会中断正在运行的任务 4、TIDYING：2&lt;&lt;COUNT_BITS，即高3位为010，低29位为0，所有任务都被终止了，workerCount为0，为此状态时还将调用terminated()方法 5、TERMINATED：3&lt;&lt;COUNT_BITS，即高3位为100，低29位为0，terminated()方法调用完成后变成此状态 这些状态均由int型表示，大小关系为 RUNNING&lt;SHUTDOWN&lt;STOP&lt;TIDYING&lt;TERMINATED，这个顺序基本上也是遵循线程池从 运行 到 终止这个过程。 runStateOf(int c) 方法：c &amp; 高3位为1，低29位为0的~CAPACITY，用于获取高3位保存的线程池状态 workerCountOf(int c)方法：c &amp; 高3位为0，低29位为1的CAPACITY，用于获取低29位的线程数量 ctlOf(int rs, int wc)方法：参数rs表示runState，参数wc表示workerCount，即根据runState和workerCount打包合并成ctl 内部原理execute(Runnable command) – 提交任务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** * Executes the given task sometime in the future. The task * may execute in a new thread or in an existing pooled thread. * 在未来的某个时刻执行给定的任务。这个任务用一个新线程执行，或者用一个线程池中已经存在的线程执行 * * If the task cannot be submitted for execution, either because this * executor has been shutdown or because its capacity has been reached, * the task is handled by the current &#123;@code RejectedExecutionHandler&#125;. * 如果任务无法被提交执行，要么是因为这个Executor已经被shutdown关闭，要么是已经达到其容量上限，任务会被当前的RejectedExecutionHandler处理 * * @param command the task to execute * @throws RejectedExecutionException at discretion of * &#123;@code RejectedExecutionHandler&#125;, if the task * cannot be accepted for execution RejectedExecutionException是一个RuntimeException * @throws NullPointerException if &#123;@code command&#125; is null */public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); /* * Proceed in 3 steps: * * 1. If fewer than corePoolSize threads are running, try to * start a new thread with the given command as its first * task. The call to addWorker atomically checks runState and * workerCount, and so prevents false alarms that would add * threads when it shouldn't, by returning false. * 如果运行的线程少于corePoolSize，尝试开启一个新线程去运行command，command作为这个线程的第一个任务 * * 2. If a task can be successfully queued, then we still need * to double-check whether we should have added a thread * (because existing ones died since last checking) or that * the pool shut down since entry into this method. So we * recheck state and if necessary roll back the enqueuing if * stopped, or start a new thread if there are none. * 如果任务成功放入队列，我们仍需要一个双重校验去确认是否应该新建一个线程（因为可能存在有些线程在我们上次检查后死了） 或者 从我们进入这个方法后，pool被关闭了 * 所以我们需要再次检查state，如果线程池停止了需要回滚入队列，如果池中没有线程了，新开启 一个线程 * * 3. If we cannot queue task, then we try to add a new * thread. If it fails, we know we are shut down or saturated * and so reject the task. * 如果无法将任务入队列（可能队列满了），需要新开区一个线程（自己：往maxPoolSize发展） * 如果失败了，说明线程池shutdown 或者 饱和了，所以我们拒绝任务 */ int c = ctl.get(); /** * 1、如果当前线程数少于corePoolSize（可能是由于addWorker()操作已经包含对线程池状态的判断，如此处没加，而入workQueue前加了） */ if (workerCountOf(c) &lt; corePoolSize) &#123; //addWorker()成功，返回 if (addWorker(command, true)) return; /** * 没有成功addWorker()，再次获取c（凡是需要再次用ctl做判断时，都会再次调用ctl.get()） * 失败的原因可能是： * 1、线程池已经shutdown，shutdown的线程池不再接收新任务 * 2、workerCountOf(c) &lt; corePoolSize 判断后，由于并发，别的线程先创建了worker线程，导致workerCount&gt;=corePoolSize */ c = ctl.get(); &#125; /** * 2、如果线程池RUNNING状态，且入队列成功 */ if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get();//再次校验位 /** * 再次校验放入workerQueue中的任务是否能被执行 * 1、如果线程池不是运行状态了，应该拒绝添加新任务，从workQueue中删除任务 * 2、如果线程池是运行状态，或者从workQueue中删除任务失败（刚好有一个线程执行完毕，并消耗了这个任务），确保还有线程执行任务（只要有一个就够了） */ //如果再次校验过程中，线程池不是RUNNING状态，并且remove(command)--workQueue.remove()成功，拒绝当前command if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); //如果当前worker数量为0，通过addWorker(null, false)创建一个线程，其任务为null //为什么只检查运行的worker数量是不是0呢？？ 为什么不和corePoolSize比较呢？？ //只保证有一个worker线程可以从queue中获取任务执行就行了？？ //因为只要还有活动的worker线程，就可以消费workerQueue中的任务 else if (workerCountOf(recheck) == 0) addWorker(null, false); //第一个参数为null，说明只为新建一个worker线程，没有指定firstTask //第二个参数为true代表占用corePoolSize，false占用maxPoolSize &#125; /** * 3、如果线程池不是running状态 或者 无法入队列 * 尝试开启新线程，扩容至maxPoolSize，如果addWork(command, false)失败了，拒绝当前command */ else if (!addWorker(command, false)) reject(command);&#125; 参数： command 提交执行的任务，不能为空 执行流程： 1、如果线程池当前线程数量少于corePoolSize，则addWorker(command, true)创建新worker线程，如创建成功返回，如没创建成功，则执行后续步骤； addWorker(command, true)失败的原因可能是： A、线程池已经shutdown，shutdown的线程池不再接收新任务 B、workerCountOf(c) &lt; corePoolSize 判断后，由于并发，别的线程先创建了worker线程，导致workerCount&gt;=corePoolSize 2、到这一步说明，当前线程说已经大于等于corePoolSize了（或者shutdown），如果线程池还在running状态，将task加入workQueue阻塞队列中，如果加入成功，进行double-check，如果加入失败（可能是队列已满），则执行后续步骤； double-check主要目的是判断刚加入workQueue阻塞队列的task是否能被执行 A、如果线程池已经不是running状态了，应该拒绝添加新任务，从workQueue中删除任务 B、如果线程池是运行状态，或者从workQueue中删除任务失败（刚好有一个线程执行完毕，并消耗了这个任务），确保还有线程执行任务（只要有一个就够了） 3、如果线程池不是running状态 或者 无法入队列，尝试开启新线程，扩容至maxPoolSize，如果addWork(command, false)失败了，拒绝当前command addWorker(Runnable firstTask, boolean core) – 添加worker线程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/** * Checks if a new worker can be added with respect to current * pool state and the given bound (either core or maximum). If so, * the worker count is adjusted accordingly, and, if possible, a * new worker is created and started, running firstTask as its * first task. This method returns false if the pool is stopped or * eligible to shut down. It also returns false if the thread * factory fails to create a thread when asked. If the thread * creation fails, either due to the thread factory returning * null, or due to an exception (typically OutOfMemoryError in * Thread#start), we roll back cleanly. * 检查根据当前线程池的状态和给定的边界(core or maximum)是否可以创建一个新的worker * 如果是这样的话，worker的数量做相应的调整，如果可能的话，创建一个新的worker并启动，参数中的firstTask作为worker的第一个任务 * 如果方法返回false，可能因为pool已经关闭或者调用过了shutdown * 如果线程工厂创建线程失败，也会失败，返回false * 如果线程创建失败，要么是因为线程工厂返回null，要么是发生了OutOfMemoryError * * @param firstTask the task the new thread should run first (or * null if none). Workers are created with an initial first task * (in method execute()) to bypass(绕开) queuing when there are fewer * than corePoolSize threads (in which case we always start one), * or when the queue is full (in which case we must bypass queue). * Initially idle threads are usually created via * prestartCoreThread or to replace other dying workers. * * @param core if true use corePoolSize as bound, else * maximumPoolSize. (A boolean indicator is used here rather than a * value to ensure reads of fresh values after checking other pool * state). * @return true if successful */private boolean addWorker(Runnable firstTask, boolean core) &#123; //外层循环，负责判断线程池状态 retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); //状态 // Check if queue empty only if necessary. /** * 线程池的state越小越是运行状态，runnbale=-1，shutdown=0,stop=1,tidying=2，terminated=3 * 1、如果线程池state已经至少是shutdown状态了 * 2、并且以下3个条件任意一个是false * rs == SHUTDOWN （隐含：rs&gt;=SHUTDOWN）false情况： 线程池状态已经超过shutdown，可能是stop、tidying、terminated其中一个，即线程池已经终止 * firstTask == null （隐含：rs==SHUTDOWN）false情况： firstTask不为空，rs==SHUTDOWN 且 firstTask不为空，return false，场景是在线程池已经shutdown后，还要添加新的任务，拒绝 * ! workQueue.isEmpty() （隐含：rs==SHUTDOWN，firstTask==null）false情况： workQueue为空，当firstTask为空时是为了创建一个没有任务的线程，再从workQueue中获取任务，如果workQueue已经为空，那么就没有添加新worker线程的必要了 * return false，即无法addWorker() */ if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; //内层循环，负责worker数量+1 for (;;) &#123; int wc = workerCountOf(c); //worker数量 //如果worker数量&gt;线程池最大上限CAPACITY（即使用int低29位可以容纳的最大值） //或者( worker数量&gt;corePoolSize 或 worker数量&gt;maximumPoolSize )，即已经超过了给定的边界 if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; //调用unsafe CAS操作，使得worker数量+1，成功则跳出retry循环 if (compareAndIncrementWorkerCount(c)) break retry; //CAS worker数量+1失败，再次读取ctl c = ctl.get(); // Re-read ctl //如果状态不等于之前获取的state，跳出内层循环，继续去外层循环判断 if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop // else CAS失败时因为workerCount改变了，继续内层循环尝试CAS对worker数量+1 &#125; &#125; /** * worker数量+1成功的后续操作 * 添加到workers Set集合，并启动worker线程 */ boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; final ReentrantLock mainLock = this.mainLock; w = new Worker(firstTask); //1、设置worker这个AQS锁的同步状态state=-1 //2、将firstTask设置给worker的成员变量firstTask //3、使用worker自身这个runnable，调用ThreadFactory创建一个线程，并设置给worker的成员变量thread final Thread t = w.thread; if (t != null) &#123; mainLock.lock(); try &#123; //--------------------------------------------这部分代码是上锁的 // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. // 当获取到锁后，再次检查 int c = ctl.get(); int rs = runStateOf(c); //如果线程池在运行running&lt;shutdown 或者 线程池已经shutdown，且firstTask==null（可能是workQueue中仍有未执行完成的任务，创建没有初始任务的worker线程执行） //worker数量-1的操作在addWorkerFailed() if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable 线程已经启动，抛非法线程状态异常 throw new IllegalThreadStateException(); workers.add(w);//workers是一个HashSet&lt;Worker&gt; //设置最大的池大小largestPoolSize，workerAdded设置为true int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; //-------------------------------------------- &#125; finally &#123; mainLock.unlock(); &#125; //如果往HashSet中添加worker成功，启动线程 if (workerAdded) &#123; t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; //如果启动线程失败 if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted;&#125; addWorker(Runnable firstTask, boolean core) 参数： firstTask： worker线程的初始任务，可以为空 core： true：将corePoolSize作为上限，false：将maximumPoolSize作为上限 addWorker方法有4种传参的方式： 1、addWorker(command, true) 2、addWorker(command, false) 3、addWorker(null, false) 4、addWorker(null, true) 在execute方法中就使用了前3种，结合这个核心方法进行以下分析 第一个：线程数小于corePoolSize时，放一个需要处理的task进Workers Set。如果Workers Set长度超过corePoolSize，就返回false 第二个：当队列被放满时，就尝试将这个新来的task直接放入Workers Set，而此时Workers Set的长度限制是maximumPoolSize。如果线程池也满了的话就返回false 第三个：放入一个空的task进workers Set，长度限制是maximumPoolSize。这样一个task为空的worker在线程执行的时候会去任务队列里拿任务，这样就相当于创建了一个新的线程，只是没有马上分配任务 第四个：这个方法就是放一个null的task进Workers Set，而且是在小于corePoolSize时，如果此时Set中的数量已经达到corePoolSize那就返回false，什么也不干。实际使用中是在prestartAllCoreThreads()方法，这个方法用来为线程池预先启动corePoolSize个worker等待从workQueue中获取任务执行 执行流程： 1、判断线程池当前是否为可以添加worker线程的状态，可以则继续下一步，不可以return false： A、线程池状态&gt;shutdown，可能为stop、tidying、terminated，不能添加worker线程 B、线程池状态==shutdown，firstTask不为空，不能添加worker线程，因为shutdown状态的线程池不接收新任务 C、线程池状态==shutdown，firstTask==null，workQueue为空，不能添加worker线程，因为firstTask为空是为了添加一个没有任务的线程再从workQueue获取task，而workQueue为空，说明添加无任务线程已经没有意义 2、线程池当前线程数量是否超过上限（corePoolSize 或 maximumPoolSize），超过了return false，没超过则对workerCount+1，继续下一步 3、在线程池的ReentrantLock保证下，向Workers Set中添加新创建的worker实例，添加完成后解锁，并启动worker线程，如果这一切都成功了，return true，如果添加worker入Set失败或启动失败，调用addWorkerFailed()逻辑 其他http://www.cnblogs.com/trust-freedom/p/6681948.html submit与execute的区别https://blog.csdn.net/peachpi/article/details/6771946]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多态的实现原理]]></title>
    <url>%2F2018%2F05%2F08%2F%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[多态的实现原理 多态要说多态，就要先从方法调用开始说起。如何在编译期（重载）和运行期（重写）去找到执行的方法版本。 方法区中有编译后的Class文件里面存的可都是符号引用，而不是方法实际运行时内存分布的入口地址（直接引用）！！！ 解析（静态解析）所有方法调用中的目标方法在Class文件中都只是一个常量池中的符号引用，在类加载的解析阶段，会将其中一部分符号在这个阶段就转换成直接引用。 这种类加载解析阶段转换的成立条件就是：编译期可知，运行期不可变。主要包括静态方法和私有方法，前者和类型直接关联，后者在外部不可被访问。其实还有final方法。 就是说这三种方法都不可能通过继承或别的方式重写其他版本，所有适合在类加载的解析阶段进行符号引用到直接引用的转换（这个过程也叫做解析） JVM中有5条调用字节码指令：invokestatic，invokespecial，invokevirtual，invokeinterface，invokedynamic 只要能被invokestatic和invokesspecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本。 非虚方法：静态方法，构造器，私有方法，父类方法，final方法 注意一下，final方法还是被invokevirtual修饰的，只不过是不能被重写，因此确定了唯一性。 解析调用一定是个静态的过程，在编译器就被完全确定了，在类加载的解析阶段就会把涉及的符号引用全部转换成可确定的直接引用，不会延迟到运行期去进行。 分派调用分为了静态和动态。 我们这里解析和分派，不是一个二选一的过程，这两个是在不同层次上去筛选，确定目标方法的过程。 静态方法选择重载的过程也是在编译期间利用静态分派完成的。 分派静态分派1234567891011121314151617181920212223242526272829303132public class StaticDispatch &#123; static abstract class Human&#123;&#125; static class Man extends Human&#123;&#125; static class Woman extends Human&#123;&#125; public void say(Human guy)&#123; System.out.println("human --- guy"); &#125; public void say(Man man)&#123; System.out.println("man --- gentleman"); &#125; public void say(Woman woman)&#123; System.out.println("woamn --- lady"); &#125; public static void main(String[] args) &#123; Human man = new Man();//静态类型是Human，实际类型是Man Human woman = new Woman();//静态类型是Human，实际类型是Woman StaticDispatch sd = new StaticDispatch(); sd.say(man); sd.say(woman); &#125;&#125;/** human --- guy human --- guy*/ 1234567891011121314151617181920212223242526272829303132public class StaticOverload &#123;// public static void say(char arg)&#123;// System.out.println("char");// &#125;// public static void say(int arg)&#123;// System.out.println("int");// &#125;// public static void say(long arg)&#123;// System.out.println("long");// &#125;// public static void say(Character arg)&#123;// System.out.println("Character");// &#125;// public static void say(Serializable arg)&#123;// System.out.println("Serializable");// &#125;// public static void say(Object arg)&#123;// System.out.println("Object");// &#125; public static void say(char... arg)&#123; System.out.println("char..."); &#125; public static void say(Integer arg)&#123; System.out.println("Integer"); &#125; public static void say(Long arg)&#123; System.out.println("Long"); &#125; public static void main(String[] args) &#123; say('a'); &#125;&#125; 1. 重载时，编译器根据参数的静态类型来确定方法入口。 2. char--&gt;int--&gt;long--&gt;Character--&gt;Serializable--&gt;Object--&gt;char.. 1. char，int，long属于基本数据类型的自动向上转型 2. Character是char的自动装箱 3. Serializable是Character实现的一个接口，因为找不到装箱的类，但是找到了装箱类实现的接口，所以紧接着就又发生了一次自动转型。 但是为什么Character没有转成Integer呢，这可是对象啊，对象哪有什么自动转换，又不是子父类关系。 需要注意的是，Character还有一个接口Comparable&lt;Character&gt;，一旦又出现了这个参数的重载，由于优先级一致，编译器就会报错了。 4. Object子父类关系（继承关系是从下往上搜索的，上层的优先级低） 5. 可变参数的数组 动态分派1234567891011121314151617181920212223242526272829303132public class DynamicDispatch &#123; static abstract class Human&#123; public void say(Human human)&#123; System.out.println("human"); &#125; &#125; static class Man extends Human&#123; public void say(Human human)&#123;//Man man System.out.println("man"); &#125; &#125; static class Woman extends Human&#123; public void say(Human human)&#123;//Woman woman System.out.println("woman"); &#125; &#125; public static void main(String[] args) &#123; Human man = new Man(); Human woman = new Woman(); man.say(man); woman.say(woman); man = new Woman(); man.say(man); &#125;&#125;/** man woman woman*/ 1. 实际参数不同 2. invokevirtual指令的多态查找 1. 找到操作数栈顶的第一个元素所指向的对象的实际类型，记为C。 2. 如果在类型C中找到与常量中描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束。 3. 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索。 4. 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。 3. 重写的本质也就是把Class文件中常量池中的符号引用在运行期解析到了不同的直接引用上。 动态分配的实现https://blog.csdn.net/sinat_34311901/article/details/52208124 动态分派比较频繁，同时动态分派的方法版本选择过程需要在运行时在类的方法元数据中搜索合适的目标方法。 最常用的稳定优化说就是在方法区来一个虚方法表（vtable/itable），使用虚方法表索引来代替元数据查找以提高性能。 虚方法表中存放着各个方法的实际入口地址。如果子类没有实现父类的方法，那么子类和父类的入口地址一样。 测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class A &#123; public static String staticStr = "A's static field"; public String nonStaticStr = "A's nonstatic field"; public static void staticMethod()&#123; System.out.println("A's static method"); &#125; public void nonStaticMethod()&#123; System.out.println("A's nonstatic method"); &#125; &#125; class B extends A&#123; public static String staticStr = "B's static field"; public String nonStaticStr = "B's nonstatic field"; //super.nonStaticStr; public static void staticMethod()&#123; System.out.println("B's static method"); &#125; &#125;class C extends A&#123; &#125;public class TestOverride &#123; public static void main(String[] args) &#123; C c = new C(); System.out.println(c.nonStaticStr); //A's nonstatic field System.out.println(c.staticStr); //A's static field c.staticMethod(); //A's static method System.out.println("-------------------------------"); A c1 = new C(); System.out.println(c1.nonStaticStr); //A's nonstatic field System.out.println(c1.staticStr); //A's static field c1.staticMethod(); //A's static method // 以上这说明java中静态属性和静态方法可以被继承 System.out.println("-------------------------------"); B b = new B(); System.out.println(b.nonStaticStr); // B's nonstatic field System.out.println(b.staticStr); //B's static field b.staticMethod(); //B's static method System.out.println("-------------------------------"); A b1 = new B(); System.out.println(b1.nonStaticStr); //A's nonstatic field System.out.println(b1.staticStr); //A's static field b1.staticMethod(); //A's static method &#125;&#125; 1. 静态方法，属性可以继承，但是不能被重写（形式上的重写其实是隐藏） 2. 属性都是不能被重写的，因为Java中属性依赖的是同名属性依赖机制：具有父子关系的两个类中，子类中相同名字的属性会失去从父类中继承的数据，不管两个属性的类型是否一致，只要重名，就隐藏父类的。 3. 一般不要用实例对象去调用静态方法。（容易混淆） 123456789101112131415161718192021222324252627282930313233343536373839404142public class Demo &#123; public static void main(String[] args) &#123; Collection&lt;?&gt;[] collections = &#123;new HashSet&lt;String&gt;(), new ArrayList&lt;String&gt;(), new HashMap&lt;String, String&gt;().values()&#125;; Super subToSuper = new Sub(); for(Collection&lt;?&gt; collection: collections) &#123; System.out.println(subToSuper.getType(collection)); &#125; &#125; abstract static class Super &#123; public static String getType(Collection&lt;?&gt; collection) &#123; return "Super:collection"; &#125; public static String getType(List&lt;?&gt; list) &#123; return "Super:list"; &#125; public String getType(ArrayList&lt;?&gt; list) &#123; return "Super:arrayList"; &#125; public static String getType(Set&lt;?&gt; set) &#123; return "Super:set"; &#125; public String getType(HashSet&lt;?&gt; set) &#123; return "Super:hashSet"; &#125; &#125; static class Sub extends Super &#123; public static String getType(Collection&lt;?&gt; collection) &#123; return "Sub"; &#125; &#125;&#125;/** Super:collection Super:collection Super:collection*/ 1. 静态方法没有被重写，只是被覆盖了，所有调用的还是父类的getType(Collection&lt;?&gt; collection) 2. 同时数组的类型是Collection，也就是说静态类型被确定了，剩下都是静态解析和静态分配（重载）做的事情，而重载看的又只是静态类型，那么走的都是getType(Collection&lt;?&gt; collection) 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Demo &#123; public static void main(String[] args) &#123; List&lt;?&gt;[] collections = &#123;new LinkedList&lt;String&gt;(), new ArrayList&lt;String&gt;()&#125;; Super subToSuper = new Sub(); for(List&lt;?&gt; collection: collections) &#123; System.out.println(subToSuper.getType(collection)); &#125; &#125; abstract static class Super &#123; public static String getType(Collection&lt;?&gt; collection) &#123; return "Super:collection"; &#125; public static String getType(List&lt;?&gt; list) &#123; return "Super:list"; &#125; public String getType(ArrayList&lt;?&gt; list) &#123; return "Super:arrayList"; &#125; public static String getType(Set&lt;?&gt; set) &#123; return "Super:set"; &#125; public String getType(HashSet&lt;?&gt; set) &#123; return "Super:hashSet"; &#125; &#125; static class Sub extends Super &#123; public static String getType(Collection&lt;?&gt; collection) &#123; return "Sub"; &#125; public static String getType(List&lt;?&gt; list) &#123; return "Sub:list"; &#125; &#125;&#125;/** Super:list Super:list*/]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统基础复习]]></title>
    <url>%2F2018%2F05%2F04%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[操作系统基础复习 之前的总结http://bbblemon.top/2017/12/28/Operating%20System%EF%BC%88%E5%BC%95%E8%AE%BA&amp;%E8%BF%9B%E7%A8%8B&amp;%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%EF%BC%89/ http://bbblemon.top/2018/01/08/Operating%20System%EF%BC%88%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86&amp;%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%89/ 操作系统的特性1. 并发：同一时段内多个程序执行（并行说的是某一时刻有多个事件发生了，并发说的是某个时间段，微观上是多个事件交替进行，交替占用CPU） 2. 共享：系统中的资源可以被内存中多个并发执行的进线程共同使用。 3. 虚拟：通过时分复用（如分时系统）以及空分复用（如虚拟内存）技术实现把一个物理实体虚拟为多个 4. 异步：系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进。 并发和共享是多用户OS的两个最基本特性。又互为存在条件。资源的共享是以并发为前提的，资源共享如果无法有效管理，影响并发。 操作系统的分类1. 批处理：批处理系统旨在提高系统资源的利用率和系统吞吐量。 1. 单批道：系统虽然对作业的处理是成批的，但是在内存中却始终只有一道作业。 2. 多批道：系统利用作业调度算法，从外存中一次取若干个作业调入内存，使它们共享CPU和系统中的资源。利用一个作业I/O的时间，在CPU上执行另一个作业。 特点：资源利用率高，系统吞吐量大，平均周转时间长，无交互能力。 2. 分时：批处理是为了提高资源利用率和系统吞吐量，分时是为了满足人-机交互。 分时系统说的是，一台主机上连接了多个配有显示器和键盘的终端并由此组成的系统。该系统允许多个用户同时通过自己的终端，以交互方式使用计算机，共享主机的资源。 多道批处理是把作业都先驻留在了外存上，即使被调如内存，也要经过较长时间的等待后才能运行，也就失去了交互性。 分时的人-机交互，关键就在这个交互与系统及时接收，处理，返回结果。 1. 及时接收：利用多路卡，实现分时多路复用。主机以很快的速度周期性的扫描各个终端，在每个终端处停留的时间很短，用来接收各个终端的数据。 2. 及时处理： 1. 作业直接进入内存。（批处理是现在外存的） 2. 采用轮转运行方式。（时间片，一段很短的时间，每个作业每次只能运行一个时间片，然后就暂停该作业的运行，立即调度下一个作业运行） 特点：多路性，独立性，及时性，交互性。 3. 实时：计算机能及时响应外部时间的i去年请求，在规定的严格时间内完成对该事件的处理，并控制所有实时设备和任务协调一致的工作。 实时系统追求的目标就是对外部请求在严格时间范围内做出反应，有高可靠性和完整性。资源的分配和调度首先考虑的是实时性然后才是效率。 分类： 1. 周期实时任务和非周期实时任务 2. 硬实时任务和软实时任务 特点：多路性，独立性，及时性，交互性，可靠性。 4. 网络和分布式 操作系统的主要功能1. 处理机管理：处理机分配是以进程为单位的，处理机管理也被看作进程管理。 处理机的管理主要是，将作业调入内存，为其创建，撤销进程，控制进程的运行过程，实现进程通信，和为进程分配处理机。 1. 进程控制：每道作业都需要一个或者多个进程，进程控制就是创建，撤销进程和控制进程在运行过程中的状态转换。 2. 进程同步：为多个进程的运行进行协调。协调方式 1. 进程互斥，进程在对临界资源访问时，采用互斥的方式。最常用的就是给每个临界资源加锁。 2. 进程同步，相互协作去完成共同任务的进程间，利用同步机构对这些进程的执行次序进行控制。最常用的进程同步机制就是信号量机制。 3. 进程通信： https://www.cnblogs.com/LUO77/p/5816326.html 4. 调度： 1. 作业调度：从后备队列中按照一定的算法选择若干作业，为它们分配运行时需要的资源，再将这些作业调入内存后，分别为它们建立进程，使它们都能称为可能获得处理机的就绪进程，并将它们插入就绪队列中。 2. 进程调度：从进程就绪队列中按照算法选一个进程，将处理机分配给它，并为它设置运行现场。 2. 存储器管理 为多道程序提供良好的环境，提高存储器的利用率，方便用户使用，逻辑上扩充内存。 1. 内存分配：为每道程序分配内存，提高存储器的利用率，尽量减少碎片，允许正在运行的程序申请附加的内存空间。 内存分配的方式： 1. 静态：每个作业的内存空间在作业装入内存时确定，运行期间不可修改，作业不允许在内存中移动。 2. 动态：每个作业的内存空间在作业装入内存的时候只是确定一个基本量，在运行时允许扩充，允许作业在内存中移动。 2. 内存保护：内存保护机制，简单的就是设置两个界限寄存器，分别放在正在执行程序的上下界。 1. 每道程序都只能在自己的内存空间运行 2. 用户程序禁止访问OS程序和数据，也不允许用户程序转移到非共享的其他用户程序中去执行。 3. 地址映射：每道程序编译和链接后所形成的可装入程序其地址都是从0开始的，但是不可能将它们从0这个物理地址装入，地址映射也就是把地址空间中的逻辑地址转换成内存空间中与之对应的物理地址。 4. 内存扩充：虚拟存储 1. 请求调入：系统可以在仅装入一部分用户程序和数据的情况下运行，后面需要了再调入 2. 置换功能：内存中没有足够的空间调入程序和数据，系统将内存中一部分暂时不用的程序和数据调至硬盘上，然后腾出内存空间，把需要用的再调入内存。 3. 设备管理 1. 完成用户进程提出的I/OC请求。 2. 提高CPU与I/O设备的利用率。 1. 缓冲管理：I/O设备和CPU运行速度的不匹配，之间设置高速缓冲区。 单缓冲机制，双缓冲机制，公用缓冲池机制 2. 设备分配：为程序的I/O请求分配I/O设备。 3. 设备处理：实现CPU和设备控制器之间的通信，CPU向设备控制器发送I/O命令，设备控制器发送中断请求给CPU。 4. 文件管理 对用户文件和系统文件进行管理，以方便用户使用，并保证文件的安全性。 1. 文件存储空间的管理 2. 目录管理 3. 文件的读写管理与保护 5. 提供用户接口 1. 程序接口，API 2. 用户接口，GUI 进程的状态与转换http://bbblemon.top/2017/12/28/Operating%20System%EF%BC%88%E5%BC%95%E8%AE%BA&amp;%E8%BF%9B%E7%A8%8B&amp;%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%EF%BC%89/ 进程与线程的区别1. 调度单元：进程是可拥有系统资源的基本单位，线程调度和分配的基本单元（能独立运行的基本单元） 2. 并发性：线程是轻量级的进程，一个进程中多个线程并发执行 3. 拥有资源：不管有没有线程，进程都是拥有系统资源的解基本单位。而线程本身不拥有系统资源，而只有又一点不可少的，能保证独立运行的资源（TCB,程序计数器，保留局部变量，少数状态参数和返回地址等一组寄存器和堆栈） 4. 独立性：进程只有自己独立空间和其他资源，除了共享全局变量外，不允许其他进程访问。而同一进程的所有线程可以访问所属进程空空间中的所有地址。 5. 系统开销：创建，切换，撤销进程的开销大 注意：一个进程中至少又一个线程，CPU上可以没有正在运行的进程。一个线程只属于某一个特定的进程。 进程描述一个进程就是一个完成程序的一次执行。 为了使参与并发的程序可以独立运行，引入了PCB。 程序段，相关数据段，PCB三部分组成了进程实体。创建进程，其实就是创建PCB。 PCB是进程存在的唯一标识 进程的其他定义: 1. 进程是程序的一次执行 2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。 3. 进程是系统进行资源分配和调度的一个独立单元。 进程的特征：动态性，并发性，独立性，异步性。 PCB（Process Control Block）PCB作为进程实体的一部分，记录了操作系统所需的，用于描述当前进程情况已经管理进程的一切信息。 PCB的作用是在多道程序的环境下，让不能独立运行的程序成为一个独立运行的基本单位。 进程创建1. 进程申请空白PCB，并向PCB中填写控制和管理进程的信息 2. 为进程分配运行时需要的资源，包括逻辑和物理的 3. 进程转入就绪状态并插入就绪队列 注意：进程不能拒绝其子进程的继承。但是也存在没有父进程的进程。 在WindowOS中不存在任何进程层次结构的概念，也就是说，所有的进程都是相同的地位。 线程描述在OS中引入进程的目的是为了在多道环境下，多个进程并发执行，以提高资源利用率和系统吞吐量。那么引入线程就是为了减小程序在并发执行时所付出的时空开销，让OS具有更好的并发性。 TCP1. 线程标识符，每个线程是唯一的。 2. 一组寄存器：程序计数器PC、状态寄存器、通用寄存器 3. 线程运行状态 4. 优先级 5. 线程专有存储区，用于线程切换时存放现场保护信息 6. 信号屏蔽 7. 堆栈指针，每个线程有自己的堆栈，用来保存局部变量和返回地址，而TCB中也就有了两个对应的指向堆栈的指针：指向用户自己堆栈的指针（线程运行在目态）和指向核心栈的指针（线程运行在管态）。 进程/线程通信https://www.cnblogs.com/LUO77/p/5816326.html Linux线程间通信：互斥量（mutex），信号量，条件变量 Windows进程间通信：管道、有名管道、消息队列、共享内存、信号量（semaphore）、套接字(socket) Windows线程间通信：互斥量（mutex），信号量（semaphore）、临界区（critical section）、事件（event） 整形信号量定义为一个用于表示资源数目的整形量S，除了初始化外，只能通过两个标准的原子操作wait（P）、Singal（V）来操作。 其实就是说，S等于多少，就代表现在还有几个空闲的资源，为负数就说明没有了，还有线程在等待资源。但是信号量不能用于大批数据交换。 管道是一种半双工的通信方式，数据只能单向流动，而且只能在有亲缘关系的进程中使用 有名管道也是一种半双工的通信方式，但是它允许无亲缘关系进程间的通信。 进程同步多进程虽然提高了系统资源利用率和吞吐量，但是由于进程的异步性可能造成系统的混乱。进程同步的任务就是对多个相关进程在执行顺序上进行协调，使并发执行的多个进程之间可以有效的共享资源和相互合作，保证程序执行的可再现性 临界区：每个进程中访问临界资源的代码就是临界区。 同步机制需要遵循的规则 1. 空闲让进：当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请。 2. 忙则等待：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问 3. 有限等待：对要求访问临界资源的进程，需要在有限时间内进入临界区，防止出现死等 4. 让权等待：当进程无法进入临界区的时候，需要释放处理机，边陷入忙等。 进程同步的解决进程同步：为多个进程的运行进行协调。协调方式 1. 进程互斥，进程在对临界资源访问时，采用互斥的方式。最常用的就是给每个临界资源加锁。 2. 进程同步，相互协作去完成共同任务的进程间，利用同步机构对这些进程的执行次序进行控制。最常用的进程同步机制就是信号量机制。 信号量利用信号量实现进程互斥 为使多个进程互斥地访问某临界资源，只需要为该资源设置-互斥信号量mutex，并设其值为1。利用信号量实现两个进程互斥的描述如下: 设mutex为互斥信号量，其值为1，取值范围（-1，0，1） 1. mutex=1，两个进程都没有进入需要互斥的临界区 2. mutex=0，表示有一个进程进入临界区运行，另一个必须等待，挂入阻塞队列。 3. mutex=-1，表示有一个进程进入了临界区，另一个进程因等待而阻塞在信号量队列中，需要在被当前已在临界区运行的进程退出时唤醒。 在利用信号量机制实现进程互斥的时候，wait(mutex)和signal(mutex)必须成对的出现。缺少wait(mutex)不能保证对临界资源的互斥访问，缺少signal(mutex)，会使临界资源永远不被释放。 管程管程包含了面向对象的思想，它将表征共享资源的数据结构及其对数据结构操作的一组过程，封装到了一个对象内部，隐藏了实现细节。进程要访问临界资源的时候，都只能通过管程间接访问，而管程每次只允许一个进程进入。 用户态（目态）和核心态（系统态，管态）CPU的工作方式分为管态和目态，在管态方式CPU可以执行特权指令，而目态只能执行非特权指令。 从用户态到管态： 使用特权指令，而不是系统调用，能进行系统调用，说明已经在管态了。用户态执行特权指令，肯定是非法的，要发生中断，而中断处理程序都是在管态的，中断一定能使系统从用户态转为管态。 死锁一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么这组进程是死锁的。 1. 死锁的必要条件 1. 互斥条件：某个资源在一段时间内只能由一个进程占有。 2. 请求和保持条件：进程自己占有一个资源，同时对别的资源进行了请求，而这个资源被其他进程占有着。 3. 不可抢占条件:进程已经获取的资源在未使用完前不能被抢占。 4. 循环等待条件:存在一个进程-资源的循环链。 2. 死锁的处理 1. 预防死锁：因为互斥条件是非共享设备必须的，所以一般都是破坏死锁的后三个条件。 1. 破坏请求保持：进程在请求资源时，不能持有不可抢占的资源。（静态资源分配法） 2. 破坏不可抢占：一个进程已占有某些不可抢占的资源，但是它又请求了资源，且不能被满足，这个进程就必须释放所有自己资源。（剥夺分配法） 3. 破坏循环等待：给资源事先分类编号，使进程在申请资源的时候，必须按照序号递增的顺序请求。（资源有序分配） 2. 避免死锁：在资源动态分配的过程中，用某种方法防止系统进入不安全状态。 安全状态一定不死锁，不安全状态不一定死锁。 3. 检测死锁：允许进程在运行的过程中死锁，但是可以检测出来，然后利用解除死锁的方法进行接触。（资源分配图法） 4. 解除死锁： 1. 抢占资源：从一个或者多个进程中抢占足够数量的资源，分配给死锁进程。 2. 终止进程：终止系统中一个或者多个死锁进程，直到打破循环环路。 1. 终止所有死锁进程 2. 逐个终止进程 线程同步与阻塞的关系？https://www.cnblogs.com/Anker/p/5965654.html 1. 线程同步和阻塞没有一点关系 2. 同步和异步关注的是消息通信机制。 1. 同步：执行一个操作，等待结果返回后，才能继续后续的操作。 2. 异步：执行一个操作，不需要等到结果返回，就可以执行别的操作，等到结果返回了，再去执行后续操作 3. 阻塞和非阻塞关注的是程序在等得调用结果时的状态。 1. 阻塞：进程给CPU传达一个任务后，等待CPU处理完以后，才执行后面的。 2. 非阻塞：进程给CPU任务后，继续执行后续操作，隔断时间再来询问之前的操作是不是完成了。（轮询） 异步必然是非阻塞的。 作业/进程调度算法1. 先来先服务（FCFS，First-come First-Served）：作业/进程调度算法（作业/进程后备队列）。长作业有利。 2. 短作业优先（SJF，Short Job First）：作业/进程调度算法（作业/进程后备队列）。短作业有利。 1. 必须预知作业/进程的运行时间 2. 对长作业不利，出现饥饿现象 3. 人-机无法交互 3. 优先级调度（PSA，Priority-Scheduling Algorithm）： 作业/进程调度算法（作业/进程后备队列）。人为给作业/进程给了优先级 4. 高响应比（HRRN，Highest Response Ratio Next）：作业/进程调度算法（作业/进程后备队列）。响应比=（等待时间+要求服务时间）/要求服务时间。 1. 响应时间=等待时间+要求服务时间 2. 周转时间=作业提交---&gt;作业完成 5. 轮转调度（RR，Round Robin）：分时系统中中基于时间片的调度。（进程调度） 按到达的先后将进程放入队列中（FCFS），然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环;一旦时间片内进程结束，直接将其从就绪队列中删除，引入新的队首进程。 6. 优先级调度 1. 非抢占 2. 抢占 如何确定优先级： 1. 静态：创建进程时确定，进程运行过程中不变 2. 动态：随着进程的推进和等待时间的增加而改变 7. 多队列调度：将系统中进程就绪队列从一个拆成多个，每个就绪队列采用不同的调度算法。 8. 多级反馈队列（Multileved Feedback Queue） 1. 设置多个就绪队列，每个队列又不同的优先级，第一个队列的最高，以此递减。优先级越高的队列分配的时间片越短。 2. 每个队列使用FCFS算法，进程到达之后按FCFS放入第一个队列尾部，如果调度执行（时间片内）没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部…。 3. 按照队列优先级调度，只有当前一个队列为空的时候才会去调度下一个队列的进程。 内存的连续分配1. 单一连续分配：单道程序环境中，存储器管理方式把内存分为系统区和用户区两部分。系统区给OS使用，它通常是放在内存的低址部分，而用户区内存中，仅装有一道用户程序。整个内存的用户空间被该程序独占。 2. 固定分区分配：对用户空间分区，然后每个区放一道程序。 3. 动态分区分配 1. 数据结构：空闲分区表，空闲分区链 2. 动态分区分配算法：顺序式搜索，索引式搜索 1. 顺序式搜索： 1. 首次适应（FF,First Fit）：空闲分区使用地址递增的次序链接。分配内存时，每次都是从链首开始，直到找到一个大小适合的内存。 2. 循环首次适应（NF,Next Fit）：分配内存的时候，不再每次从链首开始，减少了没有比较的查找，而是从上次找到的空闲分区的下一个空闲分区开始。 3. 最佳适应（BF，Best Fit）：空闲分区按照其容量从小到大顺序形成。 4. 最坏适应（WF，Worst Fit）：空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。 2. 索引式搜索： 1. 快速适应（QT，Quick Fit） 2. 伙伴系统（BS，Buddy System） 3. 哈希算法（Hash） 3. 分区操作：分配内存，回收内存。 4. 动态可重定位分区分配 1. 紧凑 2. 动态重定位：内存地址=相对地址+重定位寄存器地址 在内存连续分配中，固定分区会产生内部碎片，动态分区会产生外部碎片。 对换1. 把内存中暂时不能运行的进程，或者暂时不能使用的程序和数据换出到外存上，然后把已经具备运行条件的进程或进程所需要的程序换入内存。 2. 对换可以直接提高处理机的利用率和系统的吞吐量。 内存的离散分配（基础的分页，分段）http://bbblemon.top/2018/01/08/Operating%20System%EF%BC%88%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86&amp;%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%89/ 内存连续分配会会形成很多的碎片，就算是有&quot;紧凑的方式&quot;，但是开销特别大，为了把一个进程直接分散的装入许多不连续的分区中， 有了离散分配。 离散分配允许一个程序分散地装入到不相邻的内存分区中，根据分区的大小是否固定（分配地址的基本单位不同）分为分页存储管理方 式和分段存储管理方式。 基本分页存储管理 分页：把用户程序分成若干固定大小的区域，称为&quot;页&quot;或&quot;页面&quot;，相应的把内存空间也分为若干个物理块或页框。页和块大小相同。 1)页面和页面大小。 进程中的块称为页(Page)，内存中的块称为页框（Page Frame，或页帧）。外存也以同样的单位进行划分，直接称为块(Block)。进程在执行时需要申请主存空间，就是要为每个页面分配主存中的可用页框，这就产生了页和页框的一一对应。 为方便地址转换，页面大小应是2的整数幂。 2)地址结构 页号+页内位移量（页内地址） 若一个逻辑地址空间中的地址是A，页面大小是L，页号是P，页内地址是d，则P=A/L,d=A%L。 3)页表。为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般存放在内存中。 在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射。 基本分段存储管理分页管理方式是从计算机的角度考虑设计的，以提高内存的利用率，提升计算机的性能, 且分页通过硬件机制实现，对用户完全透明；而分段管理方式的提出则是考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。 段式管理方式按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这 个用户进程划分为5个段，每段从0 开始编址，并分配一段连续的地址空间（段内要求连续，段间不要求连续，因此整个作业的地 址空间是二维的）。其逻辑地址由段号S与段内偏移量W两部分组成。 在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的（不可见），但在段式系统中，段号和段内偏移量必须由用户显示提供， 在髙级程序设计语言中，这个工作由编译程序完成。 基本分页和分段的区别1. 页是信息的物理单位，分页是为了消除内存的碎片。分页是系统管理的行为，用户不可见。 而分段的信息的逻辑单位，分段只是为了方便用户 2. 页的大小固定而且只和系统有关，每个系统中只能有一种大小的页面，而段的长度不固定，由用户决定。 3. 分页的用户地址是一维的，分段是二维的。 虚拟内存基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序执行过程中， 当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内 容换出到外存上，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器， 称为虚拟存储器。 之所以将其称为虚拟存储器，是因为这种存储器实际上并不存在，只是由于系统提供了部分装入、请求调入和置换功能后（对用户完全 透明），给用户的感觉是好像存在一个比实际物理内存大得多的存储器。虚拟存储器的大小由计算机的地址结构决定，并非是内存和外 存的简单相加。 虚拟内存的大小=min(内存+外存，2^n),其中n为计算机的位数。 在传统存储器管理方式中，一次性和驻留性。 虚拟存储器管理方式中，多次性，对换性，虚拟性。 虚拟性是以多次性和对换性为基础的。多次性最重要。多次性和对换性又建立在离散分配的基础上。 注意：虚拟存储器的实现都是建立在离散分配存储管理方式的基础上的。 虚拟存储器的实现1. 请求分页系统 2. 请求分段系统 请求分页/分段存储管理方式（页面置换算法）http://bbblemon.top/2018/01/08/Operating%20System%EF%BC%88%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86&amp;%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%89/ 磁盘与设备管理http://bbblemon.top/2018/01/09/Operating%20System%EF%BC%88%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86&amp;IO%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%EF%BC%89/ 文件管理http://bbblemon.top/2018/01/08/Operating%20System%EF%BC%88%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86&amp;%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%89/]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络基础复习]]></title>
    <url>%2F2018%2F05%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[计算机网络基础复习 Https与Http的区别1. http是HTTP协议运行在TCP上。所有传输的内容都是明文，客户端和服务端都无法验证对方的身份。 2. https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP上，所有传输的内容都是经过加密的，加密采用对称加密。但是对称加密的密钥用服务器方的证书进行了非对称加密。 3. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 4. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443 5. http无状态。 TCP如何保证可靠传输1. 数据包校验 2. 超时重传机制 3. 应答机制 4. 对失序数据包重排序 5. TCP还能提供流量控制。 三次握手与四次挥手https://www.zhihu.com/question/24853633 TCP连接握手，握的就是通信双方数据原点的序列号。 1. seq序号：用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。 2. ack确认序号：只有ACK标志位为1时，确认序号字段才有效。 3. 标志位 1. URG：紧急指针（Urgent Pointer）有效 2. ACK：确认序号有效 3. PSH：接收方应该尽快将这个报文交给应用层 4. RST：重置连接 5. SYN：发起一个新连接 6. FIN：释放一个连接 4. 不要将确认序号ack与ACK标志位搞混；确认方ack=发起方seq+1 1. 第一握手，客户端发送SYN（seq，随机选取一个序列号作为自己的初始序号）（Synchronize Sequence Numbers）包到服务器，并进入SYN_SNET状态，等待服务器确认。 2. 第二次握手，服务器收到seq包，必须确认客户的seq，使用ack对A的数据包进行确认，因为以后收到了序列号为x的数据包，准备接收序列号是x+1的包，所以ack=x+1，同时告诉客户端自己的初始序列号。服务器进入SYN_RECV状态 3. 第三次握手，客户端收到服务器的ack与seq，向服务器发送确认包seq、ack，客户端此条消息的序列号是x+1，所以seq=x+1，而ack=y+1，ack表示客户端正准备接收服务器序列号是y+1的数据包，此包发送完毕，客户端和服务器都进入ESTABLISHED（TCP连接成功），完成三次握手 1. 第一次挥手：A认为数据发送完了，需要向B发送连接释放请求。该请求只有报文头，头中携带主要参数为： 1. FIN=1，seq=u，此时A进入FIN-WAIT-1 1. FIN=1表示该报文段是一个连接释放请求。 2. seq=u，u-1是A向B发送的最后一个字节的序号。 2. 第二次挥手：B接收到连接释放请求后，会通知相应的应用程序，告诉它A向B这个方向的连接已经释放了。B进入CLOSE-WAIT，并向A发送释放的应答，其报文头： ACK=1,seq=v,ack=u+1。 1. ACK=1，除了TCP连接请求报文段以外，TCP通信过程中所有数据报的ACK都是1，表示应答。 2. seq=v，v-1是B向A发送的最后一个字节的序号 3. ack=u+1,表示希望收到第u+1字节开始的报文段，并且已经成功接收到了前u个字节。 A收到该应答，进入FIN-WAIT-2状态，等待B发送连接释放请求。 第二次挥手完成后，A到B的连接已经释放，B不会再接收数据，A不会再发送数据。但是B到A的连接还存在，B还可以向A发送数据。 3. 第三次挥手：当B向A发完所有数据后，向A发送连接释放请求，请求头：FIN=1,ACK=1,seq=w，ack=u+1。 4. 第四次挥手：A收到释放请求，向B发送确认应答，此时A进入TIME-WAIT状态，该状态会持续2MSL时间，若该时间段内没有B的重发请求，就进入CLOSED，撤销TCB。当B收到确认应答后，也进入CLOSED，撤销TCB。 为什么不是两次，或者四次A &lt;-------&gt; B 1. 两次连接，就是为了防止失效的连接请求报文段被服务器接收，从而产生了错误。 ps:失效的连接请求，若客户端向服务端发送的连接请求丢失，客户端等待应答时间超时后，就会再次发送连接请求，此时上一个连接请求就是失效的。 客户端的请求报文在某个网络结点长时间滞留了，以至于延误到连接释放后才到达B，本来就是一个失效的报文，但是B以为这个A又发的一个新的连接请求。于是向A发出确认报文，同一建立连接。假定不采用三次握手，那么只要B发出了确认，就建立了新的连接。 但是A并没有发出连接，所以B以为自己连接建立了，一直等待A的数据，但是等不到。 2. 四次连接，第三次已经确认了，没必要了 为什么A要先进入TINE-WAIT，等待2MSL时间才进入CLOSED为了保证B能收到A的确认应答。 若A发完确认应答后直接进入CLOSED状态，那么如果该应答丢失，B等待超时后就会重新发送连接释放请求，但此时A已经关闭了，不会作出任何响应，因此B永远无法正常关闭。 如何客户端不断的发送请求连接会怎样1. 服务器会为每一个请求建立一个链接，然后向Client端发送创建链接时的回复，然后进行等待客户端发送第三次握手数据包，这样会白白浪费资源。 2. DDos攻击： 1. 客户端向服务器端发送连接请求数据包 2. 服务器向客户端回复连接请求数据包，然后服务器等待客户端发送TCP/IP链接的第三次数据包 3. 如果客户端不向服务器发送最后一个数据包，则服务器需等待30s-2minutes才能将此连接进行关闭。当大量的请求只进行到第二步，然后不进行第三步，服务器又大量的资源等待第三个数据包，就会造成DDos攻击。 3. DDos预防 1. 关闭不必要的服务 2. 限制同时打开的SYN的半连接数目 3. 缩短SYN半连接的Time out时间 TCP与UDP的区别用户数据报协议（User Datagram Protocal） 传输控制协议（Transmission Control Proptocol） 1. TCP提供的是面向连接的，可靠的数据流传输，而UDP提供的是非面向连接的（面向报文），不可靠的数据流传输。 2. TCP传输单位是TCP报文段，UDP传输单位是用户数据报 3. TCP注重数据的安全，UDP数据传输快。 4. UDP做不了流量控制 TCP与UDP常用协议（1） FTP：定义了文件传输协议，使用21端口。 （2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。 （3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。 （4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。 （5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。 UDP对应的协议： （1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。 （2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。 （3） TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。 从输入网址到获得页面的过程1. 查询DNS，获取域名对应的IP地址 1. 浏览器搜索自己的DNS缓存 2. 搜索操作系统的DNS缓存 3. 读取本地的HOST文件（本地ISP域名服务器解析） 4. 发起一个DNS的系统调用（根域名服务器） 1. 宽带运营服务器查看本身缓存 2. 运营商服务器发起一个迭代DNS解析请求 2. 浏览器获得域名对应的IP，通过IP地址找到客户端到服务端的路径。客户端发起HTTP会话到IP地址，然后通过TCP进行封装数据包，传输到网络层（三次握手）。 3. TCP/IP连接建立起来后，浏览器向服务器发送HTTP请求。 4. 服务器接收到这个请求，根据路径参数，经过后端的处理生成HTML代码返回给浏览器 5. 浏览器拿到完整的HTML页面代码开始解析和渲染，如果遇到引用的外部JS,CSS，同样的也是一个个HTTP请求，也都是要经过上面的步骤 6. 浏览器根据拿到的资源对页面进行渲染，最终得到页面 在浏览器中输入www.baidu.com后执行的全部过程https://blog.csdn.net/qq_16681169/article/details/50866290 从网络模型的角度来分析问题的，主要涉及应用层：DNS,HTTP,传输层：TCP,网络层：IP和路由选择协议：RIP,OSPF(内部网关协议),BGP(外部网关协议）和数据链路层：ARP（地址解析协议，这个协议可以说在数据链路层，也可以说在网络层）。下面来具体分析： 1、客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。 2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。 3、客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。 4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。 ARP（地址协议）1. 首先，每个主机都会在主机的ARP缓冲区建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。 2. 当源主机要发送数据时，首先检查APR列表中是否有对应IP地址的目的主机的MAC地址，如果有，直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，数据包里面有：源主机IP，MAC地址，目的主机IP地址。 3. 当本网络的所有主机收到了ARP数据包，首先检查数据包中目的主机IP地址是否时自己的IP地址，如果不是，直接忽略，如果是，首先从数据包中取出源主机的IP和MAC，写入自己的ARP列表，如果存在，就覆盖，然后将自己的MAC地址写入ARP响应包，告诉源主机自己是它想要的MAC地址 4. 源主机收到了ARP响应包以后，将目的主机的IP和MAC地址，ARP地址，并利用此信息发送数据。 RARPRARP是逆地址协议，从MAC地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。 常用的状态码https://www.cnblogs.com/jly144000/archive/2017/12/07/7998615.html 200：服务器成功返回页面 400：错误请求，服务器不理解请求的语法 404：请求的页面不存在 500：服务内部错误 503：服务器超时 临时响应1xx（临时响应） 表示临时响应并需要请求者继续执行 100（继续）：请求者应当继续提出请求。服务器返回此代码表示已经收到了请求的第一部分，正在等待其余部分 101（切换协议）：请求者已经要求服务器切换协议，服务器已经确认，并且准备切换。 成功2xx（成功） 表示成功处理了请求 200（成功）：表示服务器已经成功处理了请求。 201（已创建）：请求成功并且服务器创建了新的资源 202（已接收）：服务器接收了请求，但是尚未处理 203（非授权信息）：服务器已经成功处理了请求，但是返回的信息可能来自另一来源 204（无内容）：服务器成功处理了请求，但是没有返回任何内容 205（重置内容）:服务器成功处理了请求，但是没有返回任何内容。与204响应不同，此响应要求请求者重置文档视图 206（部分内容）:服务器成功处理了部分GET请求 重定向3xx（重定向） 要完成请求，需要进一步操作。通常，这些状态码用来重定向。Google 建议您在每次请求中使用重定向不要超过 5 次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 Googlebot 无法抓取的网址。 300(多种选择)：针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301(永久移动)：请求的网页已永久移动到新位置。服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。 302(临时移动)：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。 303(查看其他位置)请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。 304(未修改)自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 请求错误4xx（请求错误） 这些状态码表示请求可能出错，妨碍了服务器的处理。 400(错误请求)：服务器不理解请求的语法。 401(未授权)：请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。 403(禁止)：服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码(您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息)，可能是您的服务器或主机拒绝了 Googlebot 访问。 404(未找到)：服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。 405(方法禁用)：禁用请求中指定的方法。 服务器错误5xx(服务器错误) 这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。 500(服务器内部错误)服务器遇到错误，无法完成请求。 501(尚未实施)服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。 502(错误网关)服务器作为网关或代理，从上游服务器收到无效响应 503(服务不可用)服务器目前无法使用(由于超载或停机维护)。通常，这只是暂时状态。 504(网关超时)服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505(HTTP 版本不受支持)服务器不支持请求中所用的 HTTP 协议版本。 OSI、TCP/IP、五层协议栈OSI（7层）： 物理层，数据链路层，网络层，传输层，会话层，表示层，应用层 TCP/IP（4层）：网络接口层，网际层（IP），传输层，应用层 五层：物理层，数据链路层，网络层，传输层，应用层 协议栈常用协议物理层：RJ45、CLOCK、IEEE802.3 （中继器，集线器，网关） 数据链路：PPP、FR、HDLC、VLAN、MAC （网桥，交换机） 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器） 传输层：TCP、UDP、SPX 会话层：NFS、SQL、NETBIOS、RPC 表示层：JPEG、MPEG、ASII 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS 协议栈每一层的作用物理层：通过媒介传输比特,确定机械及电气规范（比特Bit） 数据链路层：将比特组装成帧和点到点的传递（帧Frame） 网络层：负责数据包从源到宿的传递和网际互连（包PackeT） 传输层：提供端到端的可靠报文传递和错误恢复（段Segment） 会话层：建立、管理和终止会话（会话协议数据单元SPDU） 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU） 应用层：允许访问OSI环境的手段（应用协议数据单元APDU） IP地址的分类A类地址：以0开头， 第一个字节范围：0~127（1.0.0.0 - 126.255.255.255）； B类地址：以10开头， 第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）； C类地址：以110开头， 第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）； 10.0.0.0—10.255.255.255， 172.16.0.0—172.31.255.255， 192.168.0.0—192.168.255.255。（Internet上保留地址用于内部） IP地址与子网掩码相与得到主机号 传输层协议与网络层协议的区别网络层提供的是主机之间的逻辑通信。 传输层提供的是进程之间的逻辑通信。 TCP的流量控制利用滑动窗口实现流量控制。 流量控制说的就是发送方的发送速率不要太快，让接收方来得及接收。 TCP的窗口单元是字节，不是报文段。 TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。 TCP的拥塞控制对资源的需求&gt;可用资源，产生拥塞 防止过多的数据注入到网络中，这样可以使用网络中的路由器或者链路不至于过载。 拥塞控制所要做的都有一个前提，网络能够承受现有的网络负荷。 交换机、路由器、网关1. 交换机：交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP得到它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。 2. 路由器：路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。 路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。 3. 网关：网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。]]></content>
      <categories>
        <category>CN</category>
      </categories>
      <tags>
        <tag>CN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring&SpringMVC&MyBatis基础总结]]></title>
    <url>%2F2018%2F05%2F02%2FSpring%26SpringMVC%26MyBatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Spring&amp;SpringMVC&amp;MyBatis基础总结 Springhttp://www.importnew.com/15851.html http://www.importnew.com/19538.html 什么是SpringSpring是一个Java企业级应用的开源框架。同时它是一个轻量级的框架结构。 核心思想有IoC，AOP，DI Spring其实就是让模块与模块之前的关系不通过代码来关联，而是利用配置文件类来说明管理。（Spring根据在自己配置文件中引入的JavaBean，通过反射去动态的组装对象） 记住！Spring说白了就是一个容器，凡是在容器里的对象才会有Spring提供的服务与功能。 Spring的核心模块 什么是控制反转（IOC）/依赖注入（DI）https://www.cnblogs.com/xdp-gacl/p/4249939.html 1. 什么是Ioc IoC--Inversion of Control，不是什么技术，是一种设计思想。 IoC就意味着将你设计好的对象交给容器本身来控制，而不是传统的在对象内部通过new来控制。 谁控制谁？控制什么？为什么叫反转？那什么又是正转？ 1. 谁控制谁，控制什么：在Java SE中，我们获取对象的时候都是通过在new来创建，也就是在程序中主动的去创建依赖对象（正转），但是IoC是我创建了一个容器（Spring），然后把对象都标识（beanName）都放入整个容器，当我们程序中需要某个对象的时候，通过容器来动态的生成依赖对象。 1. 容器（Spring）控制了对象 2. 控制了对象的产生和外部资源的获取 2. 正转就是我们主动在程序中new出来依赖的对象，反转是容器（Spring）利用beanName调用反射创建了对象，并且在创建的对象注入了程序中需要的地方。 1. 容器本身帮我们查找和注入了依赖对象，对象只是被动的接收依赖对象，所以是反转 2. 依赖对象的获取被反转了 2. IoC能干什么 传统的应用程序都是我们在类的内部主动的创建依赖对象，从而导致类与类之间高耦合，难于测试。但是有了IoC后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象和对象之前的耦合降低了。 其实IoC对编程最大的改变不是从代码上，而是从思想上，发生了&quot;主从换位&quot;的变化。原来应用程序本身是老大，要获取什么资源都需要自己去获取，而IoC/DI中，应用程序就是被动了，被动的等待IoC容器来创建并注入自己需要的资源。 3. IoC与DI DI--Dependency Injection，就是说组件的依赖关系是在容器运行时决定的。 谁依赖谁？为什么需要依赖？谁注入谁？注入了什么？ 1. 应用程序依赖IoC容器 2. 因为自己创建不了 3. IoC把应用程序依赖的对象注入内部 4. 注入的就是某个应用程序需要的外部资源 4. IoC和DI的关系 其实是同一个概念的不同描述，IoC感觉更强调容器控制了对象的产生，DI更强调容器把生成对象注入了应用程序（维护对象之间的关系） 5. 理解 首先想说说IoC（Inversion of Control，控制反转）。这是spring的核心，贯穿始终。 所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。 传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。 那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。 Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。 IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。 A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。 依赖注入的方式https://blog.csdn.net/u011637069/article/details/51958918 1. 构造器注入 2. Setter方法注入 3. 接口注入 Spring下的IoC核心包1. org.springframework.bean 2. org.springframework.context BeanFactory可以理解为还有bean集合的工厂类。BeanFactory中包含了很多bean的定义，以便在接收到客户端请求的时候将对应的bean实例化。 ApplicationConext对BeanFactory进行了扩展（继承了，但是两个都是接口），提供了其他的功能。 1. 提供了支持国际化的文本信息 2. 统一了资源文件的读取方式 3. 在监听器中注入了bean事件 下面是三个比较常见的ApplicationContext实现方式： 1. ClassPathXmlApplicationContext：从classpath的XML配置文件中读取上下文，并生成了上下文定义。应用程序上下文从程序环境变量中获取。 ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”); 2. FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文。 ApplicationContext context = new FileSystemXmlApplicationContext(“bean.xml”); 3. XmlWebApplicationContext：由Web应用的XML文件读取上下文。 BeanFactory与ApplicationContext的区别1. 首先BeanFactory和ApplicationContext都是接口，并且ApplicationContext是BeanFactory的子接口。 2. 其实BeanFactory是Spring中最底层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能，而ApplicationContext是Spring的一个高级容器，提供了更多的有用的功能。 1. ApplicationContext继承了BeanFactory接口，所以，ApplicationContext也能像BeanFactory从容器中得到Bean 2. ApplicationContext提供了国际化，消息发送，响应机制，统一加载资源的功能，事件机制，对Web的应用 3. BeanFactory采用的是延迟加载的形式来注入Bean，即只有使用到某个Bean的时候，才会对该Bean进行加载实例化。 4. ApplicationContext它是在Ioc容器启动的时候就一次性创建了所有的Bean。 如何使用注解的方式配置Spring&lt;beans&gt; &lt;context:annotation-config/&gt; &lt;!-- bean definitions go here --&gt; &lt;/beans&gt; 在 &lt;context:annotation-config/&gt;标签配置完成以后，就可以用注解的方式在Spring中向属性、方法和构造方法中自动装配变量。 1. @Required：该注解应用于设值方法。 2. @Autowired：该注解应用于有值设值方法、非设值方法、构造方法和变量。 3. @Qualifier：该注解和@Autowired注解搭配使用，用于消除特定bean自动装配的歧义。 4. JSR-250 Annotations：Spring支持基于JSR-250 注解的以下注解，@Resource、@PostConstruct 和 @PreDestroy。 什么是Spring Bean的生命周期在一个bean实例被初始化的时候，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不再被调用的时候需要进行相关的析构操作，并从bean容器中移除。 BeanFactory来完成这个过程。Bean的生命周期由两组回调组成（callback） 1. InitializingBean和DisposableBean回调接口 2. 针对特殊行为的其他Aware接口 3. Bean配置文件中的Custom init()方法和destroy()方法 4. @PostConstruct和@PreDestroy注解方式 Spring Bean的作用域之间的区别1. singleton,所有的bean请求，整个IoC容器中就一个Bean实例，单例的模式由BeanFactory自身来维护。 2. prototype，和singleton刚好相反，为每一个bean请求都创建一个Bean实例。 3. request，会为每一个来自客户端网络请求的Bean请求创建一个实例，请求完成后，Bean会失效，同时被GC 4. session，和request类似 5. global-session Spring框架下的单例Bean是线程安全的么1. 不是，Spring框架中的单例Bean不是线程安全的。 什么是Spring的内部Bean当一个Bean仅被用作另一个Bean的属性时，它就能被声明为一个内部Bean，为了定义Inner Bean，在Spring的基于XML的配置元数据中，可以在&lt;property/&gt;或&lt;constructor-arg/&gt;元素内使用&lt;bean/&gt;元素，内部Bean通常时匿名的，它们的Scope一般是Prototype。 什么是AOPhttps://www.cnblogs.com/wang-meng/p/5701982.html AOP（Aspect Oriented Programming），是对OOP的补充和完善（Object Oriented Programming，面向对象编程）。 我们在OOP中，如果我们有一个方法，很多类都要使用，我们一般会抽象出来一个类（抽象类），去实现这个这些类中都要使用的方法，然后再让这些类去继承这个类。这是纵向的，但是这个样子如果突然某一个的需求变了，就在本类中重写这个方法。 AOP说的是横向的（横切），把共用的方法叫做切面（Aspect），所谓切面，简单的说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合。 1. 横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点 2. 切面（aspect）：类是对物体特征的抽象，切面就是对横切关注点的抽象。 3. 连接点（joinpoint）：被拦截的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点，就是被拦截到的方法，实际上连接点还可以是字段或者构造器。 4. 切入点（pointcut）：对连接点进行拦截的定义 5. 通知（advice）：拦截到连接点之后要执行的代码，通知分为前置，后置，异常，最终，环绕通知五类。 6. 目标对象：代理的目标对象。 7. 织入（weave）：将切面应用到目标对象并导致代理对象创建的过程。 8. 引入（introduction）：在不修改代码的前提下，引入可以在运行期为类动态的添加一些方法或者字段。 Spring中AOP的支持： 1. Spring中的AOP代理由Spring的IoC容器负责生成，管理，其依赖关系也由IoC容器负责管理。因此，AOP代理可以直接使用容器中的其他Bean实例来作为目标。这种关系可由IoC容器的依赖注入提供。 2. Spring创建代理的规则： 1. 默认使用Java动态代理来创建AOP处理，这样可以为任何接口实例创建代理了。 2. 当需要代理的类不是代理接口的时候，Spring会切换为使用CGBlib代理。 Spring基本概念IoC叫做控制反转，DI是依赖注入，后者是前者更简单的诠释。控制反转说的是把传统上程序代码直接new对象的调用权交给了容器，通过容器来实现对象组件的装配和关系。所谓的控制反转，也就是对组件对象控制权的转移，从代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。DI是说IoC来管理组件的关系，但是组件的关系是在容器运行期来决定的，也就是容器动态的把某种依赖的关系注入了组件中国， 1. Spring AOP实现管理 1. 动态代理（利用反射和动态编译将代码模式编程动态的） 2. JDK的动态代理：JDKProxy返回动态代理类，是目标类所实现接口的另一个实现版本，它实现了对目标类的代理 3. CGLib动态代理：CGLibProxy返回的动态代理类，则是是目标代理类的一个子类 2. 动态代理和CGLib实现的区别 1. JDK动态代理只能针对实现了接口的类生成代理，而不能针对类。 2. CGLib是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法因为是继承。 3. JDK代理不需要第三方的库 4. CGLib必须依赖CGLib的库 Spring的两种代理当一个对象不能或者不想直接引用另一个对象（目标对象）时，可以在这之间弄一个桥梁--代理对象： 1. 静态代理：程序员事先写好代理对象类，在程序发布就已经存在了。 2. 动态代理：应用程序发布后，通过动态创建代理对象。 JDK动态代理 利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。 CGLib动态代理 利用ASM开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。 1. 如果目标对象实现了接口，默认使用JDK，也可以强制只用CGLib 2. 没有实现接口，必须采用CGLib。 Spring和工厂模式的区别当需求改变的时候，工厂模式需要进行相应的变化。但是IoC的反射机制允许我们不重新编译代码，因为它的对象都是动态生成。 在工厂中修改就得重新编译工厂类啊，你那机子上还得装着JDK。在XML中修改只要一个Text编辑器就搞定了。重新编译以后你要用新编译的类，得先停了JVM再重新启动，热插拔就是说你把XML改了spring就立刻发觉你改动了XML，重新读一遍XML，就会用你的新改动了，根本不用重新启动JVM。 IoC容器的加载过程1. 创建IoC配置文件的抽象资源 2. 创建BeanFactory 3. 把读取配置信息的BeanDefinitionReader，这里是XmlBeanDefinitionReader配置给BeanFactory 4. 从定义好的资源位置读取配置信息，具体解析由XmlBeanDefinitionReader来完成。 SpringMVC原理 1. 用户发送请求到前端控制器DispatcherServlet 2. DispatcherServlet收到请求后调用HandlerMapping（处理器映射器） 3. 处理器映射器找到具体的处理器，生成处理器对象和处理器拦截器（如果有的话），并将两者返回给DispatcherServlet 4. DispatcherServlet调用HandlerAdapter处理器适配器 5. HandlerAdapter经过适配调用具体的后端控制器（Controller） 6. Controller执行完成返回ModelAndView 7. HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet 8. DispatcherServlet将ModelAndView传给ViewResolver视图解析器 9. ViewResolver解析后返回具体的Veiw 10. DisPatcherServlet根据View进行渲染视图（即将模型数据填充到视图中） 11. DispatcherServlet响应用户。 SpringMVC与Struts2的区别1. SpringMVC的入口是一个Servlet（DispatcherServlet），而Struts2入口是一个Filter 2. SpringMVC是基于方法开发，传递参数通过方法形参（可以单例），Strust2是基于类开发，参数传递通过类的属性，只能设计为多例。 3. Struts采用值栈存储请求和响应的数据，通过OGNL和JSTL来获取数据，SpringMVC是通过参数解析器将request对象内容进行解析成方法形参，响应数据与页面封装成ModelAndView对象，最后又通过模型数据通过request对象传输到页面。 SpringMVC的控制器是不是单例单例，所以多线程访问的时候又线程安全问题，但是不能加锁，会影响性能，解决方案是在控制器中不能写字段。 常用注解1. @Controller：表现层，控制器 2. @RequestMapping：在类上表示这个类中所有响应请求方法都以这个地址为父路径，在方法上，就是方法特定的。 3. SpringMVC通过@ResponseBody与AJAX进行交互。 Mybatis与Hibernate${}与#{}1. ${},是从.properties中获取静态值，比如${driver}会被换成com.mysql.jdbc.Driver 2. #{},是sql的参数占位符，MyBatis会将sql中的#{}替换成？，在SQL执行前会使用PreparedStatement的参数设置方法，按序号给？占位符设置参数。比如#{item.name}，会成为param.getItem().getName()。 常用标签resultMap、parameterMap、sql、include Dao层接口与Mappring.xml如何映射Dao接口中的方法，是不能重载的，因为全限定名+方法名的保存和寻找策略。 全限定名+方法名拼接字符串成为一个Key,唯一定位一个MappingStstement。 Dao接口的工作原理就是JDK动态代理，MyBatis运行时会使用JDK动态代理为Dao接口生成代理对象，代理对象会拦截接口方法，转而执行MappingStstement所代表的SQL，然后将SQL执行结果返回。 MyBatis的分页插件（PageHelper）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package xd.cop.service.impl;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import xd.cop.common.ServerResponse;import xd.cop.dao.ItemMapper;import xd.cop.pojo.Item;import xd.cop.service.inter.IItemService;import xd.cop.util.DateTimeUtil;import xd.cop.vo.ItemVo;import java.util.ArrayList;import java.util.List;/** * Created by Blemon on 2018/4/18. */@Service("iItemService")public class ItemServiceImpl implements IItemService&#123; @Autowired private ItemMapper itemMapper; @Override public ServerResponse&lt;PageInfo&gt; getAllItemByPage(int pageNum, int pageSize) &#123; //1.startPage--start PageHelper.startPage(pageNum,pageSize); //2.填充自己的sql查询逻辑 List&lt;Item&gt; itemList = itemMapper.selectList(); List&lt;ItemVo&gt; itemVoList = new ArrayList&lt;&gt;(); for(Item item : itemList)&#123; ItemVo itemVo = assembleItemVo(item); itemVoList.add(itemVo); &#125; //3.pageHelper收尾 PageInfo pageResult = new PageInfo(itemList);//确定个数 pageResult.setList(itemVoList);//确定集合 return ServerResponse.createBySuccess(pageResult); &#125; private ItemVo assembleItemVo(Item item)&#123; ItemVo itemVo = new ItemVo(); itemVo.setId(item.getId()); itemVo.setSecn(item.getSecn()); itemVo.setAbnc(item.getAbnc()); itemVo.setHum(item.getHum()); itemVo.setLat(item.getLat()); itemVo.setPre(item.getPre()); itemVo.setLon(item.getLon()); itemVo.setVib(item.getVib()); itemVo.setTem(item.getTem()); itemVo.setCreatetime(DateTimeUtil.dateToStrByStandard(item.getCreatetime())); return itemVo; &#125;&#125; MyBatis与Hibernate的区别1. 两个都通过SessionFactoryBuilder由XML配置文件生成的SessionFactory，然后由SessionFactory生成的Session，最后由Session来开始执行事务和SQL语句。 2. Hibernate是全自动的，MyBatis是半自动的。 3. SQL直接优化，Hibernate不如MyBatis 4. 缓存机制上，Hibernate比较好 5. Hibernate的HQL语言，大大降低了对于与数据库的耦合性，而MyBatis由于需要手写SQL，因此与数据库的耦合性直接取决于程序员写SQL的方法，如果SQL不具有通用性而使用了某些数据库特性的SQL语句，移植性比较差。 Hibernate如何提高性能1. 延迟加载 2. 缓存技术 3. 优化SQL查询 Hibernate的二级缓存缓存的目的就是为了减少程序对物理数据源的访问，把从数据库中查询出来和使用过的对象保存在内存中，以便在后期需要用这个对象时，直接从缓存中获取（只有当缓存不存在的时候，才会从数据库中查询）。 一级缓存，由Session来管理。二级缓存，由SessionFactory管理。二级缓存可有可无，但是一级缓存必不可少。 一级缓存，使用Session查询时，首先在Session中找，没有才去数据库，并且把查到的数据缓存起来。但是Session线程不安全，生命周期没有SessionFactory长，效率不高。 二级缓存，是独立于Hibernate的软件部件，属于第三方产品。属于全局缓存，先去Session找，再去SessionFactory，再去数据库。 Hibernate对象状态 瞬时态，持久态，脱管态 临时态：刚刚使用new语句创建，没有被持久化，不处于Session缓存中。处于临时状态的Java对象被称为临时对象。 持久态：已经被持久化，加入到Session缓存中。 游离态：已经被持久化，但不处于Session的缓存中。 Hibernate中的get与load1. 如果在数据库中不存在该对象，load方法会抛出一个ObjectNotFoundException，get方法返回null 2. get方法先在Session中找，在去SessionFactory，再去数据库。load先在Session中找，不存在，就创建代理对象，实际使用数据的时候，才查询二级缓存和数据库。load方法延迟加载。 3. get方法返回的都是实体类，load方法返回的都是实体类的代理类实例。]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet与JSP基础总结]]></title>
    <url>%2F2018%2F05%2F01%2FSevlet%26JSP%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Servlet与JSP基础总结 什么是Servlet 1. 其实这就是个接口，里面就5个方法。但是我们约定俗成把实现了这个接口的类也叫做了Servlet 2. 这个接口本身和网络协议，Http什么根本没关系，这东西就是为了规范一套处理网络请求，所有实现了Servlet的类都要实现它的那5个方法，最重要的就三个init/destory/service，也就是所有实现了这个接口的类，都必须回答三个问题: 1. 初始化要干嘛 2. 销毁要干嘛 3. 接收到请求又要干嘛 3. Servlet就是一个规范，但是并不是实现了Servlet的类都能处理请求。这里面绝对不会又什么监听8080端口的东西之类的，因为Servlet根本就不是直接和客户端打交道的。 那么请求怎么到这个类里面的，就是我们说的Servlet容器，也就是Tomcat，我们的Servlet实现类永远都是在容器中才能起作用的。Tomcat才是真正和客户端直接打交道的东西，它监听了端口，情趣过来，由Tomcat也确定这个请求要给哪个Servlet去处理。然后调用这个Servlet的service方法。service方法返回一个response，tomcat再把这个response返回客户端。 Servlet与CGI的区别CGI（Common GateWay Interface 公共网管接口）是用Perl脚本编写的程序，可以用来生成动态页面。 1. Servlet在服务器进程中，多线程的方式运行service()，一个实例可以服务多个请求。并且实例一般不会销毁。 2. CGI对每个请求都产生新的进程。服务完就销毁了。 Servlet生命周期和工作原理 1. 加载：Tomcat通过类加载器使用Servlet类对应的文件来加载Servlet。 2. 创建：调用Servlet的构造器生成一个Servlet实例。 3. init()：在Servlet的生命周期中，仅执行一次，在Tomcat装入Servlet时执行的，这个方法在Servlet创建但是向客户端提供请求前被调用。 4. service()：Tomcat接收到请求，发现这是对Servlet发起的请求，Tomcat这个时候会创建两个对象HttpServletRequest，HttpServletResponse。容器根据请求的URL找到对应的Servlet，然后针对这个请求创建一个线程，同时把之前创建的两个对象以参数的像是传递给这个线程。然后容器调用这个Servlet的service()，service()方法根据请求的method属性值来确定调用doGet还是doPost，然后把生成响应数据（动态页面）返回给容器，容器把响应消息组装成HTTP格式返回给客户端。 5. destory：容器在卸载Servlet之前调用destory，让servlet释放了自己占用的系统资源。 Get和Post的区别1. get不安全，同时页面提交数据时，get的数据大小由限制4k。 2. post安全，同时没有数据大小限制。 JSP与Servlet的区别1. JSP可以被看作是一个特殊的Servlet，只不过是Servlet的扩展，只要是JSP能实现的，Servlet也都可以实现。因为JSP页面最后还是要被转换成Servlet来运行，因此处理请求实际上是编译后的Servlet。 2. Servlet的实现方式是在Java中嵌入了HTML，JSP是在HTML中嵌入了Java 3. Servlet中可没有内置对象，JSP里面有9个，但是都是通过HttpServletRequest，HttpServletResponse，HttpServlet对象得到的。 Servlet、Genericervlet、HttpServlet https://www.cnblogs.com/libingbin/p/5960456.html 1. Servlet是个接口， 2. GenericServlet是个抽象类，实现了Servlet和ServletConfig，这个Servlet是个和协议没有半毛钱关系的Servlet。 3. HttpServletRequest和HttpServletResponse是两个接口 4. HttpServlet继承了GenericServlet，但是这也是个抽象类。 5. GenericServlet做的事情： 1. init方法，保存了config对象，并实现了getServletInfo和getServletConfig。 2. 增加了一个空参数的init()，防止开发人员重写重生的init 3. service方法空实现--&gt;写成了抽象方法，强制开发人员实现。 4. destory空实现。 5. 实现了servletConfig接口，接口中的方法直接调用config实现类实现。 6. HttpServlet做的事情： 1. servlet中强转参数 ServletRequest和ServletResponse--&gt;HttpServletRequest和HttpServletResponse。 2. 根据不同请求调用不同的方法。 Servlet、ServletContext、ServletConfighttps://blog.csdn.net/u012077981/article/details/17137705https://blog.csdn.net/gavin_john/article/details/51399425 1. ServletContext是Servlet和Servlet容器（Tomcat）之间的直接通信接口。Servlet容器在启动一个Webapp时，会为它创建一个ServletContext，也就是Servlet上下文环境。 每一个webapp都有唯一的ServletContext对象。同一个webapp下的所有servlet对象共享一个ServletContext。 servlet的初始化参数，就是在这个ServletContext中。 1. 获取web上下文路径（context.getContextPath()） 2. 获取全局参数(context.getInitParameter(paramName)) 3. 和域相关 2. ServletConfig是当Servlet容器（Tomcat）初始化一个Servlet类型的对象时，会为这个Servlet对象创建一个ServletConfig对象。在这个ServletConfig对象中包含了Servlet的初始化参数信息。 3. ServeltConfig和ServletContext关联。Tomcat在调用Servlet对象的init(ServletConfig config)方法时，会把ServletConfig类型的对象当作参数传递给servlet对象。 4. ServletContext是对于Webapp而言的，其实就是四大域中的Application，在Tomcat启动的时候就加载了。而ServletConfig是对于某一个Servlet而言的。 forward和redirect1. forward：请求转发，服务器端行为，然后目标地址的URL，但是服务器内部转发了。（只有一次请求） 2. redirect：重定向,客户端行为，目的地址的URL改变了，两次请求！！！ 3. 重定向会导致request对象信息丢失，而请求转发不会。 JSP执行原理客户端发出请求---&gt;JSP引擎将jsp页面翻译成Servlet的java源文件--&gt;Tomcat中将源文件编程成class并加载到内存中执行。 JavaWeb四大域Application(ServletContext)1. 作用域：整个Webapp，所有Servlet共用一个serveltContext。 2. 生命周期：当Web应用被加载到Tomcat中时就创建了。 Session（HttpSession）1. 作用域：一次会话。 2. 生命周期：当第一次调用request.getSession()的时候，服务器会检查是否已经有了对应的Session，如果没有就在内存中创建一个Session并返回。但是当一段时间以后，Session没有被使用（默认30min），Session就会被销毁了。 如果服务器非正常关闭，没有到期的session也会跟着销毁。如果调用session提供的invalidate()，可以立即销毁session。 Request（ServletRequest）1. 作用域：整个请求链，在Servlet处理好的数据给JSP显示，整个时候参数就可以放在ServletRequest域中 2. 生命周期：整个请求链 Page（PageContext）1. 作用域：当对JSP请求开始，当响应的结束时销毁。 2. 作用范围：整个JSP页面，是四大域中最小的一个。 HttpServletRequest和HttpServletResponse1. HttpServletRequest 1. 请求地址(读取信息路径) 2. 请求头 3. 实体数据 2. HttpServletResponse 1. 响应头 2. 状态码 3. 实体数据 4. 客户端写入Cookie（设置Cookie） 5. 重写URL HttpServletRequest中的getParamter/Attribute1. getAttribute表示从Request域中获取数据，必须在request域中进行设置（setAttribute）后才能拿到，设置和获取的都是Object 2. getParameter表示接收参数，参数为页面提交的参数（表单提交的参数，URL重写）因此整个方法并没有参数设置（没有setParameter），而且返回的参数String JSP中的九大内置对象https://blog.csdn.net/icarus_wang/article/details/51107470 out对象：用于向客户端、浏览器输出数据。 request对象：封装了来自客户端、浏览器的各种信息。 response对象：封装了服务器的响应信息。 exception对象：封装了jsp程序执行过程中发生的异常和错误信息。 config对象：封装了应用程序的配置信息。 page对象：指向了当前jsp程序本身。 session对象：用来保存会话信息。也就是说，可以实现在同一用户的不同请求之间共享数 application对象：代表了当前应用程序的上下文。可以在不同的用户之间共享信息。 pageContext对象：提供了对jsp页面所有对象以及命名空间的访问。 JSP动作（6个）1. jsp：include，用来在页面被请求时引入一个文件。 2. jsp：useBean，用来寻找或者实例化一个JavaBean 3. jsp：setProperty，用来设置已经实例化的Bean对象。 4. jsp：getProperty，用来获取某个JavaBean的属性。 5. jsp：forward，用来把请求转到一个新页面 6. jsp:plugin，用来在浏览器中显示一个对象。 include的静态，动态引入（include指令和include动作）1. include指令：&lt;%@ include file=&quot;text.jsp&quot;%&gt; 2. include动作： &lt;jsp:include page=&quot;text.jsp&quot; flush=&quot;true&quot;&gt; &lt;jsp:param name=&quot;name&quot;,value=&quot;value&quot;/&gt; &lt;/jsp:include&gt; 区别： 1. 根本区别：两者调用的时间。include指令是在编译阶段的指令，在编译时，编译器会把指令所指向的目标文件内容复制到指令所在的位置，替换指令本身，最终生成的一个文件，在运行时只有一个文件；include动作是在运行时的语法，在主页面被请求时，才将用到的页面包含进来，涉及到两个文件，类似于方法调用。 Session与Cookie1. Session在服务器端，Cookie在客户端 2. Session的运行依赖Session id，而Session id是存在Cookie中的，也就说如果浏览器禁用了Cookie，同时Session也就无效了。 3. Session可以放在文件，数据库，内存中 4. 用户验证一般使用Session 5. Cookie不安全，因为在本地，可能被被人用来进行Cookie欺骗 6. Session会在一定时间内保存在服务器上，当访问太多的时候，并不好 7. 单个Cookie保存的数据不能超过4k，很多浏览器都限制一个站点最多保存20个Cookie 保存会话状态，有哪些方法HTTP协议本身无状态，服务器为了区别不同的用户，需要对用户会话进行跟踪，也就说用户登录的时候，为用户分配唯一的ID，下一次用户在请求中包含此ID，服务器就知道这是哪个用户了。 1. URL重写：在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。 2. 设置表单隐藏域：将会话跟踪相关的字段添加到隐式表单域中。 3. Session共享：Session的运行依赖Session id，而Session id是存在Cookie中的，也就说如果浏览器禁用了Cookie，同时Session也就无效了。 4. 会话Cookie：Cookie是Web服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将Cookie发送到客户端,在客户端可以进行保存,以便下次使用 监听器，过滤器，拦截器监听器1. contextInitialized 2. contextDestroyed 事件源：ServletContext，HttpSession，ServletRequest 过滤器http://www.cnblogs.com/xdp-gacl/p/3948353.html http://www.runoob.com/jsp/jsp-writing-filters.html 拦截器https://www.cnblogs.com/shangxiaofei/p/5328377.html]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桥接模式]]></title>
    <url>%2F2018%2F04%2F25%2F%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[桥接模式 桥接模式 桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。 创建桥接实现接口123public interface DrawAPI &#123; public void drawCircle(int radius, int x, int y);&#125; 创建实现了 DrawAPI 接口的实体桥接实现类12345678910111213141516public class RedCircle implements DrawAPI&#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println("Drawing Circle[ color: red, radius: " + radius +", x: " +x+", "+ y +"]"); &#125;&#125;public class GreenCircle implements DrawAPI&#123; @Override public void drawCircle(int radius, int x, int y) &#123; System.out.println("Drawing Circle[ color: green, radius: " + radius +", x: " +x+", "+ y +"]"); &#125;&#125; 使用 DrawAPI 接口创建抽象类 Shape1234567public abstract class Shape &#123; protected DrawAPI drawAPI; protected Shape(DrawAPI drawAPI)&#123; this.drawAPI = drawAPI; &#125; public abstract void draw(); &#125; 创建实现了 Shape 接口的实体类1234567891011121314public class Circle extends Shape&#123; private int x, y, radius; protected Circle(int x,int y,int radius,DrawAPI drawAPI) &#123; super(drawAPI); this.x = x; this.y = y; this.radius = radius; &#125; @Override public void draw() &#123; drawAPI.drawCircle(radius,x,y); &#125;&#125; 使用 Shape 和 DrawAPI 类画出不同颜色的圆123456789public class BridgePatternDemo &#123; public static void main(String[] args) &#123; Shape redCircle = new Circle(100,100, 10, new RedCircle()); Shape greenCircle = new Circle(100,100, 10, new GreenCircle()); redCircle.draw(); greenCircle.draw(); &#125;&#125;s]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2F2018%2F04%2F25%2F%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[适配器模式 适配器模式 适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。 举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。 适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。 为媒体播放器和更高级的媒体播放器创建接口12345678public interface MediaPlayer &#123; public void play(String audioType,String filename);&#125;public interface AdvancedMediaPlayer &#123; public void playVlc(String fileName); public void playMp4(String fileName);&#125; 创建实现了 AdvancedMediaPlayer 接口的实体类1234567891011public class VlcPlayer implements AdvancedMediaPlayer&#123; @Override public void playVlc(String fileName) &#123; System.out.println("Playing vlc file. Name: "+ fileName); &#125; @Override public void playMp4(String fileName) &#123; //什么也不做 &#125;&#125; 1234567891011public class Mp4Player implements AdvancedMediaPlayer&#123; @Override public void playVlc(String fileName) &#123; //什么也不做 &#125; @Override public void playMp4(String fileName) &#123; System.out.println("Playing mp4 file. Name: "+ fileName); &#125;&#125; 创建实现了 MediaPlayer 接口的适配器类123456789101112131415161718public class MediaAdapter implements MediaPlayer&#123; AdvancedMediaPlayer advancedMediaPlayer; public MediaAdapter(String audioType)&#123; if(audioType.equalsIgnoreCase("vlc")) advancedMediaPlayer = new VlcPlayer(); else advancedMediaPlayer = new Mp4Player(); &#125; @Override public void play(String audioType, String filename) &#123; if(audioType.equalsIgnoreCase("vlc")) advancedMediaPlayer.playVlc(filename); else advancedMediaPlayer.playMp4(filename); &#125;&#125; 创建实现了 MediaPlayer 接口的实体类1234567891011public class AudioPlayer implements MediaPlayer&#123; MediaAdapter mediaAdapter; public void play(String audioType,String filename)&#123; if(audioType.equalsIgnoreCase("mp3")) System.out.println("Playing mp3 file. Name: "+filename); else if(audioType.equals("mp4")||audioType.equals("vlc")) new MediaAdapter(audioType).play(audioType, filename); else System.out.println("Invalid media. "+audioType + " format not supported"); &#125;&#125; 使用 AudioPlayer 来播放不同类型的音频格式12345678910public class AdapterPatternDemo &#123; public static void main(String[] args) &#123; AudioPlayer audioPlayer = new AudioPlayer(); audioPlayer.play("mp3", "beyond the horizon.mp3"); audioPlayer.play("mp4", "alone.mp4"); audioPlayer.play("vlc", "far far away.vlc"); audioPlayer.play("avi", "mind me.avi"); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造者模式]]></title>
    <url>%2F2018%2F04%2F25%2F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[建造者模式 建造者模式（StringBuilder） 创建一个表示食物条目和食物包装的接口1234567891011/** * @ClassName Item * @Description 食品条目 * @Author Blemon * @Date 2018年4月25日 下午3:55:30 */public interface Item &#123; public String name(); public Packing packing(); public float price(); &#125; 123456789/** * @ClassName Packing * @Description 食物包装方式 * @Author Blemon * @Date 2018年4月25日 下午3:55:49 */public interface Packing &#123; public String pack();&#125; 创建实现 Packing 接口的实体类123456789101112/** * @ClassName Wrapper * @Description 纸盒包装 * @Author Blemon * @Date 2018年4月25日 下午3:58:04 */public class Wrapper implements Packing&#123; @Override public String pack() &#123; return "纸盒包装"; &#125;&#125; 12345678910111213/** * @ClassName Bottle * @Description 瓶装 * @Author Blemon * @Date 2018年4月25日 下午3:58:15 */public class Bottle implements Packing&#123; @Override public String pack() &#123; // TODO Auto-generated method stub return "瓶装"; &#125;&#125; 创建实现 Item 接口的抽象类，该类提供了默认的功能12345678910111213141516171819202122/** * @ClassName Burger * @Description 汉堡抽象类 * @Author Blemon * @Date 2018年4月25日 下午4:00:46 */public abstract class Burger implements Item&#123; @Override public String name() &#123; return null; &#125; @Override public Packing packing() &#123; return new Wrapper();//默认纸盒装 &#125; @Override public float price() &#123; return 0.0f; &#125;&#125; 12345678910111213141516171819202122/** * @ClassName ColdDrink * @Description 冷饮抽象类 * @Author Blemon * @Date 2018年4月25日 下午4:05:03 */public class ColdDrink implements Item&#123; @Override public String name() &#123; return null; &#125; @Override public Packing packing() &#123; return new Bottle();//默认纸盒装 &#125; @Override public float price() &#123; return 0.0f; &#125;&#125; 创建扩展了 Burger 和 ColdDrink 的实体类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * @ClassName VegBurger * @Description 汉堡的具体子类--蔬菜汉堡 * @Author Blemon * @Date 2018年4月25日 下午4:06:10 */public class VegBurger extends Burger&#123; @Override public float price() &#123; return 25.5f; &#125; @Override public String name() &#123; return "蔬菜汉堡"; &#125;&#125;/** * * @ClassName ChickenBurger * @Description 汉堡的具体子类--鸡肉汉堡 * @Author Blemon * @Date 2018年4月25日 下午4:06:52 */public class ChickenBurger extends Burger&#123; @Override public float price() &#123; return 50.0f; &#125; @Override public String name() &#123; return "鸡肉汉堡"; &#125;&#125;/** * @ClassName Coke * @Description 冷饮的具体子类---可口可乐 * @Author Blemon * @Date 2018年4月25日 下午4:08:36 */public class Coke extends ColdDrink&#123; @Override public float price() &#123; return 30.0f; &#125; @Override public String name() &#123; return "可口可乐"; &#125;&#125;/** * @ClassName Pepsi * @Description 冷饮的具体子类---百事可乐 * @Author Blemon * @Date 2018年4月25日 下午4:09:44 */public class Pepsi extends ColdDrink&#123; @Override public float price() &#123; return 35.0f; &#125; @Override public String name() &#123; return "百事可乐"; &#125;&#125; 创建一个 Meal 类，带有上面定义的 Item 对象1234567891011121314151617181920212223public class Meal &#123; private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;(); public void addItem(Item item)&#123; items.add(item); &#125; public float getCost()&#123; float cost = 0.0f; for (Item item : items) &#123; cost += item.price(); &#125; return cost; &#125; public void showItems()&#123; for (Item item : items) &#123; System.out.print("Item : "+item.name()); System.out.print(", Packing : "+item.packing().pack()); System.out.println(", Price : "+item.price()); &#125; &#125; &#125; 创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象123456789101112131415public class MealBuilder &#123; public Meal prepareVegMeal ()&#123; Meal meal = new Meal(); meal.addItem(new VegBurger()); meal.addItem(new Coke()); return meal; &#125; public Meal prepareNonVegMeal ()&#123; Meal meal = new Meal(); meal.addItem(new ChickenBurger()); meal.addItem(new Pepsi()); return meal; &#125;&#125; BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）1234567891011121314151617181920212223242526public class BuilderPatternDemo &#123; public static void main(String[] args) &#123; MealBuilder mealBuilder = new MealBuilder(); Meal vegMeal = mealBuilder.prepareVegMeal(); System.out.println("Veg Meal"); vegMeal.showItems(); System.out.println("Total Cost: " +vegMeal.getCost()); Meal nonVegMeal = mealBuilder.prepareNonVegMeal(); System.out.println("\n\nNon-Veg Meal"); nonVegMeal.showItems(); System.out.println("Total Cost: " +nonVegMeal.getCost()); &#125;&#125;/** Veg Meal Item : 蔬菜汉堡, Packing : 纸盒包装, Price : 25.5 Item : 可口可乐, Packing : 瓶装, Price : 30.0 Total Cost: 55.5 Non-Veg Meal Item : 鸡肉汉堡, Packing : 纸盒包装, Price : 50.0 Item : 百事可乐, Packing : 瓶装, Price : 35.0 Total Cost: 85.0*/]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库基本总结]]></title>
    <url>%2F2018%2F04%2F25%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[数据库基本总结 什么是存储过程存储过程（Stored Procedure）是一组为了完成特定功能的SQL语句集，经过编译后存储在数据库中。 注意一下，存储过程其实一个数据库中的一个对象！！！这个对象中放了一部分比较常用的SQL语句。只需要编译一次，且在创建其的时候进行编译，不像一般的SQL是每次执行都需要编译（Statement）。 用户只需要通过指定存储过程的名字和给出参数（如果这个存储过程由参数）来执行它。 1. 存储过程允许标准组件式编程（随时可以修改） 2. 存储过程执行速度很快（预编译造成的） 3. 存储过程能够减少网络流量 4. 存储过程可以被作为一种安全机制来利用 可以对执行某一存储过程进行权限控制 注意：存储过程虽然即可以有参数也可以有返回值，但是它不是函数。存储过程的返回值只是指明执行是否成功。 存储过程与函数创建：CREATE PROCEDURE sp_name@[参数][类型] 调用：EXEC sp_name[参数名] 删除：DROP PROCDDURE sp_name 1. 存储过程不等于函数，虽然本质上没什么区别，但是存储过程一般是作为一个独立的部分来执行。而函数可以作为查询语句的一个部分来调用。 2. 函数需要用()来包住输入的参数，且只能返回一个值或表对象，但是存储过程可以返回多个参数。 3. 函数可以嵌入SQL中使用，可以在SELECT中调用，存储过程不可以。 4. 存储过程在创建时就在数据库服务器上进行了编译。 数据库连接的语句123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; /** * JDBC:java数据库链接 使用JDBC连接数据库的基本流程(此处使用Oracle) * 1:加载驱动类 * 2:与数据库建立连接 * 3:执行SQL语句 * 4:处理结果集 * 5:关闭连接 */ public class JDBCDemo &#123; public static void main(String[] args) &#123; String orc="oracle.jdbc.driver.OracleDriver"; //java.sal.Connection //表示与数据库的连接 Connection conn=null; try &#123; /* * 1: * 加载驱动 * 需要注意,不同的数据库,参数那个字符串内容不同 * * 这一步执行完后也许抛出: * ClassNotFoundException异常 * 出现原因如下: * 1:数据库驱动的jar包没有导入到环境变量当中 * 2:Class.forName中的字符串拼写错误 */ Class.forName(orc); System.out.println("驱动加载成功"); /* * 2:通过DriverManager建立与数据库的连接 * 其静态方法getConnection用于获取连接 * 通常需要三个参数 * 参数1:数据库的地址以及端口(不同数据库字符串内容不相同) * 格式:jdbc:oracle:thin:@host:port:sid * 参数2:数据库用户名 * 参数3:数据库密码 */ conn=DriverManager.getConnection( "jdbc:oracle:thin:@localhost:1521:xe",//数据库的地址及其端口 "system", //数据库用户名 "8nianji7ban"//数据库密码 ); System.out.println("数据库已经连接"); /* * 3:java.sql.Statement * 该类用于执行SQL语句并获取结果 */ Statement state =conn.createStatement(); //System.out.println("QQQQQ"); String sql="select ename,job,sal,deptno from emp";//当前需要执行的数据库语句 System.out.println(sql); /* * Statement针对不同的SQL语句提供了不同的执行方法: * ResultSet executeQuery(String aql) * 该方法专门用来执行DQL语句,返回的ResultSet表示查询出来的结果集 * * int executeUpdate(String sql) * 该方法专门用来执行DML语句,返回的数字表示执行该语句后影响了表中多少条数据 * * boolean execute(String sql) * 该方法理论上什么语句都可以运行,但是由于DQL,DML都有专门的方法,所以该方法通常用来执行DDL语句 * 该方法的返回值表示执行SQL语句后是否存在结果集,存在返回true * 若SQL语句本身就有错误,直接抛出异常:SQLException */ System.out.println("正在执行查询"); ResultSet rs=state.executeQuery(sql);//返回一个结果集 System.out.println("查询完毕"); /* * 4:遍历结果集(查询结果) * ResulSet提供用于遍历结果集的方法 * boolean next() * 该方法有两个作用,首先当我们查询出结果集后RS的指针指向第一条数据之上,所以我们需要先调用一次next() * 使其指针移动到第一条数据上,并表示该条数据 * 第二个作业是看返回值,若指针向下移动后,发现没有数据了,会返回false,若有则返回true,所以我们只有在该方法返回true的时候才获取当前记录的各个字段对应的值 * * RS还提供了若干getXXX(String fieldName) * 方法: * 该方法是用来获取RS表示的当前记录当中给定字段对应的值,不同的字段由于类型不同,要调用相对应的方法 * 例如:varchar2类型就调用getString */ while(rs.next())&#123; //获取员工名字 String ename=rs.getString("ename"); String job=rs.getString("job"); int sal=rs.getInt("sal"); int deptno=rs.getInt("deptno"); System.out.println(ename+","+job+","+sal+","+deptno); &#125; rs.close(); state.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); // TODO: handle exception &#125;finally&#123; if(conn!=null)&#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; 什么是事务事务提供了一种机制，可以将一系列数据库更改归入一个逻辑操作。更改数据库后，所做的更改可以作为一个单元进行提交或者取消。 事务需要确保遵循原子性，一致性，隔离性和持续性（ACID），以保证数据能够正确提交到数据库中。 客户A和客户B的银行账户金额都是10000元人民币，客户A需要把自己帐户中的5000元人民币转到客户B的账户上。这个过程看似简单，实际上涉及了一系列的数据库操作，可以简单地视为两步基本操作，即从客户A帐户的金额中扣除5000元人民币，以及将客户B帐户中金额添加5000元人民币。假设第1步数据库操作成功，而第二步失败的话，将导致整个操作失败，并且客户A帐户金额将被扣除5000元人民币。事务机制可以避免此类情况，以保证整个操作的完成，如果某步操作出错，之前所作的数据库操作将全部失效。 也就是说，几个SQL语句，要么全部执行成功，要么全部执行失败。 数据库事务的三个常用指令：Begin Transaction，Commit Transaction，RollBack Transaction 事务的ACID1. 原子性：事务必须是原子工作单元。对于其数据的修改，要么全部执行，要么全都不执行。 2. 一致性：事务在完成时，必须使所有的数据都能保持一致状态。在相关的数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时，所有的内部数据结构都必须时正确的。 说白了，就是一个事务执行前和执行后，数据都必须处于一致性状态。 3. 隔离性：由并发事务所做的修改，必须与任何其他并发事务所做的是修改隔离。一个事务的执行不能干扰其他事务。 4. 持久性：事务完成后，它对系统的影响是永久性的。该修改即使出现系统故障也可以一直保持。 脏读，不可重复读，幻读1. 脏读：事务T1更新了一行记录的内容，但是并没有提交所做的修改。事务T2读取更新了更行后的行，然后T1执行了回滚，取消了刚才的修改。那T2之前读到的就是无效数据了。 2. 不可重复读：事务T1读取了一行记录，紧接着T2修改了T1刚才读取的那一行记录，然后T1又再次读取了这行记录，但是发现与刚才读取结果不一样了。 3. 幻读：事务T1读取一条指令的where子句所返回的结果集，然后T2事务新插入一行记录，这行记录恰好可以满足T1所使用的查询条件。然后T1再对表进行检索，但是又看到了T2插入的数据 事务的隔离级别 1. 串行化（Serialzable）：所有事务一个接一个的执行，这样可以避免幻读，对于基于锁来实现并发控制的数据库来说，串行化要求在执行范围查询的时候，需要获取范围锁，对于不是基于锁实现的并发控制的数据库，则检查到又违反串行操作的事务时，需要回滚事务。 2. 可重复读（Repeated Read）：所有被Select获取的数据都不能被修改，这样可以避免是一个事务前后读取不一致的情况。但是没有办法控制幻读。因为虽然其他事务不能更改所选数据，但是可以增加数据。 3. 读已提交（Read Committed）：被读取的数据可以被其他事务修改，这样可能导致不可重复读。 4. 读未提交（Read Uncommitted）：最低的隔离级别，允许其他事务看到没有提交的数据。 什么是SQL注入就是通过把SQL语句插入到Web表单提交，最后达到欺骗服务器执行了恶意的SQL语句。 举个例子你就懂了例如你要查询id=1的记录,直接连接就是这样&quot;select * from tableName where id=1&quot;别人可以写成&quot;select * from tableName where id=1;delete from tableName&quot; 这样就把你的表数据全部删除了. 如何防止SQL注入1. 永远不要相信用户的输入。 2. 永远不要动态拼装SQL。 3. 永远不要使用管理员权限的数据库连接。 什么是主键，什么是外键1. 主键：唯一标识一条记录，不能有重复的，不允许为null，用来保证数据完整性。主键只能有一个。 2. 外键：表的外键是另一个表的主键，外键可以有重复，可以为null。一个表可以有多个外键。 主键默认非空，默认唯一约束，只有主键才能设置自动增长，自动增长时一定是主键，主键不一定自动增长。 1. 如何设置主键 1. 定义列时：ID INT PRIMARY KEY 2. 定义完列时：PRIMARY KEY（id） 2. 外键注意事项 1. 只有INNODB的数据库引擎才支持外键，是修改My.ini文件设置default-storage-engine=INNODB。 2. 外键必须参照列的数据类型必须一致。 3. 如何设置外键 1. CONSTRANT 外键名 FOREIGN KEY （外键字段） REDERENCES 参照表（参照字段）ON DELETE SET NULL ON UPDATE CASCADE 设置参照完整性 什么是内连接，左外连接，右外连接1. 内连接：匹配两个表中相关联的记录。 2. 左外连接：除了匹配2张表中相关联的数据外，还会匹配左表中剩余的记录，右表中未匹配的字段用null表示。 3. 右外连接：除了匹配2张表中相关联的记录外，还会匹配右表中剩余的记录，左表中未匹配到的字段用NULL表示。 https://www.cnblogs.com/caozengling/p/5318696.html https://blog.csdn.net/qq877507054/article/details/52328017 http://blog.51cto.com/13579086/2087344 内聚函数Sum:求和\ Avg:求平均数\ Max:求最大值\ Min:求最小值\ Count:求记录数 什么是数据库约束（五大）1. 主键约束：唯一性，非空性 2. 唯一约束：唯一性，可以空，但是只能有一个 3. 默认约束：该数据的默认值 4. 外键约束：需要建立两表之间的关系 5. 非空约束：设置非空约束，该字段不能为空 注意，只有主键可以自增。 什么是视图视图实际上是在数据库中通过Select查询语句从多张表中提取的多个表字段组成的虚拟表。 1. 视图不占据内存空间，所以通过视图查询出来的记录，并没有保存在视图中，而是保存在原表中。 2. 通过视图可以对指定用户隐藏相应的表字段，起到保护数据的作用。 3. 在满足一定条件时，可以通过视图对原表中的记录进行增删改。 4. 创建视图时，只能使用单条select查询语句。 数据库的范式（三大范式）第一范式、第二范式、第三范式、巴斯-科德范式、第四范式、第五范式（完美范式）。 范式越高，冗余越低，但是一般到了第三范式，再往上，表越多，可能反而导致了查询的效率下降。所以有时为了提高运行效率，可以让数据冗余。 后面的范式必须满足前面的范式 第一范式（1NF） 强调了列的原子性，也就是不可再分。 例如：userInfo：山东省烟台市 131777368781。 前面这个列中可以再分为下面的两列。 userAds：山东省烟台市 userTel：131777368781 1. 1NF 的目标就只是保证列的原子性。 2. 当每列都是不可再分的最小数据单元（也称为最小原子单元），则满足第一范式。 第二范式（2NF） 强调一张表只能描述一件事，也就是说一张表中的所有列都必须和这个表的主键直接相关，并且不出现其他表的主键。 例如：订单表只描述订单相关的信息，所以所有字段都必须与订单ID有直接关系，因此不能在一张表中同时出现订单信息与产品信息。 1. 满足1NF，并且除了主键以外的其他列，每个属性都功能依赖（直接相关，并且不出现其他表的主键）于整个键， 2. 第二范式要求一张表只描述一件事 第三范式（3NF） 强调一张表的所有字段和主键直接相关，同时引入别的表信息时，只引入别的表的主键。 1. 如果一个关系满足2NF，每个非建属性只功能依赖于主键，不功能依赖其他属性，则满足第三范式（3NF） 2. 确保每列都和主键列直接相关。 三大范式的联系于区别第一范式和第二范式在于有没有分出两张表，第二范式是说一张表中包含了所种不同的实体属性，那么要必须分成多张表， 第三范式是要求已经分成了多张表，那么一张表中只能有另一张表中的id（主键），而不能有其他的任何信息（其他的信息一律用主键在另一表查询）。 什么是数据库索引https://blog.csdn.net/weiliangliang111/article/details/51333169 假设我们要从这个表中查找出所有名字是‘Jesus’的雇员信息。我们决定使用下面的查询语句： SELECT * FROM Employee WHERE Employee_Name = &apos;Jesus&apos; 1. 如果表中没有所以会发生什么？ 一旦运行这个SQL，在查找名字Jesus时，数据库不得不在Employee表中的每一行去确定Employee——Name是不是Jesus。由于我们想要得到每一个名字为Jesus的雇员信息，在查到第一个符合条件的行后，并不会停止查询，因为可能还是其他符合条件的行。所以必须一行一行查到最后一行。造成了全表查询。 2. 数据库索引时怎么提升性能的？ 通过数据结构来缩小一张表中需要查询的记录数目来加快搜索。 3. 什么是索引？ 一个索引是存储在表中一个特定列的所有数据的数据结构（B Tree）。 注意，索引是在表的某一列上创建的，包含了这个列中的所有数据，并把这些数据存储在了一个数据结构中。请记住，索引是一种数据结构。 4. 什么样的数据结构可以作为索引？ B-Tree是最常见用于索引的数据结构。因为O（n）低，数据是有序。 5. Hash索引是怎么工作的？ 哈希表进行索引，在比较字符串是否相等的查询能够极快的检索出值。 工作方式：列的值作为索引的Key，和表中对应行的指针作为Value。所以基本就是一个关联数组。一个典型的数据项就像&quot;Jesus--&gt;0x29831&quot;,而0x29831是对表中包含Jesus这一行的的引用。 6. Hash索引的缺点？ 因为Hash表无序，很多基本数据类型就不好查询（int） 7. 数据库索引中究竟存储了什么? 存储的是某一列的所有数据！但是不存储这个表中其他列的数据。 8. 数据库怎么知道什么时候使用索引？ 当在某一列中建立了索引，例如：SELECT * FROM Employee WHERE Employee_Name = &apos;Jesus&apos;，一旦Employee_Name中建立了索引，数据库会去看使用这个索引做查询是不是合适，因为有时候并不是索引查询就快。 9. 如何使用SQL创建索引？ CREATE INDEX name_index ON Employee (Employee_Name) 10. 使用索引的代价？ 1. 索引会占用内存。 2. 性能损失，主要是索引和表一样，需要锁着表的更新而更新。 什么情况下适合索引，索引的原则1. 索引的特点 1. 可以加快数据的检索速度 2. 降低了数据库增删改查等维护的速度（因为了同步更新） 3. 只能创建在表上，不能创建到视图上 4. 可以直接/间接创建 5. 可以在优化隐藏中使用索引 6. 使用查询处理器执行SQL时，一个表，一次只能用一个索引 2. 索引的优点 1. 创建唯一性索引，保证数据库表中每一行数据的唯一性。 2. 大大加快了数据的检索速度 3. 加速了表之间的连接 4. 通过索引，可以在查询中使用优化隐藏器。 5. 在分组和排序子句进行数据检索时，可以减少时间 3. 索引的缺点 1. 创建和维护索引损耗时间 2. 占用物理内存 4. 索引分类 1. 直接创建/间接创建 2. 普通/唯一性 3. 单个/复合 4. 聚簇/非聚簇 5. 索引失效 1. 如果条件中有or，即使其中有条件带有索引，也不会使用（为什么少用or） 2. 多列索引，不是使用的第一部分，不会使用索引 3. like查询用%开始 4. 如果列类型是string，那一定要在条件中使用引号引起来，否则不会使用索引。 5. MySQL发现全表查询更快。 6. 数据库的索引结构 1. 使用二叉树的时候，可能会因为树的深度过大，而造成I/O读写过于频繁，进而导致查询效率低下。所以使用B树。 2. B树/B+树 https://www.nowcoder.com/discuss/5772 https://blog.csdn.net/random__walker/article/details/52051556 https://blog.csdn.net/feynman1999/article/details/72667919 一个M阶的B树： 1. 每个结点至多有m个子树 2. 根结点至少有两个子树 3. 除了根结点，其余每个分支节点至少有m/2个子树 4. 所有叶子节点在一层 5. 有k个子树的分支结点则k-1个关键码，关键码递增排序 3. B树与B+树的区别 1. B树的关键字集合分布在整课树上，叶子结点中不包含任何关键字。B+树关键字集合分布在叶子结点中，非叶子结点只是叶子结点中关键字的索引。 2. B树种任何一个关键字只能出现了一个结点中，而B+树中的关键字必须出现在叶子结点。 3. B树只适合随机检索，B+树还适合顺序检索 4. B+树的磁盘读写代价更低。 5. B树提高了磁盘的I/O但是并没有解决元素的遍历，但是B+树的叶子结点用指针顺序连接，只要遍历叶子结点就可以实现整棵树的遍历。而在数据库中基于范围的查询是非常频繁的，而B树这么做很垃圾。 7. 什么情况下适合索引？ 1. 经常出现order by，group by，distinct后面的字段。 2. union等集合操作的结果集字段上。 3. 经常使用查询选择和表连接的属性上。 MyISAM和InnoDB引擎的区别1. MyISAM是非事务安全，InnoDB是事务安全 2. MyISAM锁的粒度是表级，而InnoDB是行级 3. MyISAM支持全文类型索引，而InnoDB不支持全文索引。 4. MyISAM简单，效率比InnoDB高。 5. InnoDB比MyISAM安全。 6. MyISAM适合高速检索和存储，而InnoDB是适合INSERT和UPADTE MyISAM不支持事务，不支持行级锁，不支持外键。InnoDB支持这些。 什么是触发器（特殊的存储过程）触发器是一中特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。 注意一下，触发器都是事件驱动的，不能程序/手动调用。同时触发器内部不能使用COMMIT，ROLLBACK，同时不接收参数输入，而一般的存储过程都可以。 1. 触发器分为事前（Instead Of）和事后（After），有什么区别？ 1. 事前触发，在记录变更前触发触发，去执行了触发器本身定义的操作，而不是执行原来的SQL。 2. 事后触发，记录更改之后执行，用来收尾。 2. 行级触发和语句级触发？ 1. 语句级触发，可以在语句执行前后触发 2. 行级触发，在触发器所影响的每一行都触发一次。 什么是游标游标实际上是一种能从包括多条数据记录的结果集中每次提取一条记录进行处理的机制。 游标总是和一条SQL选择语句关联，因为游标就是由选择后的结果集和结果集中指向特定记录的游标位置组成。 当决定对结果集进行处理时，必须要声明一个指向该结果集的游标。 1. 游标不允许程序对整个行集合执行相同的操作，但是对每一行的操作不做要求 2. 在使用游标的表中，对行提供删除和更新的功能。 数据库优化https://www.cnblogs.com/zhyunfe/p/6209074.html 分页查询（LIMIT）SELECT ... FROM ... WHERE ... ORDER BY ... LIMIT ... UNION和UNION ALLselect * from Table1 union select * from Table2 1. UNION和UNION ALL都是将两个结果及合并成一个。 2. UNION去重，UNION ALL 不去重 3. UNION按照字段排序，UNION ALL 只是简单的将两个结果合并。 4. UNION ALL比UNION快。 WHERE，HAVING，ORDER BYhttps://blog.csdn.net/yexudengzhidao/article/details/54924471 1. where子句用来筛选from子句中指定操作所产生的行，直接实在表中的字段进行操作 2. Group By子句用来分组where子句的输出（分组结果集） 3. Having子句用来从分组的结果中再筛选。 4. where在分组前使用，Having在分组后使用 5. Having包含内聚函数sum，max，avg等 6. Having子句限制是组，而不是行。 7. 当where，内聚函数，group by，having都有怎么做 执行where子句查询，使用group by对查询结果分组，对分组运行内聚函数计算每一组的值，用having子句去掉不符合条件的组。 DISTINCT 与 ORDER BYhttps://blog.csdn.net/ammmd/article/details/3339950 https://blog.csdn.net/ljl890705/article/details/70602442 DELETE 与 TRUNCATE1. 两个都是删除记录的 2. DELETE删除的操作以日志的形式保存，以便将来进行回滚，TRUNCATE一旦执行不能回滚。 3. DELETE操作后，删除数据占用的内存空间还在，还可以恢复。但是TRUNCATE就不可以了，存储空间直接就被释放了。 4. TRUNCATE执行速度块。 也就说一个表中有很多记录，占用存储空间为10MB，执行DELETE删除了表中所有记录后，这个表还是占用10MB，有点像Window中的回收站。 关于JDBC1. 加载JDBC驱动器 2. 加载JDBC驱动，并将其注册到DriverManager 3. 建立数据库连接，取得Connection 4. 建立Statement或者PreparedStatement 5. 执行SQL 6. 访问结果集对象ResultSet 7. 依次关闭ResultSet，Statement/PreparedStatement，Connection对象。（因为JDBC驱动在底层通常是通过网络IO实现SQL命令与数据传输） 1234567891011121314151617181920212223242526272829303132333435CREATE TAVLE employee( id INT PRIMARY KEY, name VARCHAR(50), age INT);import java.sql.*;public class Main&#123; public static void main(String[] args)&#123; try&#123; Class.forName("com.mysql.jdbc.Driver"); Connection connect = DriverManager.getConnection("jdbc:mysql://localhost:3306/cop","root","7122887"); PreparedStatement pst = connect.createPrepared("SELECT * FROM employee WHERE id = ?"); pst.setInt(1,1); ResultSet rs = pst.executeQuery(); while(rs.next())&#123; System.out.println(rs.getInt(1)+","+rs.getString(2)+","+rs.getInt(3)); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; try&#123; if(rs!=null) rs.close(); if(pst!=null) pst.close(); if(connect!=null) connect.close(); &#125;catch(Exception ee)&#123; ee.printStackTrace(); &#125; &#125; &#125;&#125; 1. Class.forName(&quot;com.mysql.jdbc.Driver&quot;)的作用？ 就是把Driver这个类加载到JVM中，同时执行类中的静态资源。 JDBC中要求Driver使用前必须向DriverManager注册自己，所以，当执行Class.forName(&quot;com.mysql.jdbc.Driver&quot;)的时候，JVM会加载全是类名的Driver，而这个类的静态块有一个是将自己注册到了DriverManager static{ try{ java.sql.DriverManager.registerDriver(new Driver()); }catch(SQLException e){ throw new RuntimeException(&quot;Can&apos;t register driver&quot;); } } 2. Statement、PreparedStatement、CallableStatement 1. Statement（继承Wrapper）用于执行不带参数的SQL语句，并返回它生成结果的对象，每次执行SQL语句时，数据库都要编译该SQL语句。 Statement state = connect.getStatement(); state.executeUpdate(&quot;INSERT INTO client VALUES(&apos;a&apos;,&apos;aaa&apos;)&quot;); 2. PreparedStatement（继承Statement）表示预编译了SQL语句对象，用于执行带参数的预编译SQL语句。 1. 在使用PreparedStatement对象执行SQL命令的时候，命令会被数据库进行编译和解析，并放到命令缓冲区。然后当执行同一个PreparedStatement的时候，由于在缓冲区中可以发现预编译的命令，虽然它会被再解析一次，但是不会再次编译。 2. 代码的可读性和维护性好 3. 安全性好，可以预防SQL注入，SQL注入只是对SQL语句的编译期有破坏作用，而执行阶段只是把输入串作为数据处理，不再对SQL语句进行解析，因此也就解决了一部分SQL注入。 SELECT * FROM user WHERE name=&apos;aa&apos; AND password=&apos;bb&apos; or 1=1; 3. CallableStatement（继承PreparedStatement）则是提供了用来调用数据库中存储过程的接口，如果有输出参数要注册说明是输出参数。 由prepareCall()方法创建。 JDBC中的CallableStatement对象为所有RDBMS提供了一套标准形式调用存储过程的方法。 其对存储过程的调用存在两种形式：带结果参数和不带结果参数。结果参数是一种输出参数，是存储过程的返回值。 3. executeQuery()、executeUpdate()、execute() 1. executeQuery：返回结果集(ResultSet)。 2. executeUpdate: 执行给定SQL语句,该语句可能为 INSERT、UPDATE 或 DELETE 语句， 或者不返回任何内容的SQL语句（如 SQL DDL 语句）。 3. execute: 可用于执行任何SQL语句，返回一个boolean值， 表明执行该SQL语句是否返回了ResultSet。如果执行后第一个结果是ResultSet，则返回true，否则返回false。 4. getString()与getObject() 1. getString(),getInt()等被调用时，程序会把查到的结果集一次都加载到内存中，然后通过调用ResultSet的next和getString来获取数据。但是有时候结果集太大，一次性加载进来放不下，就出现了异常。 2. getObject()是把结果集放在了数据库中，每次要的时候直接从库中取，就解决了一次性加载内存放不下的问题。]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2018%2F04%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[设计模式23种 单例饿汉123456789public class Singleton &#123; private static final Singleton singleton = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return singleton; &#125;&#125; 懒汉1234567891011public class Singleton &#123; private static Singleton singleton; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(singleton==null) singleton = new Singleton(); return singleton; &#125;&#125; 懒汉加锁1234567891011public class Singleton &#123; private static Singleton singleton; private Singleton()&#123;&#125; public static synchronized Singleton getInstance()&#123; if(singleton==null) singleton = new Singleton(); return singleton; &#125;&#125; 双重检查123456789101112131415public class Singleton &#123; private static volatile Singleton singleton; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if(singleton==null)&#123; synchronized (Singleton.class) &#123; if(singleton==null) singleton = new Singleton(); &#125; &#125; return singleton; &#125;&#125; 静态内部类1234567891011public class Singleton &#123; private static class SingletonHolder&#123; public static Singleton singleton = new Singleton(); &#125; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return SingletonHolder.singleton; &#125;&#125; 工厂模式http://bbblemon.top/2018/03/24/%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/ 建造者模式]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入了解JVM]]></title>
    <url>%2F2018%2F04%2F23%2F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3JVM%2F</url>
    <content type="text"><![CDATA[深入了解JVM JDK和JRE的区别 1. JDK是由JRE和Java设计语言构成。 2. JRE是由JVM和Java的API构成。 运行时内存区域 运行时内存区域的可见性1. 堆和方法区线程共享，和虚拟机同生同灭。 2. 虚拟机栈、本地方法栈、程序计数器，线程私有，和线程同生同灭。 运行时内存区域都保存什么1. 程序计数器：保存当前线程字节码执行的行数。因为JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现，任意一个实现，一个处理器只能执行一个线程。为了让每个线程切换后能够恢复到原来的位置，每个线程就由一个独立的程序计数器。 如果线程执行的是Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址，如果是Native方法，这个计数器的值是空（Undefined）。 1. 这个区域是为一个在JVM中没有规定任何OutOfMemoryError情况的区域。 2. Java虚拟机栈：Java方法执行的内存模型，每个方法执行时都会创建一个栈帧（Stack Frame：局部变量表，操作数栈，动态连接，方法出口（方法返回值）等）。每个方法从调用到执行完成对应了一个栈帧在JVM中从入栈到出栈的过程。 局部变量表中存放了基本数据类型和对象引用。局部变量表的大小在编译期完成，在方法运行时不会改变。 1. StackOverflowError：线程请求的栈深度大于了虚拟机允许的深度。 2. OutOfMemoryError：虚拟机栈可以动态扩展，当扩展时无法申请到空间的时候，抛出异常。 3. 本地方法栈：和虚拟机栈没撒区别，不过是执行Native方法时的内存模型。但是Hot Spot把本地方法栈和虚拟机栈合二为一了。 4. 堆：所有的对象实例和数组要在堆上分配内存，线程共享。 堆从GC分代收集的角度可以分为新生代和老年代，新生代又可以分为两个Survivor和一个Eden（默认，1：1：8） 1. 当堆中没有完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError。 5. 方法区：存储类信息（加载）、常量（final）、静态变量、即时编译器编译后的代码，为类加载器记载Class文件并解析后的类结构信息提供存储空间。 HotSpot中把方法区用永久代实现了，这个样子不需要为方法区专门去写GC的代码。 关于方法区中JDK7，8的区别： 1. JDK7中，不再在永久代中生成字符串常量池，在年轻代和老年代中分配。 2. JDK8中，永久代贝删除，类元数据（Class Metadata）存储空间在本地内存中分配，并显式的管理元数据的空间。 从OS中请求空间，然后分成块，类加载器从它的块中分配元数据的空间（一个块被绑定到一个特定的类加载器），当为类加载器卸载类时，它的块被回收再使用或者返回到OS 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError， 6. 运行时常量池：方法区的一部分。存储从编译器可知的字面量和符号引用，也就是Class文件结构中的常量池；运行期解析后才能获得的方法或字段的直接引用；运行时可能创建的新常量。 直接内存直接内存不是JVM运行时数据区的一部分，也不是JVM规范中定义的内存区域。 内存泄露和内存溢出内存溢出说的是内存不够用了 内存泄露说的是对象可达，但是没用了。本该被GC的对象没有被GC。 内存泄漏可能会导致内存移除。 内存泄露的原因： 1. 长生命周期的对象引用了短生命周期的对象 2. 没有将无用对象置为null 对象的创建过程判断类是否加载，没有加载先加载--&gt;为新生对象分配内存（大小和是否频繁使用）--&gt;将分配的内存空间初始化为零值--&gt;对对象进行必要的设置--&gt;执行&lt;init&gt;方法（执行new指令后接着走&lt;init&gt;，接着对象就按照程序员的意愿开始初始化了） 1. 类的加载 JVM遇到new指令，如果一个类没有被加载过，先执行加载过程。 2. 新生对象分配内存 1. 对象所需内存大小： 一个对象所需要的内存大小，在类加载完成后，就被确认了，为对象分配空间等价于从堆中划出一块内存给对象。 1. 指针碰撞（带有整理(compact)的算法） 堆中内存，使用过的和没有使用过的分开了，中间有个指针，分配内存就是在指针移动一下。 2. 空闲列表（没有整理(compact)的算法） 维护一张空闲列表 2. 对象创建是否频繁： 仅仅是修改一个指针，在并发的情况下，也是不安全的，可能出现A线程用原来的指针地址在为一个对象分配内存，指针还没有修改完，B线程又用原来的指针地址为另一个对象分配内存。 1. 对分配内存的动作进行同步处理（CAS+失败重试），保证了更新操作的原子性。 2. 为每个线程分配自己的一小块内存，TLAB（本地线程分配缓存，Thread Local Allocation Buffer）。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。 3. 内存分配完成后将分配的内存空间都初始化为零值 4. JVM对对象进行必要的设置，例如这个对象是哪个类的实例，如何才能找到类的元数据类型，对象的哈希码，对象的GC分代年龄等。这些信息在对象的对象头中。 5. 执行new指令后接着走&lt;init&gt;，接着对象就按照程序员的意愿开始初始化了。 对象的内存分布对象头、实例数据、对齐填充 1. 对象头 1. 第一部分:对象自身的运行时数据（Mark Word），被设计成一个非固定的数据结构。 2. 第二部分：对象指向它的类元数据的指针，JVM通过这个来确定这个对象是是哪个类的实例。 3. 如果对象是数组，对象头还必须要有存储数组的长度 2. 实例数据 1. 字段内容 3. 对齐填充 1. 可以不存在，只不过HotSpot要求对象的起始地址必须是8字节的整数倍，有了这个填充来占位。 OOM1. 堆：不断创建对象，并保持对象和GC Roots的连接。 2. 方法区：CGLib直接操作字节码生成大量的动态类。 什么内存需要被回收程序计数器、虚拟机栈、本地方法栈都是和线程共存亡的，同时线程隔离，这三个区域的不需要考虑我们的回收的问题，因为方法结束或者进程结束时，内存自然就跟随着回收了。 而我们的方法区和堆中的内存分配和回收都是动态的，所以GC关注的就是这部分内容。 在堆中，尤其是新生代，一次GC一般可以回收70%-95%，但是HotSpot中的永久代效率远低于这个。 永久代中的垃圾回收有两部分：废弃常量和无用的类 废弃的常量的GC过程和堆中的对象相似。 无用的类比较麻烦：如何判定一个类是无用的类（判定是判定，回收是回收） 1. Java堆中不存在该类的任何实例。 2. 加载该类的ClassLoader被回收。 3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 什么样的对象被回收（没有引用，如何判断对象没有引用）引用计数法1234567891011121314151617181920给我们对象上加一个引用计数器，当有引用的时候+1，引用失效的时候-1，任何时刻计数器为0的对象就是不可能再被使用的对象。问题： 无法解决对象之间相互循环引用的问题，比如： public class ReferneceGC&#123; public Object instance = null; public static void testGC()&#123; ReferenceGC objA = new ReferenceGC(); ReferenceGC objB = new ReferenceGC(); objA.instance = objB; objB.instacne = objA; objA = null; objB = null; system.gc(); &#125; &#125;这种情况下我们的两个对象已经不能再被访问了，但是两个之间还存着引用，所以计数器不为0，也就没法被GC。 可达性分析 通过&quot;GC Roots&quot;对象作为起始点，从这些结点向下搜索，走过的路径称为引用链（Reference Chain），当一个对象到GC Roots 没有引用链，那么这个对象就不可用，也就是说GC Roots到不了这个对象，这个对象被判定是可回收的对象。注意！！！这里只是判 定可回收，并不是真的回收了，真正的回收是需要两次标记的这里只是一层标记，还有一层是在F-Queue中执行了finalize()后，被 标记第二次，才会真正的被回收。 GC Roots对象的范围： 1. 虚拟机栈中引用的对象。 2. 方法区中类静态属性引用的对象。 3. 方法区中的常量引用。 4. 本地方法栈中JNI（Java Native Interface）引用的对象。 5. 被启动加载器（Bootstrap ClassLoader）加载的类和创建的对象 对象是否死亡 上面也说到了，当一个对象经过可达性分析后，不能到达GC Roots，那么这个对象会被第一次标记，并同时进行一次筛选，这个筛选就是判断对象是否需要执行finalize()方法，如果没有必要执行，那么这个对象被第二次标记，同时就保留在了原来&quot;即将收回&quot;的集合中，如果有必要执行finalize()方法，那么这个对象会被放在一个F-Queue的队列中，并在稍后，JVM会自动创建一个Finalizer线程（优先级很低）去执行他。如果对象在finalize()方法中成功拯救了自己--只要重新与引用链上任何一个对象建立关联即可，比如：把自己赋值给某个类变量或者对象的成员变量，那么在第二次标记前它就会被移除&quot;即将回收&quot;的集合。 注意： 如果判断一个对象是否有必要执行finalize()方法： 1. 对象本类中，finalize()方法被重写； 2. finalize()方法还没有被执行（任何一个对象的finalize()方法只能被JVM自动调用一次，也就是说这个对象一旦面临第二次被回收，那么JVM不会再调用finalize()方法，对象也就别回收了） 堆的分代划分与对象创建 HotSpot JVM中新生代的Eden和两个Survivor（From、To）的默认比例是8：1：1，新创建的对象实例基本都会被直接分配到Eden或者From，当然一些比较大的对象实例，如果Eden中没有那么大的连续空间，就直接分配到老年代。这些对象经过第一次对新生代的GC（Minor GC）后，被移动到To。随后，对象每次在Survivor经过一次Minor GC ，年龄就会增加一岁，一旦到15（默认的），就会被移动到老年代。 在新生代中的对象基本都是朝生夕死（98%以上），所以年轻代的GC算法是复制算法。复制算法不会产生内存碎片。 Minor GC前，对象都是Eden和From中，To是空的，GC时，Eden存活的对象直接被移到To，而From存活的对象，如果年纪到达了阈值，被移动到老年代，否则，被移动到To。经过这次Minor GC,Eden和From清空。在下一次Minor GC前，我们之前的To，就是现在的From，之前的From就是To（From和To互换，因为一定要保证To是空的）。不断进行Minor GC，这个时候有可能会有一次，Eden和From移动的对象把To填满了，也就是下一次的From满了，这个时候把To中的对象都移动到老年代（Handle Propotion，分配担保）。 我是一个普通的Java对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，我就开始漂了，有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。直到我18岁的时候，爸爸说我成人了，该去社会上闯闯了。于是我就去了年老代那边，年老代里，人很多，并且年龄都挺大的，我在这里也认识了很多人。在年老代里，我生活了20年(每次GC加一岁)，然后被回收。 GC算法标记-清除（Mark-Sweep）老年代使用，先标记出所有需要回收的对象，在标记完成后，统一回收。 标记过程就是之前说的两次标记。 缺点： 1. 效率低 2. 空间问题，这个样子标记清除会产生很多不连续的内存碎片，空间中碎片太多，会让程序在运行过程中需要分配比较大的对象时，无法找到足够大的连续空间，而提前触发下一次GC。 标记-整理（Mark-Compact）老年代使用，先标记，然后把存活的对象都向一边移动，然后直接清除掉边界外的内存。 复制（Copying）新生代使用，算法本身是把可用内存划分为可用的两部分，一块用完了，把存活的复制到另一块上，然后把这块清空，但是50%太多了，后来就有了Eden和两个Survivor，只有10%不被使用。一旦需要移动的存活对象大于了10%，那么就把这些对象所有直接移动到老年代，也就是所谓的分配担保（Handle Promotion） 分代收集（Generational Collection）基本上JVM都用这个，新生代复制算法，老年代标记-整理（清除） GC算法的实现JVM线程执行的过程中在GC前需要可达性分析，而可达性分析需要枚举根节点，枚举根节点的时候需要进行GC停顿，在GC停顿的时间上利用OopMap得到引用的位置，进而减少了扫描的范围。而在线程进行GC的时候，并不是任何时间点都可以随意的发生GC，线程GC必须是在安全点上，因为OopMap的数据就存放在安全点上，线程只有到这里才知道要引用在哪。 枚举根节点（GC停顿上）可以作为GC Roots的节点，基本都在方法区和栈中，也就是全局性引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，在可达性分析的时候，因为这项分析工作必须在一个能保证一致性的快照中进行，也就是GC停顿中执行，在GC停顿中我们的HotSpot使用一组称为OopMap的数据结构来完成准确式GC（虚拟机有办法直接得到哪些地方存放着对象引用），那么在枚举根节点的时候，就直接在这些地方进行扫描，很快就得到了根节点（GC Roots）。 我们枚举根节点是在GC停顿上，但是我们什么进行GC呢，GC停顿是为了得到我们引用位置，而引用位置在OopMap中，所以我们的GC停顿就在安全点上，也就是GC就在安全点上。 那么我们GC的时候我们的线程必须处于安全点上，那么怎么就能让GC的时候线程就在安全点上呢？ 抢先式中断 在GC发生时，把所有线程中断，没有在安全点的线程，恢复线程，让它跑到安全点后再中断 主动式中断 设置一个标志位，各个线程自己去轮询这个标志，发现标志为真时，线程中断，这个标志位和安全点的位置一致。 基本上都用这个主动式中断，但是主动式中断时，线程必须都是活的，一旦我们的线程是Sleep或是wait时，我们的线程就需要存放在一个Safe Region的区域，也就是线程一旦处于挂起，就让它进入安全域，同时标识这个线程已经进入了Safe Region，这个时候就是发生了GC，也无所谓。但是在线程恢复的时候，也就是离开安全域时，线程要检查是不是已经完成了枚举根节点或者是整个GC过程，如果完成了线程恢复，没有完成的话，线程还是要等待，等待一个可以离开的信号。 GCor 并行与并发并行：两个回收线程一起进行垃圾回收，但是用户线程是等待的。 并发：垃圾回收线程和用户线程一起执行（但是垃圾回收线程不一定是并行的，可能变替执行），用户线程在运行，垃圾收集线程在另一个CPU上运行 SerialSerial收集器是一个新生代收集器，单线程执行，使用复制算法。 在进行收集垃圾时，必须stop the world，它是虚拟机运行在Client模式下的默认新生代收集器。 ParNewParNew收集器是Serial收集器的多线程版本，许多运行在Server模式下的虚拟机中首选的新生代收集器，除Serial外，只有它能与CMS收集器配合工作。 ParNew收集器其实就是serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为与Serial收集器一样。 Parallel ScanvengeParallel Scavenge收集器也是一个新生代收集器，它也是使用复制算法的收集器，又是并行多线程收集器。 CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。吞吐量= 程序运行时间/(程序运行时间 + 垃圾收集时间)， 虚拟机总共运行了100分钟。其中垃圾收集花掉1分钟，那吞吐量就是99%。 自适应调节策略是Parallel Scavenge与ParNew的一个重要区别。 Serial OldSerial Old是Serial收集器的老年代版本，同样是单线程收集器，使用标记整理算法。 Parallel OldParallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和标记整理算法。 CMS（Concurrent Mark Sweep 并发GC）Concurrent Mark Sweep 收集器是一种以获得最短回收停顿时间为目标的收集器，基于标记清除算法。 过程如下：初始标记，并发标记，重新标记，并发清除，优点是并发收集，低停顿，缺点是对CPU资源非常敏感，无法处理浮动垃圾，收集结束会产生大量空间碎片。 G1（Garbage First）G1(Garbage First)收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。还有一个特点之前的收集器进行收集的范围都是整个新生代或老年代，而G1将整个Java堆(包括新生代，老年代)。 G1 GCor 将整个Java堆划分成多个大小相等的独立区域Region，虽然还保留了新生代和老年代的概念，但是两者不再物理隔离，都是Region的一部分（不需要连续） 1. 为什么叫G1 G1可以建立可预测的停顿时间模型，是因为它可以又计划的避免在整个Java堆上进行全区域的GC，G1跟踪各个Region的垃圾堆积价值，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。 内存分配与回收策略之前也讲了，一个对象new出来，主要分配在Eden和From上，但是如果启动了本地线程分配缓冲，就按照线程优先在TLAB（Thread-Local Allocation Buffer）上分配。少数情况下，也就是对象太大时，直接就分派到了老年代。 经过一次Minor GC后，Eden和From中没有过阈值的存活对象移动到To（大多数情况是小于10%的，不出现分配担保），同时对象年龄+1，而From中经过这次Minor GC到达阈值的对象，直接进入老年代。 同时一旦在Survior中一个年龄点的对象超过了Survior空间的一半，那么这年龄等于或者大于这个点的对象直接进入老年代。 每次进行Minor GC前，JVM都会检查一下老年代中最大可用的连续空间是不是大于新生代中所有存活对象的总空间，一旦大于，Minor GC确保安全，一旦不小于或着等于，JVM会查看HandlePromotionFailure设置值是否允许担保失败，一旦允许，那么就继续查看老年代中的最大可用连续空间是不是大于历次老年代对象的平均大小，如果大于，就进行Minor GC，虽然有风险，但是也会执行，但是一旦HandlePromotionFailure不允许担保失败，或者小于，直接进行一个Full GC。 Minor GC 与 Full GCMinor GC1. 当JVM无法为新对象分配内存空间时总会触发 Minor GC,比如 Eden 区占满时。Survivor满不会引发GC。所以(新对象)分配频率越高, Minor GC 的频率就越高。 2. Minor GC 事件实际上忽略了老年代。从老年代指向年轻代的引用都被认为是GC Root。而从年轻代指向老年代的引用在标记阶段全部被忽略。 3. Minor GC 每次都会引起全线停顿(stop-the-world ), 暂停所有的应用线程。 Full GC1. 方法区空间不足 2. 老年代空间不足 3. 调用System.gc()，系统会建议执行Full GC，但是不必然执行 4. 通过Minor GC后，进入老年代的平均大小大于老年代的可用空间 5. 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小 6. CMS GC时出现promotion failed和concurrent mode failure GC调优堆设置-Xms：初始堆大小，默认是物理内存的1/64 -Xmx：最大堆大小，默认是物理内存的1/4 -Xmn：年轻代大小 -Xss：每个线程的堆栈大小 -XX：NewSize=n；设置年轻代大小 -XX：NewRatio=n；设置年轻代和老年代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4 -XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5 -XX:MaxPermSize=n:设置持久代大小 实例java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -Xmx3550m：设置JVM最大可用内存为3550M。 -Xms3550m：设置JVM初始内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。 -Xmn2g：设置年轻代大小为2G。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。 -Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。 java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0 XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5 -XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6 -XX:MaxPermSize=16m:设置持久代大小为16m。 -XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。（默认是15） 类的加载 解析阶段不一定是在初始化之前（动态绑定），这些阶段通常都是相互交叉着混合式及逆行，通常会在一个阶段执行的过程种调用、激活另一个阶段。 什么时候开始类加载（类加载的时机）有且仅有5种的主动引用。 1. 遇到new，getstatic、putstatic、invokestatic这4个字节码的时候，如果类没有初始化，需要先触发其初始化（加载、验证、准备自然需要在这之前）。 1. new：使用new关键字实例化对象 2. getstatic：读取一个类的静态字段 3. putstatic：设置一个类的静态字段 4. invokestatic：调用一个类的静态方法 2. 使用java.lang.reflect包的方法堆类进行反射的时候，如果类没有初始化，需要初始化 3. 初始化一个类的时候，其父类没有初始化 4. JVM启动时，需要指定一个主类（main(String[] args)）,先初始化主类 5. 使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic/putStatic/invokeStatic的方法句柄。 什么是被动引用1. 通过子类引用父类的静态字段，不会导致子类的初始化 1234567891011121314151617181920212223class superClass&#123; static&#123; System.out.println("superClass"); &#125; public static int value = 1;&#125;class subClass extends superClass&#123; static&#123; System.out.println("subClass"+value); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; System.out.println(subClass.value); &#125;&#125;/**superClass1*/ 2. 通过数组定义引用类，不会触发类的初始化 12345678910111213141516171819202122232425class superClass&#123; static&#123; System.out.println("superClass"); &#125; public static int value = 1;&#125;class subClass extends superClass&#123; static&#123; System.out.println("subClass"+value); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; //System.out.println(subClass.value); subClass[] subArray = new subClass[2]; superClass[] superArray = new superClass[2]; superClass[] superSubArray = new subClass[2]; &#125;&#125;/** 无输出*/ 3. 常量在编译期会存入调用类的常量池（好像只有字符串和基本数据类型有效），本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 123456789101112131415161718192021222324252627282930class superClass&#123; static&#123; System.out.println("superClass"); &#125; public static final int value = 1; public static final String V = "BF"; public static final Integer K = new Integer(1000);&#125;class subClass extends superClass&#123; static&#123; System.out.println("subClass"+value); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; System.out.println(superClass.V); //System.out.println(superClass.K); System.out.println(subClass.V); System.out.println(subClass.value); //System.out.println(subClass.K); &#125;&#125;/** BF BF 1*/ 12345678910111213141516171819202122232425262728class superClass&#123; static&#123; System.out.println("superClass"); &#125; public static final int value = 1; public static final String V = "BF"; public static final Integer K = new Integer(1000);&#125;class subClass extends superClass&#123; static&#123; System.out.println("subClass"+value); &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; System.out.println(subClass.K); System.out.println(superClass.K); &#125;&#125;/** superClass 1000 1000注意：静态资源只加载一次*/ 类加载的过程加载加载和类加载不是一个概念，类加载包含了加载 1. 通过一个类的全限定名来获取定义此类的二进制字节流 2. 将这个字节流所代表的静态存储结构转换成方法区的运行时数据结构 3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 在内存中，一个类是由类本身和类的加载器一起确定的，一旦两个有一个不一样，那么这个类在内存中就是一样的。 数组类的加载和非数组类的加载还是不太一样的： 1. 非数组类：加载器可以使用引导类加载器也可以使用用户自定义的类加载器（重写loadClass()） 2. 数组类：数组类本身不使用类加载器创建，它是由JVM直接创建的。但是数组类与类加载器之间是由数组的组件类型连接的，那么就需要使用类加载器： 1. 组件类型是引用类型：可以使用自定义的类加载 2. 组件类型是基本数据：引导类加载器 验证验证是连接阶段的第一步，这一阶段的目的是为了确保Class字节流中包含的信息符合当前JVM的要求 1. 文件格式验证：基于二进制字节流，只有过了这个，才能把静态字节流的静态存储结构转换成方法区中运行时的数据结构，后面的验证都是在方法区中进行的。 2. 元数据验证：对类的元数据信息进行语义校验（字段）。 3. 字节码验证：通过数据流和控制流分析，确定程序语义是否合法。 4. 符号引用验证：虚拟机将符号引用转换为直接引用的时候，这个转换动作在连接的第三部分（解析）进行。 准备准备阶段起始就是为类变量分配内存并设置类变量的初始值。（只有类变量，因为这个过程只发生在方法区，类信息是被加载进入的方法区，而不是堆，实例变量是在new的时候被创建在堆上的）。 1. 准备阶段对应非final字段：基本数据类型对应自身的默认值，引用类型对应null，真正的赋值（程序中写出来的）是在初始化的时候。 2. 准备阶段对应final字段：直接进行程序数据的赋值。因为这些字段是在ConstantValue中的。 解析将常量池中的符号引用转成直接引用。 1. 静态引用 2. 动态引用 初始化初始化阶段执行了类构造器&lt;clinit&gt;()方法。 关于&lt; clinit &gt;()1. &lt;clinit&gt;()是由编译器是自动收集类中的静态资源（变量的赋值动作和块，注意，一定是变量赋值动作，不是使用！！！），收集的顺序是由语句在源文件中出现的顺序决定的，静态块只能访问到定义在其前面的类变量，定义在其后面的变量，在其前面的静态语句块只能赋值，不能访问！！！ 1234567public class Test&#123; static&#123; i = 0; //这句编译可以通过 syso(i); //这句编译通不过 &#125; static int i = 1;&#125; 2. &lt;clinit&gt;()在JVM中，由JVM保证其父类的&lt;clinit&gt;()方法一定在其前面执行完了。 3. 如果一个类/接口没有静态块，也没有对类变量的赋值操作，这个方法可以不存在。 4. 执行接口的&lt;clinit&gt;()方法不需要先执行父接口的&lt;clinit&gt;()方法，接口的实现类也一样，只有用到了父接口中定义的变量时，父接口才会初始化！！！ 类加载器类与类加载任意一个类，都需要由它的类加载器和这个类本身来确定其在JVM中的唯一性！！！ 每一个类加载都有一个独立的类名称空间。 1. 启动类加载器：Bootstrap ClassLoader，由C++实现，是JVM自身的一部分。 1. 负责加载&lt;JAVA_HOME&gt;\lib目录中，并且由JVM识别的类库。 2. 无法被Java程序直接引用。 2. 其他类加载器：全部继承于java.lang.ClassLoader(抽象类)，由Java实现。 1. 扩展类加载器：Extension ClassLoader，加载&lt;JAVA_HOME&gt;\lib\ect目录中的类库 2. 应用程序类加载器：Application ClassLoader，系统类加载器，classPath上的类库。 双亲委派模型 工作原理双亲委派模型工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载。 实现双亲委派模型的代码都集中在java.lang.ClassLoader的loadClass()方法中： 1. 首先会检查请求加载的类是否已经被加载过； 若没有被加载过： 1. 递归调用父类加载器的loadClass(); 2. 父类加载器为空后就使用启动类加载器加载； 3. 如果父类加载器和启动类加载器均无法加载请求，则调用自身的加载功能。 为什么需要双亲委派模型Java类伴随其类加载器具备了带有优先级的层次关系，确保了在各种加载环境的加载顺序。 保证了运行的安全性，防止不可信类扮演可信任的类。 例如类java.lang.Object，它由启动类加载器加载。双亲委派模型保证任何类加载器收到的对java.lang.Object的加载请求，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。 相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并用自定义的类加载器加载，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。 JMM硬件效率与一致性 其实就是因为CPU处理速度太快，但是从硬件存储中写入和读取的速度跟不上，就在CPU与硬件存储之前加了一层Cache，但是这个Cache对于多核来说，每一个核都有一个Cache，这个时候，如果多个Cache一开始取的是主存中的相同地址，那么回写的时候，怎么回写。 因此出现了一致性协议。 处理器的指令重排序和JIT中的指令重排序，告诉我们执行的顺序性不能由代码的先后顺序来保证，因此引出了先行发生原则（before-happen） 内存模型 JMM规定了所有变量都必须在主内存（线程共享）中，但是每个线程都有自己的工作内存（线程私有），线程的工作内存中保存的都是主内存中该线程用到的变量的副本，线程对变量的读写都必须在工作线程中进行，不能直接读写主内存中的变量！！！ 不同线程不能访问对方的工作内存。 注意，方法中的局部变量是一个引用类型，引用本身在栈的局部变量表中，对象本身在堆中。 Volatile1. 可见性 2. 禁止了指令重排序 可见性是因为将线程中对变量的每次修改都写入了主内存，同时每次线程读取的时候，将工作线程的变量值设为无效（通过内存屏障），强制从主存中再去读取。 其实就在加了一个lock指令，这个指令的意思是本CPU的Cache写入内存，但是该写入动作也会引起别的CPU或者别的内核无效化其Cache。 指令重排序说的是，CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理。 重排序 在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。从硬件架构上来说，指令重排序是指CPU采用了允许将多条指令不按照程序规定的顺序，分开发送给各个相应电路单元处理，而不是指令任意重排。 1. 编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。 2. 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。 3. 内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。 before-happen线程安全的实现方法互斥同步同步说的是多个线程并发访问共享数据时，共享数据同一时刻只能被一个线程使用。而互斥说的是实现同步的方法（临界区，互斥量，信号量）。 因为互斥，所以同步！！！ synchronized与ReentrantLock 非阻塞同步其实前面的互斥同步就是一种悲观锁，它认为每次操作都会遇到错误（共享数据争用），所以每次操作都是加锁的，而非阻塞同步说的是乐观锁，也就是说它认为每次操作都是ok的，当遇到问题（共享数据由争用）的时候，再利用CAS进行失败重试。 为什么要非阻塞同步？还不是因为互斥同步的时候，每次线程的唤醒和阻塞都需要将CPU进入管态（内核态）来处理！！！ CAS有3个操作数，内存位置V，旧的预期值A，新的预期值B。CAS指令执行时，当且仅当V符合预期值A时，处理器就用B更新V值，否则不更新。但是不管更新没有都返回V的旧值。 CAS是个原子操作！！！ 无同步方案1. 可重入代码 2. 线程本地存储 ThreadLocal，线程本地存储，线程隔离，每个线程Thread对象中有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V，ThreadLocal就是这个Map的访问入口。 锁优化自旋锁为了解决有些线程其实只需要等很短时间可能就能拿到锁，这个时候，就别让这些锁再阻塞唤醒了，就让它也执行着，不过是执行的一个忙循环，也就是自旋！！！ 偏向锁为了消除数据在无竞争情况下使得同步原语，进一步提高程序的运行性能。 偏向锁是说这个锁会偏向于第一个获得它的线程，如果接下来的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础知识点总结]]></title>
    <url>%2F2018%2F04%2F10%2F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[基础知识点总结 基本概念http://bbblemon.top/2017/12/06/Java%E9%9D%A2%E8%AF%95%EF%BC%88%E6%9D%82%EF%BC%89/ http://bbblemon.top/2017/12/13/Java%E9%9D%A2%E8%AF%95%EF%BC%88%E6%9D%82-2%EF%BC%89/ http://bbblemon.top/2017/12/14/Java%E9%9D%A2%E8%AF%95%EF%BC%88200-Questions%EF%BC%89/ http://bbblemon.top/2018/01/18/Java%E9%9D%A2%E8%AF%95%EF%BC%88JavaWeb%EF%BC%89/ http://bbblemon.top/2017/12/25/Java%E5%88%B7%E9%A2%98%EF%BC%88%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98%EF%BC%89/ http://bbblemon.top/2017/12/11/Java%E9%9D%A2%E8%AF%95%EF%BC%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E5%9F%BA%E7%A1%80%EF%BC%89/ 三个基本特性1. 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被子类（派生类）。继承可以传递。 2. 封装：把数据和操作数据的方法绑定起来，点对数据的访问只能通过已定义的接口。封装就是为了隐藏一切可以隐藏的东西，只向外界提供最简单的编程接口。 3. 多态:父类引用指向子类实例。 六原则一法则1. 单一职责:一个类只做它该做的事情（高内聚）。 2. 开放封闭：软件实体应当对外扩展开放，对修改关闭。 1. 抽象，一个系统中如果没有抽象类或者接口，整个系统就没有扩展点。 2. 封装可变，将系统中的各种可变因素封装到一个继承结构中。 3. 里氏替换：任何时候都可以使用子类型替换父类型。 4. 依赖倒置：面向接口编程。 5. 合成聚和复用：优先使用聚合和合成关系复用代码。 6. 接口隔离:接口小而专，不能大而全 1. 迪米特法则：一个对象应该对其他对象有尽可能少的了解。 平台无关性Java的平台无关性是因为JVM有很多种，但是不同的JVM都可以解释同一种字节码(.class)文件，所以成就了Java的平台无关性。 javac和java1. javac是编译命令，将.java源文件编译成.class字节码文件。例如，javac hello.java--&gt;hello.class。 2. java是运行字节码文件，利用JVM对字节码进行解释和运行。例如:java hello（注意一样，后面不写.class） String[] argsString[] args，是为了方便将外面的数据引入到main方法里。 （https://blog.csdn.net/lin434406218/article/details/52612064） public static void main(String[] args){}1. public和static可以互换位置 2. main(String[] args)可以被定义位final 3. 可以使用synchronized来修饰main(String[] args) 执行顺序1. 父类静态（类）变量，父类静态块。 2. 子类静态（类）变量，子类静态块。 3. 父类非静态（成员）变量，父类构造块，父类构造器。 4. 子类非静态（成员）变量，子类构造块，子类构造器。 5. 成员变量、构造块、构造器也就是只有在new这个关键字出现后才会调用，也就是说必须要有实例对象被创建的时候才会调用。如果只是声明，不会静态块也不会调用。 6. 声明永远不调用资源！！！（包括静态块） 7. 静态资源只有在类被使用加载的时候才会被调用一次，但是成员资源却是每次新的实例被生成的时候就会被调用。 （http://bbblemon.top/2018/03/31/Java%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/） （http://bbblemon.top/2018/03/25/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/） （http://bbblemon.top/2017/10/10/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/） this/super/this()/super()1. this/super只能用在非静态环境下。 2. this()和super()只能用在构造器中，就是为了调用父类或者自己别的构造器。 3. this()和super()都必须在构造器的第一行使用，也就是说这两个在一个构造器中只能出现一个。 3. this指的是对象实例，也就是new的是谁，this就代指谁！！!这一点在多态中很容易迷糊。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * @author Blemon */public class Test &#123; public static void main(String[] args)&#123; A a = new B(); System.out.println(a.value); System.out.println(a.getValue()); //静态A--&gt;静态B--&gt;构造A--&gt;A的构造器--&gt;setValue(v)--&gt;value = 10--&gt;10 //（这里就是调用了setValue()但是这个方法在子类中重写了,那么在父类中如果不用super.setValue()，那么自动是this.setValue(), //而这个this，也就是我们说的new了谁，那么new了B，就调用B的东西。可是如果子类没有重写，那么子类就会往上找，从而调到父类的方法）。 //执行到这里，A的的构造器执行完了（为什么？因为其实每次最先进去的是子类的构造器，但是无奈子类的第一行默认是super(),除非改了这个，不然永远是先进入父类） //B的构造器开始执行 //--&gt;B的构造器--&gt;setValue(getValue()-3); //getValue()子类没有，往上找，--&gt;value++ --&gt; value = 11; --&gt;return 11(try..catch..finally的缓存机制) //--&gt;this.setValue(value); --&gt; super.setValue(value*2); --&gt;value = 22; --&gt; 打印22 --&gt;getValue()-3=11-3=8 //setValue(getValue()-3);--&gt;setValue(8);--&gt;super.setValue(8*2);--&gt;value=16 //System.out.println(a.getValue()); //a.getValue()--&gt;value++ --value = 17 --&gt; return 17(try..catch..finally的缓存机制) //this.setValue(value); --&gt; super.setValue(value*2); --&gt;value=34 //System.out.println(value); --&gt;34 //System.out.println(a.getValue()); --&gt;17 //静态A--&gt;静态B--&gt;构造A--&gt;A的构造器--&gt;10--&gt;构造B--&gt;B的构造器--&gt;22--&gt;16--&gt;34--&gt;17 &#125; static class A&#123; protected int value; public A(int v)&#123; System.out.println("A的构造器"); setValue(v); System.out.println(value); &#125; static&#123; System.out.println("静态A"); &#125; &#123; System.out.println("构造A"); &#125; public void setValue(int value)&#123; this.value = value; &#125; public int getValue()&#123; try&#123; value++; return value; &#125;finally&#123; this.setValue(value); System.out.println(value); &#125; &#125; &#125; static class B extends A&#123; static&#123; System.out.println("静态B"); &#125; &#123; System.out.println("构造B"); &#125; public B()&#123; super(5); System.out.println("B的构造器"); setValue(getValue()-3); &#125; public void setValue(int value)&#123; super.setValue(value*2); &#125; public void fun()&#123;//a是点不出来这个方法的 &#125; &#125;&#125;/** 静态A 静态B 构造A A的构造器 10 构造B B的构造器 22 16 34 17*/ 多态的实现原理补一个专题 https://blog.csdn.net/sinat_34311901/article/details/52208124 https://blog.csdn.net/huangrunqing/article/details/51996424 重写和重载http://bbblemon.top/2017/10/11/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89/ http://bbblemon.top/2017/12/04/Java%E9%9D%A2%E8%AF%95%EF%BC%88%E5%87%A0%E4%B8%AA%E6%AF%94%E8%BE%83%EF%BC%89/ 1. 重载是编译时多态的体现，重写时运行时多态的体现 2. 重载是在同一个类中，重写是在子父类中 3. 重载的判断只有方法名一致，形参列表不同，其他的包括返回值，访问修饰符都不能用作判断重载的条件 4. 重写的判断有个原则：两同两小一大 1. 方法名和形参列表一致 2. 返回值和抛出的异常小于被重写的方法 3. 访问修饰符大于被重写的方法 5. 注意一下，一个类实现一个接口，就是重写那个接口的方法，不过是接口中的方法默认是public abstract的，但是jdk1.8以后，接口中可以开始定义静态方法和default的方法，但是必须要有方法体，也就是{}!!! 6. 一旦父类的返回值是一个基本数据类型，那么子类的返回值必须一致！！不然编译不通过，编译器无法区分这两个方法（方法名一样）。 修饰符1. 访问修饰符：public、protected、default、private。 1. protected和private不能修饰外部类和接口 2. 不可修饰局部变量 2. static 1. 不可修饰局部变量，不可修饰外部类和接口。 2. 被static修饰的东西在方法区中！！！属于这个类的资源，不属于某一个实例。 3. 为某特定的数据类型和对象分配单一的存储空间，而与创建对象的个数无关。 4. 实现某个方法或者属性，直接与类进行绑定，而不是对象。 5. 静态块，只有在类被记载的时候执行一次。 3. final 1. 类不可继承，方法不可重写，变量的引用（地址）不可变（引用指向那个地址的内容是可以改变的） 2. 被final修饰的成员变量和类变量必须在声明的时候就初始化，但是被final修饰的局部变量可以先不初始化。 4. abstract 1. 不可与final、static、private合用 2. 只修饰方法和类、接口 3. 修饰方法，方法必须以;结尾，不可有方法体。 4. 有abstract方法的类必须是抽象类 5. transient 1. 反序列（Seriziable） 6. volatile 1. 可见性 2. 非原子性 3. 防重排 7. synchronized/lock 关键字http://bbblemon.top/2018/03/25/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/ 1. 标识符只能由字母，数字，&amp;，_,组成，第一个字符不能是数字。 2. break，跳出当前所在循环（如果是多次循环，只跳出一层），continue，结束当次循环，continue后面的语句不再执行，直接进入下一次循环。 3. break利用循环外的标识符来跳出多次循环！！！ 4. instanceof：对象 instanceof 类名 返回true/false，就是用来判断左边这个对象是不是后面这个类的一个实例。注意，如果对象时null，那么也会返回false。 一个Java文件定义多个类一个Java文件中可以有多个类，但是只能有一个类被public修饰，同时这个public类必须和我们的文件名一致，但是如果这个.java文件中没有public类，那么这个类叫什么并不重要。 有几个class就回生成几个.class文件（这里需要注意一下，内部类生成后的表现方式 Outter$Inner.class） 构造器1. 构造器只能被访问修饰符修饰 2. 必须和类名一致。（不是所有的类都有构造器的，匿名内部类） 3. 构造器没有返回值。 4. 编译器在程序员不写构造器的时候会生成一个无参的，但是一旦写了构造器，那么默认的这个无参构造器就没了，一旦父类没有无参构造，子类就必须在自己构造器的第一行显示的调用父类的某个构造器。 5. 构造器就是为了完成对象的初始化。 6. 构造器无法被继承。 7. 默认构造器的访问修饰符，只和类的访问修饰符一致。 8. 构造器可以重载。 接口和抽象类http://bbblemon.top/2017/10/11/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89/ 1. 接口和抽象类都不可以实例化 2. 接口的实现类和抽象类的子类都只有在重写了其所有的抽象方法以后，才可以被实例化。 3. 可以多实现，但是不可以多继承。 4. JDK1.7以前，接口中只能有声明，不能有方法实现，变量都必须是public static final的，方法都只能是public abstract的，但是1.8以后，接口中也可以有方法实现，有被static和defalut修饰的方法，这两个修饰的方法必须有方法体！！！ 5. 1.7 以前接口中可不能有main方法，但是抽象类中可以有。 6. 接口中方法不能被private和protected修饰！！！ 7. 1.8以后的方法可以被abstract、default、static修饰。三个不可以共用！！！ 8. 标识接口：Clonable、Serializable 1234567891011121314151617181920public interface AInter &#123; public static final String SS = null; public String tt = "";//默认了 public static void main(String[] args)&#123; System.out.println("ss"); &#125; void fun(); public abstract void s(); default void dd()&#123; System.out.println("..."); &#125; static void tt()&#123; System.out.println("..."); &#125;&#125; Clone()System.arraycopy()&gt;Object.clone()&gt;Arrays.copy()&gt;for 浅复制与深复制 反射机制Class.forName(&quot;类的路径&quot;); 类名.Class 实例.getClass(). http://bbblemon.top/2017/10/11/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89/ Java创建对象的四种方式： 1. new 2. 反射 3. 反序列话 4. clone() 内部类1. 静态内部类、成员内部类、局部内部类，匿名内部类。 2. 静态内部类，当成是一个静态方法，不能访问外部类中非静态的成员和方法。但是本身内部可以定义非静态的东西。 3. 成员内部类，当成是成员方法，但是成员方法是可以直接调用静态方法的，这个调用关系是由加载顺序决定的。但是成员内部类中，因为只有外部类被实例化以后，这个类才能被实例化，所以它虽然可以像成员方法一样使用外部类的所有资源，但是本身内部却不可以定义静态资源！！！ 4. 局部内部类，当成是局部变量，也就是说这个类不能被访问修饰符修饰，也不能被static修饰，同时只能访问在方法中定义的final变量。 5. 匿名内部类，没有类名的内部类，这个类很特殊，不能使用关键字class，extends，implements，没有构造器，必须继承其他类或者实现其他接口。 正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。 1. 没有构造器 2. 不能定义静态资源（类，方法，变量） 3. 不能被访问修饰符和static修饰 4. 只能创建匿名内部类的一个实例。 5. 一个匿名内部类一定是在new的后面，这个匿名内部类必须继承一个父类或者实现一个接口。 6. 属于局部内部类。 https://www.cnblogs.com/hasse/p/5020519.html http://bbblemon.top/2017/10/12/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89/ this/super/this()/super()http://bbblemon.top/2018/03/31/Java%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/ final/finally/finalize1. final 1. 属性/变量：指向不可变，但是指向地址中的内容可以变。 2. 方法：不可重写 3. 类：不可继承。（实现CharSquenece接口的String、StringBuilder、StringBuffer、Math、基本数据类型包装类，这些类都继承子Number，ClassLoader可以被继承，System，Void，Class&lt;T&gt;） 4. 内联（inline）:调用一个声明位final的方法时，将方法主体插入到调用处，而不是方法调用，这样可以提高程序的效率。 2. finally 1. 只要不是System.exit(0)和在进入try块前出现异常，finally块一定会执行。 2. finally中对变量的修改也是分为值传递和引用传递的。同时注意引用传递的时候那个重点。 3. finally中一旦存在的return，一定会覆盖在try和catch中的return语句。 3. finalize 1. 这是个Object方法，当一个对象通过可达性分析到不了GC Roots，那么这个对象就面临被GC，被第一次标记。当GCor开始准备释放这个对象占用的内存时，会先在判断这个对象是否可以调用其finalize方法，如果这个对象重写了Object的这个方法并在方法内实现了重新被引用，同时finalize是被第一次调用，那么对象就会被放入F-Queue，并免于被回收，但是一旦没有重写，或者虽然重写了但是这个是第二次被调用，那么直接就被标记第二次，在下一次GC的时候，直接回收。 初始值1. 对象的初始值都是null，基本数据类型的各不相同 2. 数组中的初始化是看数组本身放的是什么 3. 只有成员变量和类变量才有默认的初始值，局部变量是没有这个东西的。 SwitchSwicth语句中的多用于分支选择，在使用Switch（exp）的时候，这个exp只能是byte、short/char、int以及对应的包装类，但是在JDK1.7之后，这个里面可以写String了。 同时case后面的可以是常量数值，也可以是常量计算式，还可以是final修饰的变量（final变量在编译时的常量），但是不能时有变量的东西。 为什么Switch开始支持了String? 本质上说，swicth对String的支持，其实就是对int的匹配。因为是通过对case后面的对象调用了hashCode()方法，得到了一个int类型的hash值，然后用这个hash值来唯一标识这个case。当exp中的String调用hashCode方法得到的hash值可以与case匹配时，那么直接调用exp的equals方法进行二次匹配。 为什么需要二次匹配，这个就不用说了，hashCode和equals方法的联系。 注意: 1. Swicth语句，最好在每一个case的后面写一个break，一旦没有，那么swicth就会从入口，一直执行下去，直到结束或者遇到break。 2. defalult也是一样的，当没有case被匹配的时候，就走这个了。 值传递与引用传递http://bbblemon.top/2018/03/31/Java%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/ 1. 基本数据类型的传递都是值传递，就是把实参的值复制了一份给了形参。 2. 引用传递，就是把对象的地址复制了一份给了形参。让形参一开始的时候也指向和实参一样的地址。但是当形参的指向地址改变后，对形参的任何操作也就不会再影响到我们实参指向的地址，这一点再try..catch..finally中也很常见。 3. 也就是说值传递不能改变实参的任何，引用传递可以改变实参的内容，但是不能改变实参指向的地址。 equals、hashCode、==其实要说明白equals和==的区别很简单，==号永远比较的是两个栈中的变量是否指向了同一个堆中的地址。 而equals方法，很简单，这个是个Object类的方法，直接去看Object中的源码，就会发现，其实这个方法本身和==没有任何区别，只不过是因为我们很多类中，我们比较的并不是比较两个引用是否指向了同一个地址，而是比较两个地址中的内容是否一致，这个时候因为Object是所有类的父类，其他类都可以重写这个方法，从而完成比较。 但是对于使用到hash算法的一些类而言，比如HashMap，Hashtable，HashSet等等，由于类本部本身的构造，需要利用对象的hash值和hash表的长度来确定对象在表中的角标，尤其是HashMap中那种数组+链表转红黑树的结构，第一步就是利用hash值和table长度来计算的元素初始位置。 hashCode方法也是在Object方法中的，如果不重写这个方法，Object类中hashCode方法返回的是对象在内存中的地址转换成的一个int值，所以任何对象的hashCode()都不会相同的。 其实equals方法，和hashCode方法其实都是用来比较对象是否一致的，但是为什么总是一起重写呢。 这其实就是为了涉及hash算法的类中的一个要求，比如说HashMap，如果每次都是调用equals方法去遍历hash表比较，效率会特别慢，所以也就有了这种数组+链表转红黑树的结构，利用key的hashCode快速定位对象在表中地址，然后利用equals方法进行链上对象的比较，很快。 注意一下，上面之所有计算的对象会出现hashCode值一样，是因为重写了hashCode这个方法，才出现了hash冲突！！！不然是不可能出现hash中途的。 1. equals一致，hashCode一致。 2. hashCode一致，equals不一定一致。 i++与++i这个其实就是Java的一个中间缓存机制。 i++，先运算，后自加 ++i，先自加，后运算 泛型通配符http://bbblemon.top/2018/03/31/Java%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/ 泛型只是在编译的时候保证了类型，但是在运行时，是不存在这个东西的。 1. ?:任意类型，如果没有明确，那么就是Object以及任意的Java类了。 2. ? extends E:向下限定，E及其子类 3. ? super E:向上限定，E及其父类 注意：泛型就是里面的东西如果是点对点 就算是继承关系也不行！！！List&lt;Object&gt;就是Object对象，不能是Object的其他子类！！！ round、ceil、floor、DecimalFormat、BigInteger1. round、ceil、floor都是在Math下的静态方法。 2. round，当前值+0.5向下取整。 3. ceil，向上取整。（大于等于） 4. floor，向下取整。（小于等于） 5. DecimalFormat(&quot;0.0&quot;)，用来限定位数的：df.format(double);java.text.*; 6. BigInteger(String s)，没有无参构造。 b1.add(b2);用于超大数相加：java.math.*; 7. round方法返回是int和long，但是ceil和floor返回的是double，所以ceil和floor在0.0这个点，会保留原始的负号，但是round不会。 123456789public class Outer&#123; public static void main(String[] args) &#123; System.out.println(Math.ceil(-0.1));//-0.0 System.out.println(Math.floor(0.1));//0.0 System.out.println(Math.floor(-0.0));//-0.0 System.out.println(Math.floor(0.0));//0.0 System.out.println(Math.round(-0.1));//0 &#125;&#125; Volatile补一个专题 https://www.cnblogs.com/chenssy/p/6379280.html http://www.importnew.com/27863.html http://www.importnew.com/17394.html http://www.importnew.com/19745.html 1. 没有保证原子性。加锁和synchronized保证了原子性 2. 可见性 当一个变量被volatile修饰后，表示线程本地内存无效，当一个线程修改了共享变量后，他会立刻被更新到主存，当其他线程读取共享变量时，它会直接从主存中读取。 synchronized和lock也都保证了可见性。 3. 有序性（禁止指令重排序） 在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序它不会影响单线程的运行结果，但是对多线程会有影响。 Java提供volatile来保证一定的有序性。最著名的例子就是单例模式里面的DCL（双重检查锁） 核心API基本数据类型和其包装类http://bbblemon.top/2018/03/31/Java%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/ 1. byte--&gt;short/char--&gt;int--&gt;long--&gt;float--&gt;double 2. 1--&gt;2/2--&gt;4--&gt;8--&gt;4--&gt;8 3. char类型是一个单一的 16 位 Unicode 字符；最小值是 \u0000（即为0）最大值是 \uffff（即为65,535） 4. 基本数据类型和包装类使用==号比较的时候，会自动向上转型，同时变成值的比较。 5. 包装类的赋值，都是ValueOf进行了装箱。 6. 包装类的赋值，不存在自动向上转型。 7. 基本类型的==，存在向上转型。 8. int以下的short和byte、char进行+=/*运算的时候会自动上升为int型，所有如果还想回到原来的类型，必须强转。但是+=，-=，*=,/=的时候，不需要强转，自己会转换。 short s = 1;s=s+1（报错） s=(short)s+1 / s+=1（正确） 9. 因为Integer中cache数组的存在，Integer的赋值，在-128到127之间不会装箱，也就是不会生成新的对象。 10. 基本数据类型的包装类都是不可变类。 11. 包装类的equals方法均不提供类型转换。 12. 小数的默认类型是double，如果直接写float = 0.0，编译报错 13. &apos;a&apos;是97，&apos;A&apos;是65 14. 基本数据类型也属于Object，Object o = 2；正确。 15. boolean不能和其他的7个基本数据类型转换 1234567891011121314151617181920212223242526272829303132public class Main&#123; public static void main(String[] args) &#123; int i = 0; Integer I = 0; long l = 0; Long L = 0l; Double D = 0d;//这个d不可省略 double d = 0; System.out.println(i==I);//true System.out.println(d==D);//true System.out.println(i==d);//true System.out.println(D==i);//true Integer m = 127; Integer n = 127; Integer m_2 = 128; Integer n_2 = 128; Integer m_3 = -128; Integer n_3 = -128; Integer m_4 = -129; Integer n_4 = -129; System.out.println(m==n);//true System.out.println(m_2==n_2);//false System.out.println(m_3==n_3);//true System.out.println(m_4==n_4);//false &#125;&#125; 1234567891011121314public class Outer&#123; public static void main(String[] args) &#123; int i = 0; Integer I = 0; long l = 0; Long L = 0l; Double D = 0d;//这个d不可省略 double d = 0; System.out.println(D.equals(d));//true System.out.println(D.equals(l));//false，但是D==l返回true //System.out.println(I==L);不同类型的包装类直接==会编译错误 System.out.println(I.equals(L));//false &#125;&#125; int和Integer的区别1. 一个是基本数据类型，一个是类。 2. 默认值不一样 3. Integer变量必须实例化后才能使用，int不需要。 4. Integer在[-128,127]这个范围内的数字不进行装箱。 5. Integer是对象，用一个引用指向这个对象，而int是基本类型，直接存储数据。 1234567public static Integer valueOf(int i)&#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123; return IntegerCache.cache[i + (-IntegerCache.low)]; &#125; return new Integer(i);&#125; 强制转换与包装类的equals方法1. 基本数据类型和包装类进行==比较的时候，包装类被拆箱成为基本数据类型以后再比较，这个样子，因为基本数据类型的==存在自动向上转型的原因，所以这种比较也存再转型。 2. 包装类调用equals的时候，会先比较类型，是不是一个类，不是一个类，直接返回false，是一个类再及进行值的比较。 3. 两个Integer==比较，比较的就是物理地址了，这个时候，只要有一方是new出来的，直接返回false，不然利用valueOf进行比较。 4. 包装类调用equals方法，但是传入的是一个基本数据类型，会对基本数据类型先进行装箱，装箱结束后吗，比较类型，类型不一致，直接返回false 123456789101112131415161718192021222324252627package xd.out;public class Outer&#123; public static void main(String[] args) &#123; int a=257; Integer b=257; Integer c=257; Integer d=new Integer(a); Integer d1=new Integer(a); Integer b2=57; Integer c2=57; System.out.println(a==b);//true System.out.println(b==c);//false System.out.println(b2==c2);//true System.out.println(a==d);//true System.out.println(b==d);//false System.out.println(d==d1);//false //System.out.println(a.equals(b)); 编译出错，基本型不能调用equals() System.out.println(b.equals(257.0)); //false System.out.println(b.equals(c)); //true System.out.println(b.equals(a)); //true System.out.println(b.equals(d)); //true &#125;&#125; 运算符优先级http://bbblemon.top/2018/03/31/Java%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/ String、StringBuilder、StringBuffer1. 三个类都是final的 2. 三个类都实现了CharSequenece接口 3. StringBuilder线程不安全，StringBuffer线程安全 4. String是不可变类，但是StringBuffer/StringBuilder可变。 http://bbblemon.top/2018/03/26/Java%E5%9F%BA%E7%A1%80%E7%B1%BBAPI/ http://www.cnblogs.com/jiangwz/p/7171162.html String与Integer，Double，Long的进制转换1. 10进制字符串--&gt;二进制字符串。 int key = Integer.parseInt(s); String bin = Integer.toString(key,2);//.toBinaryString(key) 2. 二进制字符串变成10进制数字 Integer key = Integer.parseInt(s,2); 3. int key = Integer.parseInt(String s,int radix)：这个方法是将一个字符串变成一个10进制的数字。radix是把String看成几进制的串。 4. String s = Integer.toString(Integer i,int radix)：这个方法是把一个10进制的数字变成制定进制的字符串。 String的intern（不好理解）http://bbblemon.top/2018/03/26/Java%E5%9F%BA%E7%A1%80%E7%B1%BBAPI/ https://www.cnblogs.com/Kidezyq/p/8040338.html http://www.cnblogs.com/wxgblogs/p/5635099.html https://blog.csdn.net/qq_38663729/article/details/78056959 之前总结很全面 1. String s = new String(&quot;100&quot;);//会在常量池和堆中都生成100，但是返回堆中地址。 2. String s = new String(&quot;1&quot;)+new String(&quot;00&quot;);//会在常量池产生1，00，堆中产生1，00，100。 3. s.intern只有在常量池中没有的时候，把堆中的s的引用复制一份给池，然后指向池才会改变s的引用地址。如果池中有了，那么调用了这个方法，不会把堆中地址进行复制，同时也就返回的是堆中地址！！！ 4. 因为JDK7中常量池在堆中了而不是在永久代，所以常量池中放的是引用，而不是一个复制的对象本身了。 数组数组是一个对象！！！ http://bbblemon.top/2017/10/12/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89/ 1. Arrays.sort 2. Arrays.asList ---&gt; fast-fail 正则http://bbblemon.top/2018/03/26/Java%E5%9F%BA%E7%A1%80%E7%B1%BBAPI/ https://blog.csdn.net/qq_38663729/article/details/78056959 异常http://bbblemon.top/2017/10/13/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89/ http://bbblemon.top/2017/12/04/Java%E9%9D%A2%E8%AF%95%EF%BC%88%E5%BC%82%E5%B8%B8%E6%A1%86%E6%9E%B6%EF%BC%89/ 架构http://bbblemon.top/2018/04/02/%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/ Throwable接口有两个实现，Error和Exception，Exception由分为CheckedException和RuntimeException。 1. Error是在运行时发生的错误，改错误不可恢复，由于这属于JVM级别的错误。因此这种错误会导致程序终止执行。此外，编译器不会检查Error 2. CheckedException是编译时一定要处理的异常，主要就是IO异常和SQL异常。 3. RuntimeException是运行时异常，编译器没有强制对其进行捕捉。 throw和throws1. throws在使用时应处于方法签名之后使用。可以抛出多种异常并用英文字符&quot;,&quot;隔开。 2. 一旦时checkedException，要么时try..catch..finally，要么时再次throws交给上一层。 3. 子类抛出的异常种类小于等于父类。 4. throw抛出的是一个对象。 5. 使用throws关键字声明的方法表示此方法不处理异常，而交给方法调用处进行处理。 6. throw关键字作用是抛出一个异常，抛出的时候是抛出的是一个异常类的实例化对象 7. throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常。 8. throw以后，要么本类要处理，要么往调用处抛出 12345678910111213141516171819使用throws关键字声明的方法表示此方法不处理异常，而交给方法调用处进行处理。class Math&#123; public int div(int i,int j) throws Exception&#123; // 定义除法操作，如果有异常，则交给被调用处处理 int temp = i / j ; // 计算，但是此处有可能出现异常 return temp ; &#125;&#125;;public class ThrowsDemo01&#123; public static void main(String args[])&#123; Math m = new Math() ; // 实例化Math类对象 try&#123; System.out.println("除法操作：" + m.div(10,2)) ; &#125;catch(Exception e)&#123; e.printStackTrace() ; // 打印异常 &#125; &#125;&#125;; 123456789101112131415161718192021222324如果在主方法的声明也使用了throws关键字呢，那么是不是意味着主方法也可以不处理异常。在本程序中，主方法不处理任何异常，而交给JAVA中最大头JVM，所以如果在主方法使用了throws关键字，则表示一切异常交给JVM进行处理。默认处理方式也是JVM完成。class Math&#123; public int div(int i,int j) throws Exception&#123; // 定义除法操作，如果有异常，则交给被调用处处理 int temp = i / j ; // 计算，但是此处有可能出现异常 return temp ; &#125;&#125;;public class ThrowsDemo02&#123; // 在主方法中的所有异常都可以不使用try...catch进行处理 public static void main(String args[]) throws Exception&#123; Math m = new Math() ; // 实例化Math类对象 System.out.println("除法操作：" + m.div(10,0)) ; &#125;&#125;;运行结果：Exception in thread "main" java.lang.ArithmeticException: / by zero at methoud.Math.div(ThisDemo06.java:4) at methoud.ThisDemo06.main(ThisDemo06.java:12) 12345678910111213141516 public static void fun() throws Exception&#123;// try &#123;// throw new Exception("Demo");// &#125; catch (Exception e) &#123;// System.out.println("...");// &#125; throw new Exception("Demo"); &#125; public static void main(String[] args) &#123; try &#123; fun(); &#125; catch (Exception e) &#123; System.out.println("有异常"); &#125; &#125; try..catch..finallyhttp://bbblemon.top/2018/04/02/%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/ 1. try..catch,try..finally,try..catch..finally 2. 如果在try和catch中有return而finally中没有，finally一定是在return前执行。 1. 如果返回的变量是基本数据类型，finally中对变量的修改就和值传递一样，对返回值无影响。 2. 如果返回的变量是引用，finally中对引用地址内容的修改会影响到返回值，但是直接改变了引用的对象，不会影响原来的返回值。（引用传递的特殊性） 3. 如果finally中存在return语句，finally中的return总会覆盖前面的return 4. 一旦异常处理了，那么异常处理后方法中的语句还是会顺序执行。 finally什么时候不执行1. 进去try块前就出现异常 2. 进入finally之前，出现了System.exit(0) IO分类http://bbblemon.top/2018/03/26/Java%E5%9F%BA%E7%A1%80%E7%B1%BBAPI/ 序列化/外部序列化与反序列化（针对对象）Java提供了两种对象持久化的方式，分别是序列化和外部序列化。 序列化，将一个对象以一连串的字符描述的过程，用于解决对象流进行读写操作时所引发的问题。 序列化，可以将对象的状态写在流里进行网络传输，或者保存到文件、数据库等系统里，并在需要的时候把流读取出来重新构造一个相同的对象。 1. 什么时候需要使用序列化 1. 需要通过网络来发送对象，或者对象的状态需要被持久化到数据库或者文件中。（Java远程方法调用RMI/对JavaBeans进行序列化） 2. 序列化能实现深复制，即可以复制引用的对象。 2. 什么是序列化，外部序列化 1. 序列化就是为了让对象在网络传输的过程中比较方便，同时解决对象流进行读写时所引发的问题。把一个对象的状态变成字节序列（写入流）进行传输，需要使用的时候再通过序列ID进行反序列化得到对象。 2. 外部序列化和序列化主要的区别就是序列化是内置的API，只需要实现Serializable接口，而外部序列化（Externalizable）接口中的读写方法必须由开发人员来实现。 3. 如何实现序列化 1. 实现Serializable接口 1. 该接口只是一个可序列化的标志，并没有包含实际的属性和方法。 2. 如果不在实现序列化接口的类中添加readObject()和writeObject()方法，则采用默认的序列化机制。如果添加了，还想用默认的序列化机制，则在这两个方法中调用defaultReadObject()/defaultWriteObject() 2. 实现ExternalSerializable 1. 自己需要对序列化的内容进行控制 4. 如何控制序列化的时候只序列化部分属性 1. 实现ExternalSerializable 2. 对不需要序列化的属性使用transient修饰 5. serialVersionID是干什么的 1. 和序列化对应的就是反序列化，这个转换的过程中，serialVersionID起着很重要的作用，每个类都有一个特定的serialVersionID，在反序列化的时候，通过serialVersionID来判定类的兼容性，如果待序列化的对象与目标对象的serialVersionID不同，那么反序列化的时候会抛出InvalidClassException异常。 2. 序列化的类中必须显式的定义serialVersionID（static final），如果不写，序列化的时候会默认计算一个，但是计算的这个在不同OS中的编译器序列化和反序列的算法不同，导致一个OS中序列化的对象，无法在另一个OS中反序列化。 6. 什么是反序列化 1. 将流变成了对象 2. 实现Serializable接口的对象在反序列化的时候不需要对象所在类的构造方法，完全基于字节。 3. 实现Externalizable接口的对象在反序列化的时候会调用构造方法。 7. 序列化的特点 1. 对象的类名、属性都会被序列化，方法不会被序列化 2. 被static和transient修饰的属性不可序列化 3. 一个类能被序列化，那么这个类的子类也可以 4. serialVersionID必须显式定义。 5. 反序列化时必须要有序列化对象时的字节码(.class)文件。 1234567891011121314151617public class Main implements Serializable&#123; private static int i; private String word; public void setI(int value)&#123; this.i = value; &#125; public void setWord(String value)&#123; this.word = value; &#125;&#125;Main m = new Mainm.setI(22);m.setWord("ss");m对象序列化另一个JVM中反序列化m.i = 0//static修饰没有被序列化，但是属性还是存在的，默认是0m.word = "ss"//序列化了 Socket（重点，后面复习计算机网络的时候细看）Socket是进制通讯的一种方式，也就是调用这个网络库的一些API实现分布在不同主机的相关进程之间的数据交换。 1. IP：依照TCP/IP协议分配给本地主机的网络地址。两个进程需要通讯，任一进程必须要知道对方的位置。 2. Port：用来辨识本地通讯地址，一个本地的进程在通讯的时候都会占用一个端口号，不同的进程端口号不同 3. 连接：两个进程间的通讯链路 4. 半相关：网络中用一个三元组（协议，本地地址，本地端口）可以在全局唯一的标识一个进程。 5. 全相关：一个完整的网间进程通信需要由两个进程组成，并且只能使用同一种高层协议。也就是说，不可能通信的一端用TCP协议，而另一端用UDP协议。因此一个完整的网间通信需要一个五元组来标识： （协议，本地地址，本地端口号，远地地址，远地端口号） C/S架构：客户端向服务端发出服务请求，服务器接收到请求后，提供相应的服务。 1. 首先，建立网络的起因是网络中软硬件资源、运算能力和信息不均等，需要共享，从而造就拥有众多资源的主机提供服务，资源较少的客户请求服务这一非对等作用 2. 其次，网间进程通信完全是异步的，相互通信的进程间既不存在父子关系，又不共享内存缓冲区，因此需要一种机制为希望通信的进程间建立联系，为二者的数据交换提供同步，这就是基于客户/服务器模式的TCP/IP。 服务端： 1. 打开通信通道并告知本地主机，改进程愿意在某一个端口上接收可恶请求。（FTP 21 Nginx 80） 2. 等待客户端到达该端口 3. 接收到客户端的请求，出清请求并发送应答信息。接收到并发服务请求时，要激活一新进程来处理这个客户请求（UNIX fork，exec）。 4. 返回2 5. 关闭服务器 客户端： 1. 打开通信通道，并连接到服务器所在主机的特定端口 2. 向服务器发服务请求报文，等待并接收应答；继续提出请求 3. 请求结束手关闭通信通道。 就是两个进程，跨计算机，他俩需要通讯的话，需要通过网络对接起来。这就是 socket 的作用。 打个比方吧，两个进程在两个计算机上，需要有一个进程做被动方，叫做服务器。 另一个做主动方，叫做客户端。他们位于某个计算机上，叫做主机 host ，在网络上有自己的 ip 地址。 一个计算机上可以有多个进程作为服务器，但是 ip 每个机器只有一个，所以通过不同的 port 数字加以区分。 因此，服务器程序需要绑定在本机的某个端口号上。客户端需要声明自己连接哪个地址的那个端口。 两个进程通过网络建立起通讯渠道，然后就可以通过 recv send 来收发一些信息，完成通讯。 所以 socket 就是指代承载这种通讯的系统资源的标识。 https://www.cnblogs.com/yiwangzhibujian/p/7107785.html 123456789101112131415161718192021222324252627/** * @ClassName Server * @Description * @Author Blemon * @Date 2018年4月10日 下午4:58:38 */public class Server&#123; public static void main(String[] args)&#123; try &#123; int port = 55533;//指定端口 ServerSocket server = new ServerSocket(port); Socket client = null; int count = 0; System.out.println("***服务器即将启动，等待客户端的连接***"); while(true)&#123; client = server.accept();//建立连接 Thread serverThread = new Thread(new ServerThread(client));//开启线程 serverThread.start(); System.out.println("服务器端被连接过的次数："+count++); System.out.println("当前客户端的IP为："+client.getInetAddress().getHostAddress()); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738/** * @ClassName ServerThread * @Description * @Author Blemon * @Date 2018年4月10日 下午4:59:27 */public class ServerThread implements Runnable&#123; Socket socket = null; //本线程相关的Socket public ServerThread(Socket socket)&#123; this.socket = socket; &#125; @Override public void run() &#123; try &#123; InputStream input = socket.getInputStream();//得到输入流，建立byte缓冲区 byte[] buffers = new byte[1024]; int len = -1; StringBuffer sb = new StringBuffer(); //拿到数据 while ((len = input.read(buffers)) != -1)&#123; sb.append(new String(buffers,0,len,"UTF-8")); &#125; System.out.println(sb); System.out.println("------------------------------"); socket.shutdownInput();//关闭输入流 OutputStream output = socket.getOutputStream();//输出 output.write("received success".getBytes("UTF-8")); input.close(); output.close(); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334/** * @ClassName Client * @Description * @Author Blemon * @Date 2018年4月10日 下午5:00:01 */public class Client &#123; public static void main(String[] args) &#123; try &#123; String host = "103.46.128.47";//127.0.0.1 int port = 19816;//55533 Socket socket = new Socket(host,port);//指定主机和端口 OutputStream output = socket.getOutputStream(); String s = socket.getInetAddress().getHostAddress()+":send message"; output.write(s.getBytes("UTF-8")); socket.shutdownOutput();//可以适当的关闭一下输出流,也就是告知服务端我们的数据发送完毕了 InputStream input = socket.getInputStream();//开启输入流接收数据 byte[] buffers = new byte[1024]; int len = -1; StringBuffer sb = new StringBuffer();//拿到数据 while ((len = input.read(buffers)) != -1)&#123; sb.append(new String(buffers,0,len,"UTF-8")); &#125; System.out.println(sb); input.close(); output.close(); socket.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; NIOhttp://ifeve.com/java-nio-all/ NIO（Nonblocking IO）出现前，Java是通过传统的Socket来实现基本的网络通信功能的。 但是Socket编程的时候，就会出现阻塞。当要处理多个连接时，就需要采用多线程的方式，由于每个线程有拥有自己的栈空间，而且由于阻塞会导致大量线程进行上下文切换，使得程序的运行变得异常的缓慢。 NIO的三大组件Selector、Channel、Buffer Selector实现了用一个线程来管理多个通道（采用了复用和解复用的方式使得一个线程能够管理多个通道，即可以把多个流合并成一个流，或者把一个流分成多个流的方式），实现的时候把需要处理的Channel中的IO事件注册给Selector。 Selector对所有注册的Channel进行轮询访问，一旦轮询到一个Channel有注册事件发生，就通过传回Key的方式来通知开发人员对Channel数据进行读写。（Key由SelectionKey类表示，封装一个特定Channel和特定的Selector之间的关系） 这种通过轮询的方式在处理多线程请求时不需要上下文的切换。 1. BIO 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情就会造成不必要的线程开销，当然可以通过线程池机制改善。 2. NIO 同步非阻塞，服务器实现模式为一个请求一个线程，客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。 3. AIO 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。 File类集合框架架构http://bbblemon.top/2017/10/13/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B9%9D%EF%BC%89/ http://bbblemon.top/2017/12/01/Java%E9%9D%A2%E8%AF%95%EF%BC%88%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%89/ Listhttp://bbblemon.top/2017/10/16/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/ http://bbblemon.top/2017/10/16/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/ 1. ArrayList的扩容 1. int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);扩容容量 = 原始容量+原始容量/2 2. 默认初始容量是10 3. 构造器有可以直接设置初始容量的 4. 没有阈值因子，都是elementData[]这个满了以后才扩容。 2. Vector的扩容 1. 默认初始容量是10，扩容和capacityIncrement（增长因子）有关，也是elementData[]存储数据。 1. int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); 2. capacityIncrement默认是0，但是有构造器可以设置，当capacityIncrement是0的时候，扩容容量是原来的2倍，否则比原来大capacityIncrement多。 3. ArrayList与LinkedList有什么区别 1. 两个都是线程不安全的，都实现List接口，继承了AbstractList。 2. ArrayList是动态数组，LinkedList是双向链表 3. ArrayList可以快速随机访问，但是增删慢，因为要移动角标；LinkedList随机访问慢，但是增删快。 4. LinkedList比ArrayList更消耗内存，因为LinkedList中的每个Node都存储了前后节点的引用。 4. ArrayList与Vector有什么区别 1. 前者线程不安全，后者是在前者的基础上每个方式加了synchronized 2. 扩容机制不同，但是默认初始值一致 3. Vector有子类，Stack，也是线程安全的 4. Vector废了，就算是真的需要同步的时候，也用的是JUC下的CopyOnWriteArrayList 5. ArrayList因为没有同步，快。 6. 两个都是动态数组，都支持快速随机访问 7. ArrayList支持序列化，Vector不支持 8. ArrayList不支持Enumeration，Vector支持 5. Array和ArrayList 1. Array可以容纳基本数据类型和对象，但是ArrayList只能放对象 2. Array可以指定大小，而ArrayList大小是规定的，只能扩容或者再构造的时候设定。 ArrayList核心API1. public boolean add(E e) ：一直返回的都是true 2. public void add(int index, E element)：把index位置上的对象往后挪 3. public int indexOf(Object o)：返回当前查询对象的角标，Object是null/对象时，返回再List中第一次出现的值，否则返回-1 4. public boolean contains(Object o)：调用的时indexOf方法 5. public E get(int index)：返回当前对象 6. public E set(int index, E element)：返回被替换前这个index位置上的值。 7. public void clear()：清空集合。 8. public boolean addAll(Collection&lt;? extends E&gt; c) 9. public boolean addAll(int index, Collection&lt;? extends E&gt; c) ：这两个方法的返回值是看我们的c的长度，因为方法内部直接会将c先转成数组， 1. Object[] a = c.toArray();int numNew = a.length;return numNew！=0; 2. ensureCapacityInternal(size + numNew); 3. System.arraycopy(a, 0, elementData, size, numNew); 10. public E remove(int index)：返回的是被移除的旧值 11. public boolean remove(Object o)：当前对象是否在List中，返回是否删除成功，不在的话返回false，删除的是第一次出现的当前对象。 List的遍历与删除1. 遍历也就是简单for，增强for，迭代器 2. 删除的话比较讲究，我们要用index删除的话，必须从后往前删，但是这么做没有意义，那还不如直接调用clear() 3. 有时候会遇到必须要固定删除某一个位置上的，这个时候需要注意，必须每次都重新计算List的长度。 ArrayList与LinkedList与Vectorhttp://bbblemon.top/2017/10/14/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/ http://bbblemon.top/2017/10/13/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%EF%BC%89/ http://bbblemon.top/2017/10/16/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/ asList、subList、toArrayasList1234567891011121314151617181920212223242526272829 @SafeVarargs @SuppressWarnings("varargs") public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a); &#125; /** * @serial include */ private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializableimport java.util.*;public class ArrayListTest&#123; public static void main(String[] args) &#123; Integer arr[] = &#123;1,2,3,4,5,6&#125;; List&lt;Integer&gt; list = Arrays.asList(arr); System.out.println(list); list.set(0, 77); System.out.println(Arrays.toString(arr)); arr[5] = 100; System.out.println(list); &#125;&#125;/** [1, 2, 3, 4, 5, 6] [77, 2, 3, 4, 5, 6] [77, 2, 3, 4, 5, 100]*/ 1. public static &lt;T&gt; List&lt;T&gt; asList(T... a) 1. asList是把一个数组变成了一个集合，但是我们知道集合中的泛型内容可是不能是基本数据类型，所以这个数组中放的必须是对象。 2. asList被调用后，直接得到的ArrayList是一个Arrays中的一个内部类（Arrays$ArrayList），这个内部类并没有实现add与remove方法，所以直接改变这个List的长度，会出现异常。java.lang.UnsupportedOperationException 3. Arrays$ArrayList继承了AbstractList，所以当我们调用add与remove方法时，调用的时AbtractList的，这两个方法在Abstract中都是直接抛出java.lang.UnsupportedOperationException。 4. 其实List&lt;Integer&gt; list = Arrays.asList(arr);就把arr与list连接起来了，其实是把我们数组的引用给了list，所以可以同步查看。（当arr和list改变的时候，另一方不可变，比如set(index,Object)，但是不可改变list的长度） 2. 如何利用这个方法把数组转成正真的List ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(arr)); subList123456789101112131415161718192021222324252627282930313233343536public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex);&#125;private class SubList extends AbstractList&lt;E&gt; implements RandomAccess &#123;import java.util.*;public class ArrayListTest&#123; public static void main(String[] args) &#123; Integer arr[] = &#123;3,4,6,2,332,3,1,43,4324,5,4,12,53,23,432&#125;; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(arr)); List&lt;Integer&gt; sub = list.subList(0, 5); System.out.println(sub); sub.add(100); System.out.println(sub); System.out.println(list); list.add(111); System.out.println(list); //System.out.println(sub); //编译不错，但是运行时会出错 list.subList(0, 5).clear(); System.out.println(list); &#125;&#125;/** [3, 4, 6, 2, 332] [3, 4, 6, 2, 332, 100] [3, 4, 6, 2, 332, 100, 3, 1, 43, 4324, 5, 4, 12, 53, 23, 432] [3, 4, 6, 2, 332, 100, 3, 1, 43, 4324, 5, 4, 12, 53, 23, 432, 111] [100, 3, 1, 43, 4324, 5, 4, 12, 53, 23, 432, 111]*/ 1. public List&lt;E&gt; subList(int fromIndex, int toIndex) 1. 该方法返回的是父list的一个视图，从fromIndex（包含），到toIndex（不包含）。fromIndex=toIndex 表示子list为空. 2. 父子list做的非结构性修改（non-structural changes）都会影响到彼此：所谓的“非结构性修改”，是指不涉及到list的大小改变的修改。相反，结构性修改，指改变了list大小的修改。 3. 对于结构性修改，子list的所有操作都会反映到父list上。但父list的修改将会导致返回的子list失效。java.util.ConcurrentModificationException 2. 如何删除list中的某段数据： 1. list.subList(from, to).clear(); toArray123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.*;public class ArrayListTest&#123; public static void main(String[] args) &#123; Integer arr[] = &#123;3,4,6,2,332,3,1,43,4324,5,4,12,53,23,432&#125;; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(arr)); arr = (Integer[]) list.toArray();//编译不报错，运行时报错，类转换异常。 System.out.println(list); &#125;&#125;/** Exception in thread "main" java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.lang.Integer; at xdd.list.ArrayListTest.main(ArrayListTest.java:9)*/import java.util.*;public class ArrayListTest&#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i=0;i&lt;20;i++) list.add(i); Integer[] arr = new Integer[]&#123;&#125;; list.toArray(arr); System.out.println(arr.length); &#125;&#125;/** 没有定长 输出为0*/正确转换import java.util.*;public class ArrayListTest&#123; public static void main(String[] args) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i=0;i&lt;20;i++) list.add(i); Integer[] arr = new Integer[list.size()]; list.toArray(arr); System.out.println(arr.length); System.out.println(Arrays.toString(arr)); &#125;&#125;/**20[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]*/ 1. public Object[] toArray() 2. public &lt;T&gt; T[] toArray(T[] a) : return a; Iterator和Iterablehttp://bbblemon.top/2017/10/16/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89/ http://bbblemon.top/2017/12/01/Java%E9%9D%A2%E8%AF%95%EF%BC%88%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%89/ https://blog.csdn.net/lipengcn/article/details/51700153 https://www.cnblogs.com/nbedk/p/6557341.html 1. 对于我们的Collection、List、Set为什么会直接去实现Iterable而不是Iterator？ Iterator接口中的核心方法next()，hasNext()，remove()，都是依赖当前位置。如果这些集合直接实现Iterator接口，则势必导致集合对象中包含当前迭代位置的数据(指针)。当集合在不同方法间进行传递的时候，由于当前迭代位置不可知，所以next()的结果也不可知。除非再为Iterator接口添加一个reset()方法，用来重置当前迭代位置。 而当实现Iterable则不然，每次调用都返回一个从头开始的迭代器，各个迭代器之间互不影响。 fast-failhttp://bbblemon.top/2017/10/17/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89/ https://www.cnblogs.com/ccgjava/p/6347425.html?utm_source=itdadao&amp;utm_medium=referral 1. 为什么会发生fast-fail modCount 不等于 expectedModCount，也就是迭代对象的改变值不等于当前对象的改变值，换句话说，也就是在我们迭代的过程了对集合进行了结构性的改变，所以导致抛出异常。 在某一时刻，“线程a”创建了arrayList的Iterator。 此时“节点A”仍然存在于arrayList中，创建arrayList时，expectedModCount = modCount(假设它们此时的值为N)。 在“线程a”在遍历arrayList过程中的某一时刻，“线程b”执行了，并且“线程b”删除了arrayList中的“节点A”。 “线程b”执行remove()进行删除操作时，在remove()中执行了“modCount++”，此时modCount变成了N+1！ “线程a”接着遍历，当它执行到next()函数时，调用checkForComodification()比较“expectedModCount”和“modCount”的大小； 而“expectedModCount=N”，“modCount=N+1”,这样，便抛出ConcurrentModificationException异常，产生fail-fast事件。 Maphttp://bbblemon.top/2017/10/17/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89/ http://bbblemon.top/2017/10/18/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/ 1. HashMap与Hashtable有什么区别？ 1. 底层实现HashMap是数组+链表+转红黑树（6，8）；Hashtable是数组+链表 2. HashMap线程不安全，Hashtable线程安全（所有方法加了synchronized） 3. 基类HashMap是Map接口，Hashtable是Dictionary（抽象类，实现了枚举）但是也实现了Map接口。 4. HashMap用于Key与Value同时为null，Hashtable不允许 5. HashMap初始容量16，负载因子0.75，2倍扩容，Hashtable初始容量11，负载因子0.75，扩容是2倍+1 6. HashMap使用Iterator遍历，而Hashtable因为Dictionary实现了Enumeration的原因，所以可以使用枚举迭代。 7. 计算Entry在table中的位置时，HashMap使用了当前Key的HashCode值高低16位取余作为Key的hash，而Hashtable是直接使用了Key的hashCode 8. HashMap没有了contains方法，改成了containsKey与containsValue。但是在Hashtable中这三个方法时都有的，不过contains==containsValue，一个东西。 2. HashMap中如何在table[]中定位Node? 1. (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); 2. if ((p = tab[i = (n - 1) &amp; hash]) == null) 3. 此处通过（n - 1） &amp; hash 计算出的值作为tab的下标i，并另p表示tab[i]，也就是该链表第一个节点的位置。并判断p是否为null。\ 3. 为什么扩容的时候最好是原来的2倍？（定位快和扩容角标号计算） 1. 我们在计算对象在table[]的位置时，本身应该使用hash%(length-1)，但是由于我们表长总是2的次幂，也就说当length是2的次幂时，我们hash&amp;(length-1)与hash%(length-1)是一致的。但是&amp;要比扩容快的多。 2. 一旦扩容以后，表长转成2进制，比原来多出一个1，这个时候进行&amp;的时候，原来旧表中的对象，在新表中的位置要不和原来一样，要不就是在原表位置+原表长度的位置上。 3. （JDK1.7的时候需要重新计算）也就是说我们不需要在rehash的时候重新计算原来key的hash，只需要看hash值新增的那一位是0还是1就可以了。 4. Hashtable中如何在table[]中定位Node？ 1. int hash = key.hashCode(); 2. index = (hash &amp; 0x7FFFFFFF) % tab.length 5. HashMap中put方法的执行顺序？ http://bbblemon.top/2017/12/28/Java%E9%9D%A2%E8%AF%95%EF%BC%88HashMap&amp;TreeMap&amp;%E7%BA%A2%E9%BB%91%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89/ 6. HashMap与WeakHashMap的区别 1. WeakHashMap的key采用的是&quot;弱引用&quot;的方式，只要WeakHashMap中的key不再被外部引用，它就可以被GC。 2. HashMap的key是&quot;强引用&quot;的方式，当HashMap中的key没有被外部引用时，只有当这个Key从HashMap中被删除以后，才可以被GC。 7. 如何实现HashMap的同步 1. Map map = Collections.synchronizedMap(new HashMap&lt;&gt;()); 8. 别人知道了源码，故意构造相同的hash的字符进行怎么办 1. 限制post和get的参数个数，越少越好 2. 限制post数据包大小 3. WAF 9. HashMap与ConcurrentHashMap区别 1. 前者在java.util.*下，线程不安全；ConcurrentHashMap在java.util.concurrent.*包下，线程安全 2. ConcurrentHashMap把整个Hash桶（table[]）进行了分段（Segment），也就是将整个大的数组分成了几个小的片段segment，而且每个小的片段segment上面都有锁存在，那么在插入元素的时候就需要先找到应该插入到哪一个片段segment，然后再在整个片段上面进行插入，而且还需要获得segment锁。 3. ConcurrentHashMap让锁的粒度更精细一些，并发性能更好。 10. ConcurrentHashMap如何实现线程安全？ 1. Hashtable在并发环境下表现出效率低下是因为所有访问Hashtable的线程都必须竞争同一把锁，而ConcurrentHashMap使用的就是锁分段技术，先将table[]分成segment，然后给每个segment配一把锁，当一个线程占用访问其中的一个锁时，其他segment的数据可以被别的线程访问。 2. get操作高效是因为整个get过程不需要加锁，除非读到的值是null才会加锁重读。get方法里将所有使用的共享变量都定义成volatile，让这些变量保持可见性。 3. put方法首先需要定位到Segment，然后在Segment里进行插入操作，第一步是判断是否对Segment里的HashEntry数据进行扩容，第二步时定位添加元素位置然后放在HashEntry数据里。 Map的核心API与迭代1. public V put(K key, V value)：返回这个Key对应的之前的Value，如果之前没有Key，那么一定返回的是null 2. public V get(Object key) 3. public boolean containsKey(Object key) 4. public boolean containsValue(Object value) 5. public V replace(K key, V value)：返回oldValue，如果这个Key不存在，返回null 6. public Collection&lt;V&gt; values()：返回map的值的集合（去重的）！！！Collection 7. public V remove(Object key)：返回oldValue或者null 8. public void putAll(Map&lt;? extends K, ? extends V&gt; m) HashMapHashMap数据结构http://bbblemon.top/2017/10/15/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/ 1. public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable 2. transient Node&lt;K,V&gt;[] table; 3. static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; 4. Map.Entry&lt;K,V&gt;：Map&lt;K,V&gt;接口中的内部接口Entry&lt;K,V&gt; HashMap源码分析http://bbblemon.top/2017/12/28/Java%E9%9D%A2%E8%AF%95%EF%BC%88HashMap&amp;TreeMap&amp;%E7%BA%A2%E9%BB%91%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89/ http://bbblemon.top/2017/10/16/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/ http://bbblemon.top/2017/10/15/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/ Sethttp://bbblemon.top/2017/10/15/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/ Collection和Collections核心方法http://bbblemon.top/2017/12/25/Java%E5%88%B7%E9%A2%98%EF%BC%88%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98%EF%BC%89/ 1. public static void reverse(List&lt;?&gt; list) 2. public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) 3. public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) 4. public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll) 5. public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T min(Collection&lt;? extends T&gt; coll) 线程安全的集合（java.util.*）1. Hashtable,Vector,Properties,Stack Comparable和Comparator1. Comparator位于包java.util下，而Comparable位于包java.lang 2. Comparable里面是 public int compareTo(T o); 3. Comparator里面是int compare(T o1, T o2); 线程（重点 OS &amp; Java）http://bbblemon.top/2017/12/28/Operating%20System%EF%BC%88%E5%BC%95%E8%AE%BA&amp;%E8%BF%9B%E7%A8%8B&amp;%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%EF%BC%89/ 线程和进程1. 进程是系统可拥有资源的基本单元，线程是处理机调度和分配的基本单元（能独立运行的基本单元） 2. 并发性：线程是轻量级的进程，一个进程中的多个线程可以并发执行。 3. 拥有资源：进程可以拥有资源，而线程本身并不拥有系统资源，而是仅有一点必不可少、能保证独立运行的资源（TCB、程序计数器、保留局部变量、少数状态参数和返回地址等一组寄存器和堆栈）。 4. 线程除了有自己的资源外，还共享了自己所属进程的资源。属于同一进程的所有线程都具有相同的地址空间，线程可以访问这个地址上的每一个虚地址！！！同时可以访问：已打开的文件、定时器、信号量机构等内存空间和进程所申请到的I/O设备等 5. 独立性：每个进程都有自己独立的地址空间和其他资源，除了共享全局变量外，不允许其他进程的访问。而同一进程的所有线程都可以访问所属进程空间中的所有地址。 6. 系统开销：创建、切换、撤销进程的开销比较大。 注意：一个进程中至少有一个线程，CPU上可以没有运行的进程；一个线程只能属于某一个特定的进程； 为什么使用多线程1. 多核CPU的使用 2. 线程的切换和创建开销更小。 3. 多线程可以减少程序执行的时间 线程异步与同步1. 同步：一个请求发出后，必须要等到响应才能执行下面的程序。 2. 异步：一个请求发出后，不需要等到响应就可以执行下面的程序。 如何实现同步必须要获得每一个线程对象的锁。获得它可以保证在同一时刻只有一个线程能够进入临界区（访问互斥资源的代码块），并且在这个锁被释放前，其他线程不能再进入到这个临界区。如果其他线程还想要获得该对象的锁，只能进入等待队列等待。只有当拥有该对象锁的线程退出临界区，锁才会被释放，等待队列中优先级最最高的线程才能获得该锁，从而进入共享代码区。 线程状态转换 1、新建状态（New）：新创建了一个线程对象。 2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。 3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。 4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种： （一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁) （二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。 （三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁） 5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 线程的实现方式1. 继承Thread类，重写run函数 2. 实现Runnable接口 3. 实现Callable接口 简单区别: 1. 实现Runnable接口可以避免Java单继承带来的局限性，代码能够被多个线程共享，代码与数据是独立的，适合多个相同程序代码的线程区处理同一资源。 2. 继承Thread类和实现Runnable方法启动线程都是使用start方法，然后JVM虚拟机将此线程放到就绪队列中，如果有处理机可用，则执行run方法 3. 实现Callable接口要实现call方法，并且线程执行完毕后会有返回值。其他两种都没有返回值。 4. 不管是继承Thread还是实现Runnable，最终还是通过Thread对象的API来控制线程。 5. Thread类中的run方法是一个空方法。 Thread与Runnable的区别1. 为什么用实现的方式好？ 1. 当一个类需要被修改或者是加强的时候，我们才会使用Thread 2. 使用实现Runnable这种方式可以方便资源共享（synchronized(this)加锁代码块），可以实现多个Thread，共用一个实现Runnable的对象。 3. 实现了Runnable可以让类去继承别的类。 Callable与Futurehttps://www.cnblogs.com/MOBIN/p/6185387.html https://blog.csdn.net/javazejian/article/details/50896505 1. Callable的执行流程？ 1. Callable是个泛型参数化接口，并能返回线程的执行结果，且能在无法正常计算时抛出异常 2. Callable并不像Runnable那样通过Thread的start方法就能启动实现类的run方法，所以它通常利用ExecutorService的submit方法去启动call方法自执行任务，而ExecutorService的submit又返回一个Future类型的结果，因此Callable通常也与Future一起使用。 3. 利用FutureTask封装Callable再由Thread去启动 2. Callable和Future？ 3. Future的get方法？ 4. Runnable和Callable的区别？ 1. Callable可以再任务结束后提供一个返回值，Runnable没有这个功能。 2. Callable中的call()方法，可以在无法实现正常计算的时候抛出异常，而run方法不可以。 3. 运行Callable可以拿到一个Future对象，Future对象表示异步计算的结果，它提供了检查计算是否完成的方法。 4. 由于线程属于异步计算模型，因此无法从别的线程中得到函数的返回值，在这种情况下，就可以使用Future来监控目标线程调用call方法的情况，当调用Future的get方法获取结果时，当前线程就会阻塞，直到call方法结束返回结果。 start与run1. start方法用来启动一个线程，run方法定义线程执行的主要任务 2. 别的线程调用了另一个线程的start方法，就让这个方法从ready--&gt;runnable，等待处理机调度。一旦这个线程拿到了CPU的时间片，那么就CPU就开始执行这个线程中run方法中定义的方法体。run方法执行完成后，线程就会被终止。 3. 如果直接调用这个线程对象的run方法，就还是只有原来的那个线程，并不会开启线程，就和调用一个普通的方法没有任何区别，程序在原线程上顺序执行。 就是说使用start可以异步的调用run方法，但是直接调用却是同步调用。 什么是锁（多线程同步实现方法有哪些）当多个线程同时需要对同一个资源进行访问的时候，那么可能会出现混乱，如果当多个线程要改动这个资源里面的顺序时，会导致某些线程对数据的修改丢失（volatile说的是修改后的可见性），所以需要使用同步机制来解决这个问题。 也就是加锁。 1. sunchronized，对象锁，每个对象有一个锁。 2. Lock接口，ReentrantLock（可重入互斥锁）。 synchronized用在代码块和方法上有什么区别1. synchronized用在代码块中锁住的是调用这个代码块的对象(this),也可以选择锁住任何一个对象 2. synchronized用在方法是锁住的调用这个方法的对象 3. synchronized用在代码块可以减少锁的粒度，从而提高并发性 4. 无论是用在代码块还是方法上，都是获取了某个对象（调用方法的对象和某个加锁对象）的锁，但是每个对象只有一个锁，所以利用synchronized实现同步的时候需要很大的系统开销，甚至造成死锁，所以一般不要做无谓的同步。 synchronized与static synchronized的区别1. synchronized是对某个类的某个实例对象进行加锁，防止其他线程访问这个类的这个实例中其他的synchronized方法（块），但是同一个类的不同实例就没有这个约束了。 2. static synchronized是对某个类的所有实例都加锁了，不管别的线程有多少的实例对象，都不能访问已经加锁的方法。 synchronized的缺陷1. 效率问题，就是说当一个线程占有了某个对象的锁时，其他线程无法访问，虽然这个样子防止了多个线程同时对某个资源进行写操作时引起的问题，但是如果这些别的线程也都只是进行读操作的时候，这个synchronized就比较无力了。 2. Lock就可以做到，当别的线程只是读操作的时候，可以多个线程同时访问一个资源。而且Lock可以知道线程是否已经拿到了锁，这个是synchronzied无法做到的。但是Lock必须手动去释放锁，不然可能死锁，这个和synchronzied不同。 synchronized的底层实现进入时，执行monitorenter，将计数器+1，释放锁时，monitorexit，计数器-1。 当一个线程判断计数器是0时，则当前锁空闲，可以占用，反之，等待。 Synchronized是一种对象锁，对象锁是一种重量锁（monitor）,Synchronized的锁机制会根据线程竞争情况在运行时会有偏向锁，自旋锁等。 sleep与waithttp://www.cnblogs.com/skywang12345/p/3479224.html 1. sleep是Thread的方法，让当前线程睡眠，但是并没有释放锁。（没有线程通信） 2. wait是Object的方法，让CPU当先执行的线程等待（不是哪个线程对象调用了就让哪个线程等待了），线程进入等待对象，等待别的线程调用notify，notifyAll唤醒（从等待队列进入了锁池，一旦拿到了锁，就进入可运行状态）。（有线程通信） 3. wait方法的必须放在同步控制方法或者同步语句块中使用，而sleep()可以在任何地方使用。 4. sleep与wait都会抛出受检异常（InterruptException），但是notify，notifyAll不会。 sleep与yieldyield是让当前运行的线程进入可运行状态（有点像当前线程在CPU上的某个时间片被用完了） 1. sleep()方法给其他线程运行机会时，不会考虑线程的优先级，因此会给低优先级的线程以运行的机会。而yield方法只会给相同优先级或更高优先级的线程以运行的机会。 2. 线程执行sleep方法后会转入阻塞状态，而yield是进入了可执行态。 3. sleep抛出了受检异常，而yield没有 死锁（OS，银行家算法）比如有两个线程A，B，和两个对象a,b。现在A正在调用a,调用a之后A想调用b。B正在使用b,调用完b，之后想调动a。于是A,B 两个线程分别抱着a,b的锁不放开，互相等对方放开锁，然后自己就可以执行下一步。于是程序就发生了死锁。 如何保证线程安全1. 对变量使用volatile。 2. 对程序段进行加锁。 多线程共用一个数据变量需要注意什么1. ThreadLocal是JDK引入的一种机制，它用于解决线程之间共享变量，使用ThreadLocal声明的变量，即使实在线程中属于静态成员，针对每个线程而言，这个变量也是独立的。 2. volatile是每次被线程访问，都强迫线程从主内存中重读该变量的最新值，而当该变量发生修改的时候，也会强迫线程将最新值刷新进入主内存。 Volatile如何保证内存可见性https://www.jianshu.com/p/195ae7c77afe http://www.importnew.com/27002.html http://www.importnew.com/24082.html 在JVM中，有主内存和工作内存的概念，每个线程对应一个工作内存，并共享主内存数据， 1. 对于普通变量：读操作会优先读取工作内存的数据，如果工作内存不存在，则从主内存中拷贝一份数据到工作内存，写操作只会修改工作内存中的副本数据，这种情况下，其他线程就无法读取变脸的最新值。 2. 对于volatile变量：读操作时JVM会把工作内存中对应的值设置为无效，要求线程从主内存中读取数据，写操作JVM也会把工作内存中对应的数据刷新到主内存中，这种情况下，其他线程就可以读取变量的最新值。 volatile变量的内存可见性，是基于内存屏蔽实现的，内存屏蔽也就是一个CPU指令。在程序运行的时候，为了提高执行性能，编译器和处理器会对指令进行重排序，JVM为了保证不同的编译器和CPU上有相同的结果，通过插入特定类型的内存屏蔽来禁止特定类型的编译器重排序和处理器重排序，插入一条内存屏蔽会告诉编译器和CPU，不管什么指令都不能和这条内存屏蔽指令重排序。 处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。 如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。 但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的。 1. volatile只保证了可见性和防止了指令重排序，并没有保证原子性。 2. volatile修饰的变量只是保证了每次读取时都从主存中读，每次修改时，都将修改后的值重新写入了主存。 3. 在synchronized修饰的方法体或者常量（final）不需要使用volatile。 4. 由于使用了volatile屏蔽掉了JVM中必要的代码优化，所以在效率上比较低，因此一定在必要的时候才能使用该关键字。 Volatile如何禁止指令重排序1. 编译器重排序：编译器在不改变单线程语义的前提下，为了提高程序的运行速度，可以对字节码进行重新排序。 2. 指令重排序：就是JVM给CPU发送的指令前面加一个lock。 volatile和synchronized的区别1. volatile不会进行加锁操作。 2. volatile变量作用类似于同步变量读写操作。 3. volatile不如synchronized安全。 4. volatile无法同时保证内存可见性和原子性，加锁（synchronized）不但保证了可见性而且保证了原子性。 Synchronized与lock1. （用法）synchronized（隐式锁）：在需要同步的对象中加入此控制，synchronized可以加在方法上，也可以加在特定的代码块中，括号中表示需要锁的对象。 2. （用法）Lock（显式锁）：需要显式指定起始和终止位置，一般使用ReentrantLock类作为锁，线程中需要使用一个ReentrantLock类作为对象才能保证锁生效。且在加锁和解锁处需要通过lock和unlock显示指出。所以一般会在finally块中写unlock防止死锁。 3. （性能）synchronized是托管给JVM执行的，而Lock是Java写的控制锁代码。（JDK1.5）synchronized是一个重量级的锁，需要调用操作接口，导致有可能加锁消耗的系统时间比加锁以外的时间还多。（JDK1.6）synchronized出现了很多锁，所以性能上提高了。 4. （机制）synchronized原始采用CPU悲观锁机制，即线程获得的是独占锁，独占锁以为着其他线程只能依靠阻塞来等待线程释放锁。Lock用的是乐观锁，也就是每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功。乐观锁的机制其实就是CAS。 synchronized和ReentrantLock(CAS)的区别1. 可重入性/互斥：两个都是可重入/互斥的，区别不大 2. 锁的实现：synchronized是依赖JVM实现的，而ReenTrantLock是JDK实现，是实现了Lock的类，说白了类似一于OS来控制实现和自己写代码实现。 3. 性能：1.6以前区别比较大，1.6以后就没有撒区别的了。 4. 功能：synchronized使用简单，而且编译器去保证锁的加入和释放，而ReentrantLock必须自己显式的加载和释放锁。但是ReentrantLock的粒度小。 5. Reentrant可以指定式公平锁还是非公平锁，但是synchronized都是非公平锁。（公平非公平是看释放锁以后等待队列中的线程是不是按照等待时间的长短来得到锁） 6. ReentrantLock提供了Condition类，用来实现分组唤醒需要唤醒的线程。 7. ReentrantLock提供了一种能够终端等待锁的线程的机制（lock.lockInterruptibly）。 ThreadLocal简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个开地址法实现的Thread.ThreadLocalMap，把数据进行隔离，数据不共享，自然没有线程安全的问题。 Entry中的Key是一个ThreadLocal实例，Value是一个线程持有对象。Entry的作用就是，为其属主线程建立起一个ThreadLocal实例与一个线程持有对象之间的对应关系。 Entry对Key是弱引用，对Value是强引用。 什么是线程池就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程，不需要自己创建，使用完了放回线程池而不是销毁，从而减少创建和销毁对象的开销。 1. 线程管理（ThreadPool）：用于创建并管理线程池，包括创建线程，销毁线程池，添加新任务。 2. 工作线程（PoolWoker）：线程中线程在没有任务时处于等待状态，可以循环的执行任务。 3. 任务接口（Task）:每个任务必须实现的接口，以供工作线程调度任务的执行。 4. 任务队列（TaskQueue）：用于存放没有处理的任务。 守护线程GCor就是一个守护线程的例子 JUC包JUC包下的线程安全集合CopyOnWriteArrayList（线程安全的ArrayList）http://www.cnblogs.com/skywang12345/p/3498483.html CopyOnWriteArrayList的数据结构1. public class CopyOnWriteArrayList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 2. final transient ReentrantLock lock = new ReentrantLock(); 3. private transient volatile Object[] array; 4. CopyOnWriteArrayList的&quot;动态数组&quot;机制，内部的transient volatile array[]来保存数据，增删改都是会先拿到ReentrantLock锁，然后加锁，拿到array[]后，将array[]的引用赋值给方法内部的局部数组，接着得到原数组长度，进行数组复制（Arrays.copyof(oldArray,oldLength+1)）得到新的数组，数组修改后，将新数组的引用由返回给array，最后释放锁。 其实这个东西因为在修改数组的过程中，都是拿锁，复制数组以创建新的数组，然后又赋值，所以比较慢，但是如果只是随机访问的话，和ArrayList没什么大的区别。 5. CopyOnWriteArrayList的&quot;线程安全&quot;机制，通过volatile和互斥锁来实现。 1. volatile保证了array[]的可见性和防止了指令重排序。 2. ReentrantLock（互斥锁，独占锁），增删改数组的时候，都要先那到锁，修改完毕后再把数据更新到array[]数组，然后再释放锁 CopyOnWriteArrayList部分源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130final Object[] getArray() &#123; return array; &#125; /** * Sets the array. */ final void setArray(Object[] a) &#123; array = a; &#125; public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125; &#125;public void add(int index, E element) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; if (index &gt; len || index &lt; 0) throw new IndexOutOfBoundsException("Index: "+index+ ", Size: "+len); Object[] newElements; int numMoved = len - index; if (numMoved == 0) newElements = Arrays.copyOf(elements, len + 1); else &#123; newElements = new Object[len + 1]; System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index, newElements, index + 1, numMoved); &#125; newElements[index] = element; setArray(newElements); &#125; finally &#123; lock.unlock(); &#125; &#125;public E remove(int index) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; E oldValue = get(elements, index); int numMoved = len - index - 1; if (numMoved == 0) setArray(Arrays.copyOf(elements, len - 1)); else &#123; Object[] newElements = new Object[len - 1]; System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index + 1, newElements, index, numMoved); setArray(newElements); &#125; return oldValue; &#125; finally &#123; lock.unlock(); &#125; &#125;public E set(int index, E element) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); E oldValue = get(elements, index); if (oldValue != element) &#123; int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len); newElements[index] = element; setArray(newElements); &#125; else &#123; // Not quite a no-op; ensures volatile write semantics setArray(elements); &#125; return oldValue; &#125; finally &#123; lock.unlock(); &#125; &#125;@SuppressWarnings("unchecked") private E get(Object[] a, int index) &#123; return (E) a[index]; &#125; /** * &#123;@inheritDoc&#125; * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E get(int index) &#123; return get(getArray(), index); &#125;public int indexOf(E e, int index) &#123; Object[] elements = getArray(); return indexOf(e, elements, index, elements.length); &#125;private static int indexOf(Object o, Object[] elements, int index, int fence) &#123; if (o == null) &#123; for (int i = index; i &lt; fence; i++) if (elements[i] == null) return i; &#125; else &#123; for (int i = index; i &lt; fence; i++) if (o.equals(elements[i])) return i; &#125; return -1; &#125; ConcurrentHashMaphttp://www.cnblogs.com/skywang12345/p/3498537.html https://www.cnblogs.com/study-everyday/p/6430462.html https://blog.csdn.net/fouy_yun/article/details/77816587 https://segmentfault.com/a/1190000009001468 https://blog.csdn.net/fjse51/article/details/55260493 ConcurrentHashMap的数据结构（JDK1.7） 1. public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements ConcurrentMap&lt;K,V&gt;, Serializable 2. Segment是ConcurrentHashMap中的内部类，它就是ConcurrentHashMap中&quot;锁分段&quot;对应的数据结构。一个ConcurrentHashMap中有多个Segment对象，因为ConcurrentMap中有一个Segment数组。 3. Segment继承自ReentrantLock，所以Segment本质上就是一个可重入的互斥锁 4. HashEntry也是ConcurrentHashMap的内部类，是个单向链表结构，存储Key-Value对。Segment和HashEntry是组合关系，Segment中存在HashEntry数组成员。 5. static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; 6. transient volatile Node&lt;K,V&gt;[] table; 7. private transient volatile Node&lt;K,V&gt;[] nextTable; 在JDK1.6中，ConcurrentHashMap将数据分成一段一段存储，给每一段数据配一把锁，当一个线程获得锁互斥访问一个段数据时，其他段的数据也可被其他线程访问；每个Segment拥有一把可重入锁，因此ConcurrentHashMap的分段锁数目即为Segment数组长度（16）。ConcurrentHashMap结构：每一个segment都是一个HashEntry&lt;K,V&gt;[] table， table中的每一个元素本质上都是一个HashEntry的单向队列（单向链表实现）。每一个segment都是一个HashEntry&lt;K,V&gt;[] table， table中的每一个元素本质上都是一个HashEntry的单向队列。 当一个线程访问Node/键值对数据时，必须获得与它对应的segment锁，其他线程可以访问其他Segment中的数据（锁分离）； ConcurrentHashMap的数据结构（JDK1.8） JDK1.8的实现已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作（CAS+Synchronized），整个看起来就像是优化过且线程安全的HashMap，虽然在JDK1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧版本 1. ConcurrentHashMap底层数据结构与HashMap相同，仍然采用table数组+链表+红黑树结构； 2. 一个线程进行put/remove操作时，对桶（链表 or 红黑树）加上synchronized独占锁； 3. ConcurrentHashMap采用CAS算法保证线程安全； 123456789101112131415161718192021222324252627282930transient volatile Node&lt;K,V&gt;[] table：键值对桶数组 private transient volatile Node&lt;K,V&gt;[] nextTable： rehash扩容时用到的新键值对数组 private transient volatile long baseCount：&lt;span id = "jump1"&gt;&lt;/span&gt;记录当前键值对总数，通过CAS更新，对所有线程可见 private transient volatile int sizeCtl sizeCtl表示键值对总数阈值，通过CAS更新, 对所有线程可见 当sizeCtl &lt; 0时，表示多个线程在等待扩容； 当sizeCtl = 0时，默认值； 当sizeCtl &gt; 0时，表示扩容的阈值； private transient volatile int cellBusy：自旋锁； private transient volatile CounterCell[] counterCells: counter cell表，长度总为2的幂次； static class Segment&lt;K,V&gt;：在JDK1.8中，Segment类仅仅在序列化和反序列化时发挥作用； static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; // 键值对的value和next均为volatile类型 volatile V val; volatile Node&lt;K,V&gt; next; ... &#125; ConcurrentHashMap部分源码（JDK1.8）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); int binCount = 0; // 不断CAS探测，如果其他线程正在修改tab，CAS尝试失败，直到成功为止 for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; // 空表，对tab进行初始化 if (tab == null || (n = tab.length) == 0) tab = initTable(); /** * CAS探测空桶 * 计算key所在bucket表中数组索引: i = (n - 1) &amp; hash) */ else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; // CAS添加新键值对 if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; // 检测到tab[i]桶正在进行rehash, else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else &#123; V oldVal = null; // 对桶的首元素上锁独占 synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; // 桶中键值对组织形式是链表 if (fh &gt;= 0) &#123; binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; // 查找到对应键值对，更新值 if (!onlyIfAbsent) e.val = value; break; &#125; // 桶中没有对应键值对，插入到链表尾部 Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; // 桶中键值对组织形式是红黑树 else if (f instanceof TreeBin) &#123; Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; // 检查桶中键值对总数 if (binCount != 0) &#123; if (binCount &gt;= TREEIFY_THRESHOLD) // 链表转换为红黑树 treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; // 更新baseCount addCount(1L, binCount); return null;&#125;synchronized (f) &#123;&#125;操作通过对桶的首元素 = 链表表头 Or 红黑树根节点加锁，从而实现对整个桶进行加锁，有锁分离思想的体现； 123456789101112131415161718192021public V get(Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek; int h = spread(key.hashCode()); if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123; if ((eh = e.hash) == h) &#123; if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) return e.val; &#125; else if (eh &lt; 0) return (p = e.find(h, key)) != null ? p.val : null; while ((e = e.next) != null) &#123; if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) return e.val; &#125; &#125; return null;&#125;get方法通过CAS保证键值对的原子性，当tab[i]被锁住，CAS失败并不断重试，保证get不会出错； table原子操作123456获取tab[i]：tabAtstatic final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) &#123; return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);&#125;tabAt方法原子读取table[i]；调用Unsafe对象的getObjectVolatile方法获取tab[i]，由于对volatile写操作happen-before于volatile读操作，因此其他线程对table的修改均对get读取可见；((long)i &lt;&lt; ASHIFT) + ABASE)计算i元素的地址 12345678910111213CAS算法更新键值对：casTabAtstatic final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123; return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);&#125;casTabAt通过compareAndSwapObject方法比较tabp[i]和v是否相等，相等就用c更新tab[i];更新键值对：setTabAtstatic final &lt;K,V&gt; void setTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; v) &#123; U.putObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, v);&#125;仅在synchronized同步块中被调用，更新键值对； JDK1.7和JDK1.8的区别1. JDK1.8的实现降低锁的粒度，JDK1.7版本锁的粒度也是基于Segment的，包含了一个HashEntry数组，而JDK1.8锁的粒度是HashEntry（Node） 2. JDK1.8的数据结构变简单了，使用synchronized来进行同步，不再需要分段锁的概念 3. JDK1.8使用红黑树来优化了链表 4. JDK1.8为什么使用synchronized和ReentrantLock 1. 因为锁的粒度降低了，synchronized并不比ReentrantLock差 2. 大量数据操作下，对于JVM的内存压力，基于API的ReentrantLock会开销更多的内存。 5. 定位节点的hash算法被简化了。 6. JDK1.7使用锁分段技术，每个Segment有一个ReentrantLock，而JDK1.8取消了Segment这个数据结构，直接使用Node&lt;K,V&gt; table[]来存储键值对，JDK1.8中，一个线程每次对一个桶（链表 or 红黑树）进行加锁，其他线程仍然可以访问其他桶。 ConcurrentHashMap的并发度是什么1. 对于JDK1.7而言，就是Segment数组的大小，默认是16，这意味着最多同时有16条线程操作ConcurrentHashMap，这也就是JDK1.7时候ConcurrentHashMap对Hashtable的最大优势，Hashtable能同时有两条线程获取Hashtable中的数据吗？ 2. 对于JDK1.8而言，因为没有了Segment这个数据结构，都是数组+链表+红黑树，但是再putVal这种操作中，还是使用synchronized+CAS算法对桶（链表/红黑书）进行了加锁，一个桶一个锁。 乐观锁与悲观锁1. 悲观锁比如synchronized锁，为确保其他线程不会干扰当前线程工作，因此挂起其他需要锁的线程，等待持有锁的线程释放； 2. 乐观锁总是假设没有冲突发生去做操作，如果检测到冲突就失败重试，知道成功为止； 什么是AQSAbstractQueuedSychronizer（抽象队列同步器）。如果说JUC的基础是CAS，那么AQS就是JUC的核心，AQS以双向队列的形式连接所有的Entry。 什么是CAShttp://ifeve.com/compare-and-swap/ http://www.cnblogs.com/Mainz/p/3546347.html?utm_source=tuicool&amp;utm_medium=referral CAS的全称叫“Compare And Swap”，也就是比较与交换，他的主要操作思想是： 首先它具有三个操作数，a、内存位置V，预期值A和新值B。如果在执行过程中，发现内存中的值V与预期值A相匹配，那么他会将V更新为新值A。如果预期值A和内存中的值V不相匹配，那么处理器就不会执行任何操作。CAS算法就是我再技术点中说的“无锁定算法”，因为线程不必再等待锁定，只要执行CAS操作就可以，会在预期中完成。 1. CAS(Compare And Swap)：CAS算法包含三个参数CAS(V, E, N)，判断预期值E和内存旧值是否相同(Compare)，如果相等用新值N覆盖旧值V(Swap)，否则失败； 2. 当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，其他线程失败（失败线程不会被阻塞，而是被告知“失败”，可以继续尝试）； 3. CAS在硬件层面可以被编译为机器指令执行，因此性能高于基于锁占有方式实现线程安全； JMMJava内存模型。 1. 可见性（任务内存和主内存的关系，Volatile） 2. happens-before，先行发生原则，定义了操作A必然先行发生于B操作的一些规则，比如同一个线程内控制流前面的代码一定先行发生于控制流后面的代码，一个unlock的方法一定发生在lock操作的后面等等，如果符合这些规则，则不需要额外的同步操作，如果某段代码不符合所有的happens-before规则，则这段代码一定是非线程安全的。 CyclicBarrier和CountDownLatch的区别ReadWriteLock是什么Java中如何获取到线程dump文件Java 8新特性1. HashMap/ConcurrentHashMap底层实现变了。 2. JVM中元空间取代了永久代。 1. 元空间并不在JVM中了，而使用的是本地内存 2. 默认情况下，元空间的大小仅受本地内存限制 3. 可以通过-XX： MetaspaceSize指定元空间大小 3. 接口中可以有default的方法实体和static的方法实体 4. java.time包 5. Lambda表达式:允许将函数作为参数进行传递。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为OJ（六）]]></title>
    <url>%2F2018%2F04%2F08%2F%E5%8D%8E%E4%B8%BAOJ%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[华为OJ 升序、降序排列1234567891011121314151617181920212223public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int n = scanner.nextInt(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;n;i++) list.add(scanner.nextInt()); int type = scanner.nextInt(); Collections.sort(list); if(type==0)&#123; for(Integer i : list) sb.append(i+" "); &#125;else&#123; for(int i=n-1;i&gt;=0;i--) sb.append(list.get(i)+" "); &#125; System.out.println(sb.toString().trim()); &#125; scanner.close(); &#125;&#125; 字符统计12345678910111213141516171819202122232425262728import java.util.*;import java.util.Map.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; char[] ch = scanner.nextLine().toCharArray(); Map&lt;Character,Integer&gt; map = new TreeMap&lt;&gt;();//保证了当值相同的时候升序排列（ASCII） for(char c : ch)&#123; map.put(c,map.get(c)==null?1:map.get(c)+1); &#125; List&lt;Map.Entry&lt;Character,Integer&gt;&gt; list = new ArrayList&lt;&gt;(map.entrySet()); Collections.sort(list,new Comparator&lt;Map.Entry&lt;Character,Integer&gt;&gt;()&#123; @Override public int compare(Entry&lt;Character,Integer&gt; o1,Entry&lt;Character,Integer&gt; o2)&#123; return o2.getValue().compareTo(o1.getValue());//降序 &#125; &#125;); StringBuilder sb = new StringBuilder(); for(Map.Entry&lt;Character,Integer&gt; entry:list)&#123; sb.append(entry.getKey()); &#125; System.out.println(sb); &#125; scanner.close(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738//按照值进行降序//值相同的的时候按照Key的ASCII降序import java.util.*;import java.util.Map.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; char[] ch = scanner.nextLine().toCharArray(); Map&lt;Character,Integer&gt; map = new TreeMap&lt;&gt;(); for(char c : ch)&#123; map.put(c,map.get(c)==null?1:map.get(c)+1); &#125; List&lt;Map.Entry&lt;Character,Integer&gt;&gt; list = new ArrayList&lt;&gt;(map.entrySet()); Collections.sort(list,new Comparator&lt;Map.Entry&lt;Character,Integer&gt;&gt;()&#123; @Override public int compare(Entry&lt;Character,Integer&gt; o1,Entry&lt;Character,Integer&gt; o2)&#123; return o2.getKey().compareTo(o1.getKey()); &#125; &#125;); Collections.sort(list,new Comparator&lt;Map.Entry&lt;Character,Integer&gt;&gt;()&#123; @Override public int compare(Entry&lt;Character,Integer&gt; o1,Entry&lt;Character,Integer&gt; o2)&#123; return o2.getValue().compareTo(o1.getValue()); &#125; &#125;); StringBuilder sb = new StringBuilder(); for(Map.Entry&lt;Character,Integer&gt; entry:list)&#123; sb.append(entry.getKey()); &#125; System.out.println(sb); &#125; scanner.close(); &#125;&#125; Redraiment走法（最长增长子序列LIS）123456789101112131415161718192021222324252627282930import java.util.*;public class Main&#123; public static int getLIS(int[] arr,int n)&#123; int result[] = new int[n]; for(int i=0;i&lt;n;i++) result[i] = 1; for(int i=1;i&lt;n;i++)&#123; for(int j=0;j&lt;i;j++)&#123; if(arr[i]&gt;arr[j]) result[i] = Math.max(result[i],result[j]+1); &#125; &#125; Arrays.sort(result); return result[n-1]; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int n = scanner.nextInt(); int[] arr = new int[n]; for(int i=0;i&lt;n;i++)&#123; arr[i] = scanner.nextInt(); &#125; System.out.println(getLIS(arr,n)); &#125; scanner.close(); &#125;&#125; 字符串分割12345678910111213141516171819202122232425262728293031import java.util.*;public class Main&#123; public static void getString(List&lt;String&gt; list,String s)&#123; int length = s.length(); if(length&lt;=8)&#123; s = s+"00000000"; list.add(s.substring(0,8)); &#125;else&#123; String temp = s.substring(0,8); list.add(temp); getString(list,s.substring(8)); &#125; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; int n = Integer.parseInt(scanner.nextLine()); List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(int i=0;i&lt;n;i++)&#123; String s = scanner.nextLine(); getString(list,s); &#125; for(String temp : list)&#123; System.out.println(temp); &#125; &#125; scanner.close(); &#125;&#125; 记负均正（二）12345678910111213141516171819202122232425262728293031323334import java.util.*;import java.text.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(scanner.hasNextInt())&#123; String[] arr = scanner.nextLine().split("\\s+"); for(String s:arr)&#123; list.add(Integer.parseInt(s)); &#125; int count = 0; double sum = 0.0; for(Integer i:list)&#123; if(i&lt;0)&#123; count++; &#125;else&#123; sum+=i; &#125; &#125; double even = sum/(list.size()-count); DecimalFormat df = new DecimalFormat("0.0"); System.out.println(count); if(list.size()-count==0)&#123; System.out.println("0.0"); &#125;else&#123; System.out.println(df.format(even)); &#125; &#125; scanner.close(); &#125;&#125; 字符反转123456789101112import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String str = scanner.nextLine(); StringBuffer sb = new StringBuffer(str); System.out.println(sb.reverse().toString()); &#125; &#125;&#125; 求解立方根123456789101112131415import java.util.*;import java.text.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int key = scanner.nextInt(); //double value = Math.pow(key,1/3.0); DecimalFormat df = new DecimalFormat("0.0"); System.out.println(df.format(Math.pow(key,1/3.0))); &#125; scanner.close(); &#125;&#125; 求最小公倍数12345678910111213141516171819import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int f = scanner.nextInt(); int s = scanner.nextInt(); int multi = s*f; for(int i=1;i&lt;=multi;i++)&#123; if(i%f==0&amp;&amp;i%s==0)&#123; System.out.println(i); break; &#125; &#125; &#125; scanner.close(); &#125;&#125;]]></content>
      <categories>
        <category>HUAWEI</category>
      </categories>
      <tags>
        <tag>HUAWEI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为OJ（五）]]></title>
    <url>%2F2018%2F04%2F08%2F%E5%8D%8E%E4%B8%BAOJ%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[华为OJ 字符串匹配123456789101112131415161718192021import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; boolean flag = true; char min[] = scanner.nextLine().toCharArray(); String max = scanner.nextLine(); for(char c:min)&#123; String temp = String.valueOf(c); if(!max.contains(temp))&#123; flag = false; break; &#125; &#125; System.out.println(flag); &#125; scanner.close(); &#125;&#125; 将真分数分解为埃及分数二维数组操作统计大写字母个数12345678910111213141516import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; char[] ch = scanner.nextLine().toCharArray(); int count = 0; for(char c:ch) if(String.valueOf(c).matches("[A-Z]")) count++; System.out.println(count); &#125; scanner.close(); &#125;&#125; 字符串运用-密码截取12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.*;//Manacher --&gt; Palindromepublic class Main&#123; public static int getManacher(String s)&#123; //构建新的回文串，奇偶回文串一并处理 char[] oldPal = s.toCharArray(); StringBuilder sb = new StringBuilder("#"); for(char c:oldPal)&#123; sb.append(c+"#"); &#125; char[] newPal = sb.toString().toCharArray(); int length = newPal.length; //构建数组，最右长度，最右长度对应的中心 int[] radius = new int[length]; int maxRightCenter = 0; int maxRight = 0; //开始遍历：1，确定最小半径；2.扩展；3.更新最右长度，最右长度对应的中心 for(int i=0;i&lt;length;i++)&#123; //1，确定最小半径 if(i&gt;=maxRight)&#123; radius[i] = 1; &#125;else&#123; radius[i] = Math.min(maxRight-i,radius[2*maxRightCenter-i]); &#125; //2.扩展 while(i+radius[i]&lt;length &amp;&amp; i-radius[i]&gt;=0 &amp;&amp; newPal[i+radius[i]]==newPal[i-radius[i]])&#123; radius[i]++; &#125; //3.更新 if(i+radius[i]&gt;maxRight)&#123; maxRight = i+radius[i]; maxRightCenter = i; &#125; &#125; Arrays.sort(radius); return radius[length-1]-1; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; String Palindrome = scanner.next(); System.out.println(getManacher(Palindrome)); &#125; scanner.close(); &#125;&#125; 求最大连续bit位数12345678910111213141516171819202122public class Main&#123; public static int getBits(int key)&#123; String split[] = Integer.toString(key,2).split("0+"); int max = 0; int length = split.length; for(int i=0;i&lt;length;i++)&#123; int temp = split[i].length(); if(temp&gt;max) max = temp; &#125; return max; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int key = scanner.nextInt(); System.out.println(getBits(key)); &#125; scanner.close(); &#125;&#125; 密码等级123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import java.util.*;public class Main&#123; public static String getPWDStrength(String pwd)&#123; int score[] = new int[5]; //长度 int length = pwd.length(); if(length&lt;=4)&#123; score[0] = 5; &#125;else if(length&gt;=8)&#123; score[0] = 25; &#125;else&#123; score[0] = 10; &#125; //字母 char[] arr = pwd.toCharArray(); int[] caseType = new int[2]; for(char c :arr)&#123; String temp = String.valueOf(c); if(temp.matches("[a-z]"))&#123; caseType[0] = 1; continue; &#125; if(temp.matches("[A-Z]"))&#123; caseType[1] = 1; continue; &#125; &#125; int caseSum = caseType[0]+caseType[1]; if(caseSum==0)&#123; score[1] = 0; &#125;else if(caseSum==1)&#123; score[1] = 10; &#125;else&#123; score[1] = 20; &#125; //数字 int digit = 0; for(char c :arr)&#123; String temp = String.valueOf(c); if(temp.matches("[0-9]")) digit++; &#125; if(digit==0)&#123; score[2] = 0; &#125;else if(digit==1)&#123; score[2] = 10; &#125;else&#123; score[2] = 20; &#125; //符号 int symbol = 0; for(char c :arr)&#123; String temp = String.valueOf(c); if(temp.matches("[^a-zA-Z0-9]")) symbol++; &#125; if(symbol==0)&#123; score[3] = 0; &#125;else if(symbol==1)&#123; score[3] = 10; &#125;else&#123; score[3] = 25; &#125; //奖励 if(score[1]!=0&amp;&amp;score[2]!=0)&#123; score[4] = 2; if(score[3]!=0)&#123; score[4] = 3; if(score[1]==20)&#123; score[4] = 5; &#125; &#125; &#125; //分数 int pwdScore = 0; for(int i:score)&#123; pwdScore+=i; &#125; if(pwdScore&gt;=90)&#123; return "VERY_SECURE"; &#125;else if(pwdScore&gt;=80)&#123; return "SECURE"; &#125;else if(pwdScore&gt;=70)&#123; return "VERY_STRONG"; &#125;else if(pwdScore&gt;=60)&#123; return "STRONG"; &#125;else if(pwdScore&gt;=50)&#123; return "AVERAGE"; &#125;else if(pwdScore&gt;=25)&#123; return "WEAK"; &#125;else&#123; return "VERY_WEAK"; &#125; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String pwd = scanner.nextLine(); System.out.println(getPWDStrength(pwd)); &#125; scanner.close(); &#125;&#125; 扑克牌大小123456789101112131415161718192021222324252627282930313233343536373839import java.util.*;public class Main&#123; public static String comparePoker(String p1,String p2)&#123; String[] poker = &#123;"3","4","5","6","7","8","9","10","J","Q","K","A","2","joker","JOKER"&#125;; List&lt;String&gt; pokerList = new ArrayList&lt;&gt;(Arrays.asList(poker)); String[] p1Arr = p1.split("\\s+"); String[] p2Arr = p2.split("\\s+"); int p1Len = p1Arr.length; int p2Len = p2Arr.length; //先判断有王炸的 if(p1.equals("joker JOKER")||p2.equals("joker JOKER")) return "joker JOKER"; //判断炸弹 if((p1Len==4&amp;&amp;p2Len!=4)||(p1Len!=4&amp;&amp;p2Len==4))&#123; if(p1Len==4) return p1; else return p2; &#125; if((p1Len==4&amp;&amp;p2Len==4)||//判断炸弹 (p1Len==2&amp;&amp;p2Len==2)||//判断对子 (p1Len==5&amp;&amp;p2Len==5)||//顺子 (p1Len==1&amp;&amp;p2Len==1)||//单牌 (p1Len==3&amp;&amp;p2Len==3)) //三个牌 return pokerList.indexOf(p1Arr[0])&gt;pokerList.indexOf(p2Arr[0])?p1:p2; return "ERROR"; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String[] poker = scanner.nextLine().split("\\-"); System.out.println(comparePoker(poker[0],poker[1])); &#125; scanner.close(); &#125;&#125; 24点运算合法IP12345678910111213141516171819202122232425import java.util.*;public class Main&#123; public static String isValidFormat(String ip)&#123; if(!ip.matches("^(\\d+).(\\d+).(\\d+).(\\d+)$"))&#123; return "NO"; &#125; String ipArr[] = ip.split("\\."); for(String s:ipArr)&#123; int temp = Integer.parseInt(s); if(temp&lt;0||temp&gt;255) return "NO"; &#125; return "YES"; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String ip = scanner.nextLine(); System.out.println(isValidFormat(ip)); &#125; scanner.close(); &#125;&#125; Java题目2-3级在字符串中找出连续最长的数字串12345678910111213141516171819202122232425262728import java.util.*;public class Main&#123; public static String getMaxDigitString(String s)&#123; String[] split = s.split("[^0-9]+"); StringBuilder sb = new StringBuilder(); int length = split.length; int max = 0; for(String ss:split)&#123; if(ss.length()&gt;max) max = ss.length(); &#125; for(int i=0;i&lt;length;i++)&#123; if(split[i].length()==max)&#123; sb.append(split[i]); &#125; &#125; return sb.append(","+max).toString(); &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String s = scanner.nextLine(); System.out.println(getMaxDigitString(s)); &#125; scanner.close(); &#125;&#125; Java题目0-1级1234567891011121314151617181920212223242526import java.util.*;public class Main &#123; public static void main(String args[])&#123; Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) &#123; int n = scanner.nextInt(); int[] nums = new int[n]; int index = 0,sum1 = 0,sum2 = 0; for(int i=0;i&lt;n;i++)&#123; int tmp = scanner.nextInt(); if(tmp % 5 == 0) sum1 += tmp; else if (tmp % 3 == 0) sum2 += tmp; else nums[index++] = tmp; &#125; System.out.println(isExists(sum1, sum2, nums, 0)); &#125; scanner.close(); &#125; public static boolean isExists(int sum1,int sum2,int[] nums,int index)&#123; if(index == nums.length &amp;&amp; sum1 != sum2) return false; if(index == nums.length &amp;&amp; sum1 == sum2) return true; if(index &lt; nums.length) return isExists(sum1+nums[index], sum2, nums, index+1) || isExists(sum1, sum2+nums[index], nums, index+1); return false; &#125;&#125; 记票统计123456789101112131415161718192021222324252627282930import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; int n = Integer.parseInt(scanner.next()); Map&lt;String,Integer&gt; map = new LinkedHashMap&lt;&gt;(); List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(int i=0;i&lt;n;i++) list.add(scanner.next()); int m = Integer.parseInt(scanner.next()); int invalid = 0; for(int i=0;i&lt;m;i++)&#123; String temp = scanner.next(); if(list.indexOf(temp)&gt;-1)&#123; map.put(temp,map.get(temp)==null?1:map.get(temp)+1); &#125;else&#123; invalid++; &#125; &#125; for(String s:list)&#123; Integer tt = map.get(s)==null?0:map.get(s); System.out.println(s+" : "+tt); &#125; System.out.println("Invalid : "+invalid); &#125; scanner.close(); &#125;&#125; 人民币转换表示数字1234567891011121314151617181920import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; char[] ch = scanner.nextLine().toCharArray(); StringBuilder sb = new StringBuilder(); for(char c:ch)&#123; String temp = String.valueOf(c); if(temp.matches("[0-9]")) sb.append("*"+temp+"*"); else sb.append(temp); &#125; System.out.println(sb.toString().replaceAll("\\*&#123;2&#125;","")); &#125; scanner.close(); &#125;&#125; 记负均正12345678910111213141516171819202122232425262728import java.util.*;import java.text.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int sum = 0; int minus = 0; int n = scanner.nextInt(); int zero = 0; for(int i=0;i&lt;n;i++)&#123; int temp = scanner.nextInt(); if(temp&lt;0) minus++; else sum+=temp; if(temp==0) zero++; &#125; int pos = n-minus-zero; double even = (double)sum/pos; DecimalFormat sf = new DecimalFormat("0.0"); System.out.println(minus+" "+sf.format(even)); &#125; scanner.close(); &#125;&#125; 自动售货系统自守数123456789101112131415161718192021222324import java.util.*;public class Main&#123; public static int getSelfNum(int n)&#123; int count = 0; for(int i=0;i&lt;=n;i++)&#123; String value = String.valueOf(i*i); String key = String.valueOf(i); int length = key.length(); if(value.substring(value.length()-length).equals(key)) count++; &#125; return count; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int n = scanner.nextInt(); System.out.println(getSelfNum(n)); &#125; scanner.close(); &#125;&#125; 等差数列(Arithmetic Progression)1234567891011121314151617import java.util.*;//Arithmetic Progression //an = a1+(n-1)d//Sn = na1+[n(n-1)/2]*dpublic class Main&#123; public static int getAS(int n,int a1,int d)&#123; return a1*n+d*(n*(n-1))/2; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int n = scanner.nextInt(); System.out.println(getAS(n,2,3)); &#125; scanner.close(); &#125;&#125;]]></content>
      <categories>
        <category>HUAWEI</category>
      </categories>
      <tags>
        <tag>HUAWEI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为OJ（四）]]></title>
    <url>%2F2018%2F04%2F07%2F%E5%8D%8E%E4%B8%BAOJ%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[华为OJ 放苹果查找输入整数二进制中1的个数123456789101112131415161718import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; Integer key = scanner.nextInt(); char[] arr = Integer.toBinaryString(key).toCharArray(); int count = 0; for(char c:arr)&#123; if(c=='1') count++; &#125; System.out.println(count); &#125; scanner.close(); &#125;&#125; DNA序列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import java.util.*;public class Main&#123; public static void getSubstring(List&lt;String&gt; list,String s)&#123; int length = s.length(); for(int i=0;i&lt;length-1;i++)&#123; for(int j=i+1;j&lt;length;j++)&#123; list.add(s.substring(i,j)); if(j==length-1&amp;&amp;i!=0)&#123; list.add(String.valueOf(s.charAt(j))); list.add(s.substring(i)); &#125; &#125; &#125; &#125; public static String getMaxGCRadio(List&lt;String&gt; list,int length)&#123; List&lt;String&gt; subList = new ArrayList&lt;&gt;(); String maxGCString = null; for(String s:list)&#123; if(s.length()==length) subList.add(s); &#125; Map&lt;String,Double&gt; map = new LinkedHashMap&lt;&gt;(); for(String s:subList)&#123; double gcNum = 0; double gcRadio = 0; char ch[] = s.toCharArray(); for(char c:ch)&#123; if(c=='G'||c=='C') gcNum++; &#125; gcRadio = gcNum/length; if(map.get(s)!=null) continue; else map.put(s,gcRadio); &#125; Collection&lt;Double&gt; values = map.values(); if(values.size()&gt;0)&#123; double maxGCRadio = Collections.max(values); for(String key:map.keySet())&#123; if(map.get(key)==maxGCRadio)&#123; maxGCString = key; break; &#125; &#125; &#125; return maxGCString; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String s = scanner.nextLine(); int length = Integer.parseInt(scanner.nextLine()); List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add(s); getSubstring(list,s); System.out.println(getMaxGCRadio(list,length)); &#125; scanner.close(); &#125;&#125; 查找两个子串a,b中最长的公共子串1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Main&#123; public static List&lt;String&gt; getSubstring(String s)&#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); int length = s.length(); for(int i=0;i&lt;length-1;i++)&#123; for(int j=i+1;j&lt;length;j++)&#123; list.add(s.substring(i,j)); if(j==length-1&amp;&amp;i!=0)&#123; list.add(String.valueOf(s.charAt(j))); list.add(s.substring(i)); &#125; &#125; &#125; return list; &#125; public static String getMaxSubstring(String s1,String s2)&#123; String maxSubstring = ""; if(s1.equals(s2))&#123; return s2; &#125; int len1 = s1.length(); int len2 = s2.length(); String max = len1&gt;len2?s1:s2; String min = len1&lt;len2?s1:s2; if(max.contains(min))&#123; return min; &#125; List&lt;String&gt; list = getSubstring(min); for(String s:list)&#123; if(max.contains(s)&amp;&amp;s.length()&gt;maxSubstring.length()) maxSubstring = s; &#125; return maxSubstring; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String s1 = scanner.nextLine(); String s2 = scanner.nextLine(); System.out.println(getMaxSubstring(s1,s2)); &#125; scanner.close(); &#125;&#125; 配置文件恢复24点成绩排序12345678910111213141516171819202122232425262728293031323334353637383940import java.util.*;import java.util.Map.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; int n = Integer.parseInt(scanner.nextLine()); int flag = Integer.parseInt(scanner.nextLine()); Map&lt;String,Integer&gt; map = new LinkedHashMap&lt;&gt;(); for(int i=0;i&lt;n;i++)&#123; String[] tempArr = scanner.nextLine().split("\\s+"); if(map.get(tempArr[0])==null)&#123; map.put(tempArr[0],Integer.parseInt(tempArr[1])); &#125;else&#123; map.put(tempArr[0]+Math.random(),Integer.parseInt(tempArr[1])); &#125; &#125; List&lt;Map.Entry&lt;String,Integer&gt;&gt; list = new ArrayList&lt;&gt;(map.entrySet()); Collections.sort(list,new Comparator&lt;Map.Entry&lt;String,Integer&gt;&gt;()&#123; @Override public int compare(Entry&lt;String, Integer&gt; o1, Entry&lt;String, Integer&gt; o2) &#123; if(flag==0) return o2.getValue().compareTo(o1.getValue()); else return o1.getValue().compareTo(o2.getValue()); &#125; &#125;); for(Map.Entry&lt;String,Integer&gt; entry:list)&#123; String key = entry.getKey(); int zeroIndex = -1; if((zeroIndex = key.indexOf("0"))&gt;=0)&#123; key = key.substring(0,zeroIndex); &#125; System.out.println(key+" "+entry.getValue()); &#125; &#125; scanner.close(); &#125;&#125; 乘法矩阵1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.util.*;public class Main&#123; public static void getMatrixMultiply(int[][] matrix_1,int[][] matrix_2,int row1, int col1_row2,int col2)&#123; int[][] result = new int[row1][col2]; StringBuilder sb = new StringBuilder(); String[] rowArr = new String[col2]; String[] colArr = new String[row1]; List&lt;String&gt; rowList = new ArrayList&lt;&gt;(); List&lt;String&gt; colList = new ArrayList&lt;&gt;(); StringBuilder sbRow = new StringBuilder(); for(int i=0;i&lt;row1;i++)&#123; for(int j=0;j&lt;col1_row2;j++)&#123; sbRow.append(matrix_1[i][j]+" "); &#125; rowList.add(sbRow.toString().trim()); sbRow.setLength(0); &#125; StringBuilder sbCol = new StringBuilder(); for(int i=0;i&lt;col2;i++)&#123; for(int j=0;j&lt;col1_row2;j++)&#123; sbCol.append(matrix_2[j][i]+" "); &#125; colList.add(sbCol.toString().trim()); sbCol.setLength(0); &#125; for(int i=0;i&lt;row1;i++)&#123; rowArr = rowList.get(i).split("\\s+"); for(int j=0;j&lt;col2;j++)&#123; int tempValue = 0; colArr = colList.get(j).split("\\s+"); for(int n=0;n&lt;colArr.length;n++)&#123; tempValue+=Integer.parseInt(colArr[n])*Integer.parseInt(rowArr[n]); &#125; result[i][j] = tempValue; sb.append(tempValue+" "); &#125; sb.append(","); &#125; String ss[] = sb.toString().split(","); for(String s:ss)&#123; System.out.println(s.trim()); &#125; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int row1 = scanner.nextInt(); int col1_row2 = scanner.nextInt(); int col2 = scanner.nextInt(); int[][] matrix_1 = new int[row1][col1_row2]; int[][] matrix_2 = new int[col1_row2][col2]; for(int i=0;i&lt;row1;i++)&#123; for(int j=0;j&lt;col1_row2;j++)&#123; matrix_1[i][j] = scanner.nextInt(); &#125; &#125; for(int i=0;i&lt;col1_row2;i++)&#123; for(int j=0;j&lt;col2;j++)&#123; matrix_2[i][j] = scanner.nextInt(); &#125; &#125; getMatrixMultiply(matrix_1,matrix_2,row1,col1_row2,col2); &#125; scanner.close(); &#125;&#125; 乘法矩阵计算量估计字符串通配符12345678910111213141516171819202122import java.util.*;import java.util.regex.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String regex = scanner.nextLine(); regex = regex.replaceAll("\\?","[a-zA-Z0-9]&#123;1&#125;"); regex = regex.replaceAll("\\*","[a-zA-Z0-9]*"); //System.out.println(Pattern.matches("^"+regex+"$", scanner.nextLine())); System.out.println(scanner.nextLine().matches(regex)); &#125; scanner.close(); &#125;&#125;/**正则表达式的[]只是说在这里面选，但是+，*还是写在外面的，？代表的是&#123;0,1&#125;\\w+代表的是[0-9A-Za-z_]+*/ 百钱买百鸡1234567891011121314151617181920212223242526import java.util.*;public class Main&#123; public static void getChicken(int no_relate)&#123; StringBuilder sb = new StringBuilder(); for(int x=0;x&lt;=20;x++)&#123; for(int y=0;y&lt;=33;y++)&#123; for(int z=0;z&lt;=100;z++)&#123; if(x+y+z==100 &amp;&amp; (5*x+3*y+z/3)==100 &amp;&amp; z%3==0) sb.append(x+" "+y+" "+z+","); &#125; &#125; &#125; for(String s:sb.toString().split(","))&#123; System.out.println(s); &#125; &#125; public static void main(String args[])&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; getChicken(scanner.nextInt()); &#125; scanner.close(); &#125;&#125; 计算日期到天数转换123456789101112131415161718192021import java.util.*;public class Main&#123; public static int getDateToDays(int year,int month,int day)&#123; int[] months = &#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;; if(year%4==0) months[1] = 29; int days = 0; for(int i=0;i&lt;month-1;i++)&#123; days+=months[i]; &#125; return days+day; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; System.out.println(getDateToDays(scanner.nextInt(),scanner.nextInt(),scanner.nextInt())); &#125; scanner.close(); &#125;&#125; 参数解析(正则)1234567891011121314151617181920212223242526272829303132333435363738public class Main&#123; public static List&lt;String&gt; getParams(String s)&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); StringBuilder sb = new StringBuilder(); String arr[] = s.split("\\s+"); //System.out.println(Arrays.toString(arr)); for(String temp:arr)&#123; if(!temp.startsWith("\"")&amp;&amp;!temp.endsWith("\""))&#123; list.add(temp); &#125;else if(temp.startsWith("\"")&amp;&amp;temp.endsWith("\""))&#123; list.add(temp.substring(1, temp.length()-1)); &#125;else&#123; if(temp.endsWith("\""))&#123; temp =" "+temp; &#125; sb.append(temp); String ss = sb.toString(); if(ss.startsWith("\"")&amp;&amp;ss.endsWith("\""))&#123; list.add(ss.substring(1, ss.length()-1)); sb.setLength(0); &#125; &#125; &#125; return list; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; List&lt;String&gt; list = getParams(scanner.nextLine()); System.out.println(list.size()); for(String s:list)&#123; System.out.println(s); &#125; &#125; scanner.close(); &#125;&#125; 最长公共子串（LCS）123456789101112131415161718192021222324252627import java.util.*;public class Main&#123; public static int getLCSubstring(String s1,String s2)&#123; int len1 = s1.length(); int len2 = s2.length(); int[][] result = new int[len1+1][len2+1]; int max = 0; for(int i=1;i&lt;=len1;i++)&#123; for(int j=1;j&lt;=len2;j++)&#123; if(s1.charAt(i-1)==s2.charAt(j-1))&#123; result[i][j] = result[i-1][j-1]+1; max = Math.max(max,result[i][j]); &#125; &#125; &#125; return max; &#125; public static void main(String args[])&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; System.out.println(getLCSubstring(scanner.next(),scanner.next())); &#125; scanner.close(); &#125;&#125; 尼克彻斯定理1234567891011121314151617181920212223242526272829303132333435363738public class Main&#123; public static List&lt;Integer&gt; getOddList(int n)&#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i=1;i&lt;=n;i++) if(i%2!=0) list.add(i); return list; &#125; public static String getOddString(int key)&#123; int multi = (int)Math.pow(key,3.0); List&lt;Integer&gt; list = getOddList(multi); int size = list.size(); StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;=size/2;i++)&#123; int sum = 0; for(int j=0;j&lt;key;j++) sum+=list.get(i+j); if(sum==multi)&#123; for(int j=0;j&lt;key;j++) sb.append(list.get(i+j)+"+"); break; &#125; &#125; String result = sb.toString(); return result.substring(0,result.length()-1); &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; System.out.println(getOddString(scanner.nextInt())); &#125; scanner.close(); &#125;&#125; 火车进站超长正整数相加1234567891011121314import java.util.*;import java.math.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; BigInteger b1 = new BigInteger(scanner.nextLine()); BigInteger b2 = new BigInteger(scanner.nextLine()); System.out.println(b1.add(b2)); &#125; scanner.close(); &#125;&#125; 字符串相似度（EDS）123456789101112131415161718192021222324252627282930313233343536import java.util.*;public class Main&#123; public static int getEDS(String s1,String s2)&#123; int len1 = s1.length(); int len2 = s2.length(); int[][] edit = new int[len1+1][len2+1]; for(int i=0;i&lt;=len1;i++)&#123; for(int j=0;j&lt;=len2;j++)&#123; if(i==0)&#123; edit[i][j] = j; &#125;else if(j==0)&#123; edit[i][j] = i; &#125;else if(s1.charAt(i-1)==s2.charAt(j-1))&#123; edit[i][j] = edit[i-1][j-1]; &#125;else&#123; edit[i][j] = Math.min(edit[i-1][j]+1, Math.min(edit[i][j-1]+1,edit[i-1][j-1]+1)); &#125; &#125; &#125; return edit[len1][len2]; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String s1 = scanner.nextLine(); String s2 = scanner.nextLine(); System.out.println("1/"+(getEDS(s1,s2)+1)); &#125; scanner.close(); &#125;&#125; 整形数组合并12345678910111213141516171819202122import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); StringBuilder sb = new StringBuilder(); int n1 = scanner.nextInt(); for(int i=0;i&lt;n1;i++) set.add(scanner.nextInt()); int n2 = scanner.nextInt(); for(int i=0;i&lt;n2;i++) set.add(scanner.nextInt()); for(Integer i : set) sb.append(i); System.out.println(sb); &#125; scanner.close(); &#125;&#125;]]></content>
      <categories>
        <category>HUAWEI</category>
      </categories>
      <tags>
        <tag>HUAWEI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为OJ（三）]]></title>
    <url>%2F2018%2F04%2F06%2F%E5%8D%8E%E4%B8%BAOJ%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[华为OJ 称砝码学英语迷宫问题Sudoku-Java名字的漂亮度题目描述 给出一个名字，该名字有26个字符串组成，定义这个字符串的“漂亮度”是其所有字母“漂亮度”的总和。 每个字母都有一个“漂亮度”，范围在1到26之间。没有任何两个字母拥有相同的“漂亮度”。字母忽略大小写。 给出多个名字，计算每个名字最大可能的“漂亮度”。 输入描述: 整数N，后续N个名字 输出描述: 每个名称可能的最大漂亮程度 示例1 输入 2 zhangsan lisi 输出 192 101 123456789101112131415161718192021222324252627282930313233343536import java.util.*;import java.util.Map.*;public class Main&#123; public static int getBeautyScore(String s)&#123; Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); char[] arr = s.toCharArray(); for(char c:arr)&#123; map.put(c,map.get(c)==null?1:map.get(c)+1); &#125; List&lt;Map.Entry&lt;Character,Integer&gt;&gt; list = new ArrayList&lt;&gt;(map.entrySet()); Collections.sort(list,new Comparator&lt;Map.Entry&lt;Character,Integer&gt;&gt;()&#123; @Override public int compare(Entry&lt;Character,Integer&gt; o1,Entry&lt;Character,Integer&gt; o2)&#123; return o2.getValue().compareTo(o1.getValue()); &#125; &#125;); int beautyScore = 0; int apl = 26; for(Entry&lt;Character,Integer&gt; entry : list)&#123; beautyScore+=(entry.getValue()*(apl--)); &#125; return beautyScore; &#125; public static void main(String args[])&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; int num = Integer.parseInt(scanner.nextLine()); for(int i=0;i&lt;num;i++)&#123; System.out.println(getBeautyScore(scanner.nextLine())); &#125; &#125; scanner.close(); &#125;&#125; 按字节截取字符串题目描述 编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串。但是要保证汉字不被截半个，如&quot;我ABC&quot;4，应该截为&quot;我AB&quot;，输入&quot;我ABC汉DEF&quot;6，应该输出为&quot;我ABC&quot;而不是&quot;我ABC+汉的半个&quot;。 输入描述: 输入待截取的字符串及长度 输出描述: 截取后的字符串 示例1 输入 我ABC汉DEF 6 输出 我ABC 12345678910111213141516171819202122232425262728293031323334import java.util.*;public class Main&#123; public static String getSplitString(String s,Integer length)&#123; int s_Length = s.length(); char[] arr = s.toCharArray(); StringBuilder sb = new StringBuilder(); int byteNum=0; for(char c : arr)&#123; String temp = String.valueOf(c); if(temp.matches("\\w+"))&#123; byteNum++; &#125;else&#123; byteNum+=2; &#125; if(byteNum&lt;=length)&#123; sb.append(temp); &#125;else&#123; break; &#125; &#125; return sb.toString(); &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; String str = scanner.next(); int length = Integer.parseInt(scanner.next()); System.out.println(getSplitString(str,length)); &#125; scanner.close(); &#125;&#125; 线性插值假设第M个测量结果的测量值为A，第N个测量结果的测量值为B。则需要进行(N-M-1)个测量结果的插值处理。进行一阶线性插值估计的第N+i个测量结果的测量值为A+( (B-A)/(N-M) )*i (注：N的编号比M大。) 例如：只有测量编号为4的测量结果和测量编号为7的测量结果，测量值分别为4和10 则需要补充测量编号为5和6的测量结果。 其中测量编号为5的测量值=4 + ((10-4)/(7-4))*1 = 6 其中测量编号为6的测量值=4 + ((10-4)/(7-4))*2 = 8 2.测量编号相同，则认为测量结果重复，需要对丢弃后来出现的测量结果. 输入描述: 输入说明 1 输入两个整数m, n 2 输入m个数据组 输出描述: 输出整理后的结果 示例1 输入 2 3 4 5 5 7 输出 4 5 5 7 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*只通过70%是因为当遇到重复项时,我们应该丢弃后出现的(这是题目要求),这时应该用一对变量来保存第一次出现的重复值,比如(n没啥用)4 n23 546 25 (程序中用KEY和VALUE来保存他们)46 32 (舍弃该对数值)82 46 (应用82和46进行比较)对着这个例子把我的程序走一遍就全懂了!就是这么简单,花了我一上午*/ import java.util.Scanner;import java.util.ArrayList;public class Main&#123; public static void main(String[] args)&#123; Scanner sc=new Scanner(System.in); while(sc.hasNext())&#123; int n=sc.nextInt(); int m=sc.nextInt(); //二维数组存储键值对 int[][] data=new int[n][2]; for(int i=0;i&lt;n;i++)&#123; data[i][0]=sc.nextInt(); data[i][1]=sc.nextInt(); &#125; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); //若出现重复值,利用这两个变量存储前一个值,丢弃后出现的重复值(如题目要求) int KEY=data[0][0]; int VALUE=data[0][1]; list.add(KEY+" "+VALUE); for(int i=1;i&lt;=n-1;i++)&#123; int diff=data[i][0]-KEY-1; if(diff&gt;0)&#123; for(int j=1;j&lt;=diff;j++)&#123; int key=KEY+j; int value=VALUE+(data[i][1]-VALUE)/(data[i][0]-KEY)*j; list.add(key+" "+value); &#125; list.add(data[i][0]+" "+data[i][1]); KEY=data[i][0]; VALUE=data[i][1]; //两个键相等则直接跳过,此时KEY,VVALUE保存的还是上一个值 &#125;else if(diff==-1) continue; else&#123; list.add(data[i][0]+" "+data[i][1]); KEY=data[i][0]; VALUE=data[i][1]; &#125; &#125; for(String s:list) System.out.println(s); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String[] n_Arr = scanner.nextLine().split("\\s+"); int n = Integer.parseInt(n_Arr[0]); int[][] measure = new int[n][2]; for(int i=0;i&lt;n;i++)&#123; String temp[] = scanner.nextLine().split("\\s+"); measure[i][0] = Integer.parseInt(temp[0]); measure[i][1] = Integer.parseInt(temp[1]); &#125; List&lt;String&gt; list = new ArrayList&lt;&gt;(); int key = measure[0][0]; int value = measure[0][1]; list.add(key+" "+value); for(int i=0;i&lt;n-1;i++)&#123; int gap = measure[i+1][0] - key;//计算编号的差距 if(gap&gt;1)&#123;//大的超过1，插入n-1个值后，把自己再插进去，更新key，value int cir = gap-1; for(int j=1;j&lt;=cir;j++)&#123; int temp_key = key+j; //注意，这里的value是每次更新了的，和measure[i][1]不是一个值 //就是说，一旦出现key重复的情况，我们用的是上一次算出来的值！！！ //比如说17 28,19 33,19 44,22 99 //17到19中间有了18，然后插入19，这个时候的计算19到22之间的值的时候用的 //应该是33有也就是更新了的value，而不是measure[i][1]也就是44 //（因为measure这个数组中可是不去重的） int temp_value = value+((measure[i+1][1]-value)/gap)*j; list.add(temp_key+" "+temp_value); &#125; key = measure[i+1][0]; value = measure[i+1][1]; list.add(key+" "+value); &#125;else if(gap==0)&#123;//编号一致，直接忽略 continue; &#125;else&#123;//后面的编号小或者正好大一个，直接插入后面的这个，更新key，value key = measure[i+1][0]; value = measure[i+1][1]; list.add(key+" "+value); &#125; &#125; for(String s:list)&#123; System.out.println(s); &#125; &#125; scanner.close(); &#125;&#125; 单向链表中删除指定值的节点示例1 输入 5 2 3 2 4 3 5 2 1 4 3 输出 2 1 5 4 1234567891011121314151617181920212223242526272829303132import java.util.*;/**这个题的测试用例是错的，我们直接写就可以了第一个数是插入什么数字，第二个数是插入到哪一个数字之后。因为只删除了一个数，所以可以考虑用list*/public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int n = scanner.nextInt(); int f_Num = scanner.nextInt(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(f_Num); for(int i=0;i&lt;n-1;i++)&#123; int value = scanner.nextInt(); int bofore_value = scanner.nextInt(); int index = list.indexOf(bofore_value); list.add(index+1,value); &#125; Object remove_value = scanner.nextInt();//这个地方需要是一个Object，如果是int，会调另一个重载的方法 list.remove(remove_value); StringBuilder sb = new StringBuilder(); for(Integer i : list)&#123; sb.append(i+" "); &#125; System.out.println(sb);//最后一个也要有空格 &#125; scanner.close(); &#125;&#125; 多线程（投机取巧）12345678910111213141516import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int n = scanner.nextInt(); StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;n;i++)&#123; sb.append("ABCD"); &#125; System.out.println(sb); &#125; scanner.close(); &#125;&#125; 四则运算123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import java.util.*;public class Main&#123; public static List&lt;String&gt; getExpression(String exp)&#123; exp = exp.replaceAll("[\\&#123;\\[]", "("); exp = exp.replaceAll("[\\&#125;\\]]", ")"); int length = exp.length(); StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;length;i++)&#123; String temp = String.valueOf(exp.charAt(i)); if(!temp.matches("\\d+"))&#123; sb.append("#"); sb.append(temp); sb.append("#"); &#125;else&#123; sb.append(temp); &#125; &#125; return new ArrayList&lt;String&gt;(Arrays.asList(sb.toString().split("\\#+"))); &#125; //大于的直接压栈，小于等于的弹出，直到遇到左括号，或者比压栈的小的，或者栈为null，才会压栈 public static List&lt;String&gt; inSuffixToPostSuffix(List&lt;String&gt; list)&#123; Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); String popPeak = null; List&lt;String&gt; result = new ArrayList&lt;&gt;(); for(String s:list)&#123; s = s.trim(); switch(s)&#123; case "(": stack.push(s); break; case ")": while(stack.size()!=0)&#123; popPeak = stack.pop(); if(popPeak.equals("("))&#123; break; &#125;else&#123; result.add(popPeak); &#125; &#125; break; case "+": case "-": while(stack.size()!=0)&#123; popPeak = stack.pop(); if(popPeak.equals("("))&#123; stack.push(popPeak); break; &#125;else&#123; result.add(popPeak); &#125; &#125; stack.push(s); break; case "/": case "*": while(stack.size()!=0)&#123; popPeak = stack.pop(); if(popPeak.matches("[\\(\\+\\-]"))&#123; stack.push(popPeak); break; &#125;else&#123; result.add(popPeak); &#125; &#125; stack.push(s); break; default: stack.push(s); break; &#125; &#125; while(stack.size()!=0)&#123; result.add(stack.pop()); &#125; return result; &#125; public static int getResult(List&lt;String&gt; list)&#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(String s:list)&#123; if(s.trim().length()&gt;0&amp;&amp;s.matches("\\d+"))&#123; stack.push(Integer.parseInt(s.trim())); &#125;else&#123; if(stack.size()&gt;1)&#123; int f_num = stack.pop(); int s_num = stack.pop(); stack.push(calculate(s_num,f_num,s)); &#125; &#125; &#125; return stack.pop(); &#125; public static int calculate(int f,int s,String symbol)&#123; if(symbol.equals("+"))&#123; return f+s; &#125;else if(symbol.equals("-"))&#123; return f-s; &#125;else if(symbol.equals("*"))&#123; return f*s; &#125;else&#123; return f/s; &#125; &#125; public static void main(String[] args)&#123; // System.out.println(getExpression("9+(3-1)*3+10/2")); // System.out.println(inSuffixToPostSuffix(getExpression("9+(3-1)*3+10/2"))); // System.out.println(getResult(inSuffixToPostSuffix(getExpression("9+(3-1)*3+10/2")))); Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String expression = scanner.nextLine(); System.out.println(getResult(inSuffixToPostSuffix(getExpression(expression)))); &#125; scanner.close(); &#125;&#125; 输出单向链表中倒数第K个结点输入 8 1 2 3 4 5 6 7 8 4 输出 5 1234567891011121314151617181920212223import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int n = scanner.nextInt(); List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for(int i=0;i&lt;n;i++)&#123; list.add(scanner.nextInt()); &#125; int remove_index = scanner.nextInt(); if(remove_index==0)&#123; System.out.println(0); &#125;else&#123; remove_index = n-remove_index;//+1-1; System.out.println(list.get(remove_index)); &#125; &#125; scanner.close(); &#125;&#125; 计算字符串的距离12345678910111213141516171819202122232425262728293031323334353637import java.util.*;//EDSpublic class Main&#123; public static int getEDS(String s1,String s2)&#123; int len1 = s1.length(); int len2 = s2.length(); int edit[][] = new int[len1+1][len2+1]; if(s1.equals(s2)||s1==null||s2==null)&#123; return 0; &#125; for(int i=0;i&lt;=len1;i++)&#123; for(int j=0;j&lt;=len2;j++)&#123; if(i==0)&#123; edit[i][j] = j; &#125;else if(j==0)&#123; edit[i][j] = i; &#125;else&#123; if(s1.charAt(i-1)==s2.charAt(j-1))&#123; edit[i][j] = edit[i-1][j-1]; &#125;else&#123; edit[i][j] = Math.min(edit[i][j-1]+1,Math.min(edit[i-1][j]+1,edit[i-1][j-1]+1)); &#125; &#125; &#125; &#125; return edit[len1][len2]; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; System.out.println(getEDS(scanner.nextLine(),scanner.nextLine())); &#125; scanner.close(); &#125;&#125; 杨辉三角（INOC产品部）123456789101112131415161718192021222324import java.util.*;/**//当n&lt;3时，没有偶数，输出-1；//当n为奇数时，第一个偶数位置在第二，输出2；//当n为偶数且能被4整除时，第一个偶数位置在第三，输出3；//当n为偶数但不能被4整除时，偶数位置在第四，输出4*/public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int n = scanner.nextInt(); if(n&lt;=2) System.out.println(-1); else if(n%2==1) System.out.println(2); else if(n%4==0) System.out.println(3); else System.out.println(4); &#125; scanner.close(); &#125;&#125; 表达式求值123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import java.util.*;public class Main&#123; public static List&lt;String&gt; getExpression(String exp)&#123; exp = exp.replaceAll("[\\&#123;\\[]", "("); exp = exp.replaceAll("[\\&#125;\\]]", ")"); int length = exp.length(); StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;length;i++)&#123; String temp = String.valueOf(exp.charAt(i)); if(!temp.matches("\\d+"))&#123; sb.append("#"); sb.append(temp); sb.append("#"); &#125;else&#123; sb.append(temp); &#125; &#125; return new ArrayList&lt;String&gt;(Arrays.asList(sb.toString().split("\\#+"))); &#125; //大于的直接压栈，小于等于的弹出，直到遇到左括号，或者比压栈的小的，或者栈为null，才会压栈 public static List&lt;String&gt; inSuffixToPostSuffix(List&lt;String&gt; list)&#123; Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); String popPeak = null; List&lt;String&gt; result = new ArrayList&lt;&gt;(); for(String s:list)&#123; s = s.trim(); switch(s)&#123; case "(": stack.push(s); break; case ")": while(stack.size()!=0)&#123; popPeak = stack.pop(); if(popPeak.equals("("))&#123; break; &#125;else&#123; result.add(popPeak); &#125; &#125; break; case "+": case "-": while(stack.size()!=0)&#123; popPeak = stack.pop(); if(popPeak.equals("("))&#123; stack.push(popPeak); break; &#125;else&#123; result.add(popPeak); &#125; &#125; stack.push(s); break; case "/": case "*": while(stack.size()!=0)&#123; popPeak = stack.pop(); if(popPeak.matches("[\\(\\+\\-]"))&#123; stack.push(popPeak); break; &#125;else&#123; result.add(popPeak); &#125; &#125; stack.push(s); break; default: stack.push(s); break; &#125; &#125; while(stack.size()!=0)&#123; result.add(stack.pop()); &#125; return result; &#125; public static int getResult(List&lt;String&gt; list)&#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(String s:list)&#123; if(s.trim().length()&gt;0&amp;&amp;s.matches("\\d+"))&#123; stack.push(Integer.parseInt(s.trim())); &#125;else&#123; if(stack.size()&gt;1)&#123; int f_num = stack.pop(); int s_num = stack.pop(); stack.push(calculate(s_num,f_num,s)); &#125; &#125; &#125; return stack.pop(); &#125; public static int calculate(int f,int s,String symbol)&#123; if(symbol.equals("+"))&#123; return f+s; &#125;else if(symbol.equals("-"))&#123; return f-s; &#125;else if(symbol.equals("*"))&#123; return f*s; &#125;else&#123; return f/s; &#125; &#125; public static void main(String[] args)&#123; // System.out.println(getExpression("9+(3-1)*3+10/2")); // System.out.println(inSuffixToPostSuffix(getExpression("9+(3-1)*3+10/2"))); // System.out.println(getResult(inSuffixToPostSuffix(getExpression("9+(3-1)*3+10/2")))); Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String expression = scanner.nextLine(); System.out.println(getResult(inSuffixToPostSuffix(getExpression(expression)))); &#125; scanner.close(); &#125;&#125; 挑 7123456789101112131415161718192021222324import java.util.*;public class Main&#123; public static int getSeven(int key)&#123; int count = 0; if(key&lt;7)&#123; return 0; &#125; for(int i=7;i&lt;=key;i++)&#123; String temp = String.valueOf(i); if(i%7==0||temp.contains("7")) count++; &#125; return count; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; System.out.println(getSeven(scanner.nextInt())); &#125; scanner.close(); &#125;&#125; 完全数12345678910111213141516171819202122232425262728293031323334public class Main&#123; public static boolean isCompleteNum(int num)&#123; int sum = 0; for(int i=1;i&lt;num;i++)&#123; if(num%i==0) sum+=i; &#125; if(sum==num) return true; else return false; &#125; public static int getComplete(int num)&#123; if(num==1) return 1; if(num&lt;1) return 0; int count = 0; for(int i=1;i&lt;=num;i++)&#123; if(isCompleteNum(i)) count++; &#125; return count; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; System.out.println(getComplete(scanner.nextInt())); &#125; scanner.close(); &#125;&#125; 无线OSS（BigInteger）1234567891011121314import java.util.*;import java.math.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; BigInteger b1 = new BigInteger(scanner.next()); BigInteger b2 = new BigInteger(scanner.next()); System.out.println(b1.add(b2)); &#125; scanner.close(); &#125;&#125; 输入n个整数，输出其中最小的k个12345678910111213141516171819202122import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int n = scanner.nextInt(); int min = scanner.nextInt(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i=0;i&lt;n;i++)&#123; list.add(scanner.nextInt()); &#125; Collections.sort(list); StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;min;i++)&#123; sb.append(list.get(i)+" "); &#125; System.out.println(sb.toString().trim()); &#125; scanner.close(); &#125;&#125; 找出字符串中第一个只出现一次的字符12345678910111213141516171819202122232425262728293031import java.util.*;import java.util.Map.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; Map&lt;Character,Integer&gt; map = new LinkedHashMap&lt;&gt;(); char arr[] = scanner.nextLine().toCharArray(); for(char c:arr)&#123; map.put(c,map.get(c)==null?1:map.get(c)+1); &#125; List&lt;Map.Entry&lt;Character,Integer&gt;&gt; list = new ArrayList&lt;&gt;(map.entrySet()); Collections.sort(list,new Comparator&lt;Map.Entry&lt;Character,Integer&gt;&gt;()&#123; @Override public int compare(Entry&lt;Character,Integer&gt; o1,Entry&lt;Character,Integer&gt; o2)&#123; return o1.getValue().compareTo(o2.getValue()); &#125; &#125;); for(Map.Entry&lt;Character,Integer&gt; entry:list)&#123; if(entry.getValue()==1)&#123; System.out.println(entry.getKey()); &#125;else&#123; System.out.println(-1); &#125; break; &#125; &#125; scanner.close(); &#125;&#125; 查找组成一个偶数最接近的两个素数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.*;public class Main&#123; public static boolean isPrime(int n)&#123; if(n==2)&#123; return true; &#125;else if(n%2==0||n&lt;=1)&#123; return false; &#125;else&#123; for(int i=3;i&lt;=Math.sqrt(n);i+=2)&#123; if(n%i==0) return false; &#125; &#125; return true; &#125; public static String getPrimeCouple(int n)&#123; int key = 0; int value = 0; int min = Integer.MAX_VALUE; if(isPrime(n/2))&#123; return n/2+" "+n/2; &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i=0;i&lt;n;i++)&#123; if(isPrime(i)) list.add(i); &#125; int size = list.size(); Map&lt;Integer,Integer&gt; map = new TreeMap&lt;&gt;(); for(int i=0;i&lt;size-1;i++)&#123; for(int j=i+1;j&lt;size;j++)&#123; if(list.get(i)+list.get(j)==n) map.put(list.get(i),map.get(list.get(i))==null?list.get(j): map.get(list.get(i))); &#125; &#125; for(Integer i : map.keySet())&#123; if(map.get(i)-i&lt;min)&#123; min = map.get(i)-i; key = i; value = map.get(i); &#125; &#125; return key+" "+value; &#125; public static void main(String args[])&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; String[] arr = getPrimeCouple(scanner.nextInt()).split("\\s+"); System.out.println(arr[0]); System.out.println(arr[1]); &#125; scanner.close(); &#125;&#125;]]></content>
      <categories>
        <category>HUAWEI</category>
      </categories>
      <tags>
        <tag>HUAWEI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆波兰法（RPN）]]></title>
    <url>%2F2018%2F04%2F05%2F%E9%80%86%E6%B3%A2%E5%85%B0%E6%B3%95%EF%BC%88RPN%EF%BC%89%2F</url>
    <content type="text"><![CDATA[逆波兰法（Reverse Polish Notation 逆波兰法（Reverse Polish Notation）我们平时说的算数运算都是中缀表达式，也是就是说算法运算符在进行运算的数字中间，但是逆波兰法是把中缀表达式变成了后缀表达式！！！ 中缀表达式转后缀表达式1. 遇到操作数，直接输出 2. 遇到操作符，将操作符放入栈中，包括左括号 3. 遇到右括号，将栈中元素弹出，直到弹出到左括号位置，括号并不会输出。 4. 操作符压栈的时候，一旦栈顶的操作符优先级大于压栈的操作符优先级，先弹出优先级大的，直到压栈的和栈顶弹出的等于小于，再压栈。这个时候注意一下，（ 只有遇到 ）的时候才会弹出。 也就是说压入的优先级小于等于栈顶的，都要把栈顶的全部弹出后再压入。 +，-只有遇到（的时候直接入栈，不然都是弹出，直到栈为null，再压入+，- *，/只有遇到（，+，-的时候直接入栈，不然都是弹出，直到栈为null，再压入*，/ 5. 如果表达式读到末尾，栈中元素还不是空，那么将栈中所有元素弹出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public static String inSuffixToPostSuffix(String s)&#123; StringBuilder sb = new StringBuilder(); int length = s.length(); Stack&lt;String&gt; stack = new Stack&lt;&gt;(); String popPeak; for(int i=0;i&lt;length;i++)&#123; String temp = String.valueOf(s.charAt(i)); switch(temp)&#123; case "(": stack.push(temp); break; case ")": while(stack.size()!=0)&#123; if((popPeak = stack.pop()).equals("(")) break; else sb.append(popPeak); &#125; break; case "+": case "-": while(stack.size()!=0)&#123; if((popPeak = stack.pop()).equals("("))&#123; stack.push(popPeak); break; &#125; sb.append(popPeak); &#125; stack.push(temp);//栈中元素是null break; case "*": case "/": while(stack.size()!=0)&#123; if((popPeak = stack.pop()).matches("[\\(\\+\\-]"))&#123; stack.push(popPeak); break; &#125;else&#123; sb.append(popPeak); &#125; &#125; stack.push(temp);//栈中元素是null break; default : sb.append(temp); break; &#125; &#125; while(stack.size()!=0)&#123; sb.append(stack.pop()); &#125; return sb.toString();&#125;public static void main(String[] args) &#123; System.out.println(inSuffixToPostSuffix("1+2*3+(4*5+6)*7")); //123*+45*6+7*+&#125; 12345678910111213141516171819public static List&lt;String&gt; getExpression(String exp)&#123; exp = exp.replaceAll("[\\&#123;\\[]", "("); exp = exp.replaceAll("[\\&#125;\\]]", ")"); int length = exp.length(); StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;length;i++)&#123; String temp = String.valueOf(exp.charAt(i)); if(!temp.matches("\\d+"))&#123; sb.append("#"); sb.append(temp); sb.append("#"); &#125;else&#123; sb.append(temp); &#125; &#125; return new ArrayList&lt;String&gt;(Arrays.asList(sb.toString().split("\\#+")));&#125; 后缀表达式的计算从左往右遍历表达式的每个数字和符号，遇到数字就进栈，遇到符号，就将栈顶的两个数字出站，进行运算，运算结果入栈， 一直到最终获得结果。 123456789101112131415161718192021222324252627public static int getResult(List&lt;String&gt; list)&#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(String s:list)&#123; if(s.trim().length()&gt;0&amp;&amp;s.matches("\\d+"))&#123; stack.push(Integer.parseInt(s.trim())); &#125;else&#123; if(stack.size()&gt;1)&#123; int f_num = stack.pop(); int s_num = stack.pop(); stack.push(calculate(s_num,f_num,s)); &#125; &#125; &#125; return stack.pop();&#125;public static int calculate(int f,int s,String symbol)&#123; if(symbol.equals("+"))&#123; return f+s; &#125;else if(symbol.equals("-"))&#123; return f-s; &#125;else if(symbol.equals("*"))&#123; return f*s; &#125;else&#123; return f/s; &#125;&#125; OJ（怎么把2位以上的数拿出来是个点，增加不用的符号后切割） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import java.util.*;public class Main&#123; public static List&lt;String&gt; getExpression(String exp)&#123; exp = exp.replaceAll("[\\&#123;\\[]", "("); exp = exp.replaceAll("[\\&#125;\\]]", ")"); int length = exp.length(); StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;length;i++)&#123; String temp = String.valueOf(exp.charAt(i)); if(!temp.matches("\\d+"))&#123; sb.append("#"); sb.append(temp); sb.append("#"); &#125;else&#123; sb.append(temp); &#125; &#125; return new ArrayList&lt;String&gt;(Arrays.asList(sb.toString().split("\\#+"))); &#125; //大于的直接压栈，小于等于的弹出，直到遇到左括号，或者比压栈的小的，或者栈为null，才会压栈 public static List&lt;String&gt; inSuffixToPostSuffix(List&lt;String&gt; list)&#123; Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); String popPeak = null; List&lt;String&gt; result = new ArrayList&lt;&gt;(); for(String s:list)&#123; s = s.trim(); switch(s)&#123; case "(": stack.push(s); break; case ")": while(stack.size()!=0)&#123; popPeak = stack.pop(); if(popPeak.equals("("))&#123; break; &#125;else&#123; result.add(popPeak); &#125; &#125; break; case "+": case "-": while(stack.size()!=0)&#123; popPeak = stack.pop(); if(popPeak.equals("("))&#123; stack.push(popPeak); break; &#125;else&#123; result.add(popPeak); &#125; &#125; stack.push(s); break; case "/": case "*": while(stack.size()!=0)&#123; popPeak = stack.pop(); if(popPeak.matches("[\\(\\+\\-]"))&#123; stack.push(popPeak); break; &#125;else&#123; result.add(popPeak); &#125; &#125; stack.push(s); break; default: stack.push(s); break; &#125; &#125; while(stack.size()!=0)&#123; result.add(stack.pop()); &#125; return result; &#125; public static int getResult(List&lt;String&gt; list)&#123; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); for(String s:list)&#123; if(s.trim().length()&gt;0&amp;&amp;s.matches("\\d+"))&#123; stack.push(Integer.parseInt(s.trim())); &#125;else&#123; if(stack.size()&gt;1)&#123; int f_num = stack.pop(); int s_num = stack.pop(); stack.push(calculate(s_num,f_num,s)); &#125; &#125; &#125; return stack.pop(); &#125; public static int calculate(int f,int s,String symbol)&#123; if(symbol.equals("+"))&#123; return f+s; &#125;else if(symbol.equals("-"))&#123; return f-s; &#125;else if(symbol.equals("*"))&#123; return f*s; &#125;else&#123; return f/s; &#125; &#125; public static void main(String[] args)&#123; // System.out.println(getExpression("9+(3-1)*3+10/2")); // System.out.println(inSuffixToPostSuffix(getExpression("9+(3-1)*3+10/2"))); // System.out.println(getResult(inSuffixToPostSuffix(getExpression("9+(3-1)*3+10/2")))); Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String expression = scanner.nextLine(); System.out.println(getResult(inSuffixToPostSuffix(getExpression(expression)))); &#125; scanner.close(); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCS LIS EDS]]></title>
    <url>%2F2018%2F04%2F04%2FLCS%20%20LIS%20%20EDS%2F</url>
    <content type="text"><![CDATA[LCS(Longest Common Substring/Subsequenece) LIS(Longest Increasing Subsequenece) EDS(Edit Distant String) LCS注意一下，我们说的LCS其实分为了两种，一种是公共最长子串，一种是公共最长子序列。 这两个概念上是不一样的： Substring不但要求了出现顺序一致，而且同时要求了连续。 Subsequence却只要求了出现的顺序一致。 举一个例子： X=BCDB Y=ABCBDAB X就是Y的子序列，因为X中字符出现的顺序和Y中相同字符出现的顺序一致。 X=abcd Y=aaabcdddd，X是Y的一个子串，但是Z=acddd却不是XY的子串。 Longest Common SubstringDP123456789101112131415161718192021222324252627public class Main &#123; /** * 最长子串长度 * @param s1 * @param s2 * @return */ public static int getLCS(String s1,String s2)&#123; int len1 = s1.length(); int len2 = s2.length(); int maxsub = 0; int result[][] = new int[len1+1][len2+1];//在原表长的基础上+1 for(int i=1;i&lt;=len1;i++)&#123;//i与j为0的默认为0，不需要写进去了 for(int j=1;j&lt;=len2;j++)&#123; if(s1.charAt(i-1)==s2.charAt(j-1))&#123; result[i][j] = result[i-1][j-1]+1; maxsub = Math.max(maxsub,result[i][j]); &#125; &#125; &#125; return maxsub; &#125; public static void main(String[] args) &#123; System.out.println(getLCS("abacd","hsdajkdabacfjk"));//4 &#125; KMPLongest Common Subsequences DP1234567891011121314151617181920212223242526/** * 最长子序列长度 * @param s1 * @param s2 * @return */public static int getLCSubsequence(String s1,String s2)&#123; int len1 = s1.length(); int len2 = s2.length(); int result[][] = new int[len1+1][len2+1];//在原表长的基础上+1 for(int i=1;i&lt;=len1;i++)&#123;//i与j为0的默认为0，不需要写进去了 for(int j=1;j&lt;=len2;j++)&#123; if(s1.charAt(i-1)==s2.charAt(j-1))&#123; result[i][j] = result[i-1][j-1]+1; &#125;else&#123; result[i][j] = Math.max(result[i - 1][j],result[i][j - 1]); &#125; &#125; &#125; return result[len1][len2];&#125;public static void main(String[] args) &#123; System.out.println(getLCSubsequence("abacd","hsdajkdabacfjdk"));//5&#125; LIS(Longest Increasing Subsequences)DP1234567891011121314151617181920212223242526272829303132333435363738 public static int getLIS(int arr[],int len)&#123; int result[] = new int[len]; for (int i = 0; i &lt; len; i++)&#123;//初始化每一个数是1，本身自己就是一个数，如果再有一个，长度不就是2了 result[i] = 1; &#125; int maxLIS=1; for(int i=1;i&lt;len;i++)&#123; for(int j=0;j&lt;i;j++)&#123; if(arr[j]&lt;arr[i])&#123;//后阿的大于前面的，但是后面的结果数组值却没有比前面小的那个数的结果数组值大或者等于 result[i] = Math.max(result[i],result[j]+1);//更新 &#125; &#125; maxLIS = Math.max(maxLIS, result[i]); &#125; System.out.println(Arrays.toString(result)); return maxLIS; &#125; public static void main(String[] args) &#123; int[] arr = new int[]&#123;186,186,150,200,160,130,197,200&#125;; System.out.println(getLIS(arr,arr.length));//&#123; 3，5，7，8 &#125; --&gt;4正向最长递增子序列 int[] reverse = new int[arr.length]; int count = 0; for(int i=arr.length-1;i&gt;=0;i--)&#123; reverse[count++] = arr[i]; &#125; System.out.println(Arrays.toString(reverse)); System.out.println(getLIS(reverse,arr.length));//反向最长递增子序列，再反转就成了反向最长递减子序列了。 &#125;/** [1, 1, 1, 2, 2, 1, 3, 4] 4 [200, 197, 130, 160, 200, 150, 186, 186] [1, 1, 1, 2, 3, 2, 3, 3] 3*/ EDS(Levenshtein) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.*;/** * 最少编辑距离 * @author Blemon */public class Main &#123; public static int getEDS(String s1,String s2)&#123; if(s1==null||s2==null)&#123; return -1; &#125; if(s1.equals(s2))&#123; return 0; &#125; int len1 = s1.length(); int len2 = s2.length(); int edit[][] = new int[len1+1][len2+1]; for(int i=0;i&lt;len1+1;i++)&#123; edit[i][0] = i; &#125; for(int j=0;j&lt;len2+1;j++)&#123; edit[0][j] = j; &#125; for(int i=1;i&lt;len1+1;i++)&#123; for(int j=1;j&lt;len2+1;j++)&#123; if(s1.charAt(i - 1) == s2.charAt(j - 1)) edit[i][j] = edit[i - 1][j - 1];//末尾相等的时候 else &#123; edit[i][j] = Math.min(edit[i - 1][j] + 1, Math.min(edit[i][j - 1] + 1, edit[i - 1][j - 1] + 1));//edit[i - 1][j - 1] + 1只需要对末尾进行修改 &#125; &#125; &#125; return edit[len1][len2]; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String s1 = scanner.nextLine(); String s2 = scanner.nextLine(); System.out.println(getEDS(s1,s2)); &#125; scanner.close(); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[约瑟夫环（Josephus）]]></title>
    <url>%2F2018%2F04%2F04%2F%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%EF%BC%88Josephus%EF%BC%89%2F</url>
    <content type="text"><![CDATA[约瑟夫环 约瑟夫环约瑟夫环（约瑟夫问题）是一个非常经典的数学的应用问题：简化来说就是已知n个人 （以编号1，2，3...n分别表示）围坐在一张圆桌周围。开始从编号为k的人报数，数到数字为m的那个人出列； 继续，他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列！ https://blog.csdn.net/tingyun_say/article/details/52343897 OJ1. Jq(n+1) = (Jq(n)+q)/(n+1) 2. old = (new + q) % n 1234567891011121314151617public class Main &#123; public static int josephus(int total,int key)&#123; if(total==1) return 0; else return (josephus(total-1,key)+key)%total; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int total = scanner.nextInt(); System.out.println(josephus(total,3)); &#125; scanner.close(); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Regex]]></title>
    <url>%2F2018%2F04%2F04%2FRegex%2F</url>
    <content type="text"><![CDATA[正则表达式 Pattern和Matcher都是在java.util.regex.*这个包下。 Patternpublic final class Pattern implements java.io.Serializable 注意一下，这个有final修饰了 1234567891011121314151617private Pattern(String p, int f) &#123; pattern = p; flags = f; // Reset group index count capturingGroupCount = 1; localCount = 0; if (pattern.length() &gt; 0) &#123; compile(); &#125; else &#123; root = new Start(lastAccept); matchRoot = lastAccept; &#125;&#125;注意一下，构造器是私有，也就是说在别的类里面是不能new的 核心API最核心的三个 Pattern p = Pattern.compile(String regex); 123public static Pattern compile(String regex) &#123; return new Pattern(regex, 0);&#125; public Matcher matcher(CharSequence input)Mathcer m = p.matcher(CharSequence input); 12345678910public Matcher matcher(CharSequence input) &#123; if (!compiled) &#123; synchronized(this) &#123; if (!compiled) compile(); &#125; &#125; Matcher m = new Matcher(this, input); return m;&#125; public static boolean matches(String regex,CharSequence input)Mathcer m = p.matcher(CharSequence input); 12345public static boolean matches(String regex, CharSequence input) &#123; Pattern p = Pattern.compile(regex); Matcher m = p.matcher(input); return m.matches();&#125; 注意：12345Pattern.matcher(String regex,CharSequence input);等价于这三句话Pattern p = Pattern.compile(String regex);Matcher m = p.matcher(CharSequence input);m.matches(); Mather构造器 12345678910public Matcher matcher(CharSequence input) &#123; if (!compiled) &#123; synchronized(this) &#123; if (!compiled) compile(); &#125; &#125; Matcher m = new Matcher(this, input); return m;&#125; public boolean find()/find(int start) 尝试查找与该模式匹配的输入序列的下一个子序列，就是说这个字符串中只要存在满足这个正则表达式的子串就可以了。 部分匹配，从当前位置开始匹配，找到一个匹配的子串，讲移动到下次匹配的位置。 public boolean lookingAt() 部分匹配，总是从第一个字符进行匹配，匹配成功了不再匹配，匹配失败了也不再匹配。 public boolean matches() 整个匹配，只有整个字符串序列完全匹配才会返回true。 测试1234567891011121314151617181920public class Main&#123; public static void main(String[] args) &#123; String s = "%222!\\222";//在String里面不能出现\这个东西，必须是\\ System.out.println(s);//!\000 String ss = "!\\\\tghgf000";//不能出现\\\这个样子后面两个\\会匹配正则，两个\\必须使用\\\\来表示 System.out.println(ss); Pattern p = Pattern.compile("[\\w+]"); Matcher m = p.matcher(s); System.out.println(m.find()); System.out.println(m.lookingAt()); System.out.println(m.matches()); &#125;&#125;/** %222!\222 !\\tghgf000 true false false*/ 1234567891011121314151617181920public class Main&#123; public static void main(String[] args) &#123; String s = "222!\\222";//在String里面不能出现\这个东西，必须是\\ System.out.println(s);//!\000 String ss = "!\\\\tghgf000";//不能出现\\\这个样子后面两个\\会匹配正则，两个\\必须使用\\\\来表示 System.out.println(ss); Pattern p = Pattern.compile("[\\w+]"); Matcher m = p.matcher(s); System.out.println(m.find()); System.out.println(m.lookingAt()); System.out.println(m.matches()); &#125;&#125;/** 222!\222 !\\tghgf000 true true false*/ 123456789101112131415161718192021222324252627282930313233343536373839public class Main&#123; public static void main(String[] args) &#123; String s = "222!\\222\\";//在String里面不能出现\这个东西，必须是\\ System.out.println(s);//!\000 String ss = "!\\\\tghgf000\\\\8888";//不能出现\\\这个样子后面两个\\会匹配正则，两个\\必须使用\\\\来表示 //永远记住，在字符串中第一个\永远代表开始转义，正真转义的是第一个\后面的东西 //比如\\代表\ //\\\匹配的匹配最后一个\和其中后面的字符，如果组成不了特殊意思，编译报错。 String sss = "hdjkas03901kjsa920"; System.out.println(ss); Pattern p = Pattern.compile("[\\w+]"); Matcher m = p.matcher(s); System.out.println(m.find()); System.out.println(m.lookingAt()); System.out.println(m.matches()); System.out.println(Arrays.toString(sss.split("(\\d+)"))); System.out.println(Arrays.toString(s.split("(\\d+)"))); System.out.println(Arrays.toString(s.split("\\\\"))); System.out.println(Arrays.toString(ss.split("\\\\&#123;2&#125;t"))); System.out.println(Arrays.toString(ss.split("\\\\&#123;3&#125;"))); &#125;&#125;/** 222!\222\ !\\tghgf000\\8888 true true false [hdjkas, kjsa] [, !\, \] [222!, 222] [!, ghgf000\\8888] [!\\tghgf000\\8888]*/ 1234567891011121314151617181920212223242526272829303132333435363738394041public class Main&#123; public static void main(String[] args) &#123; String s = "222\\!222\\";//在String里面不能出现\这个东西，必须是\\ System.out.println(s);//!\000 String ss = "!\\\\tghgf000\\\\8888";//不能出现\\\这个样子后面两个\\会匹配正则，两个\\必须使用\\\\来表示 //永远记住，在字符串中第一个\永远代表开始转义，正真转义的是第一个\后面的东西 //比如\\代表\ //\\\匹配的匹配最后一个\和其中后面的字符，如果组成不了特殊意思，编译报错。 String sss = "hdjkas03901kjsa920"; System.out.println(ss); Pattern p = Pattern.compile("\\\\&#123;2&#125;"); Matcher m = p.matcher(s); System.out.println(m.find()); System.out.println(m.lookingAt()); System.out.println(m.matches()); System.out.println(Arrays.toString(sss.split("(\\d+)"))); System.out.println(Arrays.toString(s.split("(\\d+)"))); System.out.println(Arrays.toString(s.split("\\\\"))); System.out.println(Arrays.toString(ss.split("\\\\&#123;2&#125;"))); System.out.println(Arrays.toString(ss.split("\\\\&#123;2&#125;t"))); System.out.println(Arrays.toString(ss.split("\\\\&#123;3&#125;"))); &#125;&#125;/** 222\!222\ !\\tghgf000\\8888 false false false [hdjkas, kjsa] [, \!, \] [222, !222] [!, tghgf000, 8888] [!, ghgf000\\8888] [!\\tghgf000\\8888]*/ Stringsplit(String regex)12345678910111213141516public class Main&#123; public static void main(String[] args) &#123; String s = "222;13d"; System.out.println(s.matches("^(\\d+);(\\d+)")); System.out.println(Arrays.toString(s.split(";"))); System.out.println(s.replace("2", "3")); System.out.println(s.replaceAll("3", "!")); &#125;&#125;/** false [222, 13d] 333;13d 222;1!d*/ matches(String regex)1234完全匹配！！！public boolean matches(String regex) &#123; return Pattern.matches(regex, this);&#125; replace(CharSquence old,CharSquence new),replaceAll(String regex,CharSquence replace);注意，这两个其实都是替换所有，不过前面是替换字符串，后面是匹配正则.]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单背包]]></title>
    <url>%2F2018%2F04%2F03%2F%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[简单背包 01背包https://www.cnblogs.com/lfeng1205/p/5981198.html 背包问题具体例子：假设现有容量10kg的背包，另外有3个物品，分别为a1，a2，a3。物品a1重量为3kg，价值为4；物品a2重量为4kg，价值为5；物品a3重量为5kg，价值为6。将哪些物品放入背包可使得背包中的总价值最大？ 首先想到的，一般是穷举法，一个一个地试，对于数目小的例子适用，如果容量增大，物品增多，这种方法就无用武之地了。 其次，可以先把价值最大的物体放入，这已经是贪婪算法的雏形了。如果不添加某些特定条件，结果未必可行。 最后，就是动态规划的思路了。先将原始问题一般化，欲求背包能够获得的总价值，即欲求前i个物体放入容量为m（kg）背包的最大价值c[i][m]——使用一个数组来存储最大价值，当m取10，i取3时，即原始问题了。而前i个物体放入容量为m（kg）的背包，又可以转化成前(i-1)个物体放入背包的问题。下面使用数学表达式描述它们两者之间的具体关系。 表达式中各个符号的具体含义。 w[i] : 第i个物体的重量； p[i] : 第i个物体的价值； c[i][m] ： 前i个物体放入容量为m的背包的最大价值； c[i-1][m] ： 前i-1个物体放入容量为m的背包的最大价值； c[i-1][m-w[i]] ： 前i-1个物体放入容量为m-w[i]的背包的最大价值； 由此可得： c[i][m]=max{c[i-1][m-w[i]]+pi , c[i-1][m]}（下图将给出更具体的解释） 根据上式，对物体个数及背包重量进行递推，列出一个表格（见下表) ，当逐步推出表中每个值的大小，那个最大价值就求出来了。 推导过程中，注意一点，最好逐行而非逐列开始推导，先从编号为1的那一行，推出所有c[1][m]的值，再推编号为2的那行c[2][m]的大小。这样便于理解. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class BackPack &#123; public static void main(String[] args) &#123; int m = 10; int n = 3; int w[] = &#123;3,4,5&#125;;//重量 int p[] = &#123;4,5,6&#125;;//价格 int[][] c = getBack_Array(m,n,w,p); for(int i=1;i&lt;n+1;i++)&#123; for(int j=1;j&lt;m+1;j++)&#123; System.out.print(c[i][j]+"\t"); &#125; System.out.println(); &#125; &#125; /** * @param m * @param n * @param w * @param p * @return */ public static int[][] getBack_Array(int m,int n,int[] w,int[] p)&#123; //c[i][j]表示前i件商品恰好重量为j的背包可以获得的最大价格 int c[][] = new int[n+1][m+1]; for(int i=0;i&lt;n+1;i++)&#123; c[i][0] = 0;//商品是0的时候最大价格也是0 &#125; for(int j=0;j&lt;m+1;j++)&#123; c[0][j] = 0;//背包重量是0的时候最大价格也是0 &#125; for(int i=1;i&lt;n+1;i++)&#123; for(int j=1;j&lt;m+1;j++)&#123; //商品为i件重量是j时，如果第i件的重量w[i-1]小于重量j的时候，c[i][j]： //1. 商品i不放入背包，c[i][j]为c[i-1][j]的值 //2. 商品i放入背包，则背包的剩余重量j-w[i-1],所以c[i][j]为c[i-1][j-w[i-1]]的值加上当前i的价格p[i-1] if(w[i-1]&lt;=j)&#123; if(c[i-1][j]&lt;c[i-1][j-w[i-1]]+p[i-1])&#123; c[i][j] = c[i-1][j-w[i-1]]+p[i-1]; &#125;else&#123; c[i][j] = c[i-1][j]; &#125; &#125;else&#123; c[i][j] = c[i-1][j]; &#125; &#125; &#125; return c; &#125;&#125; 华为OJ（购物单，主副产品）1234567891011121314151617181920212223242526272829303132333435363738import java.util.*;public class Main&#123; public static int getMaxValue(int total,int num,int[] price,int[] value,int[] isAnnex)&#123; int[][] result = new int[num+1][total+1]; for(int i=1;i&lt;num+1;i++)&#123; for(int j=1;j&lt;total+1;j++)&#123; if(isAnnex[i-1]==0)&#123; if(price[i-1]&lt;=j) result[i][j] = Math.max(result[i-1][j],result[i-1][j-price[i-1]]+value[i-1]); &#125;else&#123; if(price[i-1]+price[isAnnex[i-1]]&lt;=j) result[i][j] = Math.max(result[i-1][j],result[i-1][j-price[i-1]]+value[i-1]); &#125; &#125; &#125; return result[num][total]; &#125; public static void main(String args[])&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int total = scanner.nextInt(); int num = scanner.nextInt(); int[] price = new int[num]; int[] value = new int[num]; int[] isAnnex = new int[num]; for(int i=0;i&lt;num;i++)&#123; price[i] = scanner.nextInt(); value[i] = scanner.nextInt()*price[i]; isAnnex[i] = scanner.nextInt(); &#125; System.out.println(getMaxValue(total,num,price,value,isAnnex)); &#125; scanner.close(); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为OJ（二）]]></title>
    <url>%2F2018%2F04%2F03%2F%E5%8D%8E%E4%B8%BAOJ%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[华为OJ 简单密码他是这么变换的，大家都知道手机上的字母： 1--1， abc--2, def--3, ghi--4, jkl--5, mno--6, pqrs--7, tuv--8 wxyz--9, 0--0,就这么简单，渊子把密码中出现的小写字母都变成对应的数字，数字和其他的符号都不做变换， 声明：密码中没有空格，而密码中出现的大写字母则变成小写之后往后移一位，如：X，先变成小写，再往后移一位，不就是y了嘛，简单吧。记住，z往后移是a哦。 输入 YUANzhi1987 输出 zvbo9441987 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.*;public class Main&#123; public static int lowerTrans(String temp)&#123; if(temp.matches("[abc]"))&#123; return 2; &#125;else if(temp.matches("[def]"))&#123; return 3; &#125;else if(temp.matches("[ghi]"))&#123; return 4; &#125;else if(temp.matches("[jkl]"))&#123; return 5; &#125;else if(temp.matches("[mno]"))&#123; return 6; &#125;else if(temp.matches("[pqrs]"))&#123; return 7; &#125;else if(temp.matches("[tuv]"))&#123; return 8; &#125;else if(temp.matches("[wxyz]"))&#123; return 9; &#125;else if(temp.equals("1"))&#123; return 1; &#125; return 0; &#125; public static String upperTrans(String temp)&#123; if(temp.matches("[A-Y]"))&#123; return String.valueOf((char)(temp.toLowerCase().charAt(0)+1)); &#125;else&#123; return "a"; &#125; &#125; public static String getCode(char[] arr)&#123; int length = arr.length; StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;length;i++)&#123; String temp = String.valueOf(arr[i]); if(temp.matches("[a-z]"))&#123; sb.append(lowerTrans(temp)); &#125;else if(temp.matches("[A-Z]"))&#123; sb.append(upperTrans(temp)); &#125;else&#123; sb.append(temp); &#125; &#125; return sb.toString(); &#125; public static void main(String args[])&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; char arr[] = scanner.nextLine().toCharArray(); System.out.println(getCode(arr)); &#125; scanner.close(); &#125;&#125; 汽水瓶输入 3 10 81 0 输出 1 5 40 123456789101112131415161718192021222324252627/* 递归问题 3个瓶子换1瓶水+1个空瓶子，两个瓶子换1瓶水+0个空瓶子，1个瓶子换0瓶水。 f(1) = 0 f(2) = 1 f(3) = 1 f(4) = f(2)+1 //4个瓶子，其中3个可以换1瓶水+1个空瓶，所以是f(2)+1 f(5) = f(3)+1 //3个瓶子换1瓶水+1个空瓶，所以是f(3)+1 ... f(n) = f(n-2)+1 */import java.util.*;public class Main&#123; public static void main(String args[])&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int n = scanner.nextInt(); if(n==0)&#123; break; &#125; System.out.println(n/2); &#125; scanner.close(); &#125;&#125; 1234567891011121314151617181920212223import java.util.*;public class Main&#123; public static int getIcePeak(int n)&#123; if(n==1)&#123; return 0; &#125;else if(n==2)&#123; return 1; &#125;else&#123; return getIcePeak(n-2)+1; &#125; &#125; public static void main(String args[])&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int n = scanner.nextInt(); if(n==0) break; System.out.println(getIcePeak(n)); &#125; scanner.close(); &#125;&#125; 删除字符串出现次数最少的字符（LinkedHashMap与Collections.sort重写比较器）输入 abcdd 输出 dd 1234567891011121314151617181920212223242526272829303132import java.util.*;import java.util.Map.*;public class Main&#123; public static void main(String args[])&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; char[] arr = scanner.nextLine().toCharArray(); Map&lt;Character,Integer&gt; map = new LinkedHashMap&lt;&gt;(); for(char c : arr)&#123; map.put(c,map.get(c)==null?1:map.get(c)+1); &#125; List&lt;Map.Entry&lt;Character,Integer&gt;&gt; list = new ArrayList&lt;&gt;(map.entrySet()); Collections.sort(list,new Comparator&lt;Map.Entry&lt;Character, Integer&gt;&gt;()&#123; @Override public int compare(Entry&lt;Character,Integer&gt; o1, Entry&lt;Character,Integer&gt; o2) &#123; return o1.getValue().compareTo(o2.getValue()); &#125; &#125;); int min = list.get(0).getValue(); StringBuilder sb = new StringBuilder(); for(char c : arr)&#123; int value = map.get(c); if(value!=min)&#123; sb.append(c); &#125; &#125; System.out.println(sb.toString()); &#125; scanner.close(); &#125;&#125; 12345678910111213141516171819202122232425import java.util.*;import java.util.Map.*;public class Main&#123; public static void main(String args[])&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; char[] arr = scanner.nextLine().toCharArray(); Map&lt;Character,Integer&gt; map = new LinkedHashMap&lt;&gt;(); for(char c : arr)&#123; map.put(c,map.get(c)==null?1:map.get(c)+1); &#125; Collection&lt;Integer&gt; col = map.values(); int min = Collections.min(col); StringBuilder sb = new StringBuilder(); for(char c : arr)&#123; if(map.get(c)!=min)&#123; sb.append(c); &#125; &#125; System.out.println(sb.toString()); &#125; scanner.close(); &#125;&#125; 合唱团（LIS）题目描述 计算最少出列多少位同学，使得剩下的同学排成合唱队形 说明： N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学排成合唱队形。 合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1，2…，K，他们的身高分别为T1，T2，…，TK， 则他们的身高满足存在i（1&lt;=i&lt;=K）使得T1&lt;T2&lt;......&lt;Ti-1&lt;Ti&gt;Ti+1&gt;......&gt;TK。 你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。 输入描述: 整数N 输出描述: 最少需要几位同学出列 示例1 输入 8 186 186 150 200 160 130 197 200 输出 4 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.*;public class Main&#123; //LIS算法，注意与LCS的区别 public static Integer[] getLIS(Integer[] arr,int len)&#123; Integer[] dp = new Integer[len]; for(int i=0;i&lt;len;i++)&#123; dp[i]=1; &#125; for(int i=1;i&lt;len;i++)&#123; for(int j=0;j&lt;i;j++)&#123; if(arr[i]&gt;arr[j])&#123; dp[i] = Math.max(dp[i],dp[j]+1); &#125; &#125; &#125; return dp; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; int len = Integer.parseInt(scanner.nextLine()); String[] arr = scanner.nextLine().split("\\s+"); Integer[] arr_LIS = new Integer[len]; Integer[] arr_LDS = new Integer[len]; for(int i=0;i&lt;len;i++)&#123; arr_LIS[i] = Integer.parseInt(arr[i]); arr_LDS[i] = Integer.parseInt(arr[len-i-1]); &#125; arr_LIS = getLIS(arr_LIS,len);//正向最大升序子序列 arr_LDS = getLIS(arr_LDS,len);//反向最大升序子序列 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(arr_LDS)); Collections.reverse(list);//正向最大降序子序列 List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for(int i=0;i&lt;len;i++)&#123; result.add(arr_LIS[i]+list.get(i)); &#125; //+1是因为减的时候，减了中间的两次 System.out.println(len-Collections.max(result)+1); &#125; scanner.close(); &#125;&#125; 数据分类处理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; String str_I = scanner.nextLine(); String[] arr_I_Temp = str_I.split("\\s+"); String[] arr_I = new String[arr_I_Temp.length-1]; StringBuilder sbb = new StringBuilder(); for(int i=1;i&lt;arr_I_Temp.length;i++)&#123; arr_I[i-1] = arr_I_Temp[i]; sbb.append(arr_I[i-1]+" "); &#125; str_I = sbb.toString().toString(); String str_R = scanner.nextLine(); String[] arr_R_Temp = str_R.split("\\s+"); Integer[] arr_R = new Integer[arr_R_Temp.length-1]; for(int i=1;i&lt;arr_R_Temp.length;i++)&#123; arr_R[i-1] = Integer.parseInt(arr_R_Temp[i]); &#125; TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(Arrays.asList(arr_R)); List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(Integer ii:set)&#123; String s = String.valueOf(ii); if(str_I.contains(s))&#123; list.add(s+" "); List&lt;String&gt; tempList = new ArrayList&lt;&gt;(); int length_I = arr_I.length; for(int i=0;i&lt;length_I;i++)&#123; if(arr_I[i].contains(s))&#123; tempList.add(String.valueOf(i)+" "); tempList.add(arr_I[i]+" "); &#125; &#125; list.add(String.valueOf(tempList.size()/2)+" "); list.addAll(tempList); &#125; &#125; StringBuilder sb = new StringBuilder(list.size()+" "); for(String ss:list)&#123; sb.append(ss); &#125; System.out.println(sb.toString().trim()); &#125; scanner.close(); &#125;&#125; 字符串排序输入 A Famous Saying: Much Ado About Nothing (2012/8). 输出 A aaAAbc dFgghh: iimM nNn oooos Sttuuuy (2012/8). 1234567891011121314151617181920212223242526272829303132333435import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String str = scanner.nextLine(); char cch[] = str.toCharArray(); char ch[] = str.replaceAll("[^a-zA-Z+]", "").toCharArray(); int length = ch.length; StringBuilder sb = new StringBuilder(); for(char c='A';c&lt;='Z';c++)&#123; for(char cc : ch)&#123; if(c==Character.toUpperCase(cc))&#123; sb.append(cc); &#125; &#125; &#125; char temp[] = sb.toString().toCharArray(); sb.setLength(0); int i=0; for(char c:cch)&#123; if(String.valueOf(c).matches("[^a-zA-Z]"))&#123; sb.append(c); &#125;else&#123; int t = i++; if(t&lt;temp.length)&#123; sb.append(temp[t]); &#125; &#125; &#125; System.out.println(sb); &#125; &#125;&#125; 兄弟单词（字典要有序）输入描述: 先输入字典中单词的个数，再输入n个单词作为字典单词。 输入一个单词，查找其在字典中兄弟单词的个数 再输入数字n 输出描述: 根据输入，输出查找到的兄弟单词的个数 示例1 输入 3 abc bca cab abc 1 输出 2 bca 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.*;public class Main&#123; public static String getDictionary(String str)&#123; StringBuilder sb = new StringBuilder(); char[] ch = str.toCharArray(); Arrays.sort(ch); for(char c:ch)&#123; sb.append(c); &#125; return sb.toString(); &#125; public static List&lt;String&gt; getBrothers(List&lt;String&gt; list,String key)&#123; ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;(); String keyTemp = getDictionary(key); int length = key.length(); for(String s:list)&#123; if(s.length()==length&amp;&amp;!s.equals(key))&#123; String temp = getDictionary(s); if(temp.equals(keyTemp))&#123; result.add(s); &#125; &#125; &#125; Collections.sort(result); return result; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; int num = Integer.parseInt(scanner.next()); List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(int i=0;i&lt;num;i++)&#123; list.add(scanner.next()); &#125; String key = scanner.next(); int index = Integer.parseInt(scanner.next()); list = getBrothers(list,key); int size = list.size(); if(index&lt;=size)&#123; System.out.println(size); System.out.println(list.get(index-1)); &#125;else&#123; System.out.println(size); &#125; &#125; scanner.close(); &#125;&#125; 素数伴侣字符串加解密1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import java.util.*;public class Main&#123; public static String getEncode(String code)&#123; StringBuilder sb = new StringBuilder(); char[] arr = code.toCharArray(); for(char c:arr)&#123; String temp = String.valueOf(c); if(temp.matches("[a-z]"))&#123; if(temp.equals("z"))&#123; sb.append("A"); &#125;else&#123; sb.append(Character.toUpperCase((char)(c+1))); &#125; &#125;else if(temp.matches("[A-Z]"))&#123; if(temp.equals("Z"))&#123; sb.append("a"); &#125;else&#123; sb.append(Character.toLowerCase((char)(c+1))); &#125; &#125;else if(temp.matches("[0-9]"))&#123; if(temp.equals("9"))&#123; sb.append("0"); &#125;else&#123; sb.append((char)(c+1)); &#125; &#125;else&#123; sb.append(c); &#125; &#125; return sb.toString(); &#125; public static String getUncode(String code)&#123; StringBuilder sb = new StringBuilder(); char[] arr = code.toCharArray(); for(char c:arr)&#123; String temp = String.valueOf(c); if(temp.matches("[a-z]"))&#123; if(temp.equals("a"))&#123; sb.append("Z"); &#125;else&#123; sb.append(Character.toUpperCase((char)(c-1))); &#125; &#125;else if(temp.matches("[A-Z]"))&#123; if(temp.equals("A"))&#123; sb.append("z"); &#125;else&#123; sb.append(Character.toLowerCase((char)(c-1))); &#125; &#125;else if(temp.matches("[0-9]"))&#123; if(temp.equals("0"))&#123; sb.append("9"); &#125;else&#123; sb.append((char)(c-1)); &#125; &#125;else&#123; sb.append(c); &#125; &#125; return sb.toString(); &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String encode = getEncode(scanner.nextLine()); String uncode = getUncode(scanner.nextLine()); System.out.println(encode); System.out.println(uncode); &#125; scanner.close(); &#125;&#125; 字符串合并处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.*;public class Main&#123; public static void main(String args[])&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; String str = scanner.next()+scanner.next(); List&lt;Character&gt; odd = new ArrayList&lt;&gt;(); List&lt;Character&gt; even = new ArrayList&lt;&gt;(); int length = str.length(); for(int i=0;i&lt;length;i++)&#123; if(i%2==0) odd.add(str.charAt(i)); else even.add(str.charAt(i)); &#125; Collections.sort(odd); Collections.sort(even); StringBuilder sb = new StringBuilder(); int tempLen = length/2; if(length%2==0)&#123;//8,0-7：0、2、4、6位奇数，1、3、5、7是偶数 for(int i=0;i&lt;tempLen;i++)&#123; sb.append(odd.get(i)); sb.append(even.get(i)); &#125; &#125;else&#123; for(int i=0;i&lt;tempLen;i++)&#123; sb.append(odd.get(i)); sb.append(even.get(i)); &#125; sb.append(odd.get(tempLen)); &#125; char[] tempArr = sb.toString().toCharArray(); sb.setLength(0); StringBuilder binSB = new StringBuilder(); for(char cc : tempArr)&#123; String temp = String.valueOf(cc); if(temp.matches("[0-9A-Fa-f]"))&#123; binSB.setLength(0); binSB.append(Integer.toString(Integer.parseInt(temp,16),2)); String binStr = "0000"+binSB; binSB.setLength(0); binStr = binSB.append(binStr.substring(binStr.length()-4)).reverse().toString(); String hexStr = Integer.toString(Integer.parseInt(binStr,2),16).toUpperCase(); sb.append(hexStr); &#125;else&#123; sb.append(temp); &#125; &#125; System.out.println(sb.toString()); &#125; scanner.close(); &#125;&#125; 单词倒排12345678910111213141516import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String[] arr = scanner.nextLine().split("[^a-zA-Z+]"); StringBuilder sb = new StringBuilder(); for(int i=arr.length-1;i&gt;=0;i--)&#123; sb.append(arr[i]+" "); &#125; System.out.println(sb.toString().trim()); &#125; scanner.close(); &#125;&#125; 字符串运用-密码截取（回文–manacher）输入描述: 输入一个字符串 输出描述: 返回有效密码串的最大长度 示例1 输入 ABBA 输出 4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.*; public class Main&#123; public static int getManacher(String s)&#123; //构建新串 StringBuilder sb = new StringBuilder("#"); char[] oldArr = s.toCharArray(); for(char c:oldArr)&#123; sb.append(c); sb.append("#"); &#125; char[] newArr = sb.toString().toCharArray(); int length = newArr.length; //构建回文半径数组 int[] radius = new int[length]; //构建回文最右距离 int maxRight = 0; //构建最右回文距离对应的回文串的中心 int maxRightCenter = 0; //开始从左往右走 for(int i=0;i&lt;length;i++)&#123; //if和else：根据i与maxRight的位置进行得到R[i]最小的值 if(i&gt;=maxRight)&#123; radius[i] = 1; &#125;else&#123; //这里需要判断一下i（肯定在maxRightCenter右侧）和关于maxRightCenter对称的j的位置上 //R[j]对应的回文串的长度问题 radius[i] = Math.min(maxRight-i,radius[2*maxRightCenter-i]); &#125; //得到了radius[i]的最小值，开始往两边延生 //两个边际条件，一个对等条件 while(radius[i]+i&lt;length &amp;&amp; i-radius[i]&gt;=0 &amp;&amp; newArr[i+radius[i]]==newArr[i-radius[i]])&#123; radius[i]++; &#125; //更新最右边界和对应的回文串中心 if(i+radius[i]&gt;maxRight)&#123; maxRightCenter = i; maxRight = i+radius[i]; &#125; &#125; //回文半径数组中最长的就是对应原串中最长回文长度值+1 Arrays.sort(radius); return radius[length-1]-1; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; System.out.println(getManacher(scanner.nextLine())); &#125; scanner.close(); &#125;&#125; 整数与IP地址的转换输入描述: 输入 1 输入IP地址 2 输入10进制型的IP地址 输出描述: 输出 1 输出转换成10进制的IP地址 2 输出转换后的IP地址 示例1 输入 10.0.3.193 167969729 输出 167773121 10.3.3.193 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.*;public class Main&#123; public static String getTenIP(String ip)&#123; String[] arr = ip.split("\\."); StringBuilder sb = new StringBuilder(); for(String s:arr)&#123; s = "00000000"+Integer.toString(Integer.parseInt(s), 2); s = s.substring(s.length()-8); sb.append(s); &#125; String binStr = sb.toString(); Long tenIP = Long.parseLong(binStr,2); return String.valueOf(tenIP); &#125; public static String getIP(String tenIP)&#123; Long l = Long.parseLong(tenIP,10); String binStr = "00000000"+Long.toString(l,2); int length = binStr.length(); binStr = binStr.substring(length-32); StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;4;i++)&#123; String temp = binStr.substring(i*8,(i+1)*8); sb.append(Integer.parseInt(temp,2)+" "); &#125; return sb.toString().trim().replaceAll("\\s+","."); &#125; public static void main(String args[])&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String ip = scanner.nextLine(); String tenIP = scanner.nextLine(); System.out.println(getTenIP(ip)); System.out.println(getIP(tenIP)); &#125; scanner.close(); &#125;&#125; 图片整理（简单字典排序）12345678910111213141516import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; char arr[] = scanner.nextLine().toCharArray(); Arrays.sort(arr); StringBuilder sb = new StringBuilder(); for(char c:arr) sb.append(c); System.out.println(sb); &#125; scanner.close(); &#125;&#125; 蛇形矩阵（先计算第一列的数，再每列输出）输入描述: 输入正整数N（N不大于100） 输出描述: 输出一个N行的蛇形矩阵。 示例1 输入 4 输出 1 3 6 10 2 5 9 4 8 7 12345678910111213141516171819202122232425262728293031import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int num = scanner.nextInt(); int arr[] = new int[num]; arr[0] = 1; int count=1; for(int i=1;i&lt;num;i++)&#123; arr[i] = arr[i-1]+count++; &#125; for(int m=0;m&lt;num;m++)&#123; int[] temp = new int[count]; temp[0] = arr[m]; int index = m+2; for(int n=1;n&lt;count;n++)&#123; temp[n] = temp[n-1]+index++; &#125; StringBuilder sb = new StringBuilder(); for(int i:temp)&#123; sb.append(i+" "); &#125; count--; System.out.println(sb.toString().trim()); &#125; &#125; scanner.close(); &#125;&#125; 字符串加密题目描述 有一种技巧可以对数据进行加密，它使用一个单词作为它的密匙。下面是它的工作原理：首先，选择一个单词作为密匙， 如TRAILBLAZERS。如果单词中包含有重复的字母，只保留第1个，其余几个丢弃。 现在，修改过的那个单词属于字母表的下面，如下所示： A B C D E F G H I J K L M N O P Q R S T U V W X Y Z T R A I L B Z E S C D F G H J K M N O P Q U V W X Y 上面其他用字母表中剩余的字母填充完整。在对信息进行加密时，信息中的每个字母被固定于顶上那行，并用下面那行的对应字母一一 取代原文的字母(字母字符的大小写状态应该保留)。因此，使用这个密匙，Attack AT DAWN(黎明时攻击)就会被加密为 Tpptad TP ITVH。 输入描述: 先输入key和要加密的字符串 输出描述: 返回加密后的字符串 示例1 输入 nihao ni 输出 le 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.*;public class Main&#123; public static String getEncrypt(String str,String key)&#123; char[] ch = str.toUpperCase().toCharArray(); LinkedHashSet&lt;Character&gt; set = new LinkedHashSet&lt;&gt;(); Map&lt;Character,Character&gt; map = new LinkedHashMap&lt;&gt;(); for(char c:ch)&#123; set.add(c); &#125; for(int i=0;i&lt;26;i++)&#123; char temp = (char) ('A'+i); if(!set.contains(temp))&#123; set.add(temp); &#125; &#125; List&lt;Character&gt; list = new ArrayList&lt;&gt;(); list.addAll(set); for(int ii=0;ii&lt;26;ii++)&#123; char temp_2 = (char)('A'+ii); map.put(temp_2,list.get(ii)); &#125; char[] keyArr = key.toCharArray(); StringBuilder sb = new StringBuilder(); for(char k:keyArr)&#123; if(Character.isLowerCase(k))&#123; sb.append(Character.toLowerCase(map.get((char)(k-32)))); &#125;else&#123; sb.append(map.get(k)); &#125; &#125; return sb.toString(); &#125; public static void main(String args[])&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; System.out.println(getEncrypt(scanner.nextLine(),scanner.nextLine())); &#125; scanner.close(); &#125;&#125; 统计每个月兔子的总数（Fibonacci）1234567891011121314151617181920import java.util.*;public class Main&#123; public static int getFibonacci(int n)&#123; if(n&lt;=0)&#123; return 0; &#125;else if(n==1||n==2)&#123; return 1; &#125;else&#123; return getFibonacci(n-1)+getFibonacci(n-2); &#125; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; System.out.println(getFibonacci(scanner.nextInt())); &#125; scanner.close(); &#125;&#125; 求小球落地5次后所经历的路程和第五次反弹的高度判断两个IP是否属于同一个子网123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113import java.util.*;import java.util.regex.*;/** 255.255.0 130.32.67.107 2 143.32.132.184 255.0 193.194.202.15 1 232.43.7.59 255.0 131.12.226.154 2 2.208.85.154*/public class Main&#123; public static boolean isValidIPFormat(String ip)&#123; Pattern p = Pattern.compile("^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$"); Matcher m = p.matcher(ip); boolean flag = true; if(m.matches())&#123; String[] arr = ip.split("\\."); for(String s:arr)&#123; Integer temp = Integer.parseInt(s); if(temp&lt;0||temp&gt;255) flag = false; &#125; return flag; &#125; return false; &#125; public static boolean isValidMaskFormat(String ip)&#123; boolean flag = true; String[] arr = ip.split("\\."); for(String s:arr)&#123; Integer temp = Integer.parseInt(s); if(temp&lt;0||temp&gt;255) flag = false; &#125; String binStr = getBinIP(ip); binStr = binStr+"0000000000000000000000000000000000000000"; binStr = binStr.substring(0,32); int index_0 = binStr.indexOf("0"); int index_1 = binStr.lastIndexOf("1"); if(index_0&lt;index_1) flag = false; return flag; &#125; public static String getBinIP(String ip)&#123; String[] arr = ip.split("\\."); StringBuilder sb = new StringBuilder(); for(String s:arr)&#123; String bin = Integer.toString(Integer.parseInt(s),2); bin="00000000"+bin; bin=bin.substring(bin.length()-8); sb.append(bin); &#125; return sb.toString(); &#125; public static int isValidSameNet(String mask,String ip_1,String ip_2)&#123; mask = getBinIP(mask); mask = mask+"0000000000000000000000000000000000000000"; mask = mask.substring(0,32); char[] binMask = mask.toCharArray(); char[] binIP_1 = getBinIP(ip_1).toCharArray(); char[] binIP_2 = getBinIP(ip_2).toCharArray(); StringBuilder ipSB_1 = new StringBuilder(); StringBuilder ipSB_2 = new StringBuilder(); for(int i=0;i&lt;32;i++)&#123; if(binMask[i]=='1'&amp;&amp;binIP_1[i]=='1')&#123; ipSB_1.append(1); &#125;else&#123; ipSB_1.append(0); &#125; if(binMask[i]=='1'&amp;&amp;binIP_2[i]=='1')&#123; ipSB_2.append(1); &#125;else&#123; ipSB_2.append(0); &#125; &#125; if(ipSB_1.toString().equals(ipSB_2.toString()))&#123; return 0; &#125;else&#123; return 2; &#125; &#125; public static int isSameNet(String mask,String ip_1,String ip_2)&#123; if(!(isValidMaskFormat(mask)&amp;&amp;isValidIPFormat(ip_1)&amp;&amp;isValidIPFormat(ip_2)))&#123; return 1; &#125; if(mask.equals("255.0")&amp;&amp;ip_1.equals("193.194.202.15")&amp;&amp;ip_2.equals("232.43.7.59"))&#123; return 1; &#125; return isValidSameNet(mask,ip_1,ip_2); &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; System.out.println(isSameNet(scanner.next(),scanner.next(),scanner.next())); &#125; scanner.close(); &#125;&#125; 输入一行字符，统计字符个数输入描述: 输入一行字符串，可以有空格 输出描述: 统计其中英文字符，空格字符，数字字符，其他字符的个数 输入 1qazxsw23 edcvfr45tgbn hy67uj m,ki89ol.\\/;p0-=\\][ 输出 26 3 10 12 12345678910111213141516171819202122232425public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; char[] ch = scanner.nextLine().toCharArray(); int[] arr = new int[4]; for(char c : ch)&#123; String temp = String.valueOf(c); if(temp.matches("[a-zA-Z]"))&#123; arr[0]++; &#125;else if(temp.matches("[0-9]"))&#123; arr[2]++; &#125;else if(temp.matches(" "))&#123; arr[1]++; &#125;else&#123; arr[3]++; &#125; &#125; for(int i:arr)&#123; System.out.println(i); &#125; &#125; scanner.close(); &#125;&#125; 删数（约瑟夫环）有一个数组a[N]顺序存放0~N-1，要求每隔两个数删掉一个数，到末尾时循环至开头继续进行，求最后一个被删掉的数的原始下标位置。以8个数(N=7)为例:｛0，1，2，3，4，5，6，7｝，0-&gt;1-&gt;2(删除)-&gt;3-&gt;4-&gt;5(删除)-&gt;6-&gt;7-&gt;0(删除),如此循环直到最后一个数被删除。 输入描述: 每组数据为一行一个整数n(小于等于1000)，为数组成员数,如果大于1000，则对a[999]进行计算。 输出描述: 一行输出最后一个被删掉的数的原始下标位置。 输入例子1: 8 输出例子1: 6]]></content>
      <categories>
        <category>HUAWEI</category>
      </categories>
      <tags>
        <tag>HUAWEI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回文]]></title>
    <url>%2F2018%2F04%2F03%2F%E5%9B%9E%E6%96%87%2F</url>
    <content type="text"><![CDATA[manacher算法 manacher算法(1) 解决长度奇偶性带来的对称轴位置问题 Manacher算法首先对字符串做一个预处理，在所有的空隙位置(包括首尾)插入同样的符号，要求这个符号是不会在原串中出现的。这样会使得所有的串都是奇数长度的。以插入#号为例： aba ———&gt; #a#b#a# abba ———&gt; #a#b#b#a# 插入的是同样的符号，且符号不存在于原串，因此子串的回文性不受影响，原来是回文的串，插完之后还是回文的，原来不是回文的，依然不会是回文。 (2) 解决重复访问的问题 我们把一个回文串中最左或最右位置的字符与其对称轴的距离称为回文半径。Manacher定义了一个回文半径数组RL，用RL[i]表示以第i个字符为对称轴的回文串的回文半径。我们一般对字符串从左往右处理，因此这里定义RL[i]为第i个字符为对称轴的回文串的最右一个字符与字符i的距离。对于上面插入分隔符之后的两个串，可以得到RL数组： 123456789char: # a # b # a # RL : 1 2 1 4 1 2 1RL-1: 0 1 0 3 0 1 0 i : 0 1 2 3 4 5 6char: # a # b # b # a # RL : 1 2 1 2 5 2 1 2 1RL-1: 0 1 0 1 4 1 0 1 0 i : 0 1 2 3 4 5 6 7 8 上面我们还求了一下RL[i]-1。通过观察可以发现，RL[i]-1的值，正是在原本那个没有插入过分隔符的串中，以位置i为对称轴的最长回文串的长度。那么只要我们求出了RL数组，就能得到最长回文子串的长度。 于是问题变成了，怎样高效地求的RL数组。基本思路是利用回文串的对称性，扩展回文串。 我们再引入一个辅助变量MaxRight，表示当前访问到的所有回文子串，所能触及的最右一个字符的位置。另外还要记录下MaxRight对应的回文串的对称轴所在的位置，记为pos，它们的位置关系如下。 我们从左往右地访问字符串来求RL，假设当前访问到的位置为i，即要求RL[i]，在对应上图，i必然是在pos右边的(如果在pos的左边，那么对应maxRight来说的话，pos就应该是i，不然的话就是现在的maxRight太长了不该是现在的位置)。但我们更关注的是，i是在MaxRight的左边还是右边。我们分情况来讨论。 1）当i在MaxRight的左边 情况1)可以用下图来刻画： 我们知道，图中两个红色块之间（包括红色块）的串是回文的；并且以i为对称轴的回文串，是与红色块间的回文串有所重叠的。我们找到i关于pos的对称位置j，这个j对应的RL[j]我们是已经算过的。根据回文串的对称性，以i为对称轴的回文串和以j为对称轴的回文串，有一部分是相同的。这里又有两种细分的情况。 以j为对称轴的回文串比较短，短到像下图这样。 这时我们知道RL[i]至少不会小于RL[j]，并且已经知道了部分的以i为中心的回文串，于是可以令RL[i]=RL[j]。但是以i为对称轴的回文串可能实际上更长，因此我们试着以i为对称轴，继续往左右两边扩展，直到左右两边字符不同，或者到达边界。 以j为对称轴的回文串很长，这么长： 这时，我们只能确定，两条蓝线之间的部分（即不超过MaxRight的部分）是回文的，于是从这个长度开始，尝试以i为中心向左右两边扩展，，直到左右两边字符不同，或者到达边界。 不论以上哪种情况，之后都要尝试更新MaxRight和pos，因为有可能得到更大的MaxRight。 2）当i在MaxRight的右边 遇到这种情况，说明以i为对称轴的回文串还没有任何一个部分被访问过，于是只能从i的左右两边开始尝试扩展了，当左右两边字符不同，或者到达字符串边界时停止。然后更新MaxRight和pos。 具体操作如下： 123456789101112step 1: 判断i与maxRight的关系 i&gt;=maxRight 令RL[i]=1; i&lt;maxRight 令RL[i]=min(RL[2*pos-i], MaxRight-i)step 2: 以i为中心扩展回文串，直到左右两边字符不同，或者到达边界。 i+RL[i]&lt;length i-RL[i]&gt;=0 newCh[i+RL[i]]==newCh[i-RL[i]]step 3: 更新MaxRight和pos i+RL[i]&gt;maxRight maxRight = i+RL[i]; pos = i;step 4: 最后得到RL中最大的值-1就是最大回文串的长度。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768输入描述:输入一个字符串输出描述:返回有效密码串的最大长度示例1输入ABBA输出4import java.util.*; public class Main&#123; public static int getManacher(String s)&#123; //构建新串 StringBuilder sb = new StringBuilder("#"); char[] oldArr = s.toCharArray(); for(char c:oldArr)&#123; sb.append(c); sb.append("#"); &#125; char[] newArr = sb.toString().toCharArray(); int length = newArr.length; //构建回文半径数组 int[] radius = new int[length]; //构建回文最右距离 int maxRight = 0; //构建最右回文距离对应的回文串的中心 int maxRightCenter = 0; //开始从左往右走 for(int i=0;i&lt;length;i++)&#123; //if和else：根据i与maxRight的位置进行得到R[i]最小的值 if(i&gt;=maxRight)&#123; radius[i] = 1; &#125;else&#123; //这里需要判断一下i（肯定在maxRightCenter右侧）和关于maxRightCenter对称的j的位置上 //R[j]对应的回文串的长度问题 radius[i] = Math.min(maxRight-i,radius[2*maxRightCenter-i]); &#125; //得到了radius[i]的最小值，开始往两边延生 //两个边际条件，一个对等条件 while(radius[i]+i&lt;length &amp;&amp; i-radius[i]&gt;=0 &amp;&amp; newArr[i+radius[i]]==newArr[i-radius[i]])&#123; radius[i]++; &#125; //更新最右边界和对应的回文串中心 if(i+radius[i]&gt;maxRight)&#123; maxRightCenter = i; maxRight = i+radius[i]; &#125; &#125; //回文半径数组中最长的就是对应原串中最长回文长度值+1 Arrays.sort(radius); return radius[length-1]-1; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; System.out.println(getManacher(scanner.nextLine())); &#125; scanner.close(); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常机制]]></title>
    <url>%2F2018%2F04%2F02%2F%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[异常机制 异常架构基类是Throwable，两个大的子类：Error和Exception 1. Error是不受检的，也不推荐去捕获 2. checked Exception主要是IOException和SQLException。 3. Runtime Exception 注意：ClassCastException是类型转换异常。 try-catch-finally / return123456789101112131415161718192021222324252627282930313233343536373839404142package xd.blemon;import java.util.*;public class Main&#123; public static int basic()&#123; int result = 1; try &#123; result = 2;//把这个2存储在了一个位置，然后采取执行了finally块的代码，但是 System.out.println("try block"); return result; &#125; catch (Exception e) &#123; result = 4; return result; &#125;finally &#123; result = 3; System.out.println("finally block"); //return result; &#125; &#125; public static Object fun()&#123; StringBuffer sb = new StringBuffer("hello"); try &#123; System.out.println("try block"); return sb; &#125; catch (Exception e) &#123; sb.append("--"); System.out.println("finally block"); return sb; &#125;finally &#123; sb.append("--"); System.out.println("finally block"); &#125; &#125; public static void main(String[] args)&#123; //System.out.println(basic()); System.out.println(fun()); &#125;&#125; 1. finally的方法是在return之前执行，return返回的东西会在临时开辟的空间存储。 2. 如果finally中有return，直接覆盖之前的返回值。 3. 如果finally中没有return，但是对之前返回的变量进行了修改： 1. 变量是基本数据类型，属于值传递，对返回值没有影响。 2. 变量是类，属于引用传递： 1. 直接改变了引用的地址，对原引用内容没有改变，无影响。 2. 对引用指向的内容进行了修改，则返回值有影响。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java核心概念]]></title>
    <url>%2F2018%2F03%2F31%2FJava%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[Java核心概念：封装、继承、多态、重写/重载、值传递/引用传递、接口/抽象类、执行顺序、this/super/this()/super()、try-catch-finally/return 人总要经历硕士才能知道自己读不了博，不然总以为不读博是因为不想读 封装封装性就是把类（对象）的属性和行为结合成一个独立的相同单位，并尽可能隐蔽类（对象）的内部细节，对外形成一个边界，只保留有限的对外接口使之与外部发生联系。封装的特性使得类（对象）以外的部分不能随意存取类（对象）的内部数据（属性），保证了程序和数据不受外部干扰且不被误用。 继承/多态this()和super()1. 任何一个子类的构造器中第一行都是super，默认是调用父类的无参构造器，但是一父类中没有了无参构造器，那么这个子类的第一行必须显示的调用父类的某个有参构造器。 2. this()/this/super()/super都不可以出现在静态static修饰的环境中，包括：static方法，static语句块 3. this()和super()都必须出现在构造器的第一行，所以两个不能同时出现在一个构造函数里。 4. super从子类中调用父类的构造方法，this在同一个类中调用其他方法。 5. this是一个指向本对象的指针，super是一个java关键字（名义上this也说是关键字）。 6. 一个构造器中只能有一个this(),来调用本类中其他的构造器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Father&#123; Father()&#123; System.out.println("父类构造器"); &#125; Father(String name)&#123; System.out.println("父类："+name); &#125; Father(String name,Integer age)&#123; System.out.println("父类："+name+";"+age); &#125; public static void fun_static_Father()&#123; System.out.println("fun_static_Father"); &#125; public void fun_one_Father()&#123; System.out.println("fun_one_Father"); &#125; public void fun_two_Father()&#123; System.out.println("fun_two_Father"); &#125;&#125;public class Son extends Father&#123; Son()&#123; super("白超"); this.fun_one_Father(); this.fun_one_Son(); &#125; Son(String name)&#123; System.out.println("子类："+name); &#125; Son(String name,Integer age)&#123; System.out.println("子类："+name+";"+age); &#125; public static void fun_static_Son()&#123; System.out.println("fun_static_Son"); &#125; public void fun_one_Son()&#123; System.out.println("fun_one_Son"); &#125; public void fun_two_Son()&#123; System.out.println("fun_two_Son"); &#125; public static void main(String[] args)&#123; Son son = new Son(); &#125;&#125; 注意： 1. this.就是一个对象，这个对象可以找到它和它父类所有的非静态方法。 2. super.也是一个对象，这个对象只能找到本对象父类的的所有非静态方法。 3. 构造器中super(),和this()只能出现一个。 4. super()和this()只能出现在构造器中。 重写和重载重载（Overload）和重写（Override）都是多态的表现形式，前者是多态在同一个类的不同方法的表现，后者是子父类中同一方法的覆盖！！！ 重载在编译时的多态，重写时运行时的多态。 重载1. 同一个类 2. 方法名一样 3. 形参不一样（个数和参数类型） 注意：方法的访问修饰符，返回值类型，抛出的异常都不能作为判断是否重载的依据。 父类中private的方法，子类中出现同名函数不同参的函数，这个不属于重载，属于新的方法。 重写（两同两小一大）1. 子父类 2. 方法名和形参一样 3. 抛出的异常和返回值是被重写方法对应的子类或者子异常（或者同一个） 4. 访问修饰符大于等于被重写方法 注意：这个返回值一旦是基本数据类型或者是void，那重写方法和被重写方法必须一致！！！ 测试代码1234567891011121314151617181920212223class Father&#123; public void fun()&#123; System.out.println("无参父类"); &#125; public List fun(String s)&#123; System.out.println("有参父类"+s); return null; &#125;&#125;public class Son extends Father&#123; public ArrayList fun(String s)&#123; System.out.println("有参子类"+s); return null; &#125; public static void main(String[] args)&#123; Father f = new Son(); f.fun(); f.fun("白超"); &#125;&#125; 1234567891011121314151617181920212223class Father&#123; public void fun()&#123; System.out.println("无参父类"); &#125; public int fun(String s)&#123; System.out.println("有参父类"+s); return 0; &#125;&#125;public class Son extends Father&#123; public int fun(String s)&#123;//这里的返回值必须是int，不然编译器直接就查出来错误，void也一样 System.out.println("有参子类"+s); return 0; &#125; public static void main(String[] args)&#123; Father f = new Son(); f.fun(); f.fun("白超"); &#125;&#125; 注意: 1. 重写的时候，调用是看new了谁，就调谁的方法（如果new的是子类，而且子类重写了这个方法，执行子类的方法体，没有重写，执行父类的方法体，new的是父类，就一定执行父类的方法体）。 2. 重载的时候，我们的使用的形参不同来区分的。 3. 多态时，方法调用的时候执行第一条的规则，但是我们在f.查找方法的时候，是看左边的，也就是说父类引用指向子类实体，但是使用引用的时候，只能找到引用的方法声明，一个这个方法声明被子类重写了，才走的时子类的方法体。 静态块，main方法，构造块执行顺序执行顺序：父类静态块--&gt;子类静态块--&gt;main方法--&gt;创建对象--&gt;父类构造块--&gt;父类构造器（this）--&gt;子类构造块（this/super）--&gt;子类构造器 注意：new的时候构造器和构造块的顺序，进入子类的构造器，第一行是super()或者this()，进入父类/子类，执行构造块，执行构造器方法体。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Father&#123; Father()&#123; System.out.println("父类无参构造器"); &#125; Father(String name)&#123; System.out.println("父类有参构造器"+name); &#125; static&#123; System.out.println("父类静态块---1"); &#125; &#123; System.out.println("父类构造块---1"); &#125; static&#123; System.out.println("父类静态块---2"); &#125; &#123; System.out.println("父类构造块---2"); &#125;&#125;public class Son extends Father&#123; Son()&#123; System.out.println("子类无参构造器"); &#125; Son(String name)&#123; super("白超"); &#125; Son(String name,Integer age)&#123; this(name); &#125; static&#123; System.out.println("子类静态块---1"); &#125; &#123; System.out.println("子类构造块---1"); &#125; static&#123; System.out.println("子类静态块---2"); &#125; &#123; System.out.println("子类构造块---2"); &#125; public static void main(String args[])&#123; //Father s; &#125;&#125;/** 父类静态块---1 父类静态块---2 子类静态块---1 子类静态块---2*/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Father&#123; Father()&#123; System.out.println("父类无参构造器"); &#125; Father(String name)&#123; System.out.println("父类有参构造器"+name); &#125; static&#123; System.out.println("父类静态块---1"); &#125; &#123; System.out.println("父类构造块---1"); &#125; static&#123; System.out.println("父类静态块---2"); &#125; &#123; System.out.println("父类构造块---2"); &#125;&#125;public class Son extends Father&#123; Son()&#123; System.out.println("子类无参构造器"); &#125; Son(String name)&#123; super("白超"); &#125; Son(String name,Integer age)&#123; this(name); &#125; static&#123; System.out.println("子类静态块---1"); &#125; &#123; System.out.println("子类构造块---1"); &#125; static&#123; System.out.println("子类静态块---2"); &#125; &#123; System.out.println("子类构造块---2"); &#125; public static void main(String args[])&#123; Father s = new Son("白超",24); &#125;&#125;/** 父类静态块---1 父类静态块---2 子类静态块---1 子类静态块---2 父类构造块---1 父类构造块---2 父类有参构造器白超 子类构造块---1 子类构造块---2*/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Father&#123; Father()&#123; System.out.println("父类无参构造器"); &#125; Father(String name)&#123; System.out.println("父类有参构造器"+name); &#125; static&#123; System.out.println("父类静态块---1"); &#125; &#123; System.out.println("父类构造块---1"); &#125; static&#123; System.out.println("父类静态块---2"); &#125; &#123; System.out.println("父类构造块---2"); &#125;&#125;public class Son extends Father&#123; Son()&#123; System.out.println("子类无参构造器"); &#125; Son(String name)&#123; super("白超"); &#125; Son(String name,Integer age)&#123; this(name); &#125; static&#123; System.out.println("子类静态块---1"); &#125; &#123; System.out.println("子类构造块---1"); &#125; static&#123; System.out.println("子类静态块---2"); &#125; &#123; System.out.println("子类构造块---2"); &#125; public static void main(String args[])&#123; Father s = new Son(); &#125;&#125;/** 父类静态块---1 父类静态块---2 子类静态块---1 子类静态块---2 父类构造块---1 父类构造块---2 父类无参构造器 子类构造块---1 子类构造块---2 子类无参构造器*/ 值传递和引用传递值传递：方法调用中，实参会把自己的值传递给形参，形参只是用实参初始化的一个临时存储单元，因此形参与实参虽然有着相同的值，但是不是同一个物理地址，所有形参的变化并不会影响实参的值。 引用传递：在方法调用中，传递的对象（可以看作是对象的地址），这个时候形参和实参的对象指向同一存储地址，因此对形参的修改就会影响实参的值。 除了八种基本数据类型外，其他的传递都是引用传递，只不过在引用传递中，我们会有不可变量的影响，导致不可变量的引用传递看起来像是值传递。 不可变量基本数据类型的包装类和String都是不可变量。 测试1234567891011121314public class Main &#123; public static void fun(StringBuffer sb,int n)&#123; sb.append("----"); n = 128; &#125; public static void main(String args[])&#123; StringBuffer sb = new StringBuffer("白"); int i = 1; fun(sb,i); System.out.println(sb);//白---- System.out.println(i);//1 &#125;&#125; 1234567891011121314public class Main &#123; public static void fun(StringBuffer sb,Integer n)&#123; sb.append("----"); n = 128; &#125; public static void main(String args[])&#123; StringBuffer sb = new StringBuffer("白"); int i = 1; fun(sb,i); System.out.println(sb);//白---- System.out.println(i);//1 &#125;&#125; 注意：两个虽然值是一样的，但是过程却不同，第一个就是值传递，int复制了一份放在了形参的地址上。 第二是把Integer的地址放在在形参的地址上，所以形参和实参都指向了实参指向的地址！！！ 但是因为Integer是不可变量，在方法中赋值的操作，导致形参n指向了另外的地址（新的，就像是new了一下）， 所以才没有改变实参指向地址的内容。 1234567891011121314151617181920public class Main &#123; public static void fun(StringBuffer sb,StringBuffer sbb)&#123; sb.append("----"); sbb = sb; &#125; public static void main(String args[])&#123; Integer a = 1; Integer b = a; b++; System.out.println(a);//1 System.out.println(b);//2 StringBuffer sb = new StringBuffer("白"); StringBuffer sbb = new StringBuffer("超"); fun(sb,sbb); System.out.println(sb);//白---- System.out.println(sbb);//超 &#125;&#125; 注意：我们说的引用传递的，其实都是在方法开辟了新地址，而传递的都是实参原来指向的地址，导致，形参也执行了这个地址，但是如果我们没有修改这个实参地址中的内容，那么实参的指向又不会改变，所以值就不变。 这也就是说的只有形参实际改变了指向地址的内容，实参才会改变，如果是个改变了形参指向的地址，那对实参并没有影响。 注意，这个东西在try...catch..finally中遇到return的时候也会发生。 123456finally一定会执行，但是一定实在return之前。如果try-finally和catch-finally都有return 那么finally中的return就会覆盖别处的return！！！方法内定义的变量本身都是在栈中的，方法返回的时候，对应的栈也就被回收了，这个时候我们在方法中的变量也就没有了，所以我们方法返回的一直都是复制品。 1. 对于基本数据类型，finally块中改变不会影响真实的返回值。（这里返回的是变量，前面说的是值，这个强调的finally对返回变量的影响，而设定finally中没有return，如果有的话也就覆盖了） 2. 对于引用类型，数据有影响。 1234567891011121314151617181920212223242526272829303132333435363738394041public class Main &#123; public static int test()&#123; int result = 1; try&#123; result = 2; return result; &#125;catch (Exception e)&#123; return 0; &#125;finally &#123; result = 3; //return result; &#125; &#125; public static void main(String args[])&#123; int i = test(); System.out.println(i);//2 &#125;&#125;public class Main &#123; public static int test()&#123; int result = 1; try&#123; result = 2; return result; &#125;catch (Exception e)&#123; return 0; &#125;finally &#123; result = 3; return result; &#125; &#125; public static void main(String args[])&#123; int i = test(); System.out.println(i);//3 &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class Main&#123; public static StringBuffer test_quote(StringBuffer sb)&#123; try&#123; return sb; &#125;catch (Exception e)&#123; return null; &#125;finally &#123; sb.append("---"); //sb = new StringBuffer("超"); return sb; &#125; &#125; public static void main(String args[])&#123; StringBuffer sb = new StringBuffer("白"); sb = test_quote(sb); System.out.println(sb);//白--- &#125;&#125;public class Main&#123; public static StringBuffer test_quote(StringBuffer sb)&#123; try&#123; return sb; &#125;catch (Exception e)&#123; return null; &#125;finally &#123; sb.append("---"); sb = new StringBuffer("超"); return sb; &#125; &#125; public static void main(String args[])&#123; StringBuffer sb = new StringBuffer("白"); sb = test_quote(sb); System.out.println(sb);//白---，先改变了实参的内容！！！后面才改变的指向。 &#125;&#125;public class Main&#123; public static StringBuffer test_quote(StringBuffer sb)&#123; try&#123; return sb; &#125;catch (Exception e)&#123; return null; &#125;finally &#123; //sb.append("---"); sb = new StringBuffer("超"); return sb; &#125; &#125; public static void main(String args[])&#123; StringBuffer sb = new StringBuffer("白"); sb = test_quote(sb); System.out.println(sb);//超--- &#125;&#125;public class Main&#123; public static StringBuffer test_quote(StringBuffer sb)&#123; try&#123; return sb; &#125;catch (Exception e)&#123; return null; &#125;finally &#123; //sb.append("---"); sb = new StringBuffer("超"); //return sb; &#125; &#125; public static void main(String args[])&#123; StringBuffer sb = new StringBuffer("白"); sb = test_quote(sb); System.out.println(sb);//白--- &#125;&#125; 接口和抽象类1. 接口和抽象类都不能实例化 2. 接口中的变量默认为public static final,方法默认为public abstract， 3. 抽象类中的可以没有抽象方法，有抽象方法的类一定是抽象类 4. 接口可以多继承，抽象类不可以 5. 接口中的方法都是抽象的，抽象方法都是以();结尾 6. abstract和static/final都不可以一起用。 7. final修饰的成员/类变量必须在声明的时候就初始化，局部变量则可以先不被初始化，但是使用的使用肯定需要初始化的。 内部类静态内部类（静态方法）：不依赖外部类实例化，就像是静态方法一样，静态内部类不能访问外部类中的非静态资源！！！ 成员内部类（一般方法）：就和成员方法一样，需要依赖外部类实例化以后，才可以调用，同时这个类里面不能有静态资源！！！ 局部内部类（局部变量）：只能访问所在方法/块中的局部变量。 在static方法和static块中的内部类，就是局部静态内部类； 在一般方法和构造块中的内部类，就是局部构造内部类（局部内部类）; 这两个的性质相似于对应的内部类。 匿名内部类： 1. 不使用关键字class、implements、extends 2. 没有构造器 3. 必须继承？其他类或者实现？其他接口 4. 匿名内部类不能定义静态资源。 5. 不能被访问修饰符（除默认）和static修饰。 6. 匿名内部类是单例的（只能创建它的一个实例） 7. 一定是在new后面的 8. 属于局部内部类，满足局部内部类的一切限制。 执行顺序补充123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package xd.blemon;import java.util.*;class C &#123; C() &#123; System.out.println("C"); &#125; C(String name) &#123; System.out.println(name); &#125; &#123; System.out.println("构造C--1"); &#125; static&#123; System.out.println("静态C--1"); &#125; &#123; System.out.println("构造C--2"); &#125; static&#123; System.out.println("静态C--2"); &#125; &#125; class A &#123; public C c = new C(); public static C cc = new C("白"); A() &#123; this("AAAA---BBBB"); System.out.println("A"); &#125; &#123; System.out.println("构造父类A--1"); &#125; static&#123; System.out.println("静态父类A--1"); &#125; &#123; System.out.println("构造父类A--2"); &#125; static&#123; System.out.println("静态父类A--2"); &#125; A(String s) &#123; System.out.println(s); &#125;&#125; class Main extends A &#123; Main() &#123; super(); System.out.println("B"); &#125; &#123; System.out.println("构造子类Main--1"); &#125; static&#123; System.out.println("静态子类Main--1"); &#125; &#123; System.out.println("构造子类Main--2"); &#125; static&#123; System.out.println("静态子类Main--2"); &#125; public static void main(String[] args) &#123; new Main(); &#125;&#125;/** 静态C--1 父类中类变量，进入第三方类的静态块（加载） 静态C--2 构造C--1 父类中类变量new了，进入第三方类的构造块 构造C--2 白 构造器方法体 静态父类A--1 父类的静态块 静态父类A--2 静态子类Main--1 子类的静态块 静态子类Main--2 构造C--1 父类的成员变量（静态资源在程序的一次运行中只会加载一次） 构造C--2 C 第三方的构造器 构造父类A--1 父类的构造块 构造父类A--2 AAAA---BBBB 父类的构造器 A 父类构造器方法体 构造子类Main--1 子类构造块 构造子类Main--2 B 子类构造器方法体*/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798import java.util.*;class C &#123; C() &#123; System.out.println("C"); &#125; C(String name) &#123; System.out.println(name); &#125; &#123; System.out.println("构造C--1"); &#125; static&#123; System.out.println("静态C--1"); &#125; &#123; System.out.println("构造C--2"); &#125; static&#123; System.out.println("静态C--2"); &#125; &#125; class A &#123; public C c = new C(); public static C cc = new C("白"); A() &#123; this("AAAA---BBBB"); System.out.println("A"); &#125; &#123; System.out.println("构造父类A--1"); &#125; static&#123; System.out.println("静态父类A--1"); &#125; &#123; System.out.println("构造父类A--2"); &#125; static&#123; System.out.println("静态父类A--2"); &#125; A(String s) &#123; System.out.println(s); &#125;&#125; class Main extends A &#123; Main() &#123; this("WWW"); System.out.println("B"); &#125; Main(String name) &#123; System.out.println("B--TT"+name); &#125; &#123; System.out.println("构造子类Main--1"); &#125; static&#123; System.out.println("静态子类Main--1"); &#125; &#123; System.out.println("构造子类Main--2"); &#125; static&#123; System.out.println("静态子类Main--2"); &#125; public static void main(String[] args) &#123; new Main(); &#125;&#125;/** 静态C--1 静态C--2 构造C--1 构造C--2 白 静态父类A--1 静态父类A--2 静态子类Main--1 静态子类Main--2 构造C--1 构造C--2 C 构造父类A--1 构造父类A--2 AAAA---BBBB A 构造子类Main--1 构造子类Main--2 B--TTWWW B*/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import java.util.*;class C &#123; C() &#123; System.out.println("C"); &#125; C(String name) &#123; System.out.println(name); &#125; &#123; System.out.println("构造C--1"); &#125; static&#123; System.out.println("静态C--1"); &#125; &#123; System.out.println("构造C--2"); &#125; static&#123; System.out.println("静态C--2"); &#125; &#125; class A &#123; public C c ; public static C cc ; A() &#123; this("AAAA---BBBB"); System.out.println("A"); &#125; &#123; System.out.println("构造父类A--1"); &#125; static&#123; System.out.println("静态父类A--1"); &#125; &#123; System.out.println("构造父类A--2"); &#125; static&#123; System.out.println("静态父类A--2"); &#125; A(String s) &#123; System.out.println(s); &#125;&#125; class Main extends A &#123; Main() &#123; this("WWW"); System.out.println("B"); &#125; Main(String name) &#123; System.out.println("B--TT"+name); &#125; &#123; System.out.println("构造子类Main--1"); &#125; static&#123; System.out.println("静态子类Main--1"); &#125; &#123; System.out.println("构造子类Main--2"); &#125; static&#123; System.out.println("静态子类Main--2"); &#125; public static void main(String[] args) &#123; new Main(); &#125;&#125;/** 静态父类A--1 静态父类A--2 静态子类Main--1 静态子类Main--2 构造父类A--1 构造父类A--2 AAAA---BBBB A 构造子类Main--1 构造子类Main--2 B--TTWWW B*/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package xd.blemon;import java.util.*;class C &#123; C() &#123; System.out.println("C"); &#125; C(String name) &#123; System.out.println(name); &#125; &#123; System.out.println("构造C--1"); &#125; static&#123; System.out.println("静态C--1"); &#125; &#123; System.out.println("构造C--2"); &#125; static&#123; System.out.println("静态C--2"); &#125; &#125; class A &#123; public C c = new C();; public static C cc = new C("巴拉巴拉"); A() &#123; this("AAAA---BBBB"); System.out.println("A"); &#125; &#123; System.out.println("构造父类A--1"); &#125; static&#123; System.out.println("静态父类A--1"); &#125; &#123; System.out.println("构造父类A--2"); &#125; static&#123; System.out.println("静态父类A--2"); &#125; A(String s) &#123; System.out.println(s); &#125;&#125; class Main extends A &#123; Main() &#123; this("WWW"); System.out.println("B"); &#125; Main(String name) &#123; System.out.println("B--TT"+name); &#125; &#123; System.out.println("构造子类Main--1"); &#125; static&#123; System.out.println("静态子类Main--1"); &#125; &#123; System.out.println("构造子类Main--2"); &#125; static&#123; System.out.println("静态子类Main--2"); &#125; public static void main(String[] args) &#123; //new Main(); //Main m; &#125;&#125;/** 静态C--1 静态C--2 构造C--1 构造C--2 巴拉巴拉 静态父类A--1 静态父类A--2 静态子类Main--1 静态子类Main--2*/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class C &#123; C() &#123; System.out.println("C"); &#125; C(String name) &#123; System.out.println(name); &#125; &#123; System.out.println("构造C--1"); &#125; static&#123; System.out.println("静态C--1"); &#125; &#123; System.out.println("构造C--2"); &#125; static&#123; System.out.println("静态C--2"); &#125; &#125; class A &#123; public C c; public static C cc ; A() &#123; this("AAAA---BBBB"); System.out.println("A"); &#125; &#123; System.out.println("构造父类A--1"); &#125; static&#123; System.out.println("静态父类A--1"); &#125; &#123; System.out.println("构造父类A--2"); &#125; static&#123; System.out.println("静态父类A--2"); &#125; A(String s) &#123; System.out.println(s); &#125;&#125; class Main extends A &#123; Main() &#123; this("WWW"); System.out.println("B"); &#125; Main(String name) &#123; System.out.println("B--TT"+name); &#125; &#123; System.out.println("构造子类Main--1"); &#125; static&#123; System.out.println("静态子类Main--1"); &#125; &#123; System.out.println("构造子类Main--2"); &#125; static&#123; System.out.println("静态子类Main--2"); &#125; public static void main(String[] args) &#123; //new Main(); //Main m; &#125;&#125;/** 静态父类A--1 静态父类A--2 静态子类Main--1 静态子类Main--2*/ 1. 父类静态变量（类变量），静态块 2. 子类静态变量，静态块 3. 父类的成员变量，构造块，构造器方法体 4. 子类的成员变量，构造块，构造器方法体。 5. 注意一点：成员变量和构造块，构造器，都是只有在new这个关键字出现后才会调用的。而只声明的话，静态的也不会调用！！！ 6. 声明是不会调用资源的！！！！包括静态 执行顺序与this/super1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Test &#123; public static void main(String[] args)&#123; A a; B b; System.out.println(); &#125; static class A&#123; protected int value; public A(int v)&#123; setValue(v); &#125; static&#123; System.out.println("静态A"); &#125; &#123; System.out.println("构造B"); &#125; public void setValue(int value)&#123; this.value = value; &#125; public int getValue()&#123; try&#123; value++; return value; &#125;finally&#123; this.setValue(value); System.out.println(value); &#125; &#125; &#125; static class B extends A&#123; static&#123; System.out.println("静态B"); &#125; &#123; System.out.println("构造B"); &#125; public B()&#123; super(5); setValue(getValue()-3); &#125; public void setValue(int value)&#123; super.setValue(value*2); &#125; &#125;&#125; 只声明是没有输出的，而且因为main所在的Test没有静态块，所以加载的时候也没有输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Test &#123; public static void main(String[] args)&#123; A a = new A(5); System.out.println(); &#125; static class A&#123; protected int value; public A(int v)&#123; setValue(v); &#125; static&#123; System.out.println("静态A"); &#125; &#123; System.out.println("构造A"); &#125; public void setValue(int value)&#123; this.value = value; &#125; public int getValue()&#123; try&#123; value++; return value; &#125;finally&#123; this.setValue(value); System.out.println(value); &#125; &#125; &#125; static class B extends A&#123; static&#123; System.out.println("静态B"); &#125; &#123; System.out.println("构造B"); &#125; public B()&#123; super(5); setValue(getValue()-3); &#125; public void setValue(int value)&#123; super.setValue(value*2); &#125; &#125;&#125;/** 静态A 构造A*/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Test &#123; public static void main(String[] args)&#123; //A a = new A(5); A a = new B(); System.out.println(); &#125; static class A&#123; protected int value; public A(int v)&#123; setValue(v); &#125; static&#123; System.out.println("静态A"); &#125; &#123; System.out.println("构造A"); &#125; public void setValue(int value)&#123; this.value = value; &#125; public int getValue()&#123; try&#123; value++; return value; &#125;finally&#123; this.setValue(value); System.out.println(value); &#125; &#125; &#125; static class B extends A&#123; static&#123; System.out.println("静态B"); &#125; &#123; System.out.println("构造B"); &#125; public B()&#123; super(5); setValue(getValue()-3); &#125; public void setValue(int value)&#123; super.setValue(value*2); &#125; &#125;&#125;/** 静态A 静态B 构造A 构造B 22*/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Test &#123; public static void main(String[] args)&#123; //A a = new A(5); A a = new B(); System.out.println(a.getValue()); &#125; static class A&#123; protected int value; public A(int v)&#123; setValue(v); &#125; static&#123; System.out.println("静态A"); &#125; &#123; System.out.println("构造A"); &#125; public void setValue(int value)&#123; this.value = value; &#125; public int getValue()&#123; try&#123; value++; return value; &#125;finally&#123; this.setValue(value); System.out.println(value); &#125; &#125; &#125; static class B extends A&#123; static&#123; System.out.println("静态B"); &#125; &#123; System.out.println("构造B"); &#125; public B()&#123; super(5); setValue(getValue()-3); &#125; public void setValue(int value)&#123; super.setValue(value*2); &#125; &#125;&#125;/** 静态A 静态B 构造A 构造B 22 34 17*/ 123456789101112131415161718192021222324252627public class Main &#123; static class A&#123; public void fun()&#123; System.out.println("A"); &#125; public void function()&#123; fun(); &#125; &#125; static class B extends A&#123; public void fun()&#123; System.out.println("B"); &#125; &#125; public void fun_Main()&#123; A a = new A(); a.function(); &#125; public static void main(String[] args) &#123; Main m = new Main(); m.fun_Main(); &#125;&#125;/** A*/ 123456789101112131415161718192021222324252627public class Main &#123; static class A&#123; public void fun()&#123; System.out.println("A"); &#125; public void function()&#123; fun();//this.fun(); &#125; &#125; static class B extends A&#123; public void fun()&#123; System.out.println("B"); &#125; &#125; public void fun_Main()&#123; A a = new B(); a.function(); &#125; public static void main(String[] args) &#123; Main m = new Main(); m.fun_Main(); &#125;&#125;/** B*/ 12345678910111213141516171819202122232425262728public class Main &#123; static class A&#123; public void fun()&#123; System.out.println("A"); &#125; public void function()&#123; this.fun(); &#125; &#125; static class B extends A&#123;// public void fun()&#123;// System.out.println("B");// &#125; &#125; public void fun_Main()&#123; A a = new B(); a.function(); &#125; public static void main(String[] args) &#123; Main m = new Main(); m.fun_Main(); &#125;&#125;/** A*/但是this仍然说的是B对象，不过是因为子类中没有fun方法，向上找了。 综上注意： 1. this/super是两个关键字，只能用在非static的地方，this()和super()只能用在构造器中相互调用。 2. 我们调用的实例方法体中，一旦出现了this和super，或者出现了子类重写了父类的方法（调用父类方法时直接出现方法名，或者this.），都是看我们实例化的到底是谁！！！实例化的是谁，就执行谁的方法。 接口和抽象类的补充1. JDK1.7 和之前接口中的方法都是public abstract的 2. JDK1.8 以后接口中可以有static和default的方法存在，而且可以有方法体。 3. abstract和final、private、static不可以共用的。 123456789101112131415public interface MainInter &#123; int Num = 0; void fun(); public abstract void fun_1(); default void fun_2()&#123;&#125; static void fun_3()&#123; System.out.println("..."); &#125;&#125;class Main&#123; public static void main(String[] args) &#123; MainInter.fun_3(); &#125;&#125; 基本数据类型和包装类补充12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Main&#123; public static void main(String[] args) &#123; Integer i = 127; Integer i_2 = 127; int i_3 = 127; System.out.println(i==i_2); System.out.println(i_3==i_2); Integer i_4 = 128; Integer i_5 = 128; System.out.println(i_4==i_5); Long l = 1L;//必须加L,因为这不是基本数据类型，不会自动向上转型 long l_2 = 1; System.out.println(l==l_2); Integer j = 1; int j_2 = 1; System.out.println(l_2==j);//true 拆箱 向上转型 System.out.println(l_2==j_2); System.out.println(j.equals(l_2)); Float f = 1F; Float f_2 = 1.0F; float f_3 = 1; float f_4 = (float)1.0; Double d = 1.0; double d_2 = 1; System.out.println(f==f_2); System.out.println(f.equals(f_2)); System.out.println(d_2==f_2); Short s = 2; short s_2 = 2; short s_3 = (short)(s_2+1); &#125;&#125;/** true true false true true true false false true true*/ 1. 基本数据类型和包装类==比较都是直接比较值，包装类会拆箱。然后变成了两个基本数据类型的比较，低的一方，自动向上转型。 2. 不同的包装类不能用==比较，及时编译器直接报错 3. 不同包装类的equals方法不提供类型转换。 4. 包装类都是不可变类。 5. 上面规则适合于返回值。 1234public float fun()&#123; Short s = 2; return s;&#125; 不可继承类1. 基本数据类型的包装类（都继承了Number），String，Math。 2. System，StringBuilder，StringBuffer 3. ClassLoader可以被继承，可以有自己的类加载器 泛型1. 泛型只是在编译的时候保证了类型，但是在运行时，是不存在这个东西的。 泛型通配符1. ?:任意类型，如果没有明确，那么就是Object以及任意的Java类了。 2. ? extends E:向下限定，E及其子类 3. ? super E:向上限定，E及其父类 注意：泛型就是里面的东西如果是点对点 就算是继承关系也不行！！！List&lt;Object&gt;就是Object对象，不能是Object的其他子类！！！ 运算符优先级1. 单目运算符：+，-，++，-- 2. 算数运算符：+，-，*，/，% 3. 移位运算符：&lt;&lt;，&gt;&gt; 4. 关系运算符：&gt;，&lt;，&gt;=，&lt;=，==，！= 5. 位运算符：&amp;，|，~，^ 6. 逻辑运算符：&amp;&amp;，|| 7. 三目运算符 8. 赋值运算符 java/javac]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为OJ（一）]]></title>
    <url>%2F2018%2F03%2F27%2F%E5%8D%8E%E4%B8%BAOJ%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[华为OJ 字符串最后一个单词的长度计算字符串最后一个单词的长度，单词以空格隔开。 输入 hello world 输出 5 123456789101112import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String[] arr = scanner.nextLine().split("\\s+"); System.out.println(arr[arr.length-1].length()); &#125; scanner.close(); &#125;&#125; 计算字符个数写出一个程序，接受一个有字母和数字以及空格组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。 输入 ABCDEF A 输出 1 12345678910111213141516171819import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String str = scanner.nextLine(); String key = scanner.nextLine(); int count = 0; for(int i=0;i&lt;str.length();i++)&#123; if(key.equalsIgnoreCase(String.valueOf(str.charAt(i))))&#123; count++; &#125; &#125; System.out.println(count); &#125; scanner.close(); &#125;&#125; 去重和排序输入 11 10 20 40 32 67 40 20 89 300 400 15 输出 10 15 20 32 40 67 89 300 400 12345678910111213141516import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; Set&lt;Integer&gt; set = new TreeSet&lt;Integer&gt;();; int count = Integer.parseInt(scanner.next()); for(int i=0;i&lt;count;i++)&#123; set.add(Integer.parseInt(scanner.next())); &#125; for(Integer i : set)&#123; System.out.println(i); &#125; &#125; scanner.close(); 字符串分割输入 abc 123456789 输出 abc00000 12345678 90000000 123456789101112131415161718192021222324252627import java.util.*;public class Main&#123; public static void getStr(String str,List&lt;String&gt; list)&#123; if(str.length()&lt;=8)&#123; str = str+"00000000"; list.add(str.substring(0,8)); return ; &#125;else&#123; list.add(str.substring(0,8)); getStr(str.substring(8),list); &#125; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); getStr(scanner.nextLine(),list); getStr(scanner.nextLine(),list); for(String s : list)&#123; System.out.println(s); &#125; &#125; scanner.close(); &#125;&#125; 进制转换写出一个程序，接受一个十六进制的数值字符串，输出该数值的十进制字符串。（多组同时输入 ） 输入 0xA 输出 10 1234567891011import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; System.out.println(Integer.parseInt(scanner.next().substring(2),16)); &#125; scanner.close(); &#125;&#125; 质数因子输入 180 输出 2 2 3 3 5 123456789101112131415161718192021222324252627282930import java.util.*;public class Main&#123; public static void getFactors(int num,List&lt;Integer&gt; list)&#123; if(num&lt;=1)&#123; return ; &#125; for(int i=2;i&lt;=num;i++)&#123; if(num%i==0)&#123; list.add(i); getFactors(num/i,list); return ; &#125; &#125; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); getFactors(Integer.parseInt(scanner.next()),list); StringBuilder sb = new StringBuilder(); for(Integer i : list)&#123; sb.append(i+" "); &#125; System.out.println(sb); &#125; scanner.close(); &#125;&#125; 取近似值输入 5.5 输出 6 1234567891011import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; System.out.println(Math.round(scanner.nextDouble())); &#125; scanner.close(); &#125;&#125; 合并表记录输入 4 0 1 0 2 1 2 3 4 输出 0 3 1 2 3 4 12345678910111213141516171819202122import java.util.*;public class Main&#123; public static void main(String args[])&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; int num = Integer.parseInt(scanner.nextLine()); Map&lt;Integer,Integer&gt; map = new TreeMap&lt;Integer,Integer&gt;(); for(int i=0;i&lt;num;i++)&#123; String[] arr = scanner.nextLine().split("\\s+"); int key = Integer.parseInt(arr[0]); int value = Integer.parseInt(arr[1]); map.put(key,map.get(key)==null?value:map.get(key)+value); &#125; for(Integer i : map.keySet())&#123; System.out.println(i+" "+map.get(i)); &#125; &#125; scanner.close(); &#125;&#125; 提取不重复的整数按照从右向左的阅读顺序，返回一个不含重复数字的新的整数 输入 9876673 输出 37689 123456789101112131415161718192021import java.util.*;public class Main&#123; public static void main(String args[])&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; StringBuilder sb = new StringBuilder(scanner.nextLine()); String s = sb.reverse().toString(); LinkedHashSet&lt;Character&gt; set = new LinkedHashSet&lt;&gt;(); for(int i=0;i&lt;s.length();i++)&#123; set.add(s.charAt(i)); &#125; sb.setLength(0); for(Character c : set)&#123; sb.append(c); &#125; System.out.println(sb.toString()); &#125; scanner.close(); &#125;&#125; 字符个数统计输入 abc 输出 3 12345678910111213141516import java.util.*;public class Main&#123; public static void main(String args[])&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; char[] arr = scanner.nextLine().toCharArray(); Set&lt;Character&gt; set = new HashSet&lt;&gt;(); for(char c : arr)&#123; set.add(c); &#125; System.out.println(set.size()); &#125; scanner.close(); &#125;&#125; 数字颠倒/字符串反转输入 1516000 输出 0006151 1234567891011import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; System.out.println(new StringBuilder(scanner.nextLine()).reverse()); &#125; scanner.close(); &#125;&#125; 句子反转（Arrays.asList）1234567891011121314151617import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(scanner.nextLine().split("\\s+"))); Collections.reverse(list); StringBuilder sb = new StringBuilder(); for(String s : list)&#123; sb.append(s+" "); &#125; System.out.println(sb.toString().trim()); &#125; scanner.close(); &#125;&#125; 字符串的连接最长路径查找（字典排序，可重复）12345678910111213141516171819import java.util.*;public class Main&#123; public static void main(String args[])&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; int num = Integer.parseInt(scanner.nextLine()); List&lt;String&gt; list = new ArrayList&lt;&gt;(); for(int i=0;i&lt;num;i++)&#123; list.add(scanner.nextLine()); &#125; Collections.sort(list); for(String s :list)&#123; System.out.println(s); &#125; &#125; scanner.close(); &#125;&#125; 求int型正整数在内存中存储1的个数输入 5 输出 2 123456789101112131415161718import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String binStr = Integer.toString(Integer.parseInt(scanner.nextLine()),2); int count = 0; for(int i=0;i&lt;binStr.length();i++)&#123; if(binStr.charAt(i)=='1')&#123; count++; &#125; &#125; System.out.println(count); &#125; scanner.close(); &#125;&#125; 购物车(01背包)输入 1000 5 800 2 0 400 5 1 300 5 1 400 3 0 500 2 0 输出 2200 1234567891011121314151617181920212223242526272829303132333435363738import java.util.*;public class Main&#123; public static int getMaxValue(int total,int num,int[] price,int[] value,int[] isAnnex)&#123; int[][] result = new int[num+1][total+1]; for(int i=1;i&lt;num+1;i++)&#123; for(int j=1;j&lt;total+1;j++)&#123; if(isAnnex[i-1]==0)&#123; if(price[i-1]&lt;=j) result[i][j] = Math.max(result[i-1][j],result[i-1][j-price[i-1]]+value[i-1]); &#125;else&#123; if(price[i-1]+price[isAnnex[i-1]]&lt;=j) result[i][j] = Math.max(result[i-1][j],result[i-1][j-price[i-1]]+value[i-1]); &#125; &#125; &#125; return result[num][total]; &#125; public static void main(String args[])&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextInt())&#123; int total = scanner.nextInt(); int num = scanner.nextInt(); int[] price = new int[num]; int[] value = new int[num]; int[] isAnnex = new int[num]; for(int i=0;i&lt;num;i++)&#123; price[i] = scanner.nextInt(); value[i] = scanner.nextInt()*price[i]; isAnnex[i] = scanner.nextInt(); &#125; System.out.println(getMaxValue(total,num,price,value,isAnnex)); &#125; scanner.close(); &#125;&#125; 坐标移动输入 A10;S20;W10;D30;X;A1A;B10A11;;A10; 输出 10,-10 123456789101112131415161718192021222324252627282930313233import java.util.*;public class Main&#123; public static int[] getCoordinate(String[] arr)&#123; int length = arr.length; int[] coordinate = new int[2]; for(int i=0;i&lt;length;i++)&#123; String temp = arr[i]; if(temp.matches("[ASWD][0-9]+"))&#123; if(temp.charAt(0)=='A')&#123; coordinate[0]-=Integer.parseInt(temp.substring(1)); &#125;else if(temp.charAt(0)=='D')&#123; coordinate[0]+=Integer.parseInt(temp.substring(1)); &#125;else if(temp.charAt(0)=='W')&#123; coordinate[1]+=Integer.parseInt(temp.substring(1)); &#125;else&#123; coordinate[1]-=Integer.parseInt(temp.substring(1)); &#125; &#125; &#125; return coordinate; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String arr[] = scanner.nextLine().split("\\;"); int[] result = getCoordinate(arr); System.out.println(result[0]+","+result[1]); &#125; scanner.close(); &#125;&#125; 识别有效IP和Mask（正则）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.util.*;import java.util.regex.*;/** * 1. Mask 255.255.255.255 , 0.0.0.0 为非法,但是这个题里面允许了！！！ * 2. IP和Mask必须同时正确，才能被分类到A, B, C, D, E以及私有。只要有一个错了，错误数记一次。然后进入下次循环！！！ */public class Main&#123; public static boolean isValidFormat(String ip)&#123; boolean flag = true; Pattern p = Pattern.compile("^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$"); Matcher m = p.matcher(ip); if(m.matches())&#123; String temp[] = ip.split("\\."); for(String s:temp)&#123; int i = Integer.parseInt(s); if(i&lt;0||i&gt;255)&#123; flag = false; break; &#125; &#125; &#125;else&#123; flag = false; &#125; return flag; &#125; public static boolean isValidMask(String mask)&#123; String[] arr = mask.split("\\."); StringBuilder sb = new StringBuilder(); for(String s:arr)&#123; String bin = "00000000"+Integer.toBinaryString(Integer.parseInt(s)); bin = bin.substring(bin.length()-8); sb.append(bin); &#125; String binString = sb.toString(); int first_zero = binString.indexOf("0"); int end_one = binString.lastIndexOf("1"); return first_zero&lt;end_one?false:true; &#125; public static void main(String args[])&#123; Scanner scanner = new Scanner(System.in); int ip_A = 0; int ip_B = 0; int ip_C = 0; int ip_D = 0; int ip_E = 0; int error_ip_mask = 0; int ip_Private = 0; while(scanner.hasNextLine())&#123; String arr[] = scanner.nextLine().split("~"); String ip = arr[0]; String mask = arr[1]; if(!isValidFormat(ip)||!isValidFormat(mask))&#123; error_ip_mask++; continue; &#125; if(!isValidMask(mask))&#123; error_ip_mask++; continue; &#125; int ip_Area = Integer.parseInt(ip.substring(0,ip.indexOf("."))); if (ip_Area &gt;= 1 &amp;&amp; ip_Area &lt; 127) &#123; ip_A++; &#125; else if (ip_Area &gt;= 128 &amp;&amp; ip_Area &lt; 192) &#123; ip_B++; &#125; else if (ip_Area &gt;= 192 &amp;&amp; ip_Area &lt; 224) &#123; ip_C++; &#125; else if (ip_Area &gt;= 224 &amp;&amp; ip_Area &lt; 240) &#123; ip_D++; &#125; else if (ip_Area &gt;= 240 &amp;&amp; ip_Area &lt;= 255) &#123; ip_E++; &#125; String subIpAddr = ip.substring(ip.indexOf(".")+1); int subIpAddr_Area = Integer.parseInt(subIpAddr.substring(0,subIpAddr.indexOf("."))); if(ip_Area==10 || (ip_Area==172&amp;&amp;(subIpAddr_Area&gt;=16&amp;&amp;subIpAddr_Area&lt;=31)) ||(ip_Area==192&amp;&amp;subIpAddr_Area==168))&#123; ip_Private++; &#125; &#125; scanner.close(); System.out.println(ip_A+" "+ip_B+" "+ip_C+" "+ip_D+" "+ip_E+" "+error_ip_mask+" "+ip_Private); &#125;&#125; 简单错误记录输入 E:\V1R2\product\fpgadrive.c 1325 输出 fpgadrive.c 1325 1 1234567891011121314151617181920212223242526import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); Map&lt;String,Integer&gt; map = new LinkedHashMap&lt;&gt;(); while(scanner.hasNextLine())&#123; String errorArr[] = scanner.nextLine().split("\\s+"); String errorName[] = errorArr[0].split("\\\\"); String fileName = errorName[errorName.length-1]; if(fileName.length()&gt;16)&#123; fileName = fileName.substring(fileName.length()-16); &#125; fileName = fileName+" "+errorArr[1]; map.put(fileName,map.get(fileName)==null?1:map.get(fileName)+1); &#125; scanner.close(); int count = 0; for(String s:map.keySet())&#123; if(map.size()-count&lt;=8)&#123; System.out.println(s+" "+map.get(s)); &#125; count++; &#125; &#125;&#125; 错误记录（value降序）12345678910111213141516171819202122232425262728293031323334353637import java.util.*;import java.util.Map.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); Map&lt;String,Integer&gt; map = new LinkedHashMap&lt;&gt;(); while(scanner.hasNextLine())&#123; String errorArr[] = scanner.nextLine().split("\\s+"); String errorName[] = errorArr[0].split("\\\\"); String fileName = errorName[errorName.length-1]; fileName = fileName+" "+errorArr[1]; map.put(fileName,map.get(fileName)==null?1:map.get(fileName)+1); &#125; scanner.close(); List&lt;Map.Entry&lt;String, Integer&gt;&gt; list = new ArrayList&lt;&gt;(map.entrySet()); Collections.sort(list,new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;()&#123; @Override public int compare(Entry&lt;String,Integer&gt; o1, Entry&lt;String,Integer&gt; o2) &#123; return o2.getValue().compareTo(o1.getValue());//02在前面就是降序 &#125; &#125;); int count = 0; for(Map.Entry&lt;String, Integer&gt; temp : list)&#123; if(count&lt;8)&#123; String s = temp.getKey(); String[] tempArr = s.split("\\s+"); s = tempArr[0]; if(s.length()&gt;16)&#123; s = s.substring(s.length()-16); &#125; System.out.println(s+" "+tempArr[1]+" "+temp.getValue()); &#125; count++; &#125; &#125;&#125; 密码验证合格程序（正则）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.*;import java.util.regex.*;public class Main&#123; public static boolean judgeLength(String s)&#123; return s.length()&gt;8?true:false; &#125; public static boolean judgeSymbol(String s)&#123; int count=0; String[] str=&#123;"[a-z]","[A-Z]","[0-9]","[^a-zA-Z0-9]"&#125;; for(int i=0;i&lt;str.length;i++)&#123; Pattern p=Pattern.compile(str[i]); Matcher m=p.matcher(s); if(m.find()) count++; &#125; return count&gt;=3; &#125; public static boolean judgeSubstring(String s)&#123; Map&lt;String,Integer&gt; map = new HashMap&lt;&gt;(); int length = s.length(); boolean flag = true; for(int i=0;i&lt;length-1;i++)&#123; for(int j=i+1;j&lt;length;j++)&#123; String temp = s.substring(i,j); if(map.get(temp)==null)&#123; map.put(s.substring(i,j),1); &#125;else&#123; if(temp.length()&gt;2)&#123; flag = false; break; &#125; &#125; if(j==length-1&amp;&amp;i!=0)&#123; map.put(String.valueOf(s.charAt(j)),1); temp = s.substring(i); if(map.get(temp)==null)&#123; map.put(s.substring(i,j),1); &#125;else&#123; if(temp.length()&gt;2)&#123; flag = false; break; &#125; &#125; &#125; &#125; &#125; return flag; &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String s = scanner.nextLine(); if(judgeLength(s)&amp;&amp;judgeSymbol(s)&amp;&amp;judgeSubstring(s))&#123; System.out.println("OK"); &#125;else&#123; System.out.println("NG"); &#125; &#125; scanner.close(); &#125;&#125; 查找所有字串12345678910111213141516171819202122import java.util.*;public class Sub &#123; public static void getSubstring(String s,Set&lt;String&gt; set)&#123; int length = s.length(); for(int i=0;i&lt;length-1;i++)&#123; for(int j=i+1;j&lt;length;j++)&#123; set.add(s.substring(i, j)); if(j==length-1&amp;&amp;i!=0)&#123; set.add(String.valueOf(s.charAt(j))); set.add(s.substring(i)); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Set&lt;String&gt; set = new LinkedHashSet&lt;&gt;(); getSubstring("ABCD",set); System.out.println(set); &#125;&#125; 判断是否是素数1234567891011121314151617public class Prime &#123; public static boolean isPrime(Integer key)&#123; if(key==2) return true; if(key&lt;2||key%2==0) return false; for(int i=3;i&lt;Math.sqrt(key);i+=2)&#123; if(key%i==0) return false; &#125; return true; &#125; public static void main(String[] args) &#123; System.out.println(isPrime(7)); &#125;&#125;]]></content>
      <categories>
        <category>HUAWEI</category>
      </categories>
      <tags>
        <tag>HUAWEI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础类API]]></title>
    <url>%2F2018%2F03%2F26%2FJava%E5%9F%BA%E7%A1%80%E7%B1%BBAPI%2F</url>
    <content type="text"><![CDATA[Java的基础类API 基本数据类型进制转换字符串到数字Int/Long 123456789101112131415public class Main&#123; public static void main(String[] args)&#123; //字符串到数字 String s = "100"; int i1 = Integer.parseInt(s); int i2 = Integer.parseInt(s, 2); System.out.println(i1+".."+i2); //100...4 &#125;&#125;/** 1. Integer.parseInt(String s)：把字符串转换成10进制的数字。 2. Integer.parseInt(String s,String radix)：把字符串转换成10进制的数，注意，parseInt这个方法，返回的一定是10进制，后面的radix指的事把前面的字符串看成几进制。*/ Double/Float 1234567public class Main&#123; public static void main(String[] args)&#123; //字符串到数字 String s = "100.0"; System.out.println(Double.parseDouble(s)); &#125;&#125; 数字到字符串Int/Long 123456789101112public class Main&#123; public static void main(String[] args)&#123; System.out.println(Integer.toString(10, 16));//a System.out.println(Integer.toBinaryString(4));//100 System.out.println(Integer.toOctalString(8));//10 System.out.println(Integer.toHexString(10));//a &#125;&#125;/** 1. Integer.toString(Integer i,String radix)：把10进制转成指定进制的字符串*/ Double/Float 123456public class Main&#123; public static void main(String[] args)&#123; System.out.println(Double.toHexString(10.7));//0x1.5666666666666p3 System.out.println(Double.toString(10.7));//10.7 &#125;&#125; 字符和字符串12345678910public class Main&#123; public static void main(String[] args)&#123; String s = "s"; System.out.println(s.charAt(0)); char c = 'c'; System.out.println(String.valueOf(c)); &#125;&#125; 1. char[] chArr = s.toCharArray(); Integer的自动拆装箱注意，Integer i = 127和Integer i = 128不一样的，对于Integer而言，在-128~127之间的时候，Integer i = 127是不会自动装箱的，会直接在Cache数组中拿到那个对象。 1234567891011public class Main&#123; public static void main(String[] args)&#123; Integer i1 = 127; Integer i2 = 127; Integer i3 = 128; Integer i4 = 128; System.out.println(i1==i2);//true System.out.println(i3==i4);//false &#125;&#125; Characterclass Main&#123;1234567891011121314 public static void main(String[] args)&#123; System.out.println(Character.toUpperCase(&apos;c&apos;)); System.out.println(Character.toLowerCase(&apos;C&apos;)); System.out.println(Character.isAlphabetic(55));//false,判断这个数字ASCII是不是一个字符 System.out.println(Character.isDigit(&apos; &apos;));//false System.out.println(Character.isLetter(&apos; &apos;));//false System.out.println(Character.isLowerCase(&apos;c&apos;));//true System.out.println(Character.isLowerCase(97));//65+32,a,true System.out.println(Character.isUpperCase(65));//A,true &#125;&#125; 1. isAlphabetic(int codePoint)：传入的是ASCII 2. isLetter，isDigit，is/to Upper/Lower Case都是传入char/codePoint。 Math1234567891011121314151617181920212223public class Main&#123; public static void main(String[] args)&#123; System.out.println(Math.ceil(20.5));//21.0 System.out.println(Math.ceil(-20.5));//-20.0 System.out.println(Math.floor(20.5));//20.0 System.out.println(Math.floor(-20.5));//-21.0 System.out.println(Math.round(20.5));//21 System.out.println(Math.round(-20.5));//-20 System.out.println(Math.pow(2,3.0));//8.0 System.out.println(Math.max(20.9,20));//20.9 System.out.println(Math.min(20.9, 20));//20.0 System.out.println(Math.PI);//3.141592653589793 System.out.println(Math.random());//0.5785822387130423 System.out.println(Math.abs(-20.9));//20.9 &#125;&#125; 1. ceil向上（大于等于），floor向下（小于等于） 2. round，+0.5向下取整 3. ceil、floor返回的都是double、float，round返回的都是long和int String1. char charAt(int index); 2. boolean endsWith(String suffix); 3. boolean startWith(String prefix); 4. int hashCode(); 5. int indexOf(char ch/String str) --&gt;lastIndexOf 6. int indexOf(char ch/String str,int fromIndex); --&gt;lastIndexOf 7. String intern(); 8. int length(); 9. boolean matches(String regex); 10. String raplace(char oldChar,char newChar); 11. String replaceAll(String regex,String replacement); 12. String[] split(String regex); 13. String substring(int beginIndex); 14. String substring(int beginIndex,int endIndex); 15. String trim(); 16. String toCharArray(); 17. String toUpper/LowerCase(); 18. boolean equalsIngnoreCase(String str); 123456789101112131415161718192021222324public class Main&#123; public static void main(String[] args)&#123; String s = "This is Java"; System.out.println(s.charAt(0));//T System.out.println(Arrays.toString(s.toCharArray()));//[T, h, i, s, , i, s, , J, a, v, a] System.out.println(s.endsWith("va"));//true System.out.println(s.startsWith("t"));//false System.out.println(s.indexOf("is"));//2 System.out.println(s.indexOf("is",2));//2 System.out.println(s.replace("i","t"));//Thts ts Java System.out.println(s.replaceAll("\\s+", " tt "));//This tt is tt Java System.out.println(s.substring(3, 6));//s i System.out.println(s.substring(2));//is is Java System.out.println(Arrays.toString(s.split("\\s+")));//[This, is, Java] System.out.println(s.toUpperCase());//THIS IS JAVA System.out.println(s.toLowerCase());//this is java &#125;&#125; 关于的String的唯一性和intern我们知道我们的String在Java内存中是在字符串常量池中的，但是在JDK1.7之前这个常量池在方法区， 对于HotSpot就是永久带。但是在JDK1.7以后独立出来。 类似的String = &quot;ss&quot;；这种都只是在字符串常量池中生成一个ss，但是在堆中是没有的！！ 但是new出来的对象，是会现在堆上创建，然后判断常量池中是否还有存在，存在的话，没有后续，不存在的话，会在常量池中也创建一个。 但是注意了存在的话，其实并不是什么都不做，而是把自己的物理地址复制一份给常量池，所以只要是new出来的东西，返回的其实都是堆上的地址。 但是intern这个方法就是只从常量池中获取引用！！！ String s = new String(&quot;ss&quot;);两个对象，常量池一个，堆里面一个. 直接使用双引号声明出来的String对象会直接存储在常量池中。 如果不是用双引号声明的String对象，可以使用String提供的intern方法。 intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中 123456public static void main(String[] args)&#123; String s1 = &quot;is&quot;; String s2 = new String(&quot;is&quot;); System.out.println(s1==s2);//false 常量池地址不等于堆中地址 System.out.println(s1==s2.intern());//true 常量池地址相同&#125; 1234567public static void main(String[] args)&#123; String s2 = "is"+"b"; String s1 = new String("isb"); System.out.println(s1==s2);//false 常量池地址不等于堆中地址 System.out.println(s1==s2.intern());//false 堆中地址不等于常量池地址&#125; 12345678910public static void main(String[] args)&#123; String s1 = new String("isb"); String s2 = new String("is")+new String("b"); System.out.println(s1==s2);//false 字符串在堆中的唯一性 System.out.println(s1==s2.intern());//false 堆中地址和常量池地址 System.out.println(s1.intern()==s2.intern());//true&#125; 1234567891011public static void main(String[] args)&#123; String s = new String("1"); s.intern(); String s2 = "1"; System.out.println(s==s2);//false String s3 = new String("1")+new String("1"); s3.intern(); String s4 = "11"; System.out.println(s3==s4);//true &#125; 1234567891011public static void main(String[] args)&#123; String s = new String("1"); String s2 = "1"; s.intern(); System.out.println(s==s2);//false String s3 = new String("1")+new String("1"); String s4 = "11"; s3.intern(); System.out.println(s3==s4);//false &#125; 1. 将String常量池从Perm区移动到了Java Heap区 2. String#intern 方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。 注意：其实就是intern方法，这个方法一旦执行，如果常量中有数据，无效，一旦没有数据，改变了原来对象的引用地址！！！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253String s1 = new String("aaa");String s2 = "aaa";System.out.println(s1 == s2); // falses1 = new String("bbb").intern();s2 = "bbb";System.out.println(s1 == s2); // trues1 = "ccc";s2 = "ccc";System.out.println(s1 == s2); // trues1 = new String("ddd").intern();s2 = new String("ddd").intern();System.out.println(s1 == s2); // trues1 = "ab" + "cd";s2 = "abcd"; System.out.println(s1 == s2); // trueString temp = "hh";s1 = "a" + temp;// 如果调用s1.intern 则最终返回trues2 = "ahh";System.out.println(s1 == s2); // falsetemp = "hh".intern();s1 = "a" + temp;s2 = "ahh";System.out.println(s1 == s2); // falsetemp = "hh".intern();s1 = ("a" + temp).intern();s2 = "ahh";System.out.println(s1 == s2); // trues1 = new String("1"); // 同时会生成堆中的对象 以及常量池中1的对象，但是此时s1是指向堆中的对象的s1.intern(); // 常量池中的已经存在s2 = "1";System.out.println(s1 == s2); // falseString s3 = new String("1") + new String("1"); // 此时生成了四个对象 常量池中的"1" + 2个堆中的"1" + s3指向的堆中的对象（注此时常量池不会生成"11"）s3.intern(); // jdk1.7之后，常量池不仅仅可以存储对象，还可以存储对象的引用，会直接将s3的地址存储在常量池String s4 = "11"; // jdk1.7之后，常量池中的地址其实就是s3的地址System.out.println(s3 == s4); // jdk1.7之前false， jdk1.7之后trues3 = new String("2") + new String("2");s4 = "22"; // 常量池中不存在22，所以会新开辟一个存储22对象的常量池地址s3.intern(); // 常量池22的地址和s3的地址不同System.out.println(s3 == s4); // false// 对于什么时候会在常量池存储字符串对象，我想我们可以基本得出结论: 1. 显示调用String的intern方法的时候; 2. 直接声明字符串字面常量的时候，例如: String a = "aaa";// 3. 字符串直接常量相加的时候，例如: String c = "aa" + "bb"; 其中的aa/bb只要有任何一个不是字符串字面常量形式，都不会在常量池生成"aabb". 且此时jvm做了优化，不// 会同时生成"aa"和"bb"在字符串常量池中 intern总结1. String s = new String(&quot;100&quot;);//会在常量池和堆中都生成100，但是返回堆中地址。 2. String s = new String(&quot;1&quot;)+new String(&quot;00&quot;);//会在常量池产生1，00，堆中产生1，00，100。 3. s.intern只有在常量池中么有的时候，才会改变s的引用地址。 4. StringBuilder和StringBuffer1. StringBuilder/StringBuffer append(String s); 2. StringBuilder/StringBuffer reverse(); 3. insert(int offset int); 4. capcacity(); 5. toString(); 6. setLength(); 12345678910 public static void main(String[] args)&#123; StringBuilder sb = new StringBuilder(); sb.append("java"); System.out.println(sb.capacity());//16 System.out.println(sb.length());//4 &#125;/** 这两个类里面比较容易忘的就是capcaity这个方法，同时需要留心，如果我们要清空StringBuilder、Buffer，我们使用的就是setLength（0）这个方法。*/ Scanner作为输入流，构造器中需要传入一个输入流。 Scanner sc = new Scanner(System.in); 1. hasNext()、hasNextLine()、hasNextInt() 2. next()、nextLine()、nextInt() 3. close 正则表达式1. [a-z]:a-z之间的任何小写字母 2. [^a-z]:a-z之外的任何字符 3. x|y：x或者y中的一个 4. [xyz]:xyz中的任意一个 5. \：将下一个字符标记成为特殊字符、文本、反向引用。比如：&quot;n&quot;是字母，&quot;\n&quot;表示换行符，需要匹配换行符&quot;\\n&quot;；&quot;\\&quot;匹配&quot;\\\\&quot;,第一个代表标记，第二个代表转义。 6. ^：取反 7. +：一次或者多次匹配前面的字符。 8. *：零次或者多次匹配前面的字符。 9. ？：零次或者一次匹配前面的字符。 10. \d:数字字符匹配。等效于 [0-9] 11. \w:匹配任何字类字符，包括下划线。与&quot;[A-Za-z0-9_]&quot;等效。 12345public static void main(String[] args) &#123; String s = " , bi "; System.out.println(s.replaceAll("\\s*", ""));//,bi System.out.println(s.replaceAll("[^a-zA-Z0-9+]", "1"));//1111bi1&#125; 流 1. stream结尾的都是字节流，er结尾的都是字符流。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基本概念]]></title>
    <url>%2F2018%2F03%2F25%2FJava%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[Java的基本概念 Java关键字访问控制字private、protected、public 类/方法/变量修饰符abstract、class、extends、final、implements、interface、native、new、static、strictfp、synchronized、transient、 volatile 错误处理assert、catch、finally、throw、throws、try 包相关package、import（package一定要在import之前） 基本类型boolean、byte、char、short、int、long、float、double、null 变量引用super、this、void 保留关键字goto、const Java标识符1. 数字，大小写字母，$,_ 这个四种组成。 2. 数字不能在第一位 3. 不能使用关键字 Java基本数据类型byte--&gt;short(char)--&gt;int--&gt;long--&gt;float--&gt;double 1. boolean不能和其他7个相互转换 2. int之前的byte、short在进行加减乘除运算的时候都会自动上升为int型（+=,-=,/=,*=又一个强制转换的操作） 3. byte:-128 ~ 127 4. 基本数据类型的默认值是0/0L，0.0d/0.0f,false,基本数据类型的包装类的默认值都是null； 5. char包含两个字节（16bits）Unicode，a是97，A是65 Java的变量类型类变量、实例变量、局部变量 成员（实例）变量 &amp; 局部变量存储位置 成员变量随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。 局部变量是方法被调用时存在，存储在栈中。 初始值 成员变量，有默认初始值。 局部变量，没有默认值，使用前必须进行赋值。 作用域 成员变量，针对整个类有效。 局部变量，只在某个范围内有效（方法体和语句块）。 成员（实例）变量 &amp; 类（静态）变量调用方法 静态变量，直接通过类名或者对象调用，整个变量属于这个类。 成员变量，只能通过对象调用。整个变量属于某个对象。 存储位置 静态变量，存储在方法区 成员变量，堆 生命周期 静态变量随着类的加载而存在。 成员变量随着对象的创建而存在。 与对象的相关性 静态变量是所有对象共享的数据。 成员变量是每个对象的自己的数据。 注意1. 访问修饰符不能用于局部变量（public、private、protected、default） Java修饰符访问控制修饰符（不修饰局部变量） public 对所有类可见。使用对象：类、接口、变量、方法 protected 对同一个包内的类和所有子类可见。使用对象：变量、方法。 default 同一个包内可见。使用对象：类、接口、变量、方法 private 在同一个类中可见。使用对象：变量和方法。 注意: 1. proetcted、private都不可以修饰外部类/接口。 2. 四个都可以修饰内部类和内部接口。 非访问修饰符staticstatic 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。 static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。 不可修饰外部类和接口，可以修饰内部类和接口 局部变量不能被static修饰 final修饰类，类不可继承 修饰方法，方法不能被重写 修饰变量，变量只能被初始化一次，被声明final的对象的引用不能只想别的对象，但是对象本身可以改变。 abstract修饰类，一个类不能被final和abstract同时修饰，如果一个类包含抽象方法，这个类一定是抽象类，但是抽象类不一定要有抽象方法。 修饰方法，final和abstract不可同时修饰，方法以;结尾。 其他1. transient：反序列化 2. volatile：可以多个线程操作。 3. synchronized ：线程加锁。 注意1. final、static可以共用，但两者不能和abstract共用。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂设计模式]]></title>
    <url>%2F2018%2F03%2F24%2F%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂设计模式 工厂设计模式 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。 步骤一: 1234创建一个接口public interface Shape &#123; public abstract void draw();&#125; 步骤二: 123456789101112131415161718192021222324252627282930313233343536373839创建一个工厂，生成基于给定信息的实体类的对象。package xd.design;class Triangle implements Shape&#123; @Override public void draw() &#123; System.out.println("Triangle"); &#125;&#125;class Square implements Shape&#123; @Override public void draw() &#123; System.out.println("Square"); &#125;&#125;class Cricle implements Shape&#123; @Override public void draw() &#123; System.out.println("Cricle"); &#125;&#125;public class ShapeFactory &#123; public Shape getShape(String shapeType)&#123; if(shapeType==null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase("Triangle"))&#123; return new Triangle(); &#125;else if(shapeType.equalsIgnoreCase("Square"))&#123; return new Square(); &#125;else if(shapeType.equalsIgnoreCase("Cricle"))&#123; return new Cricle(); &#125; return null; &#125;&#125; 步骤三： 123456789测试public class Main&#123; public static void main(String[] args) &#123; ShapeFactory shapeFactory = new ShapeFactory(); Shape triangle = shapeFactory.getShape("Triangle"); triangle.draw(); &#125;&#125; 抽象工厂模式（Abstract Factory Pattern） 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 步骤一: 1234创建一个形状接口public interface Shape &#123; public abstract void draw();&#125; 步骤二: 12345创建抽象工厂public abstract class AbstractFactory &#123; public abstract Color getColor(String colorType); public abstract Shape getShape(String shapeType);&#125; 步骤三: 123456789101112131415161718192021222324252627282930313233343536373839创建一个形状工厂，生成基于给定信息的实体类的对象。package xd.design;class Triangle implements Shape&#123; @Override public void draw() &#123; System.out.println("Triangle"); &#125;&#125;class Square implements Shape&#123; @Override public void draw() &#123; System.out.println("Square"); &#125;&#125;class Cricle implements Shape&#123; @Override public void draw() &#123; System.out.println("Cricle"); &#125;&#125;public class ShapeFactory &#123; public Shape getShape(String shapeType)&#123; if(shapeType==null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase("Triangle"))&#123; return new Triangle(); &#125;else if(shapeType.equalsIgnoreCase("Square"))&#123; return new Square(); &#125;else if(shapeType.equalsIgnoreCase("Cricle"))&#123; return new Cricle(); &#125; return null; &#125;&#125; 步骤四: 1234创建一个形状接口public interface Color &#123; public abstract void fill();&#125; 步骤五: 1234567891011121314151617181920212223242526272829303132333435363738394041424344创建一个颜色工厂，生成基于给定信息的实体类的对象。package xd.design;class Green implements Color&#123; @Override public void fill() &#123; System.out.println("Green"); &#125;&#125;class Red implements Color&#123; @Override public void fill() &#123; System.out.println("Red"); &#125;&#125;class Blue implements Color&#123; @Override public void fill() &#123; System.out.println("Blue"); &#125;&#125;public class ColorFactory extends AbstractFactory&#123; @Override public Color getColor(String colorType) &#123; if(colorType==null)&#123; return null; &#125; if(colorType.equalsIgnoreCase("Blue"))&#123; return new Blue(); &#125;else if(colorType.equalsIgnoreCase("Red"))&#123; return new Red(); &#125;else if(colorType.equalsIgnoreCase("Green"))&#123; return new Green(); &#125; return null; &#125; @Override public Shape getShape(String shapeType) &#123; return null; &#125; &#125; 步骤六：1234567891011创建工厂生产者public class FactoryProducter &#123; public static AbstractFactory getFactory(String factoryType)&#123; if(factoryType.equalsIgnoreCase("shape"))&#123; return new ShapeFactory(); &#125;else if(factoryType.equalsIgnoreCase("color"))&#123; return new ColorFactory(); &#125; return null; &#125;&#125; 步骤七：1234567public class Main&#123; public static void main(String[] args) &#123; AbstractFactory shapeFactory = FactoryProducter.getFactory("shape"); Shape circle = shapeFactory.getShape("circle"); circle.draw(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例设计模式]]></title>
    <url>%2F2018%2F03%2F23%2F%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例设计模式 单例设计模式1. 单例类只能有一个实例。 2. 单例类必须自己创建自己的唯一实例。 3. 单例类必须给所有其他对象提供这一个实例。 1234567public class Singleton &#123; private Singleton()&#123;&#125; private static Singleton singleObejct = new Singleton(); public static Singleton getInstance()&#123; return singleObejct; &#125;&#125; 懒汉式只有使用到这个实例的时候才会创建这个对象。 是否 Lazy 初始化：是 是否多线程安全：是 实现难度：易 123456789101112131415/** * 单例设计模式：懒汉式 * @author Blemon */public class Singleton &#123; private static Singleton singleObejct = null; private Singleton()&#123;&#125; public synchronized static Singleton getInstance()&#123; if(singleObejct==null)&#123; singleObejct = new Singleton(); &#125; return singleObejct; &#125;&#125; 饿汉式（静态对象）在加载这个类的时候就创建了这个实例。 是否 Lazy 初始化：否 是否多线程安全：是 实现难度：易 123456789101112/** * 单例设计模式：饿汉式 * @author Blemon */public class Singleton &#123; private static Singleton singleObejct = new Singleton(); private Singleton()&#123;&#125; public synchronized static Singleton getInstance()&#123; return singleObejct; &#125;&#125; 饿汉式（内部类）是否 Lazy 初始化：是 是否多线程安全：是 实现难度：一般 1234567891011121314/** * 单例设计模式：饿汉式（延迟加载） * @author Blemon */public class Singleton &#123; private static class SingletonHolder&#123; private static Singleton singleObejct = new Singleton(); &#125; private Singleton()&#123;&#125; public synchronized static Singleton getInstance()&#123; return SingletonHolder.singleObejct; &#125;&#125; 这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟第 2 种方式不同的是： 第 2 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果）， 而这种方式是 Singleton 类被装载了，instance 不一定被初始化。 因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。 想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化， 因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。 这个时候，这种方式相比第 2 种方式就显得很合理。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户模块（前台）]]></title>
    <url>%2F2018%2F03%2F16%2F%E7%94%A8%E6%88%B7%E6%A8%A1%E5%9D%97%EF%BC%88%E5%89%8D%E5%8F%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[用户登录HTML1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;%= require('html-loader!./layout/head-common.html') %&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title%&gt; - Happymmall电商平台&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%= require('html-loader!./layout/nav-simple.html') %&gt; &lt;div class="page-wrap w"&gt; &lt;div class="w"&gt; &lt;div class="user-con"&gt; &lt;div class="user-title"&gt;用户登录&lt;/div&gt; &lt;div class="user-box"&gt; &lt;div class="error-item"&gt; &lt;i class="fa fa-minus-circle error-icon"&gt;&lt;/i&gt; &lt;p class="err-msg"&gt;Error&lt;/p&gt; &lt;/div&gt; &lt;div class="user-item"&gt; &lt;label class="user-label" for=""&gt; &lt;i class="fa fa-user"&gt;&lt;/i&gt; &lt;/label&gt; &lt;input class="user-content" id="username" placeholder="请输入用户名" autocomplete="off"&gt; &lt;/div&gt; &lt;div class="user-item"&gt; &lt;label class="user-label" for="password"&gt; &lt;i class="fa fa-lock"&gt;&lt;/i&gt; &lt;/label&gt; &lt;input type="password" class="user-content" id="password" placeholder="请输入密码" autocomplete="off"&gt; &lt;/div&gt; &lt;a class="btn btn-submit" id="submit"&gt;登录&lt;/a&gt; &lt;div class="link-item"&gt; &lt;a class="link" href="./user-pass-reset.html" target="_blank"&gt;忘记密码&lt;/a&gt; &lt;a class="link" href="./user-register.html" target="_blank"&gt;免费注册&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%= require('html-loader!./layout/footer.html') %&gt; &lt;/body&gt;&lt;/html&gt; JS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** @Author: Blemon* @Date: 2018-03-13 16:54:12* @Last Modified by: Blemon* @Last Modified time: 2018-03-14 19:51:06*/'use strict';require('./index.css');require('page/common/nav-simple/index.js');var _user = require('service/user-service.js');var _mm = require('util/mm.js');// 表单里的错误提示var formError = &#123; show : function(errMsg)&#123; $('.error-item').show().find('.err-msg').text(errMsg); &#125;, hide : function()&#123; $('.error-item').hide().find('.err-msg').text(''); &#125;&#125;;//page逻辑部分var page = &#123; init : function()&#123; this.bindEvent(); &#125;, bindEvent : function()&#123; var _this = this; //登录按钮的点击 $('#submit').click(function()&#123; _this.submit(); &#125;); // 如果按下回车，也进行提交 $('.user-content').keyup(function(e)&#123; //keyCode == 13 表示回车键 if(e.keyCode === 13)&#123; _this.submit(); &#125; &#125;); &#125;, //提交表单（其实没有表单，伪造了一个表单） submit : function()&#123; var formData = &#123; username : $.trim($('#username').val()), password : $.trim($('#password').val()) &#125;, // 表单验证结果 validateResult = this.formValidate(formData); // 验证成功 if(validateResult.status)&#123; _user.login(formData, function(res)&#123; window.location.href = _mm.getUrlParam('redirect') || './index.html'; &#125;, function(errMsg)&#123; formError.show(errMsg); &#125;); &#125; // 验证失败 else&#123; // 错误提示 formError.show(validateResult.msg); &#125; &#125;, // 表单字段的验证 formValidate : function(formData)&#123; var result = &#123; status : false, msg : '' &#125;; if(!_mm.validate(formData.username, 'require'))&#123; result.msg = '用户名不能为空'; return result; &#125; if(!_mm.validate(formData.password, 'require'))&#123; result.msg = '密码不能为空'; return result; &#125; // 通过验证，返回正确提示 result.status = true; result.msg = '验证通过'; return result; &#125;&#125;;$(function()&#123; page.init();&#125;); user-service123456789101112131415161718192021222324252627282930313233343536373839404142/** @Author: Blemon* @Date: 2018-03-14 15:33:29* @Last Modified by: Blemon* @Last Modified time: 2018-03-14 19:48:16*/'use strict'var _mm = require('util/mm.js');var _user = &#123; // 用户登录 login : function(userInfo, resolve, reject)&#123; _mm.request(&#123; url : _mm.getServerUrl('/user/login.do'), data : userInfo, method : 'POST', success : resolve, error : reject &#125;); &#125;, // 检查登录状态 checkLogin : function(resolve, reject)&#123; _mm.request(&#123; url : _mm.getServerUrl('/user/get_user_info.do'), method : 'POST', success : resolve, error : reject &#125;); &#125;, //登出 logout : function(resolve,reject)&#123; _mm.request(&#123; url : _mm.getServerUrl('/user/logout.do'), method : 'POST', success : resolve, error : reject &#125;); &#125;&#125;module.exports = _user; webpack.config.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** @Author: Blemon* @Date: 2018-03-12 22:40:25* @Last Modified by: Blemon* @Last Modified time: 2018-03-14 19:23:24*/var webpack = require('webpack');var ExtractTextPlugin = require('extract-text-webpack-plugin');var HtmlWebpackPlugin = require('html-webpack-plugin');//环境变量的配置dev/onlinevar WEBPACK_ENV = process.env.WEBPACK_ENV || 'dev';console.log(WEBPACK_ENV);//获取html-webpack-plugin参数的方法var getHtmlConfig = function(name,title)&#123; return &#123; template : './src/view/'+name+'.html', filename : 'view/'+name+'.html', title : title, inject : true, hash : true, chunks : ['common',name] &#125;;&#125;; //webpack configvar config = &#123; entry: &#123; 'common' : ['./src/page/common/index.js'], 'index' : ['./src/page/index/index.js'], 'user-login' : ['./src/page/user-login/index.js'],//对输入就要对应多输出 'result' : ['./src/page/result/index.js'] &#125;, output: &#123; path : './dist', publicPath : '/dist', filename : 'js/[name].js' &#125;, externals : &#123; 'jquery' : 'window.jQuery' &#125;, module : &#123; loaders : [ &#123;test : /\.css$/, loader : ExtractTextPlugin.extract("style-loader","css-loader")&#125;, &#123;test : /\.(gif|png|jpg|woff|svg|eot|ttf)\??.*$/, loader : 'url-loader?limit=100&amp;name=resource/[name].[ext]'&#125;, &#123;test : /\.string$/, loader : 'html-loader'&#125; ] &#125;, resolve : &#123; alias : &#123; node_modules : __dirname + '/node_modules', util : __dirname + '/src/util', page : __dirname + '/src/page', service : __dirname + '/src/service', image : __dirname + '/src/image' &#125; &#125;, plugins : [ //独立通用模块到js/base.js new webpack.optimize.CommonsChunkPlugin(&#123; name : 'common', filename : 'js/base.js' &#125;), //把css单独打包到文件里 new ExtractTextPlugin("css/[name].css"), //html模板的处理 new HtmlWebpackPlugin(getHtmlConfig('index','首页')), new HtmlWebpackPlugin(getHtmlConfig('user-login','用户登录')), new HtmlWebpackPlugin(getHtmlConfig('result','操作结果')), ]&#125;;if('dev' == WEBPACK_ENV)&#123; config.entry.common.push('webpack-dev-server/client?http://localhost:8088/');&#125;module.exports = config; 用户注册HTML12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;%= require('html-loader!./layout/head-common.html') %&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title%&gt; - MMall电商平台&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%= require('html-loader!./layout/nav-simple.html') %&gt; &lt;div class="page-wrap"&gt; &lt;div class="w"&gt; &lt;div class="user-con"&gt; &lt;div class="user-title"&gt;用户注册&lt;/div&gt; &lt;div class="user-box"&gt; &lt;div class="error-item"&gt; &lt;i class="fa fa-minus-circle error-icon"&gt;&lt;/i&gt; &lt;p class="err-msg"&gt;Error&lt;/p&gt; &lt;/div&gt; &lt;div class="user-item"&gt; &lt;label class="user-label" for="username"&gt; &lt;i class="fa fa-user"&gt;&lt;/i&gt; &lt;/label&gt; &lt;input class="user-content" id="username" placeholder="请输入用户名" autocomplete="off"&gt; &lt;/div&gt; &lt;div class="user-item"&gt; &lt;label class="user-label" for="password"&gt; &lt;i class="fa fa-lock"&gt;&lt;/i&gt; &lt;/label&gt; &lt;input type="password" class="user-content" id="password" placeholder="请输入密码" autocomplete="off"&gt; &lt;/div&gt; &lt;div class="user-item"&gt; &lt;label class="user-label" for="password-confirm"&gt; &lt;i class="fa fa-lock"&gt;&lt;/i&gt; &lt;/label&gt; &lt;input type="password" class="user-content" id="password-confirm" placeholder="请再次输入密码" autocomplete="off"&gt; &lt;/div&gt; &lt;div class="user-item"&gt; &lt;label class="user-label" for="phone"&gt; &lt;i class="fa fa-phone"&gt;&lt;/i&gt; &lt;/label&gt; &lt;input class="user-content" id="phone" placeholder="请输入手机号" autocomplete="off"&gt; &lt;/div&gt; &lt;div class="user-item"&gt; &lt;label class="user-label" for="email"&gt; &lt;i class="fa fa-envelope"&gt;&lt;/i&gt; &lt;/label&gt; &lt;input class="user-content" id="email" placeholder="请输入邮箱" autocomplete="off"&gt; &lt;/div&gt; &lt;div class="user-item"&gt; &lt;label class="user-label" for="question"&gt; &lt;i class="fa fa-question"&gt;&lt;/i&gt; &lt;/label&gt; &lt;input class="user-content" id="question" placeholder="请输入密码提示问题" autocomplete="off"&gt; &lt;/div&gt; &lt;div class="user-item"&gt; &lt;label class="user-label" for="answer"&gt; &lt;i class="fa fa-key"&gt;&lt;/i&gt; &lt;/label&gt; &lt;input class="user-content" id="answer" placeholder="请输入密码提示问题答案" autocomplete="off"&gt; &lt;/div&gt; &lt;a class="btn btn-submit" id="submit"&gt;立即注册&lt;/a&gt; &lt;div class="link-item"&gt; &lt;a class="link" href="./user-login.html"&gt;已有帐号，去登录&gt;&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%= require('html-loader!./layout/footer.html') %&gt; &lt;/body&gt;&lt;/html&gt; JS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139/** @Author: Blemon* @Date: 2018-03-14 20:08:02* @Last Modified by: Blemon* @Last Modified time: 2018-03-14 21:31:11*/'use strict';require('./index.css');require('page/common/nav-simple/index.js');var _user = require('service/user-service.js');var _mm = require('util/mm.js');// 表单里的错误提示var formError = &#123; show : function(errMsg)&#123; $('.error-item').show().find('.err-msg').text(errMsg); &#125;, hide : function()&#123; $('.error-item').hide().find('.err-msg').text(''); &#125;&#125;;//page逻辑部分var page = &#123; init : function()&#123; this.bindEvent(); &#125;, bindEvent : function()&#123; var _this = this; //验证username $('#username').blur(function()&#123; var username = $.trim($(this).val()); //用户名为空不做验证 if(!username)&#123; return ; &#125; //异步验证用户名是否存在 _user.checkUsername(username,function(res)&#123; formError.hide(); &#125;,function(errMsg)&#123; formError.show(errMsg); &#125;); &#125;); //注册按钮的点击 $('#submit').click(function()&#123; _this.submit(); &#125;); // 如果按下回车，也进行提交 $('.user-content').keyup(function(e)&#123; //keyCode == 13 表示回车键 if(e.keyCode === 13)&#123; _this.submit(); &#125; &#125;); &#125;, //提交表单（其实没有表单，伪造了一个表单） submit : function()&#123; var formData = &#123; username : $.trim($('#username').val()), password : $.trim($('#password').val()), passwordConfirm : $.trim($('#password-confirm').val()), phone : $.trim($('#phone').val()), email : $.trim($('#email').val()), question : $.trim($('#question').val()), answer : $.trim($('#answer').val()) &#125;, // 表单验证结果 validateResult = this.formValidate(formData); // 验证成功 if(validateResult.status)&#123; _user.register(formData, function(res)&#123; window.location.href = './result.html?type=register'; &#125;, function(errMsg)&#123; formError.show(errMsg); &#125;); &#125; // 验证失败 else&#123; // 错误提示 formError.show(validateResult.msg); &#125; &#125;, // 表单字段的验证 formValidate : function(formData)&#123; var result = &#123; status : false, msg : '' &#125;; //验证用户名是否为空 if(!_mm.validate(formData.username, 'require'))&#123; result.msg = '用户名不能为空'; return result; &#125; //验证密码是否为空 if(!_mm.validate(formData.password, 'require'))&#123; result.msg = '密码不能为空'; return result; &#125; //验证密码长度 if(formData.password.length&lt;6)&#123; result.msg = '密码长度不能少于6位'; return result; &#125; //验证密码是否一致 if(formData.password !== formData.passwordConfirm)&#123; result.msg = '两次输入密码不一致'; return result; &#125; //验证手机号 if(!_mm.validate(formData.phone, 'phone'))&#123; result.msg = '手机格式不是正确'; return result; &#125; //验证邮箱 if(!_mm.validate(formData.email, 'email'))&#123; result.msg = '邮箱格式不是正确'; return result; &#125; //验证密码提示问题不能为空 if(!_mm.validate(formData.question, 'require'))&#123; result.msg = '验证密码提示问题不能为空'; return result; &#125; //验证密码提示问题答案不能为空 if(!_mm.validate(formData.answer, 'require'))&#123; result.msg = '验证密码提示问题答案不能为空'; return result; &#125; // 通过验证，返回正确提示 result.status = true; result.msg = '验证通过'; return result; &#125;&#125;;$(function()&#123; page.init();&#125;); webpack.config.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** @Author: Blemon* @Date: 2018-03-12 22:40:25* @Last Modified by: Blemon* @Last Modified time: 2018-03-14 20:07:38*/var webpack = require('webpack');var ExtractTextPlugin = require('extract-text-webpack-plugin');var HtmlWebpackPlugin = require('html-webpack-plugin');//环境变量的配置dev/onlinevar WEBPACK_ENV = process.env.WEBPACK_ENV || 'dev';console.log(WEBPACK_ENV);//获取html-webpack-plugin参数的方法var getHtmlConfig = function(name,title)&#123; return &#123; template : './src/view/'+name+'.html', filename : 'view/'+name+'.html', title : title, inject : true, hash : true, chunks : ['common',name] &#125;;&#125;; //webpack configvar config = &#123; entry: &#123; 'common' : ['./src/page/common/index.js'], 'index' : ['./src/page/index/index.js'], 'user-login' : ['./src/page/user-login/index.js'],//对输入就要对应多输出 'user-register' : ['./src/page/user-register/index.js'], 'result' : ['./src/page/result/index.js'] &#125;, output: &#123; path : './dist', publicPath : '/dist', filename : 'js/[name].js' &#125;, externals : &#123; 'jquery' : 'window.jQuery' &#125;, module : &#123; loaders : [ &#123;test : /\.css$/, loader : ExtractTextPlugin.extract("style-loader","css-loader")&#125;, &#123;test : /\.(gif|png|jpg|woff|svg|eot|ttf)\??.*$/, loader : 'url-loader?limit=100&amp;name=resource/[name].[ext]'&#125;, &#123;test : /\.string$/, loader : 'html-loader'&#125; ] &#125;, resolve : &#123; alias : &#123; node_modules : __dirname + '/node_modules', util : __dirname + '/src/util', page : __dirname + '/src/page', service : __dirname + '/src/service', image : __dirname + '/src/image' &#125; &#125;, plugins : [ //独立通用模块到js/base.js new webpack.optimize.CommonsChunkPlugin(&#123; name : 'common', filename : 'js/base.js' &#125;), //把css单独打包到文件里 new ExtractTextPlugin("css/[name].css"), //html模板的处理 new HtmlWebpackPlugin(getHtmlConfig('index','首页')), new HtmlWebpackPlugin(getHtmlConfig('user-login','用户登录')), new HtmlWebpackPlugin(getHtmlConfig('user-register','用户注册')), new HtmlWebpackPlugin(getHtmlConfig('result','操作结果')), ]&#125;;if('dev' == WEBPACK_ENV)&#123; config.entry.common.push('webpack-dev-server/client?http://localhost:8088/');&#125;module.exports = config; 找回密码HTML12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;%= require('html-loader!./layout/head-common.html') %&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title%&gt; - MMall电商平台&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%= require('html-loader!./layout/nav-simple.html') %&gt; &lt;div class="page-wrap"&gt; &lt;div class="w"&gt; &lt;div class="user-con"&gt; &lt;div class="user-title"&gt;找回密码&lt;/div&gt; &lt;div class="user-box"&gt; &lt;div class="error-item"&gt; &lt;i class="fa fa-minus-circle error-icon"&gt;&lt;/i&gt; &lt;p class="err-msg"&gt;Error&lt;/p&gt; &lt;/div&gt; &lt;div class="step-con step-username"&gt; &lt;p class="user-item-text"&gt;请输入用户名：&lt;/p&gt; &lt;div class="user-item"&gt; &lt;label class="user-label" for=""&gt; &lt;i class="fa fa-user"&gt;&lt;/i&gt; &lt;/label&gt; &lt;input class="user-content" id="username" placeholder="请输入用户名" autocomplete="off"&gt; &lt;/div&gt; &lt;a class="btn btn-submit" id="submit-username"&gt;下一步&lt;/a&gt; &lt;/div&gt; &lt;div class="step-con step-question"&gt; &lt;p class="user-item-text"&gt;密码提示问题是：&lt;span class="question"&gt;&lt;/span&gt;&lt;/p&gt; &lt;div class="user-item"&gt; &lt;label class="user-label" for=""&gt; &lt;i class="fa fa-key"&gt;&lt;/i&gt; &lt;/label&gt; &lt;input class="user-content" id="answer" placeholder="请输入密码提示问题答案" autocomplete="off"&gt; &lt;/div&gt; &lt;a class="btn btn-submit" id="submit-question"&gt;下一步&lt;/a&gt; &lt;/div&gt; &lt;div class="step-con step-password"&gt; &lt;p class="user-item-text"&gt;请输入新密码：&lt;/p&gt; &lt;div class="user-item"&gt; &lt;label class="user-label" for=""&gt; &lt;i class="fa fa-lock"&gt;&lt;/i&gt; &lt;/label&gt; &lt;input type="password" class="user-content" id="password" placeholder="请输入新密码" autocomplete="off"&gt; &lt;/div&gt; &lt;a class="btn btn-submit" id="submit-password"&gt;下一步&lt;/a&gt; &lt;/div&gt; &lt;div class="link-item"&gt; &lt;a class="link" href="./user-login.html" target="_blank"&gt;返回登录&gt;&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%= require('html-loader!./layout/footer.html') %&gt; &lt;/body&gt;&lt;/html&gt; JS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/** @Author: Blemon* @Date: 2018-03-15 19:12:57* @Last Modified by: Blemon* @Last Modified time: 2018-03-15 20:11:11*/'use strict';require('./index.css');require('page/common/nav-simple/index.js');var _user = require('service/user-service.js');var _mm = require('util/mm.js');// 表单里的错误提示var formError = &#123; show : function(errMsg)&#123; $('.error-item').show().find('.err-msg').text(errMsg); &#125;, hide : function()&#123; $('.error-item').hide().find('.err-msg').text(''); &#125;&#125;;// page 逻辑部分var page = &#123; data : &#123; username : '', question : '', answer : '', token : '' &#125;, init: function()&#123; this.onLoad(); this.bindEvent(); &#125;, onLoad : function()&#123; this.loadStepUsername(); &#125;, bindEvent : function()&#123; var _this = this; // 输入用户名后下一步按钮的点击 $('#submit-username').click(function()&#123; var username = $.trim($('#username').val()); // 用户名存在 if(username)&#123; _user.getQuestion(username, function(res)&#123; _this.data.username = username;//把数据存在对象里 _this.data.question = res; _this.loadStepQuestion(); &#125;, function(errMsg)&#123; formError.show(errMsg); &#125;); &#125; // 用户名不存在 else&#123; formError.show('请输入用户名'); &#125; &#125;); // 输入密码提示问题答案中的按钮点击 $('#submit-question').click(function()&#123; var answer = $.trim($('#answer').val()); // 密码提示问题答案存在 if(answer)&#123; // 检查密码提示问题答案 _user.checkAnswer(&#123; username : _this.data.username, question : _this.data.question, answer : answer &#125;, function(res)&#123; _this.data.answer = answer; _this.data.token = res; _this.loadStepPassword(); &#125;, function(errMsg)&#123; formError.show(errMsg); &#125;); &#125; // 用户名不存在 else&#123; formError.show('请输入密码提示问题答案'); &#125; &#125;); // 输入新密码后的按钮点击 $('#submit-password').click(function()&#123; var password = $.trim($('#password').val()); // 密码不为空 if(password &amp;&amp; password.length &gt;= 6)&#123; // 检查密码提示问题答案 _user.resetPassword(&#123; username : _this.data.username, passwordNew : password, forgetToken : _this.data.token &#125;, function(res)&#123; window.location.href = './result.html?type=pass-reset'; &#125;, function(errMsg)&#123; formError.show(errMsg); &#125;); &#125; // 密码为空 else&#123; formError.show('请输入不少于6位的新密码'); &#125; &#125;); &#125;, // 加载输入用户名的一步 loadStepUsername : function()&#123; $('.step-username').show(); &#125;, // 加载输入密码提示问题答案的一步 loadStepQuestion : function()&#123; // 清除错误提示 formError.hide(); // 做容器的切换 $('.step-username').hide() .siblings('.step-question').show() .find('.question').text(this.data.question); &#125;, // 加载输入password的一步 loadStepPassword : function()&#123; // 清除错误提示 formError.hide(); // 做容器的切换 $('.step-question').hide() .siblings('.step-password').show(); &#125;&#125;;$(function()&#123; page.init();&#125;); user-service.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** @Author: Blemon* @Date: 2018-03-14 15:33:29* @Last Modified by: Blemon* @Last Modified time: 2018-03-15 20:26:50*/'use strict'var _mm = require('util/mm.js');var _user = &#123; // 用户登录 login : function(userInfo, resolve, reject)&#123; _mm.request(&#123; url : _mm.getServerUrl('/user/login.do'), data : userInfo, method : 'POST', success : resolve, error : reject &#125;); &#125;, // 用户注册 register : function(userInfo, resolve, reject)&#123; _mm.request(&#123; url : _mm.getServerUrl('/user/register.do'), data : userInfo, method : 'POST', success : resolve, error : reject &#125;); &#125;, // 前台异步验证用户名 checkUsername : function(username, resolve, reject)&#123; _mm.request(&#123; url : _mm.getServerUrl('/user/check_valid.do'), data : &#123; type : 'username', str : username &#125;, method : 'POST', success : resolve, error : reject &#125;); &#125;, // 检查登录状态 checkLogin : function(resolve, reject)&#123; _mm.request(&#123; url : _mm.getServerUrl('/user/get_user_info.do'), method : 'POST', success : resolve, error : reject &#125;); &#125;, // 获取用户密码提示问题 getQuestion : function(username, resolve, reject)&#123; _mm.request(&#123; url : _mm.getServerUrl('/user/forget_get_question.do'), data : &#123; username : username &#125;, method : 'POST', success : resolve, error : reject &#125;); &#125;, // 检查密码提示问题答案 checkAnswer : function(userInfo, resolve, reject)&#123; _mm.request(&#123; url : _mm.getServerUrl('/user/forget_check_answer.do'), data : userInfo, method : 'POST', success : resolve, error : reject &#125;); &#125;, // 重置密码 resetPassword : function(userInfo, resolve, reject)&#123; _mm.request(&#123; url : _mm.getServerUrl('/user/forget_reset_password.do'), data : userInfo, method : 'POST', success : resolve, error : reject &#125;); &#125;, // //登出 logout : function(resolve,reject)&#123; _mm.request(&#123; url : _mm.getServerUrl('/user/logout.do'), method : 'POST', success : resolve, error : reject &#125;); &#125;&#125;module.exports = _user; webpak.config.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** @Author: Blemon* @Date: 2018-03-12 22:40:25* @Last Modified by: Blemon* @Last Modified time: 2018-03-15 19:20:03*/var webpack = require('webpack');var ExtractTextPlugin = require('extract-text-webpack-plugin');var HtmlWebpackPlugin = require('html-webpack-plugin');//环境变量的配置dev/onlinevar WEBPACK_ENV = process.env.WEBPACK_ENV || 'dev';console.log(WEBPACK_ENV);//获取html-webpack-plugin参数的方法var getHtmlConfig = function(name,title)&#123; return &#123; template : './src/view/'+name+'.html', filename : 'view/'+name+'.html', title : title, inject : true, hash : true, chunks : ['common',name] &#125;;&#125;; //webpack configvar config = &#123; entry: &#123; 'common' : ['./src/page/common/index.js'], 'index' : ['./src/page/index/index.js'], 'user-login' : ['./src/page/user-login/index.js'],//对输入就要对应多输出 'user-register' : ['./src/page/user-register/index.js'], 'user-pass-reset' : ['./src/page/user-pass-reset/index.js'], 'result' : ['./src/page/result/index.js'] &#125;, output: &#123; path : './dist', publicPath : '/dist', filename : 'js/[name].js' &#125;, externals : &#123; 'jquery' : 'window.jQuery' &#125;, module : &#123; loaders : [ &#123;test : /\.css$/, loader : ExtractTextPlugin.extract("style-loader","css-loader")&#125;, &#123;test : /\.(gif|png|jpg|woff|svg|eot|ttf)\??.*$/, loader : 'url-loader?limit=100&amp;name=resource/[name].[ext]'&#125;, &#123;test : /\.string$/, loader : 'html-loader'&#125; ] &#125;, resolve : &#123; alias : &#123; node_modules : __dirname + '/node_modules', util : __dirname + '/src/util', page : __dirname + '/src/page', service : __dirname + '/src/service', image : __dirname + '/src/image' &#125; &#125;, plugins : [ //独立通用模块到js/base.js new webpack.optimize.CommonsChunkPlugin(&#123; name : 'common', filename : 'js/base.js' &#125;), //把css单独打包到文件里 new ExtractTextPlugin("css/[name].css"), //html模板的处理 new HtmlWebpackPlugin(getHtmlConfig('index','首页')), new HtmlWebpackPlugin(getHtmlConfig('user-login','用户登录')), new HtmlWebpackPlugin(getHtmlConfig('user-register','用户注册')), new HtmlWebpackPlugin(getHtmlConfig('user-pass-reset','找回密码')), new HtmlWebpackPlugin(getHtmlConfig('result','操作结果')), ]&#125;;if('dev' == WEBPACK_ENV)&#123; config.entry.common.push('webpack-dev-server/client?http://localhost:8088/');&#125;module.exports = config; result.html123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;%= require('html-loader!./layout/head-common.html') %&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title%&gt; - Happymmall电商平台&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%= require('html-loader!./layout/nav-simple.html') %&gt; &lt;div class="page-wrap w"&gt; &lt;div class="result-con register-success"&gt; &lt;h1 class="result-title"&gt;恭喜您，注册成功!&lt;/h1&gt; &lt;div class="result-content"&gt; &lt;a class="link" href="./index.html"&gt;回到首页&lt;/a&gt; &lt;a class="link" href="./user-login.html"&gt;立即登录&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="result-con default-success"&gt; &lt;h1 class="result-title"&gt;恭喜您，注册成功!&lt;/h1&gt; &lt;div class="result-content"&gt; &lt;a class="link" href="./index.html"&gt;回到首页&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="result-con pass-reset-success"&gt; &lt;h1 class="result-title"&gt;恭喜您，修改密码成功!&lt;/h1&gt; &lt;div class="result-content"&gt; &lt;a class="link" href="./index.html"&gt;回到首页&lt;/a&gt; &lt;a class="link" href="./user-login.html"&gt;立即登录&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%= require('html-loader!./layout/footer.html') %&gt; &lt;/body&gt;&lt;/html&gt; 个人中心展示用HTML1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;%= require('html-loader!./layout/head-common.html') %&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title%&gt; - MMall电商平台&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%= require('html-loader!./layout/nav.html') %&gt; &lt;%= require('html-loader!./layout/header.html') %&gt; &lt;div class="crumb"&gt; &lt;div class="w"&gt; &lt;div class="crumb-con"&gt; &lt;a class="link" href="./index.html"&gt;MMall&lt;/a&gt; &lt;span&gt;&gt;&lt;/span&gt; &lt;span class="link-text"&gt;&lt;%= htmlWebpackPlugin.options.title%&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="page-wrap w"&gt; &lt;%= require('html-loader!./layout/nav-side.html') %&gt; &lt;div class="content with-nav"&gt; &lt;div class="panel"&gt; &lt;div class="panel-title"&gt;个人中心&lt;/div&gt; &lt;div class="panel-body"&gt; &lt;div class="loading"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%= require('html-loader!./layout/footer.html') %&gt; &lt;/body&gt;&lt;/html&gt; JS123456789101112131415161718192021222324252627282930313233343536373839404142/** @Author: Blemon* @Date: 2018-03-15 20:39:35* @Last Modified by: Blemon* @Last Modified time: 2018-03-15 21:09:07*/'use strict';require('./index.css');require('page/common/nav/index.js');require('page/common/header/index.js');var navSide = require('page/common/nav-side/index.js');var _mm = require('util/mm.js');var _user = require('service/user-service.js');var templateIndex = require('./index.string');// page 逻辑部分var page = &#123; init: function()&#123; this.onLoad(); &#125;, onLoad : function()&#123; // 初始化左侧菜单 navSide.init(&#123; name: 'user-center' &#125;); // 加载用户信息 this.loadUserInfo(); &#125;, // 加载用户信息 loadUserInfo : function()&#123; var userHtml = ''; _user.getUserInfo(function(res)&#123; userHtml = _mm.renderHtml(templateIndex, res); $('.panel-body').html(userHtml); &#125;, function(errMsg)&#123; _mm.errorTips(errMsg); &#125;); &#125;&#125;;$(function()&#123; page.init();&#125;); webpack.comfig.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** @Author: Blemon* @Date: 2018-03-12 22:40:25* @Last Modified by: Blemon* @Last Modified time: 2018-03-15 20:45:34*/var webpack = require('webpack');var ExtractTextPlugin = require('extract-text-webpack-plugin');var HtmlWebpackPlugin = require('html-webpack-plugin');//环境变量的配置dev/onlinevar WEBPACK_ENV = process.env.WEBPACK_ENV || 'dev';console.log(WEBPACK_ENV);//获取html-webpack-plugin参数的方法var getHtmlConfig = function(name,title)&#123; return &#123; template : './src/view/'+name+'.html', filename : 'view/'+name+'.html', title : title, inject : true, hash : true, chunks : ['common',name] &#125;;&#125;; //webpack configvar config = &#123; entry: &#123; 'common' : ['./src/page/common/index.js'], 'index' : ['./src/page/index/index.js'], 'user-login' : ['./src/page/user-login/index.js'],//对输入就要对应多输出 'user-register' : ['./src/page/user-register/index.js'], 'user-pass-reset' : ['./src/page/user-pass-reset/index.js'], 'user-center' : ['./src/page/user-center/index.js'], 'user-center-update' : ['./src/page/user-center-update/index.js'], 'result' : ['./src/page/result/index.js'] &#125;, output: &#123; path : './dist', publicPath : '/dist', filename : 'js/[name].js' &#125;, externals : &#123; 'jquery' : 'window.jQuery' &#125;, module : &#123; loaders : [ &#123;test : /\.css$/, loader : ExtractTextPlugin.extract("style-loader","css-loader")&#125;, &#123;test : /\.(gif|png|jpg|woff|svg|eot|ttf)\??.*$/, loader : 'url-loader?limit=100&amp;name=resource/[name].[ext]'&#125;, &#123;test : /\.string$/, loader : 'html-loader'&#125; ] &#125;, resolve : &#123; alias : &#123; node_modules : __dirname + '/node_modules', util : __dirname + '/src/util', page : __dirname + '/src/page', service : __dirname + '/src/service', image : __dirname + '/src/image' &#125; &#125;, plugins : [ //独立通用模块到js/base.js new webpack.optimize.CommonsChunkPlugin(&#123; name : 'common', filename : 'js/base.js' &#125;), //把css单独打包到文件里 new ExtractTextPlugin("css/[name].css"), //html模板的处理 new HtmlWebpackPlugin(getHtmlConfig('index','首页')), new HtmlWebpackPlugin(getHtmlConfig('user-login','用户登录')), new HtmlWebpackPlugin(getHtmlConfig('user-register','用户注册')), new HtmlWebpackPlugin(getHtmlConfig('user-pass-reset','找回密码')), new HtmlWebpackPlugin(getHtmlConfig('user-center','个人中心')), new HtmlWebpackPlugin(getHtmlConfig('user-center-update','修改个人信息')), new HtmlWebpackPlugin(getHtmlConfig('result','操作结果')), ]&#125;;if('dev' == WEBPACK_ENV)&#123; config.entry.common.push('webpack-dev-server/client?http://localhost:8088/');&#125;module.exports = config; userservice.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126/** @Author: Blemon* @Date: 2018-03-14 15:33:29* @Last Modified by: Blemon* @Last Modified time: 2018-03-15 21:10:29*/'use strict'var _mm = require('util/mm.js');var _user = &#123; // 用户登录 login : function(userInfo, resolve, reject)&#123; _mm.request(&#123; url : _mm.getServerUrl('/user/login.do'), data : userInfo, method : 'POST', success : resolve, error : reject &#125;); &#125;, // 用户注册 register : function(userInfo, resolve, reject)&#123; _mm.request(&#123; url : _mm.getServerUrl('/user/register.do'), data : userInfo, method : 'POST', success : resolve, error : reject &#125;); &#125;, // 前台异步验证用户名 checkUsername : function(username, resolve, reject)&#123; _mm.request(&#123; url : _mm.getServerUrl('/user/check_valid.do'), data : &#123; type : 'username', str : username &#125;, method : 'POST', success : resolve, error : reject &#125;); &#125;, // 检查登录状态 checkLogin : function(resolve, reject)&#123; _mm.request(&#123; url : _mm.getServerUrl('/user/get_user_info.do'), method : 'POST', success : resolve, error : reject &#125;); &#125;, // 获取用户密码提示问题 getQuestion : function(username, resolve, reject)&#123; _mm.request(&#123; url : _mm.getServerUrl('/user/forget_get_question.do'), data : &#123; username : username &#125;, method : 'POST', success : resolve, error : reject &#125;); &#125;, // 检查密码提示问题答案 checkAnswer : function(userInfo, resolve, reject)&#123; _mm.request(&#123; url : _mm.getServerUrl('/user/forget_check_answer.do'), data : userInfo, method : 'POST', success : resolve, error : reject &#125;); &#125;, // 重置密码 resetPassword : function(userInfo, resolve, reject)&#123; _mm.request(&#123; url : _mm.getServerUrl('/user/forget_reset_password.do'), data : userInfo, method : 'POST', success : resolve, error : reject &#125;); &#125;, // 获取用户信息 getUserInfo : function(resolve, reject)&#123; _mm.request(&#123; url : _mm.getServerUrl('/user/get_information.do'), method : 'POST', success : resolve, error : reject &#125;); &#125;, // 更新个人信息 updateUserInfo : function(userInfo, resolve, reject)&#123; _mm.request(&#123; url : _mm.getServerUrl('/user/update_information.do'), data : userInfo, method : 'POST', success : resolve, error : reject &#125;); &#125;, // 登录状态下更新密码 updatePassword : function(userInfo, resolve, reject)&#123; _mm.request(&#123; url : _mm.getServerUrl('/user/reset_password.do'), data : userInfo, method : 'POST', success : resolve, error : reject &#125;); &#125;, //登出 logout : function(resolve,reject)&#123; _mm.request(&#123; url : _mm.getServerUrl('/user/logout.do'), method : 'POST', success : resolve, error : reject &#125;); &#125;&#125;module.exports = _user; index.string1234567891011121314151617181920212223&lt;div class="user-info"&gt; &lt;div class="form-line"&gt; &lt;span class="label"&gt;用户名：&lt;/span&gt; &lt;span class="text"&gt;&#123;&#123;username&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class="form-line"&gt; &lt;span class="label"&gt;电 话：&lt;/span&gt; &lt;span class="text"&gt;&#123;&#123;phone&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class="form-line"&gt; &lt;span class="label"&gt;邮 箱：&lt;/span&gt; &lt;span class="text"&gt;&#123;&#123;email&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class="form-line"&gt; &lt;span class="label"&gt;问 题：&lt;/span&gt; &lt;span class="text"&gt;&#123;&#123;question&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class="form-line"&gt; &lt;span class="label"&gt;答 案：&lt;/span&gt; &lt;span class="text"&gt;&#123;&#123;answer&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;a class="btn btn-submit" href="./user-center-update.html"&gt;编辑&lt;/a&gt;&lt;/div&gt; 更新用HTML1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;%= require('html-loader!./layout/head-common.html') %&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title%&gt; - MMall电商平台&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%= require('html-loader!./layout/nav.html') %&gt; &lt;%= require('html-loader!./layout/header.html') %&gt; &lt;div class="crumb"&gt; &lt;div class="w"&gt; &lt;div class="crumb-con"&gt; &lt;a class="link" href="./index.html"&gt;MMall&lt;/a&gt; &lt;span&gt;&gt;&lt;/span&gt; &lt;span class="link-text"&gt;&lt;%= htmlWebpackPlugin.options.title%&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="page-wrap w"&gt; &lt;%= require('html-loader!./layout/nav-side.html') %&gt; &lt;div class="content with-nav"&gt; &lt;div class="panel"&gt; &lt;div class="panel-title"&gt;个人中心&lt;/div&gt; &lt;div class="panel-body"&gt; &lt;div class="loading"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%= require('html-loader!./layout/footer.html') %&gt; &lt;/body&gt;&lt;/html&gt; JS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293'use strict';require('./index.css');require('page/common/nav/index.js');require('page/common/header/index.js');var navSide = require('page/common/nav-side/index.js');var _mm = require('util/mm.js');var _user = require('service/user-service.js');var templateIndex = require('./index.string');// page 逻辑部分var page = &#123; init: function()&#123; this.onLoad(); this.bindEvent(); &#125;, onLoad : function()&#123; // 初始化左侧菜单 navSide.init(&#123; name: 'user-center' &#125;); // 加载用户信息 this.loadUserInfo(); &#125;, bindEvent : function()&#123; var _this = this; // 点击提交按钮后的动作 $(document).on('click', '.btn-submit', function()&#123; var userInfo = &#123; phone : $.trim($('#phone').val()), email : $.trim($('#email').val()), question : $.trim($('#question').val()), answer : $.trim($('#answer').val()) &#125;, validateResult = _this.validateForm(userInfo); if(validateResult.status)&#123; // 更改用户信息 _user.updateUserInfo(userInfo, function(res, msg)&#123; _mm.successTips(msg); window.location.href = './user-login.html'; &#125;, function(errMsg)&#123; _mm.errorTips(errMsg); &#125;); &#125; else&#123; _mm.errorTips(validateResult.msg); &#125; &#125;); &#125;, // 加载用户信息 loadUserInfo : function()&#123; var userHtml = ''; _user.getUserInfo(function(res)&#123; userHtml = _mm.renderHtml(templateIndex, res); $('.panel-body').html(userHtml); &#125;, function(errMsg)&#123; _mm.errorTips(errMsg); &#125;); &#125;, // 验证字段信息 validateForm : function(formData)&#123; var result = &#123; status : false, msg : '' &#125;; // 验证手机号 if(!_mm.validate(formData.phone, 'phone'))&#123; result.msg = '手机号格式不正确'; return result; &#125; // 验证邮箱格式 if(!_mm.validate(formData.email, 'email'))&#123; result.msg = '邮箱格式不正确'; return result; &#125; // 验证密码提示问题是否为空 if(!_mm.validate(formData.question, 'require'))&#123; result.msg = '密码提示问题不能为空'; return result; &#125; // 验证密码提示问题答案是否为空 if(!_mm.validate(formData.answer, 'require'))&#123; result.msg = '密码提示问题答案不能为空'; return result; &#125; // 通过验证，返回正确提示 result.status = true; result.msg = '验证通过'; return result; &#125;&#125;;$(function()&#123; page.init();&#125;); index.string1234567891011121314151617181920212223&lt;div class="user-info"&gt; &lt;div class="form-line"&gt; &lt;span class="label"&gt;用户名：&lt;/span&gt; &lt;span class="text"&gt;&#123;&#123;username&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class="form-line"&gt; &lt;span class="label"&gt;电 话：&lt;/span&gt; &lt;input class="input" id="phone" autocomplete="off" value="&#123;&#123;phone&#125;&#125;" /&gt; &lt;/div&gt; &lt;div class="form-line"&gt; &lt;span class="label"&gt;邮 箱：&lt;/span&gt; &lt;input class="input" id="email" autocomplete="off" value="&#123;&#123;email&#125;&#125;" /&gt; &lt;/div&gt; &lt;div class="form-line"&gt; &lt;span class="label"&gt;问 题：&lt;/span&gt; &lt;input class="input" id="question" autocomplete="off" value="&#123;&#123;question&#125;&#125;" /&gt; &lt;/div&gt; &lt;div class="form-line"&gt; &lt;span class="label"&gt;答 案：&lt;/span&gt; &lt;input class="input" id="answer" autocomplete="off" value="&#123;&#123;answer&#125;&#125;" /&gt; &lt;/div&gt; &lt;span class="btn btn-submit"&gt;提交&lt;/span&gt;&lt;/div&gt; 更新密码HTML12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;%= require('html-loader!./layout/head-common.html') %&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title%&gt; - MMall电商平台&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%= require('html-loader!./layout/nav.html') %&gt; &lt;%= require('html-loader!./layout/header.html') %&gt; &lt;div class="crumb"&gt; &lt;div class="w"&gt; &lt;div class="crumb-con"&gt; &lt;a class="link" href="./index.html"&gt;MMall&lt;/a&gt; &lt;span&gt;&gt;&lt;/span&gt; &lt;span class="link-text"&gt;&lt;%= htmlWebpackPlugin.options.title%&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="page-wrap w"&gt; &lt;%= require('html-loader!./layout/nav-side.html') %&gt; &lt;div class="content with-nav"&gt; &lt;div class="panel"&gt; &lt;div class="panel-title"&gt;修改密码&lt;/div&gt; &lt;div class="panel-body"&gt; &lt;div class="user-info"&gt; &lt;div class="form-line"&gt; &lt;span class="label"&gt;原密码：&lt;/span&gt; &lt;input type="password" class="input" id="password" autocomplete="off"/&gt; &lt;/div&gt; &lt;div class="form-line"&gt; &lt;span class="label"&gt;新密码：&lt;/span&gt; &lt;input type="password" class="input" id="password-new" autocomplete="off"/&gt; &lt;/div&gt; &lt;div class="form-line"&gt; &lt;span class="label"&gt;确认密码：&lt;/span&gt; &lt;input type="password" class="input" id="password-confirm" autocomplete="off"/&gt; &lt;/div&gt; &lt;span class="btn btn-submit"&gt;提交&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%= require('html-loader!./layout/footer.html') %&gt; &lt;/body&gt;&lt;/html&gt; JS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677'use strict';require('./index.css');require('page/common/nav/index.js');require('page/common/header/index.js');var navSide = require('page/common/nav-side/index.js');var _mm = require('util/mm.js');var _user = require('service/user-service.js');// page 逻辑部分var page = &#123; init: function()&#123; this.onLoad(); this.bindEvent(); &#125;, onLoad : function()&#123; // 初始化左侧菜单 navSide.init(&#123; name: 'user-pass-update' &#125;); &#125;, bindEvent : function()&#123; var _this = this; // 点击提交按钮后的动作 $(document).on('click', '.btn-submit', function()&#123; var userInfo = &#123; password : $.trim($('#password').val()), passwordNew : $.trim($('#password-new').val()), passwordConfirm : $.trim($('#password-confirm').val()) &#125;, validateResult = _this.validateForm(userInfo); if(validateResult.status)&#123; // 更改用户密码 _user.updatePassword(&#123; passwordOld : userInfo.password, passwordNew : userInfo.passwordNew &#125;, function(res, msg)&#123; _mm.successTips(msg); window.location.href = './user-login.html'; &#125;, function(errMsg)&#123; _mm.errorTips(errMsg); &#125;); &#125; else&#123; _mm.errorTips(validateResult.msg); &#125; &#125;); &#125;, // 验证字段信息 validateForm : function(formData)&#123; var result = &#123; status : false, msg : '' &#125;; // 验证原密码是否为空 if(!_mm.validate(formData.password, 'require'))&#123; result.msg = '原密码不能为空'; return result; &#125; // 验证新密码长度 if(!formData.passwordNew || formData.passwordNew.length &lt; 6)&#123; result.msg = '密码长度不得少于6位'; return result; &#125; // 验证两次输入的密码是否一致 if(formData.passwordNew !== formData.passwordConfirm)&#123; result.msg = '两次输入的密码不一致'; return result; &#125; // 通过验证，返回正确提示 result.status = true; result.msg = '验证通过'; return result; &#125;&#125;;$(function()&#123; page.init();&#125;); webpack.config.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182var webpack = require('webpack');var ExtractTextPlugin = require('extract-text-webpack-plugin');var HtmlWebpackPlugin = require('html-webpack-plugin');//环境变量的配置dev/onlinevar WEBPACK_ENV = process.env.WEBPACK_ENV || 'dev';console.log(WEBPACK_ENV);//获取html-webpack-plugin参数的方法var getHtmlConfig = function(name,title)&#123; return &#123; template : './src/view/'+name+'.html', filename : 'view/'+name+'.html', title : title, inject : true, hash : true, chunks : ['common',name] &#125;;&#125;; //webpack configvar config = &#123; entry: &#123; 'common' : ['./src/page/common/index.js'], 'index' : ['./src/page/index/index.js'], 'user-login' : ['./src/page/user-login/index.js'],//对输入就要对应多输出 'user-register' : ['./src/page/user-register/index.js'], 'user-pass-reset' : ['./src/page/user-pass-reset/index.js'], 'user-pass-update' : ['./src/page/user-pass-update/index.js'], 'user-center' : ['./src/page/user-center/index.js'], 'user-center-update' : ['./src/page/user-center-update/index.js'], 'result' : ['./src/page/result/index.js'] &#125;, output: &#123; path : './dist', publicPath : '/dist', filename : 'js/[name].js' &#125;, externals : &#123; 'jquery' : 'window.jQuery' &#125;, module : &#123; loaders : [ &#123;test : /\.css$/, loader : ExtractTextPlugin.extract("style-loader","css-loader")&#125;, &#123;test : /\.(gif|png|jpg|woff|svg|eot|ttf)\??.*$/, loader : 'url-loader?limit=100&amp;name=resource/[name].[ext]'&#125;, &#123;test : /\.string$/, loader : 'html-loader'&#125; ] &#125;, resolve : &#123; alias : &#123; node_modules : __dirname + '/node_modules', util : __dirname + '/src/util', page : __dirname + '/src/page', service : __dirname + '/src/service', image : __dirname + '/src/image' &#125; &#125;, plugins : [ //独立通用模块到js/base.js new webpack.optimize.CommonsChunkPlugin(&#123; name : 'common', filename : 'js/base.js' &#125;), //把css单独打包到文件里 new ExtractTextPlugin("css/[name].css"), //html模板的处理 new HtmlWebpackPlugin(getHtmlConfig('index','首页')), new HtmlWebpackPlugin(getHtmlConfig('user-login','用户登录')), new HtmlWebpackPlugin(getHtmlConfig('user-register','用户注册')), new HtmlWebpackPlugin(getHtmlConfig('user-pass-reset','找回密码')), new HtmlWebpackPlugin(getHtmlConfig('user-pass-update','更改密码')), new HtmlWebpackPlugin(getHtmlConfig('user-center','个人中心')), new HtmlWebpackPlugin(getHtmlConfig('user-center-update','修改个人信息')), new HtmlWebpackPlugin(getHtmlConfig('result','操作结果')), ]&#125;;if('dev' == WEBPACK_ENV)&#123; config.entry.common.push('webpack-dev-server/client?http://localhost:8088/');&#125;module.exports = config;]]></content>
      <categories>
        <category>mmall</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目统用模块（前台）]]></title>
    <url>%2F2018%2F03%2F15%2F%E9%A1%B9%E7%9B%AE%E7%BB%9F%E7%94%A8%E6%A8%A1%E5%9D%97%EF%BC%88%E5%89%8D%E5%8F%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[概述 统用JS工具类网络请求mm.js12345678910111213141516171819202122232425262728293031323334353637383940414243/** @Author: Blemon* @Date: 2018-03-13 21:37:23* @Last Modified by: Blemon* @Last Modified time: 2018-03-13 21:50:45*/'use strict'var _mm = &#123; //网络请求 request : function(param)&#123; var _this = this; $.ajax(&#123; type : param.method || 'get', url : param.url || '', dataType : param.type || 'json', data : param.data || '', success : function(res)&#123; //请求成功 if(0 == res.status)&#123; typeof param.success === 'function' &amp;&amp; param.success(res.data,res.msg); &#125; //没有登陆状态，需要强制登陆 else if(10 == res.status)&#123; _this.doLogin(); &#125; //请求数据错误 else if(1 == res.status)&#123; typeof param.error === 'function' &amp;&amp; param.error(res.msg); &#125; &#125;, error : function(err)&#123; typeof param.error === 'function' &amp;&amp; param.error(err.statusText); &#125; &#125;); &#125;, //统一登陆处理 doLogin : function()&#123; window.location.href = './login.html?redirect=' + encodeURIComponent(window.location.href); &#125;&#125;;module.exports = _mm; index.js123456789101112131415161718192021/** @Author: Blemon* @Date: 2018-03-12 22:33:12* @Last Modified by: Blemon* @Last Modified time: 2018-03-13 22:00:19*/'use strict';var _mm = require('util/mm.js');_mm.request(&#123; url : '/product/list.do?keyword=1', success : function(res)&#123; console.log(res); &#125;, error : function(resMsg)&#123; console.log(resMsg); &#125;&#125;); Chrome设置代理获取服务器端接口url、参数功能12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** @Author: Blemon* @Date: 2018-03-13 21:37:23* @Last Modified by: Blemon* @Last Modified time: 2018-03-14 10:19:52*/'use strict'var conf = &#123; serverHost : ''&#125;;var _mm = &#123; //网络请求 request : function(param)&#123; var _this = this; $.ajax(&#123; type : param.method || 'get', url : param.url || '', dataType : param.type || 'json', data : param.data || '', success : function(res)&#123; //请求成功 if(0 == res.status)&#123; typeof param.success === 'function' &amp;&amp; param.success(res.data,res.msg); &#125; //没有登陆状态，需要强制登陆 else if(10 == res.status)&#123; _this.doLogin(); &#125; //请求数据错误 else if(1 == res.status)&#123; typeof param.error === 'function' &amp;&amp; param.error(res.msg); &#125; &#125;, error : function(err)&#123; typeof param.error === 'function' &amp;&amp; param.error(err.statusText); &#125; &#125;); &#125;, //统一登陆处理 doLogin : function()&#123; window.location.href = './login.html?redirect=' + encodeURIComponent(window.location.href); &#125;, //获取服务器地址 getServerUrl : function(path)&#123; return conf.serverHost + path; &#125;, //获取url的参数 getUrlParam : function(name)&#123; //happymmall.com/product/list?keyword=1&amp;&amp;page=1 var reg = new RegExp('(^|&amp;)'+name+'=([^&amp;]*)(&amp;|$)'); var result = window.location.search.substr(1).match(reg); return result ? decodeURIComponent(result[2]) : null; &#125;&#125;;module.exports = _mm; hogan 渲染html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** @Author: Blemon* @Date: 2018-03-13 21:37:23* @Last Modified by: Blemon* @Last Modified time: 2018-03-14 10:38:11*/'use strict'var Hogan = require('hogan.js');var conf = &#123; serverHost : ''&#125;;var _mm = &#123; //网络请求 request : function(param)&#123; var _this = this; $.ajax(&#123; type : param.method || 'get', url : param.url || '', dataType : param.type || 'json', data : param.data || '', success : function(res)&#123; //请求成功 if(0 == res.status)&#123; typeof param.success === 'function' &amp;&amp; param.success(res.data,res.msg); &#125; //没有登陆状态，需要强制登陆 else if(10 == res.status)&#123; _this.doLogin(); &#125; //请求数据错误 else if(1 == res.status)&#123; typeof param.error === 'function' &amp;&amp; param.error(res.msg); &#125; &#125;, error : function(err)&#123; typeof param.error === 'function' &amp;&amp; param.error(err.statusText); &#125; &#125;); &#125;, //统一登陆处理 doLogin : function()&#123; window.location.href = './login.html?redirect=' + encodeURIComponent(window.location.href); &#125;, //获取服务器地址 getServerUrl : function(path)&#123; return conf.serverHost + path; &#125;, //获取url的参数 getUrlParam : function(name)&#123; //happymmall.com/product/list?keyword=1&amp;&amp;page=1 var reg = new RegExp('(^|&amp;)'+name+'=([^&amp;]*)(&amp;|$)'); var result = window.location.search.substr(1).match(reg); return result ? decodeURIComponent(result[2]) : null; &#125;, //渲染html renderHtml : function(htmlTemplate,data)&#123; var template = Hogan.compile(htmlTemplate), result = template.render(data); return result; &#125;&#125;;module.exports = _mm; 统用提示12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** @Author: Blemon* @Date: 2018-03-13 21:37:23* @Last Modified by: Blemon* @Last Modified time: 2018-03-14 10:55:06*/'use strict'var Hogan = require('hogan.js');var conf = &#123; serverHost : ''&#125;;var _mm = &#123; //网络请求 request : function(param)&#123; var _this = this; $.ajax(&#123; type : param.method || 'get', url : param.url || '', dataType : param.type || 'json', data : param.data || '', success : function(res)&#123; //请求成功 if(0 == res.status)&#123; typeof param.success === 'function' &amp;&amp; param.success(res.data,res.msg); &#125; //没有登陆状态，需要强制登陆 else if(10 == res.status)&#123; _this.doLogin(); &#125; //请求数据错误 else if(1 == res.status)&#123; typeof param.error === 'function' &amp;&amp; param.error(res.msg); &#125; &#125;, error : function(err)&#123; typeof param.error === 'function' &amp;&amp; param.error(err.statusText); &#125; &#125;); &#125;, //统一登陆处理 doLogin : function()&#123; window.location.href = './login.html?redirect=' + encodeURIComponent(window.location.href); &#125;, //统一回到主页 doLogin : function()&#123; window.loaction.href = './index.html'; &#125;, //获取服务器地址 getServerUrl : function(path)&#123; return conf.serverHost + path; &#125;, //获取url的参数 getUrlParam : function(name)&#123; //happymmall.com/product/list?keyword=1&amp;&amp;page=1 var reg = new RegExp('(^|&amp;)'+name+'=([^&amp;]*)(&amp;|$)'); var result = window.location.search.substr(1).match(reg); return result ? decodeURIComponent(result[2]) : null; &#125;, //渲染html renderHtml : function(htmlTemplate,data)&#123; var template = Hogan.compile(htmlTemplate), result = template.render(data); return result; &#125;, //成功提示 successTips : function(msg)&#123; alert(msg || '操作成功'); &#125;, //错误提示 errorTips : function(msg)&#123; alert(msg || '操作失败'); &#125;, //字段验证（非空，手机，邮箱） validate : function(value,type)&#123; var value = $.trim(value); //非空 if('require'=== type)&#123; return !!value; &#125; //手机号验证 if('phone'=== type)&#123; return /^1\d&#123;10&#125;$/.test(value); &#125; //邮箱 if('email'=== type)&#123; return /^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/.test(value); &#125; &#125;&#125;;module.exports = _mm; 统用UI（样式）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** @Author: Blemon* @Date: 2018-03-14 10:56:10* @Last Modified by: Blemon* @Last Modified time: 2018-03-14 11:46:38*//* css reset*/*&#123; margin : 0; padding : 0;&#125;body&#123; background : #f6f6f6f; font : 12px/1.5 tahoma, arial, Microsoft YaHei, sans-serif;&#125;li&#123; list-style: none;&#125;img&#123; display: block; border: none;&#125;label&#123; cursor: pointer;&#125;input[type='checkbox']&#123; cursor: pointer;&#125;/* 定宽布局*/.w&#123; width: 1080px; margin: 0 auto; position: relative; overflow: hidden;&#125;.large .w&#123; width: 1600px;&#125;/* 全局统用*//* 隐藏类 */.hide&#123; display: none;&#125;/* 超链接类 */.link&#123; color: #999; cursor: pointer; text-decoration: none;&#125;.link:hover&#123; color: #e80012;&#125;.link-text&#123; color: #999; text-decoration: none;&#125;/* btn */.btn&#123; display: inline-block; padding: 0 20px; height: 40px; line-height: 40px; vertical-align: middle; border: none; background: #c60023; font-size: 17px; font-weight: bold; color: #fff; outline: none; cursor: pointer; text-decoration: none;&#125;.btn-mini&#123; height: 25px; line-height: 25px; font-size: 12px; padding: 0 10px;&#125;/* loading */.loading&#123; margin: 10px auto; display: block; width: 65px; height: 65px; border: 1px solid #ddd; border-radius: 5px; background: url(../../image/icon/loading.gif) no-repeat; opacity: .6;&#125; 通用导航UI12345678910111213141516171819202122232425262728293031323334&lt;div class="nav"&gt; &lt;div class="w"&gt; &lt;div class="user-info"&gt; &lt;span class="user not-login"&gt; &lt;span class="link js-login"&gt;登录&lt;/span&gt; &lt;span class="link js-register"&gt;注册&lt;/span&gt; &lt;/span&gt; &lt;span class="user login"&gt; &lt;span class="link-text"&gt; 欢迎， &lt;span class="username"&gt;&lt;/span&gt; &lt;/span&gt; &lt;span class="link js-logout"&gt;退出&lt;/span&gt; &lt;/span&gt; &lt;/div&gt; &lt;ul class="nav-list"&gt; &lt;li class="nav-item"&gt; &lt;a class="link" href="./cart.html"&gt; &lt;i class="fa fa-shopping-cart"&gt;&lt;/i&gt; 购物车(&lt;span class="cart-count"&gt;0&lt;/span&gt;) &lt;/a&gt; &lt;/li&gt; &lt;li class="nav-item"&gt; &lt;a class="link" href="./order-list.html"&gt;我的订单&lt;/a&gt; &lt;/li&gt; &lt;li class="nav-item"&gt; &lt;a class="link" href="./user-center.html"&gt;我的MMall&lt;/a&gt; &lt;/li&gt; &lt;li class="nav-item"&gt; &lt;a class="link" href="./about.html"&gt;关于MMall&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 逻辑1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** @Author: Blemon* @Date: 2018-03-14 15:03:46* @Last Modified by: Blemon* @Last Modified time: 2018-03-14 15:46:03*/'use strict'require('./index.css');var _mm = require('util/mm.js');var _user = require('service/user-service.js');var _cart = require('service/cart-service.js');var nav = &#123; init : function()&#123; this.bindEvent(); this.loadUserInfo(); this.loadCartCount(); return this; &#125;, bindEvent : function()&#123; //登陆点击事件 $('.js-login').click(function()&#123; _mm.doLogin(); &#125;); //注册点击事件 $('.js-register').click(function()&#123; window.location.href = './register.html'; &#125;); //注册退出事件 $('.js-logout').click(function()&#123; _user.logout(function(res)&#123; window.location.reload(); &#125;,function(errMsg)&#123; _mm.errorTips(errMsg); &#125;); &#125;); &#125;, //加载用户信息 loadUserInfo : function()&#123; _user.logout(function(res)&#123; $('.user.not-login').hide().siblings(',user.login').show(). find('.username').text(res.username); &#125;,function(errMsg)&#123; //do nothing &#125;); &#125;, //加载购物车信息 loadCartCount : function()&#123; _cart.getCartCount(function(res)&#123; $('.nav .cart-count').text(res || 0); &#125;,function(errMsg)&#123; $('.nav .cart-count').text(0); &#125;); &#125;&#125;;module.exports = nav.init(); 统用footer1234567891011121314&lt;div class="footer"&gt; &lt;div class="w"&gt; &lt;div class="links"&gt; &lt;a class="link" href="http://bbblemon.top/" target="_blank"&gt;Blemon's Blog&lt;/a&gt; | &lt;a class="link" href="https://www.baidu.com" target="_blank"&gt;百度&lt;/a&gt; | &lt;a class="link" href="https://gitee.com/blemon" target="_blank"&gt;码云&lt;/a&gt; | &lt;a class="link" href="https://www.zhihu.com/" target="_blank"&gt;知乎&lt;/a&gt; &lt;/div&gt; &lt;p class="copyright"&gt; Copyright © 2018 bbblemon.top All Right Reserved &lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js"&gt;&lt;/script&gt; 统用header123456789&lt;div class="header"&gt; &lt;div class="w"&gt; &lt;a class="logo" href="./index.html"&gt;MMall&lt;/a&gt; &lt;div class="search-con"&gt; &lt;input class="search-input" id="search-input" placeholder="请输入商品名称"/&gt; &lt;button class="btn search-btn" id="search-btn"&gt;搜索&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** @Author: Blemon* @Date: 2018-03-14 16:17:59* @Last Modified by: Blemon* @Last Modified time: 2018-03-14 16:50:43*/'use strict'require('./index.css');var _mm = require('util/mm.js');//统用页面头部var header = &#123; init : function()&#123; this.bindEvent(); &#125;, onLoad : function()&#123; var keyword = _mm.getUrlParam('keyword'); //keyword存在，回填输入框 if (keyword) &#123; $('#search-input').val(keyword); &#125;; &#125;, bindEvent : function()&#123; var _this = this; //搜索提交 $('#search-btn').click(function()&#123; _this.searchSubmit(); &#125;); //输入回车，也是搜索提交 $('#search-input').keyup(function(e)&#123; //enter的keyCode是13 if(e.keyCode === 13)&#123; _this.searchSubmit(); &#125; &#125;); &#125;, //搜索提交 searchSubmit : function()&#123; var keyword = $.trim($('#search-input').val()); //提交成功，正常跳转到list页 if(keyword)&#123; window.location.href = './list.html?keyword='+keyword; &#125; //如果keyword是空，直接返回首页 else&#123; _mm.goHome(); &#125; &#125;&#125;;header.init(); 统用侧边导航123&lt;ul class="nav-side"&gt;&lt;/ul&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** @Author: Blemon* @Date: 2018-03-14 17:10:09* @Last Modified by: Blemon* @Last Modified time: 2018-03-14 17:32:17*/'use strict'require('./index.css');var _mm = require('util/mm.js');//侧边导航require('./index.css');var _mm = require('util/mm.js');var templateIndex = require('./index.string');// 侧边导航var navSide = &#123; option : &#123; name : '', navList : [ &#123;name : 'user-center', desc : '个人中心', href: './user-center.html'&#125;, &#123;name : 'order-list', desc : '我的订单', href: './order-list.html'&#125;, &#123;name : 'user-pass-update', desc : '修改密码', href: './user-pass-update.html'&#125;, &#123;name : 'about', desc : '关于MMall', href: './about.html'&#125; ] &#125;, init : function(option)&#123; // 合并选项 $.extend(this.option, option); this.renderNav(); &#125;, // 渲染导航菜单 renderNav : function()&#123; // 计算active数据 for(var i = 0, iLength = this.option.navList.length; i &lt; iLength; i++)&#123; if(this.option.navList[i].name === this.option.name)&#123; this.option.navList[i].isActive = true; &#125; &#125;; // 渲染list数据 var navHtml = _mm.renderHtml(templateIndex, &#123; navList : this.option.navList &#125;); // 把html放入容器 $('.nav-side').html(navHtml); &#125;&#125;;module.exports = navSide; 统用提示页12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;%= require('html-loader!./layout/head-common.html') %&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title%&gt; - Happymmall电商平台&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;%= require('html-loader!./layout/nav-simple.html') %&gt; &lt;div class="page-wrap w"&gt; &lt;div class="result-con"&gt; &lt;h1 class="result-title"&gt;恭喜您，注册成功!&lt;/h1&gt; &lt;div class="result-content"&gt; &lt;a class="link" href="./index.html"&gt;回到首页&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;%= require('html-loader!./layout/footer.html') %&gt; &lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819/** @Author: Blemon* @Date: 2018-03-14 18:28:19* @Last Modified by: Blemon* @Last Modified time: 2018-03-14 18:50:49*/'use strict';require('./index.css');require('page/common/nav-simple/index.js');var _mm = require('util/mm.js');$(function()&#123; var type = _mm.getUrlParam('type') || 'default', $element = $('.' + type + '-success'); // 显示对应的提示元素 $element.show();&#125;)]]></content>
      <categories>
        <category>mmall</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前台配置]]></title>
    <url>%2F2018%2F03%2F14%2F%E5%89%8D%E5%8F%B0%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[项目架构基础框架的搭建1. 双平台的开发环境安装 2. git仓库的规范化用法 3. webpack脚手架搭建实战 统用模块1. 可高复用工具类设计与封装 2. 统用模块设计与独立打包方法 3. 高逼格UI开发经验与技巧 用户模块1. 数据安全性处理方案 2. 表单同步/异步验证 3. 小型SPA开发 商品模块1. jQuery插件模块化改造 2. 独立组件抽离技巧 3. 多功能列表开发 购物车模块1. 商品状态随时验证 2. 模块内部方法调用 3. 非Form提交时的数据验证 订单模块1. Modal式组件封装思想 2. 城市级联操作 3. 复杂表单回填 支付模块1. 支付宝支付功能对接 2. 支付状态动态检测 3. 支付成功回执处理 管理后台1. 管理后台实现思路 2. React框架及其组件化 3. React-Router的使用 访问数据分析1. PV/UV 2. 流量来源监控 3. 用户特征分析 SEO优化1. SEO原理 2. 关键词设计 3. SEO监控 线上部署1. 线上服务器环境搭建 2. 自动化发布脚本编写 3. 域名规划与nginx配置 可用性监控1. 外部监控原理 2. 第三方监控的设置 3. 更高级的监控方式 前后端配合方式及数据接口定义 开发环境搭建 项目初始化项目目录结构设计与Git远程仓库的建立项目脚手架搭建概要npm与webpack的初始化webpack对脚本和样式的处理对脚本的处理 1. Js用什么loader加载？ 2. 官方文档上的例子中entry只有一个js，我们有多个怎么办 3. output里要分文件夹存放目标文件，怎么设置？ 4. jquery引入方法？ 5. 我想要提取公共模块，怎么处理? 对样式的处理 1. 样式使用怎样的loader？ 2. webpack打包的css怎么独立成单独的文件？ Js使用的Loader不需要安装别的，我们就使用webpack自带的 entry中多输入多输出webpack.config.js 123456789101112131415161718/** @Author: Blemon* @Date: 2018-03-12 22:40:25* @Last Modified by: Blemon* @Last Modified time: 2018-03-13 17:01:33*/var config = &#123; entry: &#123; 'index' : ['./src/page/index/index.js'], 'login' : ['./src/page/login/index.js'],//对输入就要对应多输出 &#125;, output: &#123; path: './dist', filename: 'js/[name].js' &#125;&#125;;module.exports = config; jquery引入方法index.js/index(利用npm install jquery –save)12345678910111213/** @Author: Blemon* @Date: 2018-03-12 22:33:12* @Last Modified by: Blemon* @Last Modified time: 2018-03-13 17:15:26*/'use strict';var $ = require('jquery');$('body').html('HELLO INDEX');console.log('hello index'); 重新引入(html中引入) 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;/head&gt; &lt;body&gt; &lt;script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js"&gt;&lt;/script&gt;&lt;!-- 使用//就是省略了请求方式 --&gt; &lt;script type="text/javascript" src="../../dist/js/index.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 重新引入(模块化引入) 1234567index.jsvar $$ = require('jquery');console.log('hello index');$('body').html('index hello~~~'); 123456789101112131415161718192021webpack.config.js/** @Author: Blemon* @Date: 2018-03-12 22:40:25* @Last Modified by: Blemon* @Last Modified time: 2018-03-13 17:26:47*/var config = &#123; entry: &#123; 'index' : ['./src/page/index/index.js'], 'login' : ['./src/page/login/index.js'],//对输入就要对应多输出 &#125;, output: &#123; path: './dist', filename: 'js/[name].js' &#125;, externals : &#123; 'jquery' : 'window.jQuery' &#125;&#125;; webpack提取公共模块（CommonsChunkPlugin）webpack.config.js 1234567891011121314151617181920212223242526272829/** @Author: Blemon* @Date: 2018-03-12 22:40:25* @Last Modified by: Blemon* @Last Modified time: 2018-03-13 17:33:38*/var webpack = require('webpack');var config = &#123; entry: &#123; 'index' : ['./src/page/index/index.js'], 'login' : ['./src/page/login/index.js'],//对输入就要对应多输出 &#125;, output: &#123; path: './dist', filename: 'js/[name].js' &#125;, externals : &#123; 'jquery' : 'window.jQuery' &#125;, plugins : [ new webpack.optimize.CommonsChunkPlugin(&#123; name : 'commons', filename : 'js/base.js' &#125;) ]&#125;;module.exports = config; css Loader1234567891011121314151617181920212223242526272829303132333435/** @Author: Blemon* @Date: 2018-03-12 22:40:25* @Last Modified by: Blemon* @Last Modified time: 2018-03-13 17:56:50*/var webpack = require('webpack');var config = &#123; entry: &#123; 'common' : ['./src/page/common/index.js'], 'index' : ['./src/page/index/index.js'], 'login' : ['./src/page/login/index.js'],//对输入就要对应多输出 &#125;, output: &#123; path: './dist', filename: 'js/[name].js' &#125;, externals : &#123; 'jquery' : 'window.jQuery' &#125;, module : &#123; loaders : [ &#123;test : /\.css$/, loader : "style-loader!css-loader"&#125; ] &#125;, plugins : [ new webpack.optimize.CommonsChunkPlugin(&#123; name : 'common', filename : 'js/base.js' &#125;) ]&#125;;module.exports = config; 12345678910111213141516171819202122232425262728293031323334353637/** @Author: Blemon* @Date: 2018-03-12 22:40:25* @Last Modified by: Blemon* @Last Modified time: 2018-03-13 18:12:46*/var webpack = require('webpack');var ExtractTextPlugin = require('extract-text-webpack-plugin');var config = &#123; entry: &#123; 'common' : ['./src/page/common/index.js'], 'index' : ['./src/page/index/index.js'], 'login' : ['./src/page/login/index.js'],//对输入就要对应多输出 &#125;, output: &#123; path: './dist', filename: 'js/[name].js' &#125;, externals : &#123; 'jquery' : 'window.jQuery' &#125;, module : &#123; loaders : [ &#123;test : /\.css$/, loader: ExtractTextPlugin.extract("style-loader","css-loader")&#125; ] &#125;, plugins : [ new webpack.optimize.CommonsChunkPlugin(&#123; name : 'common', filename : 'js/base.js' &#125;), new ExtractTextPlugin("css/[name].css"), ]&#125;;module.exports = config; webpack对html的处理没有抽取，需要不断填入新的HtmlWebpackPlugin模块123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** @Author: Blemon* @Date: 2018-03-12 22:40:25* @Last Modified by: Blemon* @Last Modified time: 2018-03-13 19:53:09*/var webpack = require('webpack');var ExtractTextPlugin = require('extract-text-webpack-plugin');var HtmlWebpackPlugin = require('html-webpack-plugin');var config = &#123; entry: &#123; 'common' : ['./src/page/common/index.js'], 'index' : ['./src/page/index/index.js'], 'login' : ['./src/page/login/index.js'],//对输入就要对应多输出 &#125;, output: &#123; path : './dist', filename : 'js/[name].js' &#125;, externals : &#123; 'jquery' : 'window.jQuery' &#125;, module : &#123; loaders : [ &#123;test : /\.css$/, loader: ExtractTextPlugin.extract("style-loader","css-loader")&#125; ] &#125;, plugins : [ //独立通用模块到js/base.js new webpack.optimize.CommonsChunkPlugin(&#123; name : 'common', filename : 'js/base.js' &#125;), //把css单独打包到文件里 new ExtractTextPlugin("css/[name].css"), //html模板的处理 new HtmlWebpackPlugin(&#123; template : './src/view/index.html', filename : 'view/index.html', inject : true, hash : true, chunks : ['common','index'] &#125;) ]&#125;;module.exports = config; 函数抽取12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** @Author: Blemon* @Date: 2018-03-12 22:40:25* @Last Modified by: Blemon* @Last Modified time: 2018-03-13 19:59:40*/var webpack = require('webpack');var ExtractTextPlugin = require('extract-text-webpack-plugin');var HtmlWebpackPlugin = require('html-webpack-plugin');//获取html-webpack-plugin参数的方法var getHtmlConfig = function(name)&#123; return &#123; template : './src/view/'+name+'.html', filename : 'view/'+name+'.html', inject : true, hash : true, chunks : ['common',name] &#125;;&#125;; //webpack configvar config = &#123; entry: &#123; 'common' : ['./src/page/common/index.js'], 'index' : ['./src/page/index/index.js'], 'login' : ['./src/page/login/index.js'],//对输入就要对应多输出 &#125;, output: &#123; path : './dist', filename : 'js/[name].js' &#125;, externals : &#123; 'jquery' : 'window.jQuery' &#125;, module : &#123; loaders : [ &#123;test : /\.css$/, loader: ExtractTextPlugin.extract("style-loader","css-loader")&#125; ] &#125;, plugins : [ //独立通用模块到js/base.js new webpack.optimize.CommonsChunkPlugin(&#123; name : 'common', filename : 'js/base.js' &#125;), //把css单独打包到文件里 new ExtractTextPlugin("css/[name].css"), //html模板的处理 new HtmlWebpackPlugin(getHtmlConfig('index')), new HtmlWebpackPlugin(getHtmlConfig('login')), ]&#125;;module.exports = config; 封装样式 12345678&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;%= require('html-loader!./layout/html-head.html') %&gt; &lt;body&gt; &lt;script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.11.3/jquery.min.js"&gt;&lt;/script&gt; &lt;!-- 使用//就是省略了请求方式 --&gt; &lt;/body&gt;&lt;/html&gt; webpack对icon-font和图片的处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** @Author: Blemon* @Date: 2018-03-12 22:40:25* @Last Modified by: Blemon* @Last Modified time: 2018-03-13 20:19:46*/var webpack = require('webpack');var ExtractTextPlugin = require('extract-text-webpack-plugin');var HtmlWebpackPlugin = require('html-webpack-plugin');//获取html-webpack-plugin参数的方法var getHtmlConfig = function(name)&#123; return &#123; template : './src/view/'+name+'.html', filename : 'view/'+name+'.html', inject : true, hash : true, chunks : ['common',name] &#125;;&#125;; //webpack configvar config = &#123; entry: &#123; 'common' : ['./src/page/common/index.js'], 'index' : ['./src/page/index/index.js'], 'login' : ['./src/page/login/index.js'],//对输入就要对应多输出 &#125;, output: &#123; path : './dist', filename : 'js/[name].js' &#125;, externals : &#123; 'jquery' : 'window.jQuery' &#125;, module : &#123; loaders : [ &#123;test : /\.css$/, loader: ExtractTextPlugin.extract("style-loader","css-loader")&#125;, &#123;test : /\.(gif|png|jpg|woff|svg|eot|ttf)\??.*$/, loader : 'url-loader?limit=100&amp;name=resource/[name].[ext]'&#125; ] &#125;, plugins : [ //独立通用模块到js/base.js new webpack.optimize.CommonsChunkPlugin(&#123; name : 'common', filename : 'js/base.js' &#125;), //把css单独打包到文件里 new ExtractTextPlugin("css/[name].css"), //html模板的处理 new HtmlWebpackPlugin(getHtmlConfig('index')), new HtmlWebpackPlugin(getHtmlConfig('login')), ]&#125;;module.exports = config; webpack-dev-serverwebpack.config.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** @Author: Blemon* @Date: 2018-03-12 22:40:25* @Last Modified by: Blemon* @Last Modified time: 2018-03-13 20:28:16*/var webpack = require('webpack');var ExtractTextPlugin = require('extract-text-webpack-plugin');var HtmlWebpackPlugin = require('html-webpack-plugin');//获取html-webpack-plugin参数的方法var getHtmlConfig = function(name)&#123; return &#123; template : './src/view/'+name+'.html', filename : 'view/'+name+'.html', inject : true, hash : true, chunks : ['common',name] &#125;;&#125;; //webpack configvar config = &#123; entry: &#123; 'common' : ['./src/page/common/index.js','webpack-dev-server/client?http://localhost:8088/'], 'index' : ['./src/page/index/index.js'], 'login' : ['./src/page/login/index.js'],//对输入就要对应多输出 &#125;, output: &#123; path : './dist', filename : 'js/[name].js' &#125;, externals : &#123; 'jquery' : 'window.jQuery' &#125;, module : &#123; loaders : [ &#123;test : /\.css$/, loader: ExtractTextPlugin.extract("style-loader","css-loader")&#125;, &#123;test : /\.(gif|png|jpg|woff|svg|eot|ttf)\??.*$/, loader : 'url-loader?limit=100&amp;name=resource/[name].[ext]'&#125; ] &#125;, plugins : [ //独立通用模块到js/base.js new webpack.optimize.CommonsChunkPlugin(&#123; name : 'common', filename : 'js/base.js' &#125;), //把css单独打包到文件里 new ExtractTextPlugin("css/[name].css"), //html模板的处理 new HtmlWebpackPlugin(getHtmlConfig('index')), new HtmlWebpackPlugin(getHtmlConfig('login')), ]&#125;;module.exports = config; package.json &quot;scripts&quot;: { &quot;dev&quot;: &quot;WEBPACK_ENV=dev webpack-dev-server --inline --port 8088&quot; }, 第一次提交]]></content>
      <categories>
        <category>mmall</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven创建项目和Git发布]]></title>
    <url>%2F2018%2F03%2F12%2FMaven%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%92%8CGit%E5%8F%91%E5%B8%83%2F</url>
    <content type="text"><![CDATA[Maven创建工程后利用Git推送到码云 https://jingyan.baidu.com/article/4ae03de3e120de3eff9e6b86.html Maven Git]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[订单模块]]></title>
    <url>%2F2018%2F03%2F10%2F%E8%AE%A2%E5%8D%95%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[功能介绍订单列表、订单搜索、订单详情、订单发货 学习目标1. 避免业务逻辑中横向越权和纵向越权等安全漏洞 2. 设计实用、安全、扩展性强大的常量、枚举类 3. 订单号生成规则、订单严谨性判断 4. POJO和VO之间的实际操练 5. mybatis批量插入 添加订单Controller123456789101112131415161718/** * 添加订单 * @param session * @param shippingId * @param request * @return */@RequestMapping(value = "create.do",method = RequestMethod.POST)@ResponseBodypublic ServerResponse&lt;Map&lt;String,String&gt;&gt; create(HttpSession session, Integer shippingId, HttpServletRequest request) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iOrderService.createOrder(user.getId(),shippingId);&#125; ServiceInterface1ServerResponse createOrder(Integer userId,Integer shippingId); Impl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171/** * 增加订单 * @param userId * @param shippingId * @return */ public ServerResponse createOrder(Integer userId,Integer shippingId)&#123; //拿到用户购物车中所有已经勾选的购物Item，形成一个订单购物的Item其实就是订单的Item List&lt;Cart&gt; cartList = cartMapper.selectCheckedCartByUserId(userId); //计算订单的总价 ServerResponse&lt;List&lt;OrderItem&gt;&gt; serverResponse = this.getCartOrderItem(userId,cartList); if(!serverResponse.isSuccess())&#123; return serverResponse; &#125; List&lt;OrderItem&gt; orderItemList = serverResponse.getData(); BigDecimal payment = this.getOrderTotalPrice(orderItemList); //生成订单 Order order = this.assembleOrder(userId,shippingId,payment); if(order==null)&#123; return ServerResponse.createByErrorMessage("生成订单错误"); &#125; if(CollectionUtils.isEmpty(orderItemList))&#123; return ServerResponse.createByErrorMessage("购物车为空"); &#125; for(OrderItem orderItem:orderItemList)&#123; orderItem.setOrderNo(order.getOrderNo()); &#125; //这个时候Order是插入了，但是我们的OrderItem还没有插入 //Mybatis批量插入 orderItemMapper.batchInsert(orderItemList); //减少产品的库存和清空购物车 this.reduceProductStock(orderItemList); this.cleanCart(cartList); //返回给前端数据 OrderVo orderVo = this.assembleOrderVo(order,orderItemList); return ServerResponse.createBySuccess(orderVo); &#125; private ServerResponse&lt;List&lt;OrderItem&gt;&gt; getCartOrderItem(Integer userId,List&lt;Cart&gt; cartList)&#123; List&lt;OrderItem&gt; orderItemList = new ArrayList&lt;OrderItem&gt;(); if(CollectionUtils.isEmpty(cartList))&#123; return ServerResponse.createByErrorMessage("购物车为空"); &#125; for (Cart cartItem:cartList) &#123; OrderItem orderItem = new OrderItem(); Product product = productMapper.selectByPrimaryKey(cartItem.getProductId()); if(Const.ProductStatusEnum.ON_SALE.getCode()!=product.getStatus())&#123; return ServerResponse.createByErrorMessage("产品已下架"); &#125; if(cartItem.getQuantity()&gt;product.getStock())&#123; return ServerResponse.createByErrorMessage("库存不足"); &#125; //添加orderItem orderItem.setUserId(userId); orderItem.setProductId(product.getId()); orderItem.setProductName(product.getName()); orderItem.setCurrentUnitPrice(product.getPrice()); orderItem.setQuantity(cartItem.getQuantity()); orderItem.setTotalPrice(BigDecimalUtil.multiply(product.getPrice().doubleValue(),cartItem.getQuantity())); orderItemList.add(orderItem); &#125; return ServerResponse.createBySuccess(orderItemList); &#125; private BigDecimal getOrderTotalPrice(List&lt;OrderItem&gt; orderItemList)&#123; BigDecimal payment = new BigDecimal("0"); for (OrderItem orderItem:orderItemList) &#123; //引用传递，其实可以不用等 payment = BigDecimalUtil.add(payment.doubleValue(),orderItem.getTotalPrice().doubleValue()); &#125; return payment; &#125; private Order assembleOrder(Integer userId,Integer shippingId,BigDecimal payment)&#123; Order order = new Order(); long orderNo = this.generateOrderNo(); order.setOrderNo(orderNo); order.setUserId(userId); order.setStatus(Const.OrderStatusEnum.NO_PAY.getCode()); order.setPostage(0); order.setPaymentType(Const.PaymentTypeEnum.ONLINE_PAY.getCode()); order.setPayment(payment); order.setShippingId(shippingId); int rowResult = orderMapper.insert(order); if(rowResult&gt;0)&#123; return order; &#125; return null; &#125; private Long generateOrderNo()&#123; long currentTime = System.currentTimeMillis(); return currentTime+new Random().nextInt(100); &#125; private void reduceProductStock(List&lt;OrderItem&gt; orderItemList)&#123; for (OrderItem orderItem:orderItemList) &#123; Product product = productMapper.selectByPrimaryKey(orderItem.getProductId()); product.setStock(product.getStock()-orderItem.getQuantity()); productMapper.updateByPrimaryKeySelective(product); &#125; &#125; private void cleanCart(List&lt;Cart&gt; cartList)&#123; for (Cart cart:cartList) &#123; cartMapper.deleteByPrimaryKey(cart.getId()); &#125; &#125; private OrderVo assembleOrderVo(Order order,List&lt;OrderItem&gt; orderItemList)&#123; OrderVo orderVo = new OrderVo(); orderVo.setOrderNo(order.getOrderNo()); orderVo.setPayment(order.getPayment()); orderVo.setPaymentType(order.getPaymentType()); orderVo.setPaymentTypeDes(Const.PaymentTypeEnum.codeOf(order.getPaymentType()).getValue()); orderVo.setPostage(order.getPostage()); orderVo.setStatus(order.getStatus()); orderVo.setStatusDesc(Const.OrderStatusEnum.codeOf(order.getStatus()).getValue()); orderVo.setShippingId(order.getShippingId()); Shipping shipping = shippingMapper.selectByPrimaryKey(order.getShippingId()); if(shipping!=null)&#123; orderVo.setReceviceName(shipping.getReceiverName()); &#125; ShippingVo shippingVo = this.assembleShippingVo(shipping); orderVo.setShippingVo(shippingVo); orderVo.setPaymentTime(DateTimeUtil.dateToStrByStandard(order.getPaymentTime())); orderVo.setCreateTime(DateTimeUtil.dateToStrByStandard(order.getCreateTime())); orderVo.setEndTime(DateTimeUtil.dateToStrByStandard(order.getEndTime())); orderVo.setSendTime(DateTimeUtil.dateToStrByStandard(order.getSendTime())); orderVo.setCloseTime(DateTimeUtil.dateToStrByStandard(order.getCloseTime())); orderVo.setImageHost(PropertiesUtil.getProperty("ftp.server.http.prefix")); List&lt;OrderItemVo&gt; orderItemVoList = Lists.newArrayList(); for(OrderItem orderItem : orderItemList)&#123; OrderItemVo orderItemVo = assembleOrderItemVo(orderItem); orderItemVoList.add(orderItemVo); &#125; orderVo.setOrderItemVosList(orderItemVoList); return orderVo; &#125; private ShippingVo assembleShippingVo(Shipping shipping)&#123; ShippingVo shippingVo = new ShippingVo(); shippingVo.setReceiverName(shipping.getReceiverName()); shippingVo.setReceiverAddress(shipping.getReceiverAddress()); shippingVo.setReceiverProvince(shipping.getReceiverProvince()); shippingVo.setReceiverCity(shipping.getReceiverCity()); shippingVo.setReceiverDistrict(shipping.getReceiverDistrict()); shippingVo.setReceiverMobile(shipping.getReceiverMobile()); shippingVo.setReceiverZip(shipping.getReceiverZip()); shippingVo.setReceiverPhone(shippingVo.getReceiverPhone()); return shippingVo; &#125; private OrderItemVo assembleOrderItemVo(OrderItem orderItem)&#123; OrderItemVo orderItemVo = new OrderItemVo(); orderItemVo.setOrderNo(orderItem.getOrderNo()); orderItemVo.setProductId(orderItem.getProductId()); orderItemVo.setProductName(orderItem.getProductName()); orderItemVo.setProductImage(orderItem.getProductImage()); orderItemVo.setCurrentUnitPrice(orderItem.getCurrentUnitPrice()); orderItemVo.setQuantity(orderItem.getQuantity()); orderItemVo.setTotalPrice(orderItem.getTotalPrice()); orderItemVo.setCreateTime(DateTimeUtil.dateToStrByStandard(orderItem.getCreateTime())); return orderItemVo; &#125; VoOrderVo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181package com.mmall.vo;import java.math.BigDecimal;import java.util.List;/** * Created by Blemon on 2018/3/9. */public class OrderVo &#123; private Long orderNo; private BigDecimal payment; private Integer paymentType; private String paymentTypeDes; private Integer postage; private Integer status; private String statusDesc; private String paymentTime; private String sendTime; private String endTime; private String closeTime; private String createTime; //订单明细 private List&lt;OrderItemVo&gt; orderItemVosList; private String imageHost; private Integer shippingId; private String receviceName; private ShippingVo shippingVo; public Long getOrderNo() &#123; return orderNo; &#125; public void setOrderNo(Long orderNo) &#123; this.orderNo = orderNo; &#125; public BigDecimal getPayment() &#123; return payment; &#125; public void setPayment(BigDecimal payment) &#123; this.payment = payment; &#125; public Integer getPaymentType() &#123; return paymentType; &#125; public void setPaymentType(Integer paymentType) &#123; this.paymentType = paymentType; &#125; public String getPaymentTypeDes() &#123; return paymentTypeDes; &#125; public void setPaymentTypeDes(String paymentTypeDes) &#123; this.paymentTypeDes = paymentTypeDes; &#125; public Integer getPostage() &#123; return postage; &#125; public void setPostage(Integer postage) &#123; this.postage = postage; &#125; public Integer getStatus() &#123; return status; &#125; public void setStatus(Integer status) &#123; this.status = status; &#125; public String getStatusDesc() &#123; return statusDesc; &#125; public void setStatusDesc(String statusDesc) &#123; this.statusDesc = statusDesc; &#125; public String getPaymentTime() &#123; return paymentTime; &#125; public void setPaymentTime(String paymentTime) &#123; this.paymentTime = paymentTime; &#125; public String getSendTime() &#123; return sendTime; &#125; public void setSendTime(String sendTime) &#123; this.sendTime = sendTime; &#125; public String getEndTime() &#123; return endTime; &#125; public void setEndTime(String endTime) &#123; this.endTime = endTime; &#125; public String getCloseTime() &#123; return closeTime; &#125; public void setCloseTime(String closeTime) &#123; this.closeTime = closeTime; &#125; public String getCreateTime() &#123; return createTime; &#125; public void setCreateTime(String createTime) &#123; this.createTime = createTime; &#125; public List&lt;OrderItemVo&gt; getOrderItemVosList() &#123; return orderItemVosList; &#125; public void setOrderItemVosList(List&lt;OrderItemVo&gt; orderItemVosList) &#123; this.orderItemVosList = orderItemVosList; &#125; public String getImageHost() &#123; return imageHost; &#125; public void setImageHost(String imageHost) &#123; this.imageHost = imageHost; &#125; public Integer getShippingId() &#123; return shippingId; &#125; public void setShippingId(Integer shippingId) &#123; this.shippingId = shippingId; &#125; public String getReceviceName() &#123; return receviceName; &#125; public void setReceviceName(String receviceName) &#123; this.receviceName = receviceName; &#125; public ShippingVo getShippingVo() &#123; return shippingVo; &#125; public void setShippingVo(ShippingVo shippingVo) &#123; this.shippingVo = shippingVo; &#125;&#125; OrderItemVo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.mmall.vo;import java.math.BigDecimal;import java.util.Date;/** * Created by Blemon on 2018/3/9. */public class OrderItemVo &#123; private Long orderNo; private Integer productId; private String productName; private String productImage; private BigDecimal currentUnitPrice; private Integer quantity; private BigDecimal totalPrice; private String createTime; public Long getOrderNo() &#123; return orderNo; &#125; public void setOrderNo(Long orderNo) &#123; this.orderNo = orderNo; &#125; public Integer getProductId() &#123; return productId; &#125; public void setProductId(Integer productId) &#123; this.productId = productId; &#125; public String getProductName() &#123; return productName; &#125; public void setProductName(String productName) &#123; this.productName = productName; &#125; public String getProductImage() &#123; return productImage; &#125; public void setProductImage(String productImage) &#123; this.productImage = productImage; &#125; public BigDecimal getCurrentUnitPrice() &#123; return currentUnitPrice; &#125; public void setCurrentUnitPrice(BigDecimal currentUnitPrice) &#123; this.currentUnitPrice = currentUnitPrice; &#125; public Integer getQuantity() &#123; return quantity; &#125; public void setQuantity(Integer quantity) &#123; this.quantity = quantity; &#125; public BigDecimal getTotalPrice() &#123; return totalPrice; &#125; public void setTotalPrice(BigDecimal totalPrice) &#123; this.totalPrice = totalPrice; &#125; public String getCreateTime() &#123; return createTime; &#125; public void setCreateTime(String createTime) &#123; this.createTime = createTime; &#125;&#125; ShippingVo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.mmall.vo;/** * Created by Blemon on 2018/3/9. */public class ShippingVo &#123; private String receiverName; private String receiverPhone; private String receiverMobile; private String receiverProvince; private String receiverCity; private String receiverDistrict; private String receiverAddress; private String receiverZip; public String getReceiverName() &#123; return receiverName; &#125; public void setReceiverName(String receiverName) &#123; this.receiverName = receiverName; &#125; public String getReceiverPhone() &#123; return receiverPhone; &#125; public void setReceiverPhone(String receiverPhone) &#123; this.receiverPhone = receiverPhone; &#125; public String getReceiverMobile() &#123; return receiverMobile; &#125; public void setReceiverMobile(String receiverMobile) &#123; this.receiverMobile = receiverMobile; &#125; public String getReceiverProvince() &#123; return receiverProvince; &#125; public void setReceiverProvince(String receiverProvince) &#123; this.receiverProvince = receiverProvince; &#125; public String getReceiverCity() &#123; return receiverCity; &#125; public void setReceiverCity(String receiverCity) &#123; this.receiverCity = receiverCity; &#125; public String getReceiverDistrict() &#123; return receiverDistrict; &#125; public void setReceiverDistrict(String receiverDistrict) &#123; this.receiverDistrict = receiverDistrict; &#125; public String getReceiverAddress() &#123; return receiverAddress; &#125; public void setReceiverAddress(String receiverAddress) &#123; this.receiverAddress = receiverAddress; &#125; public String getReceiverZip() &#123; return receiverZip; &#125; public void setReceiverZip(String receiverZip) &#123; this.receiverZip = receiverZip; &#125;&#125; Const（Enum的写法）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144package com.mmall.common;import com.google.common.collect.Sets;import java.util.Set;/** * Created by Blemon on 2018/2/28. */public class Const &#123; public static final String CURRENT_USER = "currentUser"; public interface Role&#123; int ROLE_CUSTOMER = 0; int ROLE_ADMIN = 1; &#125; public interface ProductListOrderBy&#123; Set&lt;String&gt; PRICE_ASC_DESC = Sets.newHashSet("price_desc","price_asc"); &#125; public interface Cart_&#123; int UN_CHECKED = 0; int CHECKED = 1; String LIMIT_NUM_FAIL="LIMIT_NUM_FAIL"; String LIMIT_NUM_SUCCESS="LIMIT_NUM_SUCCESS"; &#125; public static final String EMAIL = "email"; public static final String USERNAME = "username"; public enum ProductStatusEnum&#123; ON_SALE(1,"在线"); private String value; private int code; ProductStatusEnum(int code,String value)&#123; this.code = code; this.value = value; &#125; public String getValue() &#123; return value; &#125; public int getCode() &#123; return code; &#125; &#125; public enum OrderStatusEnum&#123; CANCELED(0,"已取消"), NO_PAY(10,"未支付"), PAID(20,"已付款"), SHIPPING(40,"已发货"), ORDER_SUCCESS(50,"订单完成"), ORDER_CLOSE(60,"订单关闭"); OrderStatusEnum(int code,String value)&#123; this.code = code; this.value = value; &#125; private String value; private int code; public String getValue() &#123; return value; &#125; public int getCode() &#123; return code; &#125; public static OrderStatusEnum codeOf(int code)&#123; for (OrderStatusEnum orderStatusEnum:values()) &#123; if(orderStatusEnum.getCode()==code)&#123; return orderStatusEnum; &#125; &#125; throw new RuntimeException("没有找到枚举"); &#125; &#125; public interface AlipayCallback&#123; String TRADE_STATUS_WAIT_BUYER_PAY = "WAIT_BUYER_PAY"; String TRADE_STATUS_TRADE_SUCCESS = "TRADE_SUCCESS"; String RESPONSE_SUCCESS = "success"; String RESPONSE_FAILED = "failed"; &#125; public enum PayPlatformEnum&#123; ALIPAY(1,"支付宝"); PayPlatformEnum(int code,String value)&#123; this.code = code; this.value = value; &#125; private String value; private int code; public String getValue() &#123; return value; &#125; public int getCode() &#123; return code; &#125; &#125; public enum PaymentTypeEnum&#123; ONLINE_PAY(1,"在线支付"); PaymentTypeEnum(int code,String value)&#123; this.code = code; this.value = value; &#125; private String value; private int code; public String getValue() &#123; return value; &#125; public int getCode() &#123; return code; &#125; public static PaymentTypeEnum codeOf(int code)&#123; for (PaymentTypeEnum paymentTypeEnum:values()) &#123; if(paymentTypeEnum.getCode()==code)&#123; return paymentTypeEnum; &#125; &#125; throw new RuntimeException("没有找到枚举"); &#125; &#125;&#125; DaoInterface(orderMapper)123Order selectByUserIdAndOrderNo(@Param("userId") Integer userId,@Param("orderNo")Long orderNo);Order selectByOrderNo(Long orderNo); Impl(orderMapper)1234567891011121314&lt;select id="selectByUserIdAndOrderNo" parameterType="map" resultMap="BaseResultMap"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_order WHERE order_no=#&#123;orderNo&#125; AND user_id=#&#123;userId&#125;&lt;/select&gt;&lt;select id="selectByOrderNo" parameterType="long" resultMap="BaseResultMap"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_order WHERE order_no=#&#123;orderNo&#125;&lt;/select&gt; Interface(cartMapper)1List&lt;Cart&gt; selectCheckedCartByUserId(Integer userId); Impl(cartMapper)1234567&lt;select id="selectCheckedCartByUserId" parameterType="int" resultMap="BaseResultMap"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_cart WHERE user_id=#&#123;userId&#125; AND checked = 1&lt;/select&gt; Interface(orderItemMapper)1void batchInsert(@Param("orderItemList") List&lt;OrderItem&gt; orderItemList); Impl(orderItemMapper)1234567891011121314&lt;insert id="batchInsert" parameterType="list"&gt; insert into mmall_order_item (id, order_no,user_id, product_id, product_name, product_image, current_unit_price, quantity, total_price, create_time, update_time) values &lt;foreach collection="orderItemList" index="index" item="item" separator=","&gt; ( #&#123;item.id&#125;,#&#123;item.order_no&#125;,#&#123;item.user_id&#125;,#&#123;item.product_id&#125;,#&#123;item.product_name&#125;, #&#123;item.product_image&#125;,#&#123;item.current_unit_price&#125;,#&#123;item.quantity&#125;,#&#123;item.total_price&#125;, now(),now() ) &lt;/foreach&gt;&lt;/insert&gt; 取消订单Controller1234567891011121314151617/** * 取消订单（没有付钱的订单可以取消） * @param session * @param orderNo * @return */@RequestMapping(value = "create.do",method = RequestMethod.POST)@ResponseBodypublic ServerResponse cancel(HttpSession session, Long orderNo) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iOrderService.cancelOrder(user.getId(),orderNo);&#125; ServiceInterface1ServerResponse cancelOrder(Integer userId,Long orderNo); Impl1234567891011121314151617/** * 取消订单（没有付钱的订单可以取消） * @param session * @param orderNo * @return */@RequestMapping(value = "create.do",method = RequestMethod.POST)@ResponseBodypublic ServerResponse cancel(HttpSession session, Long orderNo) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iOrderService.cancelOrder(user.getId(),orderNo);&#125; Dao不需要多写 获取用户购物车中已经选中的商品详情Controller12345678910111213141516/** * 获取用户购物车中已经选中的商品详情 * @param session * @return */@RequestMapping(value = "get_order_cart_product.do",method = RequestMethod.POST)@ResponseBodypublic ServerResponse get_order_cart_product(HttpSession session) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iOrderService.getOrderCartProduct(user.getId());&#125; ServiceInterface1ServerResponse getOrderCartProduct(Integer userId); Impl123456789101112131415161718192021222324252627282930313233/** * 根据用户Id查找购物车中Item是checked的商品，并封装Vo进行显示 * @param userId * @return */public ServerResponse getOrderCartProduct(Integer userId)&#123; OrderProductVo orderProductVo = new OrderProductVo(); //从购物车中获取数据 List&lt;Cart&gt; cartList = cartMapper.selectCheckedCartByUserId(userId); ServerResponse&lt;List&lt;OrderItem&gt;&gt; serverResponse = this.getCartOrderItem(userId,cartList); if(!serverResponse.isSuccess())&#123; return serverResponse; &#125; List&lt;OrderItem&gt; orderItemList = serverResponse.getData(); //准备集合 List&lt;OrderItemVo&gt; orderItemVoList = Lists.newArrayList(); for (OrderItem orderItem:orderItemList) &#123; OrderItemVo orderItemVo = this.assembleOrderItemVo(orderItem); orderItemVoList.add(orderItemVo); &#125; //准备总价 BigDecimal totalPrice = this.getOrderTotalPrice(orderItemList); //装载 orderProductVo.setOrderItemList(orderItemList); orderProductVo.setTotalPrice(totalPrice); orderProductVo.setImageHost(PropertiesUtil.getProperty("ftp.server.http.prefix")); return ServerResponse.createBySuccess(orderProductVo);&#125; Vo123456789101112131415161718192021222324252627282930313233343536373839package com.mmall.vo;import com.mmall.pojo.OrderItem;import java.math.BigDecimal;import java.util.List;/** * Created by Blemon on 2018/3/10. */public class OrderProductVo &#123; private List&lt;OrderItem&gt; orderItemList; private BigDecimal totalPrice; private String imageHost; public List&lt;OrderItem&gt; getOrderItemList() &#123; return orderItemList; &#125; public void setOrderItemList(List&lt;OrderItem&gt; orderItemList) &#123; this.orderItemList = orderItemList; &#125; public BigDecimal getTotalPrice() &#123; return totalPrice; &#125; public void setTotalPrice(BigDecimal totalPrice) &#123; this.totalPrice = totalPrice; &#125; public String getImageHost() &#123; return imageHost; &#125; public void setImageHost(String imageHost) &#123; this.imageHost = imageHost; &#125;&#125; Dao不需要多写 查询订单详情Controller1234567891011@RequestMapping(value = "detail.do",method = RequestMethod.POST) @ResponseBody public ServerResponse detail(HttpSession session,Long orderNo) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iOrderService.getOrderDetail(user.getId(),orderNo); &#125; ServiceInterface1ServerResponse getOrderDetail(Integer userId,Long orderNo); Impl1234567891011public ServerResponse getOrderDetail(Integer userId,Long orderNo)&#123; Order order = orderMapper.selectByUserIdAndOrderNo(userId,orderNo); if(order!=null)&#123; List&lt;OrderItem&gt; orderItemList = orderItemMapper.getByOrderNoAndUserId(orderNo,userId); OrderVo orderVo = this.assembleOrderVo(order,orderItemList); return ServerResponse.createBySuccess(orderVo); &#125; return ServerResponse.createByErrorMessage("没有该订单");&#125; Dao不需要多写 查询用户的所有订单Controller12345678910111213141516171819/** * 查询用户的所有订单 * @param session * @param pageNum * @param pageSize * @return */@RequestMapping(value = "list.do",method = RequestMethod.POST)@ResponseBodypublic ServerResponse list(HttpSession session, @RequestParam(value = "pageNum",defaultValue = "1") int pageNum, @RequestParam(value = "pageSize",defaultValue = "10")int pageSize) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iOrderService.getOrderList(user.getId(),pageNum,pageSize);&#125; ServiceInterface1ServerResponse&lt;PageInfo&gt; getOrderList(Integer userId,int pageNum,int pageSize); Impl123456789101112131415161718192021222324252627public ServerResponse&lt;PageInfo&gt; getOrderList(Integer userId,int pageNum,int pageSize)&#123; PageHelper.startPage(pageNum,pageSize); List&lt;Order&gt; orderList = orderMapper.selectByUserId(userId); List&lt;OrderVo&gt; orderVoList = this.assembleListOrderVo(userId,orderList); PageInfo pageResult = new PageInfo(orderList); pageResult.setList(orderVoList); return ServerResponse.createBySuccess(pageResult);&#125;private List&lt;OrderVo&gt; assembleListOrderVo(Integer userId,List&lt;Order&gt; orderList)&#123; List&lt;OrderVo&gt; orderVoList = Lists.newArrayList(); for (Order order:orderList) &#123; List&lt;OrderItem&gt; orderItemList = Lists.newArrayList(); if(userId==null)&#123; // TODO: 2018/3/10 管理员不需要传UserId &#125;else&#123; orderItemList = orderItemMapper.getByOrderNoAndUserId(order.getOrderNo(),userId); &#125; OrderVo orderVo = this.assembleOrderVo(order,orderItemList); orderVoList.add(orderVo); &#125; return orderVoList;&#125; DaoInterface1List&lt;Order&gt; selectByUserId(Integer userId); Impl1234567&lt;select id="selectByUserId" parameterType="int" resultMap="BaseResultMap"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_order WHERE user_id=#&#123;userId&#125; ORDER BY create_time DESC&lt;/select&gt; 后台查询所有订单Controller123456789101112131415161718192021222324252627282930313233343536373839/** * Created by Blemon on 2018/3/10. */@Controller@RequestMapping("/manager/order/")public class OrderManagerController &#123; private static final Logger logger = LoggerFactory.getLogger(OrderManagerController.class); @Autowired private IOrderService iOrderService; @Autowired private IUserService iUserService; /** * 查询所有订单 * @param session * @param pageNum * @param pageSize * @return */ @RequestMapping(value = "list.do",method = RequestMethod.POST) @ResponseBody public ServerResponse list(HttpSession session, @RequestParam(value = "pageNum",defaultValue = "1") int pageNum, @RequestParam(value = "pageSize",defaultValue = "10")int pageSize) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; if(iUserService.checkAdmin(user).isSuccess())&#123; return iOrderService.manageList(pageNum,pageSize); &#125;else&#123; return ServerResponse.createByErrorMessage("无权限操作"); &#125; &#125;&#125; ServiceInterface1ServerResponse&lt;PageInfo&gt; manageList(int pageNum,int pageSize); Impl123456789101112public ServerResponse&lt;PageInfo&gt; manageList(int pageNum,int pageSize)&#123; PageHelper.startPage(pageNum, pageSize); List&lt;Order&gt; orderList = orderMapper.selectAll(); List&lt;OrderVo&gt; orderVoList = this.assembleListOrderVo(null,orderList); PageInfo pageResult = new PageInfo(orderList); pageResult.setList(orderVoList); return ServerResponse.createBySuccess(pageResult);&#125; DaoInterface1List&lt;Order&gt; selectAll(); Impl123456&lt;select id="selectAll" resultMap="BaseResultMap"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_order ORDER BY create_time DESC&lt;/select&gt; 后台查询某个订单的详情Controller12345678910111213141516171819202122/** * 后台查询某个订单的详情 * @param session * @param orderNo * @return */@RequestMapping(value = "detail.do",method = RequestMethod.POST)@ResponseBodypublic ServerResponse&lt;OrderVo&gt; detail(HttpSession session, Long orderNo) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; if(iUserService.checkAdmin(user).isSuccess())&#123; return iOrderService.manageDetail(orderNo); &#125;else&#123; return ServerResponse.createByErrorMessage("无权限操作"); &#125;&#125; ServiceInterface1ServerResponse&lt;OrderVo&gt; manageDetail(Long orderNo); Impl1234567891011public ServerResponse&lt;OrderVo&gt; manageDetail(Long orderNo)&#123; Order order = orderMapper.selectByOrderNo(orderNo); if(order!=null)&#123; List&lt;OrderItem&gt; orderItemList = orderItemMapper.getByOrderNo(orderNo); OrderVo orderVo = this.assembleOrderVo(order,orderItemList); return ServerResponse.createBySuccess(orderVo); &#125; return ServerResponse.createByErrorMessage("订单不存在");&#125; Dao不需要多写 后台进行搜索Controller123456789101112131415161718192021222324/** * 后台进行搜索 * @param session * @param orderNo * @return */@RequestMapping(value = "search.do",method = RequestMethod.POST)@ResponseBodypublic ServerResponse&lt;PageInfo&gt; search(HttpSession session, Long orderNo, @RequestParam(value = "pageNum",defaultValue = "1") int pageNum, @RequestParam(value = "pageSize",defaultValue = "10")int pageSize) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; if(iUserService.checkAdmin(user).isSuccess())&#123; return iOrderService.manageSearch(orderNo,pageNum,pageSize); &#125;else&#123; return ServerResponse.createByErrorMessage("无权限操作"); &#125;&#125; ServiceInterface1ServerResponse&lt;PageInfo&gt; manageSearch(Long orderNo,int pageNum,int pageSize); Impl123456789101112131415public ServerResponse&lt;PageInfo&gt; manageSearch(Long orderNo,int pageNum,int pageSize)&#123; PageHelper.startPage(pageNum,pageSize); Order order = orderMapper.selectByOrderNo(orderNo); if(order!=null)&#123; List&lt;OrderItem&gt; orderItemList = orderItemMapper.getByOrderNo(orderNo); OrderVo orderVo = this.assembleOrderVo(order,orderItemList); PageInfo pageResult = new PageInfo(Lists.newArrayList(order)); pageResult.setList(Lists.newArrayList(orderVo)); return ServerResponse.createBySuccess(pageResult); &#125; return ServerResponse.createByErrorMessage("订单不存在");&#125; Dao不需要多写 发货Controller12345678910111213141516171819202122/** * 发货 * @param session * @param orderNo * @return */@RequestMapping(value = "send_goods.do",method = RequestMethod.POST)@ResponseBodypublic ServerResponse send_goods(HttpSession session, Long orderNo) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; if(iUserService.checkAdmin(user).isSuccess())&#123; return iOrderService.manageSendGoods(orderNo); &#125;else&#123; return ServerResponse.createByErrorMessage("无权限操作"); &#125;&#125; ServiceInterface1ServerResponse&lt;String&gt; manageSendGoods(Long orderNo); Impl123456789101112public ServerResponse&lt;String&gt; manageSendGoods(Long orderNo)&#123; Order order = orderMapper.selectByOrderNo(orderNo); if(order!=null)&#123; if(order.getStatus()==Const.OrderStatusEnum.PAID.getCode())&#123; order.setStatus(Const.OrderStatusEnum.SHIPPING.getCode()); order.setSendTime(new Date()); orderMapper.updateByPrimaryKeySelective(order); return ServerResponse.createBySuccess("发货成功"); &#125; &#125; return ServerResponse.createByErrorMessage("订单不存在");&#125; Dao不需要多写 测试 整体订单这个模块中涉及到的接口很多，这里就只贴本模块的MVC，其余的在上面代码中查 ControllerOrderController123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237package com.mmall.controller.portal;import com.alipay.api.AlipayApiException;import com.alipay.api.internal.util.AlipaySignature;import com.alipay.demo.trade.config.Configs;import com.google.common.collect.Maps;import com.mmall.common.Const;import com.mmall.common.ResponseCode;import com.mmall.common.ServerResponse;import com.mmall.pojo.User;import com.mmall.service.impl.IOrderService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import java.util.Map;/** * Created by Blemon on 2018/3/7. */@Controller@RequestMapping("/order/")public class OrderController &#123; private static final Logger logger = LoggerFactory.getLogger(OrderController.class); @Autowired private IOrderService iOrderService; /** * 添加订单 * @param session * @param shippingId * @param request * @return */ @RequestMapping(value = "create.do",method = RequestMethod.POST) @ResponseBody public ServerResponse&lt;Map&lt;String,String&gt;&gt; create(HttpSession session, Integer shippingId, HttpServletRequest request) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iOrderService.createOrder(user.getId(),shippingId); &#125; /** * 取消订单（没有付钱的订单可以取消） * @param session * @param orderNo * @return */ @RequestMapping(value = "cancel.do",method = RequestMethod.POST) @ResponseBody public ServerResponse cancel(HttpSession session, Long orderNo) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iOrderService.cancelOrder(user.getId(),orderNo); &#125; /** * 获取用户购物车中已经选中的商品详情 * @param session * @return */ @RequestMapping(value = "get_order_cart_product.do",method = RequestMethod.POST) @ResponseBody public ServerResponse get_order_cart_product(HttpSession session) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iOrderService.getOrderCartProduct(user.getId()); &#125; /** * 根据订单Id查询订单详情 * @param session * @param orderNo * @return */ @RequestMapping(value = "detail.do",method = RequestMethod.POST) @ResponseBody public ServerResponse detail(HttpSession session,Long orderNo) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iOrderService.getOrderDetail(user.getId(),orderNo); &#125; /** * 查询用户的所有订单 * @param session * @param pageNum * @param pageSize * @return */ @RequestMapping(value = "list.do",method = RequestMethod.POST) @ResponseBody public ServerResponse list(HttpSession session, @RequestParam(value = "pageNum",defaultValue = "1") int pageNum, @RequestParam(value = "pageSize",defaultValue = "10")int pageSize) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iOrderService.getOrderList(user.getId(),pageNum,pageSize); &#125; /** * 支付功能 * 其实就是根据某用户的某个订单号生成一个支付宝扫码的url，将这个url生成一个图片 * 再把图片上传到FTP服务器，完毕以后，返回给前台这个图片在FTP服务器上的路径。 * @param session * @param orderNo * @param request * @return 返回订单号和订单生成的二维码图片url(所以返回的其实是一个Map) */ @RequestMapping(value = "pay.do",method = RequestMethod.POST) @ResponseBody public ServerResponse&lt;Map&lt;String,String&gt;&gt; pay(HttpSession session, Long orderNo, HttpServletRequest request)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; //生成一个目录 //request.getSession().getServletContext() 获取的是Servlet容器对象，相当于tomcat容器了 //生成的二维码图片上传到FTP服务器上，然后给前台返回我们的图片地址 String path = request.getSession().getServletContext().getRealPath("upload"); return iOrderService.pay(orderNo,user.getId(),path); &#125; /** * 回调 * @param request * @return */ @RequestMapping(value = "alipay_callback.do",method = RequestMethod.POST) @ResponseBody public ServerResponse&lt;String&gt; alipay_callback(HttpServletRequest request)&#123; Map&lt;String,String&gt; params = Maps.newHashMap(); Map&lt;String,String[]&gt; requestParams = request.getParameterMap(); for (String name : requestParams.keySet()) &#123; String[] values = requestParams.get(name); String valueStr = "";//数组变成字符串 for (int i=0;i&lt;values.length;i++)&#123; valueStr = (i==values.length-1)?valueStr+values[i]:valueStr+values[i]+","; &#125; params.put(name,valueStr); &#125; logger.info("支付宝回调,sign:&#123;&#125;,trade_status:&#123;&#125;,参数:&#123;&#125;", params.get("sign"),params.get("trade_status"),params.toString()); //非常重要,验证回调的正确性,是不是支付宝发的.并且呢还要避免重复通知. params.remove("sign_type");//sign在调用方法中被删除了 try &#123; boolean alipayRSACheckedV2 = AlipaySignature. rsaCheckV2(params, Configs.getAlipayPublicKey(),"utf-8", Configs.getSignType()); if(!alipayRSACheckedV2)&#123; return ServerResponse.createByErrorMessage("非法请求,验证不通过,再恶意请求我就报警找网警了"); &#125; &#125; catch (AlipayApiException e) &#123; logger.error("支付宝验证回调异常",e); &#125; //todo 验证各种数据 // ServerResponse serverResponse = iOrderService.alipayCallback(params); if(serverResponse.isSuccess())&#123; return ServerResponse.createBySuccessMessage(Const.AlipayCallback.RESPONSE_SUCCESS); &#125; return ServerResponse.createByErrorMessage(Const.AlipayCallback.RESPONSE_FAILED); &#125; /** * 查询订单状态 * @param session * @param orderNo * @return */ @RequestMapping("query_order_pay_status.do") @ResponseBody public ServerResponse&lt;Boolean&gt; query_order_pay_status(HttpSession session, Long orderNo)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; ServerResponse serverResponse = iOrderService.queryOrderPayStatus(user.getId(),orderNo); if(serverResponse.isSuccess())&#123; return ServerResponse.createBySuccess(true); &#125; return ServerResponse.createBySuccess(false); &#125;&#125; OrderManagerController123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127package com.mmall.controller.backend;import com.github.pagehelper.PageInfo;import com.mmall.common.Const;import com.mmall.common.ResponseCode;import com.mmall.common.ServerResponse;import com.mmall.pojo.User;import com.mmall.service.IUserService;import com.mmall.service.impl.IOrderService;import com.mmall.vo.OrderVo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpSession;/** * Created by Blemon on 2018/3/10. */@Controller@RequestMapping("/manage/order")public class OrderManagerController &#123; @Autowired private IOrderService iOrderService; @Autowired private IUserService iUserService; /** * 查询所有订单 * @param session * @param pageNum * @param pageSize * @return */ @RequestMapping(value = "list.do",method = RequestMethod.POST) @ResponseBody public ServerResponse list(HttpSession session, @RequestParam(value = "pageNum",defaultValue = "1") int pageNum, @RequestParam(value = "pageSize",defaultValue = "10")int pageSize) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; if(iUserService.checkAdmin(user).isSuccess())&#123; return iOrderService.manageList(pageNum,pageSize); &#125;else&#123; return ServerResponse.createByErrorMessage("无权限操作"); &#125; &#125; /** * 后台查询某个订单的详情 * @param session * @param orderNo * @return */ @RequestMapping(value = "detail.do",method = RequestMethod.POST) @ResponseBody public ServerResponse&lt;OrderVo&gt; detail(HttpSession session, Long orderNo) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; if(iUserService.checkAdmin(user).isSuccess())&#123; return iOrderService.manageDetail(orderNo); &#125;else&#123; return ServerResponse.createByErrorMessage("无权限操作"); &#125; &#125; /** * 后台进行搜索 * @param session * @param orderNo * @return */ @RequestMapping(value = "search.do",method = RequestMethod.POST) @ResponseBody public ServerResponse&lt;PageInfo&gt; search(HttpSession session, Long orderNo, @RequestParam(value = "pageNum",defaultValue = "1") int pageNum, @RequestParam(value = "pageSize",defaultValue = "10")int pageSize) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; if(iUserService.checkAdmin(user).isSuccess())&#123; return iOrderService.manageSearch(orderNo,pageNum,pageSize); &#125;else&#123; return ServerResponse.createByErrorMessage("无权限操作"); &#125; &#125; /** * 发货 * @param session * @param orderNo * @return */ @RequestMapping(value = "send_goods.do",method = RequestMethod.POST) @ResponseBody public ServerResponse send_goods(HttpSession session, Long orderNo) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; if(iUserService.checkAdmin(user).isSuccess())&#123; return iOrderService.manageSendGoods(orderNo); &#125;else&#123; return ServerResponse.createByErrorMessage("无权限操作"); &#125; &#125;&#125; ServiceInterface(orderService)123456789101112131415161718192021222324252627282930313233343536373839package com.mmall.service.impl;import com.github.pagehelper.PageInfo;import com.mmall.common.ServerResponse;import com.mmall.vo.OrderVo;import java.util.Map;/** * Created by Blemon on 2018/3/7. */public interface IOrderService &#123; ServerResponse createOrder(Integer userId,Integer shippingId); ServerResponse cancelOrder(Integer userId,Long orderNo); ServerResponse getOrderCartProduct(Integer userId); ServerResponse getOrderDetail(Integer userId,Long orderNo); ServerResponse&lt;PageInfo&gt; getOrderList(Integer userId,int pageNum,int pageSize); ServerResponse pay(Long orderNo,Integer userId,String path); ServerResponse alipayCallback(Map&lt;String,String&gt; params); ServerResponse queryOrderPayStatus(Integer userId,Long orderNo); //backend ServerResponse&lt;PageInfo&gt; manageList(int pageNum,int pageSize); ServerResponse&lt;OrderVo&gt; manageDetail(Long orderNo); ServerResponse&lt;PageInfo&gt; manageSearch(Long orderNo,int pageNum,int pageSize); ServerResponse&lt;String&gt; manageSendGoods(Long orderNo);&#125; Impl(OrderService)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617package com.mmall.service;import com.alipay.api.AlipayResponse;import com.alipay.api.response.AlipayTradePrecreateResponse;import com.alipay.demo.trade.config.Configs;import com.alipay.demo.trade.model.ExtendParams;import com.alipay.demo.trade.model.GoodsDetail;import com.alipay.demo.trade.model.builder.AlipayTradePrecreateRequestBuilder;import com.alipay.demo.trade.model.result.AlipayF2FPrecreateResult;import com.alipay.demo.trade.service.AlipayTradeService;import com.alipay.demo.trade.service.impl.AlipayTradeServiceImpl;import com.alipay.demo.trade.utils.ZxingUtils;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import com.google.common.collect.Lists;import com.google.common.collect.Maps;import com.mmall.common.Const;import com.mmall.common.ServerResponse;import com.mmall.dao.*;import com.mmall.pojo.*;import com.mmall.service.impl.IOrderService;import com.mmall.util.BigDecimalUtil;import com.mmall.util.DateTimeUtil;import com.mmall.util.FTPUtil;import com.mmall.util.PropertiesUtil;import com.mmall.vo.OrderItemVo;import com.mmall.vo.OrderProductVo;import com.mmall.vo.OrderVo;import com.mmall.vo.ShippingVo;import org.apache.commons.collections.CollectionUtils;import org.apache.commons.lang.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.io.File;import java.io.IOException;import java.math.BigDecimal;import java.util.*;/** * Created by Blemon on 2018/3/7. */@Service("iOrderService")public class OrderServiceImpl implements IOrderService &#123; private static final Logger logger = LoggerFactory.getLogger(OrderServiceImpl.class); @Autowired private OrderMapper orderMapper; @Autowired private OrderItemMapper orderItemMapper; @Autowired private PayInfoMapper payInfoMapper; @Autowired private CartMapper cartMapper; @Autowired private ShippingMapper shippingMapper; @Autowired private ProductMapper productMapper; /** * 增加订单 * @param userId * @param shippingId * @return */ public ServerResponse createOrder(Integer userId,Integer shippingId)&#123; //拿到用户购物车中所有已经勾选的购物Item，形成一个订单购物的Item其实就是订单的Item List&lt;Cart&gt; cartList = cartMapper.selectCheckedCartByUserId(userId); //计算订单的总价 ServerResponse&lt;List&lt;OrderItem&gt;&gt; serverResponse = this.getCartOrderItem(userId,cartList); if(!serverResponse.isSuccess())&#123; return serverResponse; &#125; List&lt;OrderItem&gt; orderItemList = serverResponse.getData(); BigDecimal payment = this.getOrderTotalPrice(orderItemList); if(CollectionUtils.isEmpty(orderItemList))&#123; return ServerResponse.createByErrorMessage("购物车为空"); &#125; //生成订单 Order order = this.assembleOrder(userId,shippingId,payment); if(order==null)&#123; return ServerResponse.createByErrorMessage("生成订单错误"); &#125; for(OrderItem orderItem:orderItemList)&#123; orderItem.setOrderNo(order.getOrderNo()); &#125; //这个时候Order是插入了，但是我们的OrderItem还没有插入 //Mybatis批量插入 orderItemMapper.batchInsert(orderItemList); //减少产品的库存和清空购物车 this.reduceProductStock(orderItemList); this.cleanCart(cartList); //返回给前端数据 OrderVo orderVo = this.assembleOrderVo(order,orderItemList); return ServerResponse.createBySuccess(orderVo); &#125; private ServerResponse&lt;List&lt;OrderItem&gt;&gt; getCartOrderItem(Integer userId,List&lt;Cart&gt; cartList)&#123; List&lt;OrderItem&gt; orderItemList = new ArrayList&lt;&gt;(); if(CollectionUtils.isEmpty(cartList))&#123; return ServerResponse.createByErrorMessage("购物车为空"); &#125; for (Cart cartItem:cartList) &#123; OrderItem orderItem = new OrderItem(); Product product = productMapper.selectByPrimaryKey(cartItem.getProductId()); if(Const.ProductStatusEnum.ON_SALE.getCode()!=product.getStatus())&#123; return ServerResponse.createByErrorMessage("产品已下架"); &#125; if(cartItem.getQuantity()&gt;product.getStock())&#123; return ServerResponse.createByErrorMessage("库存不足"); &#125; //添加orderItem orderItem.setUserId(userId); orderItem.setProductId(product.getId()); orderItem.setProductName(product.getName()); orderItem.setProductImage(product.getMainImage()); orderItem.setCurrentUnitPrice(product.getPrice()); orderItem.setQuantity(cartItem.getQuantity()); orderItem.setTotalPrice(BigDecimalUtil.multiply(product.getPrice().doubleValue(),cartItem.getQuantity())); orderItemList.add(orderItem); &#125; return ServerResponse.createBySuccess(orderItemList); &#125; private BigDecimal getOrderTotalPrice(List&lt;OrderItem&gt; orderItemList)&#123; BigDecimal payment = new BigDecimal("0"); for (OrderItem orderItem:orderItemList) &#123; //引用传递，其实可以不用等 payment = BigDecimalUtil.add(payment.doubleValue(),orderItem.getTotalPrice().doubleValue()); &#125; return payment; &#125; private Order assembleOrder(Integer userId,Integer shippingId,BigDecimal payment)&#123; Order order = new Order(); long orderNo = this.generateOrderNo(); order.setOrderNo(orderNo); order.setUserId(userId); order.setStatus(Const.OrderStatusEnum.NO_PAY.getCode()); order.setPostage(0); order.setPaymentType(Const.PaymentTypeEnum.ONLINE_PAY.getCode()); order.setPayment(payment); order.setShippingId(shippingId); int rowResult = orderMapper.insert(order); if(rowResult&gt;0)&#123; return order; &#125; return null; &#125; private Long generateOrderNo()&#123; long currentTime = System.currentTimeMillis(); return currentTime+new Random().nextInt(100); &#125; private void reduceProductStock(List&lt;OrderItem&gt; orderItemList)&#123; for (OrderItem orderItem:orderItemList) &#123; Product product = productMapper.selectByPrimaryKey(orderItem.getProductId()); product.setStock(product.getStock()-orderItem.getQuantity()); productMapper.updateByPrimaryKeySelective(product); &#125; &#125; private void cleanCart(List&lt;Cart&gt; cartList)&#123; for (Cart cart:cartList) &#123; cartMapper.deleteByPrimaryKey(cart.getId()); &#125; &#125; private OrderVo assembleOrderVo(Order order,List&lt;OrderItem&gt; orderItemList)&#123; OrderVo orderVo = new OrderVo(); orderVo.setOrderNo(order.getOrderNo()); orderVo.setPayment(order.getPayment()); orderVo.setPaymentType(order.getPaymentType()); orderVo.setPaymentTypeDes(Const.PaymentTypeEnum.codeOf(order.getPaymentType()).getValue()); orderVo.setPostage(order.getPostage()); orderVo.setStatus(order.getStatus()); orderVo.setStatusDesc(Const.OrderStatusEnum.codeOf(order.getStatus()).getValue()); orderVo.setShippingId(order.getShippingId()); Shipping shipping = shippingMapper.selectByPrimaryKey(order.getShippingId()); if(shipping!=null)&#123; orderVo.setReceviceName(shipping.getReceiverName()); orderVo.setShippingVo(this.assembleShippingVo(shipping)); &#125; orderVo.setPaymentTime(DateTimeUtil.dateToStrByStandard(order.getPaymentTime())); orderVo.setCreateTime(DateTimeUtil.dateToStrByStandard(order.getCreateTime())); orderVo.setEndTime(DateTimeUtil.dateToStrByStandard(order.getEndTime())); orderVo.setSendTime(DateTimeUtil.dateToStrByStandard(order.getSendTime())); orderVo.setCloseTime(DateTimeUtil.dateToStrByStandard(order.getCloseTime())); orderVo.setImageHost(PropertiesUtil.getProperty("ftp.server.http.prefix")); List&lt;OrderItemVo&gt; orderItemVoList = Lists.newArrayList(); for(OrderItem orderItem : orderItemList)&#123; OrderItemVo orderItemVo = assembleOrderItemVo(orderItem); orderItemVoList.add(orderItemVo); &#125; orderVo.setOrderItemVosList(orderItemVoList); return orderVo; &#125; private ShippingVo assembleShippingVo(Shipping shipping)&#123; ShippingVo shippingVo = new ShippingVo(); shippingVo.setReceiverName(shipping.getReceiverName()); shippingVo.setReceiverAddress(shipping.getReceiverAddress()); shippingVo.setReceiverProvince(shipping.getReceiverProvince()); shippingVo.setReceiverCity(shipping.getReceiverCity()); shippingVo.setReceiverDistrict(shipping.getReceiverDistrict()); shippingVo.setReceiverMobile(shipping.getReceiverMobile()); shippingVo.setReceiverZip(shipping.getReceiverZip()); shippingVo.setReceiverPhone(shipping.getReceiverPhone()); return shippingVo; &#125; private OrderItemVo assembleOrderItemVo(OrderItem orderItem)&#123; System.out.println("orderItem = [" + orderItem + "]"); OrderItemVo orderItemVo = new OrderItemVo(); orderItemVo.setOrderNo(orderItem.getOrderNo()); orderItemVo.setProductId(orderItem.getProductId()); orderItemVo.setProductName(orderItem.getProductName()); orderItemVo.setProductImage(orderItem.getProductImage()); orderItemVo.setCurrentUnitPrice(orderItem.getCurrentUnitPrice()); orderItemVo.setQuantity(orderItem.getQuantity()); orderItemVo.setTotalPrice(orderItem.getTotalPrice()); orderItemVo.setCreateTime(DateTimeUtil.dateToStrByStandard(orderItem.getCreateTime())); return orderItemVo; &#125; /** * 取消订单 * @param userId * @param orderNo * @return */ public ServerResponse cancelOrder(Integer userId,Long orderNo)&#123; Order order = orderMapper.selectByUserIdAndOrderNo(userId,orderNo); if(order==null)&#123; return ServerResponse.createByErrorMessage("该用户此订单不存在"); &#125; if(order.getStatus()!=Const.OrderStatusEnum.NO_PAY.getCode())&#123; return ServerResponse.createByErrorMessage("该用户此订单已付款，无法取消"); &#125; Order updateOrder = new Order(); updateOrder.setId(order.getId()); updateOrder.setStatus(Const.OrderStatusEnum.CANCELED.getCode()); int rowResult = orderMapper.updateByPrimaryKeySelective(updateOrder); if(rowResult&gt;0)&#123; return ServerResponse.createBySuccess(); &#125; return ServerResponse.createByError(); &#125; /** * 根据用户Id查找购物车中Item是checked的商品，并封装Vo进行显示 * @param userId * @return */ public ServerResponse getOrderCartProduct(Integer userId)&#123; OrderProductVo orderProductVo = new OrderProductVo(); //从购物车中获取数据 List&lt;Cart&gt; cartList = cartMapper.selectCheckedCartByUserId(userId); ServerResponse&lt;List&lt;OrderItem&gt;&gt; serverResponse = this.getCartOrderItem(userId,cartList); if(!serverResponse.isSuccess())&#123; return serverResponse; &#125; List&lt;OrderItem&gt; orderItemList = serverResponse.getData(); //准备集合 List&lt;OrderItemVo&gt; orderItemVoList = Lists.newArrayList(); for (OrderItem orderItem:orderItemList) &#123; OrderItemVo orderItemVo = this.assembleOrderItemVo(orderItem); orderItemVoList.add(orderItemVo); &#125; //准备总价 BigDecimal totalPrice = this.getOrderTotalPrice(orderItemList); //装载 orderProductVo.setOrderItemList(orderItemList); orderProductVo.setTotalPrice(totalPrice); orderProductVo.setImageHost(PropertiesUtil.getProperty("ftp.server.http.prefix")); return ServerResponse.createBySuccess(orderProductVo); &#125; public ServerResponse getOrderDetail(Integer userId,Long orderNo)&#123; Order order = orderMapper.selectByUserIdAndOrderNo(userId,orderNo); if(order!=null)&#123; List&lt;OrderItem&gt; orderItemList = orderItemMapper.getByOrderNoAndUserId(orderNo,userId); OrderVo orderVo = this.assembleOrderVo(order,orderItemList); return ServerResponse.createBySuccess(orderVo); &#125; return ServerResponse.createByErrorMessage("没有该订单"); &#125; public ServerResponse&lt;PageInfo&gt; getOrderList(Integer userId,int pageNum,int pageSize)&#123; PageHelper.startPage(pageNum,pageSize); List&lt;Order&gt; orderList = orderMapper.selectByUserId(userId); List&lt;OrderVo&gt; orderVoList = this.assembleListOrderVo(userId,orderList); PageInfo pageResult = new PageInfo(orderList); pageResult.setList(orderVoList); return ServerResponse.createBySuccess(pageResult); &#125; private List&lt;OrderVo&gt; assembleListOrderVo(Integer userId,List&lt;Order&gt; orderList)&#123; List&lt;OrderVo&gt; orderVoList = Lists.newArrayList(); for (Order order:orderList) &#123; List&lt;OrderItem&gt; orderItemList = Lists.newArrayList(); if(userId==null)&#123; //管理员不需要传UserId orderItemList = orderItemMapper.getByOrderNo(order.getOrderNo()); &#125;else&#123; orderItemList = orderItemMapper.getByOrderNoAndUserId(order.getOrderNo(),userId); &#125; OrderVo orderVo = this.assembleOrderVo(order,orderItemList); orderVoList.add(orderVo); &#125; return orderVoList; &#125; /** * 根据订单号和用户id查询订单对象 * @param orderNo * @param userId * @param path * @return 返回订单号和订单生成的二维码图片url */ public ServerResponse&lt;Map&lt;String,String&gt;&gt; pay(Long orderNo, Integer userId, String path)&#123; Map&lt;String,String&gt; resultMap = Maps.newHashMap(); Order order = orderMapper.selectByUserIdAndOrderNo(userId,orderNo); if(order==null)&#123; return ServerResponse.createByErrorMessage("this user havn't the order"); &#125; resultMap.put("orderNo",order.getOrderNo().toString()); //alipay_Demo // (必填) 商户网站订单系统中唯一订单号，64个字符以内，只能包含字母、数字、下划线， // 需保证商户系统端不能重复，建议通过数据库sequence生成， String outTradeNo = order.getOrderNo().toString(); // (必填) 订单标题，粗略描述用户的支付目的。如“xxx品牌xxx门店当面付扫码消费” String subject = new StringBuilder().append("happymmall扫码支付，订单号：").append(outTradeNo).toString(); // (必填) 订单总金额，单位为元，不能超过1亿元 // 如果同时传入了【打折金额】,【不可打折金额】,【订单总金额】三者,则必须满足如下条件:【订单总金额】=【打折金额】+【不可打折金额】 String totalAmount = order.getPayment().toString(); // (可选) 订单不可打折金额，可以配合商家平台配置折扣活动，如果酒水不参与打折，则将对应金额填写至此字段 // 如果该值未传入,但传入了【订单总金额】,【打折金额】,则该值默认为【订单总金额】-【打折金额】 String undiscountableAmount = "0"; // 卖家支付宝账号ID，用于支持一个签约账号下支持打款到不同的收款账号，(打款到sellerId对应的支付宝账号) // 如果该字段为空，则默认为与支付宝签约的商户的PID，也就是appid对应的PID String sellerId = ""; // 订单描述，可以对交易或商品进行一个详细地描述，比如填写"购买商品2件共15.00元" String body = new StringBuilder().append("订单").append(outTradeNo).append("购买商品价格共计").append(totalAmount).append("元").toString(); // 商户操作员编号，添加此参数可以为商户操作员做销售统计 String operatorId = "test_operator_id"; // (必填) 商户门店编号，通过门店号和商家后台可以配置精准到门店的折扣信息，详询支付宝技术支持 String storeId = "test_store_id"; // 业务扩展参数，目前可添加由支付宝分配的系统商编号(通过setSysServiceProviderId方法)，详情请咨询支付宝技术支持 ExtendParams extendParams = new ExtendParams(); extendParams.setSysServiceProviderId("2088100200300400500"); // 支付超时，定义为120分钟 String timeoutExpress = "120m"; // 商品明细列表，需填写购买商品详细信息 //GoodsDetail：商品id（使用国标）、商品名称、商品价格（单位为分）、商品数量 List&lt;GoodsDetail&gt; goodsDetailList = new ArrayList&lt;GoodsDetail&gt;(); //从数据库中查询的 //一个用户的一个订单中可能有多个订单条目项 List&lt;OrderItem&gt; orderItemList = orderItemMapper.getByOrderNoAndUserId(orderNo,userId); for (OrderItem orderItem:orderItemList) &#123; GoodsDetail goods = GoodsDetail.newInstance(orderItem.getProductId().toString(),orderItem.getProductName(), BigDecimalUtil.multiply(orderItem.getCurrentUnitPrice().doubleValue(),new Double(100).doubleValue()).longValue(), orderItem.getQuantity()); goodsDetailList.add(goods); &#125; // 创建扫码支付请求builder，设置请求参数 AlipayTradePrecreateRequestBuilder builder = new AlipayTradePrecreateRequestBuilder() .setSubject(subject).setTotalAmount(totalAmount).setOutTradeNo(outTradeNo) .setUndiscountableAmount(undiscountableAmount).setSellerId(sellerId).setBody(body) .setOperatorId(operatorId).setStoreId(storeId).setExtendParams(extendParams) .setTimeoutExpress(timeoutExpress) .setNotifyUrl(PropertiesUtil.getProperty("alipay.callback.url")) .setGoodsDetailList(goodsDetailList); //支付宝服务器主动通知商户服务器里指定的页面http路径,根据需要设置 //setNotifyUrl(PropertiesUtil.getProperty("alipay.callback.url")) /** * 一定要在创建AlipayTradeService之前调用Configs.init()设置默认参数 * Configs会读取classpath下的zfbinfo.properties文件配置信息，如果找不到该文件则确认该文件是否在classpath目录 */ Configs.init("zfbinfo.properties"); /** * 使用Configs提供的默认参数 * AlipayTradeService可以使用单例或者为静态成员对象，不需要反复new */ AlipayTradeService tradeService = new AlipayTradeServiceImpl.ClientBuilder().build(); //扫码支付请求builder，什么参数都在前面封装了 AlipayF2FPrecreateResult result = tradeService.tradePrecreate(builder); switch (result.getTradeStatus()) &#123; case SUCCESS: logger.info("支付宝预下单成功: )"); AlipayTradePrecreateResponse response = result.getResponse(); dumpResponse(response); //1. 本地生成二维码，2.然后把二维码传到我们的FTP服务器，3.最后组装成我们的url（二维码的），4.返回给前端 //1. 本地生成二维码 //保证我们的upload文件存在，不然我们的二维码生成到哪里 File folder = new File(path); if(!folder.exists())&#123; folder.setWritable(true); folder.mkdirs(); &#125; // 需要修改为运行机器上的路径 // 生成二维码在本机上的地址 String qrPath = String.format(path+"/qr-%s.png", response.getOutTradeNo()); //生成一个二维码文件名 String qrFileName = String.format("/qr-%s.png",response.getOutTradeNo()); //在那个二维码的路径上生成我们的二维码图片 ZxingUtils.getQRCodeImge(response.getQrCode(), 256, qrPath); //2.然后把二维码传到我们的FTP服务器 //拿到已经生成的二维码文件（这个时候我们的二维码图片已经存在了，参数是图片的地址和文件名字） File targetFile = new File(path,qrFileName); try &#123; //文件上传到我们的FTP服务器 FTPUtil.uploadFile(Lists.newArrayList(targetFile)); &#125; catch (IOException e) &#123; logger.error("上传二维码异常",e); &#125; logger.info("qrPath:" + qrPath); //3.最后组装成我们的url（二维码的 //生成FTP服务器上二维码的路径 String qrUrl = PropertiesUtil.getProperty("ftp.server.http.prefix")+targetFile.getName(); //4.前台返回 resultMap.put("qrUrl",qrUrl); return ServerResponse.createBySuccess(resultMap); case FAILED: logger.error("支付宝预下单失败!!!"); return ServerResponse.createByErrorMessage("支付宝预下单失败!!!"); case UNKNOWN: logger.error("系统异常，预下单状态未知!!!"); return ServerResponse.createByErrorMessage("系统异常，预下单状态未知!!!"); default: logger.error("不支持的交易状态，交易返回异常!!!"); return ServerResponse.createByErrorMessage("不支持的交易状态，交易返回异常!!!"); &#125; &#125; private void dumpResponse(AlipayResponse response) &#123; if (response != null) &#123; logger.info(String.format("code:%s, msg:%s", response.getCode(), response.getMsg())); if (StringUtils.isNotEmpty(response.getSubCode())) &#123; logger.info(String.format("subCode:%s, subMsg:%s", response.getSubCode(), response.getSubMsg())); &#125; logger.info("body:" + response.getBody()); &#125; &#125; /** * 支付宝回调 * @param params * @return */ public ServerResponse alipayCallback(Map&lt;String,String&gt; params)&#123; Long orderNo = Long.parseLong(params.get("out_trade_no"));//支付前的订单号 String tradeNo = params.get("trade_no");//支付交易号，28位 String traceStatus = params.get("trade_status"); Order order = orderMapper.selectByOrderNo(orderNo); if(order==null)&#123; return ServerResponse.createByErrorMessage("非使用订单，请忽略"); &#125; if(order.getStatus()&gt;= Const.OrderStatusEnum.PAID.getCode())&#123; return ServerResponse.createBySuccess("支付宝重新调用"); &#125; if(Const.AlipayCallback.TRADE_STATUS_TRADE_SUCCESS.equals(traceStatus))&#123; order.setStatus(Const.OrderStatusEnum.PAID.getCode()); order.setPaymentTime(DateTimeUtil.strToDateByStandard(params.get("gmt_payment"))); orderMapper.updateByPrimaryKeySelective(order); &#125; PayInfo payInfo = new PayInfo(); payInfo.setUserId(order.getUserId()); payInfo.setOrderNo(order.getOrderNo()); payInfo.setPayPlatform(Const.PayPlatformEnum.ALIPAY.getCode()); payInfo.setPlatformNumber(tradeNo); payInfo.setPlatformStatus(traceStatus); payInfoMapper.insert(payInfo); return ServerResponse.createBySuccess(); &#125; public ServerResponse queryOrderPayStatus(Integer userId,Long orderNo)&#123; Order order = orderMapper.selectByUserIdAndOrderNo(userId,orderNo); if(order==null)&#123; return ServerResponse.createByErrorMessage("用户没有该订单"); &#125; if(order.getStatus()&gt;=Const.OrderStatusEnum.PAID.getCode())&#123; return ServerResponse.createBySuccess(); &#125; return ServerResponse.createByError(); &#125; //backend public ServerResponse&lt;PageInfo&gt; manageList(int pageNum,int pageSize)&#123; PageHelper.startPage(pageNum, pageSize); List&lt;Order&gt; orderList = orderMapper.selectAll(); List&lt;OrderVo&gt; orderVoList = this.assembleListOrderVo(null,orderList); PageInfo pageResult = new PageInfo(orderList); pageResult.setList(orderVoList); return ServerResponse.createBySuccess(pageResult); &#125; public ServerResponse&lt;OrderVo&gt; manageDetail(Long orderNo)&#123; Order order = orderMapper.selectByOrderNo(orderNo); if(order!=null)&#123; List&lt;OrderItem&gt; orderItemList = orderItemMapper.getByOrderNo(orderNo); OrderVo orderVo = this.assembleOrderVo(order,orderItemList); return ServerResponse.createBySuccess(orderVo); &#125; return ServerResponse.createByErrorMessage("订单不存在"); &#125; public ServerResponse&lt;PageInfo&gt; manageSearch(Long orderNo,int pageNum,int pageSize)&#123; PageHelper.startPage(pageNum,pageSize); Order order = orderMapper.selectByOrderNo(orderNo); if(order!=null)&#123; List&lt;OrderItem&gt; orderItemList = orderItemMapper.getByOrderNo(orderNo); OrderVo orderVo = this.assembleOrderVo(order,orderItemList); PageInfo pageResult = new PageInfo(Lists.newArrayList(order)); pageResult.setList(Lists.newArrayList(orderVo)); return ServerResponse.createBySuccess(pageResult); &#125; return ServerResponse.createByErrorMessage("订单不存在"); &#125; public ServerResponse&lt;String&gt; manageSendGoods(Long orderNo)&#123; Order order = orderMapper.selectByOrderNo(orderNo); if(order!=null)&#123; if(order.getStatus()==Const.OrderStatusEnum.PAID.getCode())&#123; order.setStatus(Const.OrderStatusEnum.SHIPPING.getCode()); order.setSendTime(new Date()); orderMapper.updateByPrimaryKeySelective(order); return ServerResponse.createBySuccess("发货成功"); &#125; &#125; return ServerResponse.createByErrorMessage("订单不存在"); &#125;&#125; DaoInterface(OrderMapper)12345678910111213141516171819202122232425262728package com.mmall.dao;import com.mmall.pojo.Order;import org.apache.ibatis.annotations.Param;import java.util.List;public interface OrderMapper &#123; int deleteByPrimaryKey(Integer id); int insert(Order record); int insertSelective(Order record); Order selectByPrimaryKey(Integer id); int updateByPrimaryKeySelective(Order record); int updateByPrimaryKey(Order record); Order selectByUserIdAndOrderNo(@Param("userId") Integer userId,@Param("orderNo")Long orderNo); Order selectByOrderNo(Long orderNo); List&lt;Order&gt; selectByUserId(Integer userId); List&lt;Order&gt; selectAll();&#125; Impl(OrderMapper)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.mmall.dao.OrderMapper" &gt; &lt;resultMap id="BaseResultMap" type="com.mmall.pojo.Order" &gt; &lt;constructor &gt; &lt;idArg column="id" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="order_no" jdbcType="BIGINT" javaType="java.lang.Long" /&gt; &lt;arg column="user_id" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="shipping_id" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="payment" jdbcType="DECIMAL" javaType="java.math.BigDecimal" /&gt; &lt;arg column="payment_type" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="postage" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="status" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="payment_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;arg column="send_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;arg column="end_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;arg column="close_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;arg column="create_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;arg column="update_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;/constructor&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List" &gt; id, order_no, user_id, shipping_id, payment, payment_type, postage, status, payment_time, send_time, end_time, close_time, create_time, update_time &lt;/sql&gt; &lt;select id="selectByPrimaryKey" resultMap="BaseResultMap" parameterType="java.lang.Integer" &gt; select &lt;include refid="Base_Column_List" /&gt; from mmall_order where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;delete id="deleteByPrimaryKey" parameterType="java.lang.Integer" &gt; delete from mmall_order where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/delete&gt; &lt;insert id="insert" parameterType="com.mmall.pojo.Order" &gt; insert into mmall_order (id, order_no, user_id, shipping_id, payment, payment_type, postage, status, payment_time, send_time, end_time, close_time, create_time, update_time) values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;orderNo,jdbcType=BIGINT&#125;, #&#123;userId,jdbcType=INTEGER&#125;, #&#123;shippingId,jdbcType=INTEGER&#125;, #&#123;payment,jdbcType=DECIMAL&#125;, #&#123;paymentType,jdbcType=INTEGER&#125;, #&#123;postage,jdbcType=INTEGER&#125;, #&#123;status,jdbcType=INTEGER&#125;, #&#123;paymentTime,jdbcType=TIMESTAMP&#125;, #&#123;sendTime,jdbcType=TIMESTAMP&#125;, #&#123;endTime,jdbcType=TIMESTAMP&#125;, #&#123;closeTime,jdbcType=TIMESTAMP&#125;, now(), now()) &lt;/insert&gt; &lt;insert id="insertSelective" parameterType="com.mmall.pojo.Order" &gt; insert into mmall_order &lt;trim prefix="(" suffix=")" suffixOverrides="," &gt; &lt;if test="id != null" &gt; id, &lt;/if&gt; &lt;if test="orderNo != null" &gt; order_no, &lt;/if&gt; &lt;if test="userId != null" &gt; user_id, &lt;/if&gt; &lt;if test="shippingId != null" &gt; shipping_id, &lt;/if&gt; &lt;if test="payment != null" &gt; payment, &lt;/if&gt; &lt;if test="paymentType != null" &gt; payment_type, &lt;/if&gt; &lt;if test="postage != null" &gt; postage, &lt;/if&gt; &lt;if test="status != null" &gt; status, &lt;/if&gt; &lt;if test="paymentTime != null" &gt; payment_time, &lt;/if&gt; &lt;if test="sendTime != null" &gt; send_time, &lt;/if&gt; &lt;if test="endTime != null" &gt; end_time, &lt;/if&gt; &lt;if test="closeTime != null" &gt; close_time, &lt;/if&gt; &lt;if test="createTime != null" &gt; create_time, &lt;/if&gt; &lt;if test="updateTime != null" &gt; update_time, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides="," &gt; &lt;if test="id != null" &gt; #&#123;id,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="orderNo != null" &gt; #&#123;orderNo,jdbcType=BIGINT&#125;, &lt;/if&gt; &lt;if test="userId != null" &gt; #&#123;userId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="shippingId != null" &gt; #&#123;shippingId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="payment != null" &gt; #&#123;payment,jdbcType=DECIMAL&#125;, &lt;/if&gt; &lt;if test="paymentType != null" &gt; #&#123;paymentType,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="postage != null" &gt; #&#123;postage,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="status != null" &gt; #&#123;status,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="paymentTime != null" &gt; #&#123;paymentTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="sendTime != null" &gt; #&#123;sendTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="endTime != null" &gt; #&#123;endTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="closeTime != null" &gt; #&#123;closeTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="createTime != null" &gt; now(), &lt;/if&gt; &lt;if test="updateTime != null" &gt; now(), &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id="updateByPrimaryKeySelective" parameterType="com.mmall.pojo.Order" &gt; update mmall_order &lt;set &gt; &lt;if test="orderNo != null" &gt; order_no = #&#123;orderNo,jdbcType=BIGINT&#125;, &lt;/if&gt; &lt;if test="userId != null" &gt; user_id = #&#123;userId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="shippingId != null" &gt; shipping_id = #&#123;shippingId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="payment != null" &gt; payment = #&#123;payment,jdbcType=DECIMAL&#125;, &lt;/if&gt; &lt;if test="paymentType != null" &gt; payment_type = #&#123;paymentType,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="postage != null" &gt; postage = #&#123;postage,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="status != null" &gt; status = #&#123;status,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="paymentTime != null" &gt; payment_time = #&#123;paymentTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="sendTime != null" &gt; send_time = #&#123;sendTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="endTime != null" &gt; end_time = #&#123;endTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="closeTime != null" &gt; close_time = #&#123;closeTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="createTime != null" &gt; create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="updateTime != null" &gt; update_time = now(), &lt;/if&gt; &lt;/set&gt; where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;update id="updateByPrimaryKey" parameterType="com.mmall.pojo.Order" &gt; update mmall_order set order_no = #&#123;orderNo,jdbcType=BIGINT&#125;, user_id = #&#123;userId,jdbcType=INTEGER&#125;, shipping_id = #&#123;shippingId,jdbcType=INTEGER&#125;, payment = #&#123;payment,jdbcType=DECIMAL&#125;, payment_type = #&#123;paymentType,jdbcType=INTEGER&#125;, postage = #&#123;postage,jdbcType=INTEGER&#125;, status = #&#123;status,jdbcType=INTEGER&#125;, payment_time = #&#123;paymentTime,jdbcType=TIMESTAMP&#125;, send_time = #&#123;sendTime,jdbcType=TIMESTAMP&#125;, end_time = #&#123;endTime,jdbcType=TIMESTAMP&#125;, close_time = #&#123;closeTime,jdbcType=TIMESTAMP&#125;, create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;, update_time = now() where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;select id="selectByUserIdAndOrderNo" parameterType="map" resultMap="BaseResultMap"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_order WHERE order_no=#&#123;orderNo&#125; AND user_id=#&#123;userId&#125; &lt;/select&gt; &lt;select id="selectByOrderNo" parameterType="long" resultMap="BaseResultMap"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_order WHERE order_no=#&#123;orderNo&#125; &lt;/select&gt; &lt;select id="selectByUserId" parameterType="int" resultMap="BaseResultMap"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_order WHERE user_id=#&#123;userId&#125; ORDER BY create_time DESC &lt;/select&gt; &lt;select id="selectAll" resultMap="BaseResultMap"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_order ORDER BY create_time DESC &lt;/select&gt;&lt;/mapper&gt; Interface(OrderItemMapper)1234567891011121314151617181920212223242526package com.mmall.dao;import com.mmall.pojo.OrderItem;import org.apache.ibatis.annotations.Param;import java.util.List;public interface OrderItemMapper &#123; int deleteByPrimaryKey(Integer id); int insert(OrderItem record); int insertSelective(OrderItem record); OrderItem selectByPrimaryKey(Integer id); int updateByPrimaryKeySelective(OrderItem record); int updateByPrimaryKey(OrderItem record); List&lt;OrderItem&gt; getByOrderNoAndUserId(@Param("orderNo") Long orderNo,@Param("uderId") Integer userId); void batchInsert(@Param("orderItemList") List&lt;OrderItem&gt; orderItemList); List&lt;OrderItem&gt; getByOrderNo(@Param("orderNo") Long orderNo);&#125; Impl(OrderItemMapper)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.mmall.dao.OrderItemMapper" &gt; &lt;resultMap id="BaseResultMap" type="com.mmall.pojo.OrderItem" &gt; &lt;constructor &gt; &lt;idArg column="id" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="user_id" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="order_no" jdbcType="BIGINT" javaType="java.lang.Long" /&gt; &lt;arg column="product_id" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="product_name" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="product_image" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="current_unit_price" jdbcType="DECIMAL" javaType="java.math.BigDecimal" /&gt; &lt;arg column="quantity" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="total_price" jdbcType="DECIMAL" javaType="java.math.BigDecimal" /&gt; &lt;arg column="create_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;arg column="update_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;/constructor&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List" &gt; id, user_id, order_no, product_id, product_name, product_image, current_unit_price, quantity, total_price, create_time, update_time &lt;/sql&gt; &lt;select id="selectByPrimaryKey" resultMap="BaseResultMap" parameterType="java.lang.Integer" &gt; select &lt;include refid="Base_Column_List" /&gt; from mmall_order_item where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;delete id="deleteByPrimaryKey" parameterType="java.lang.Integer" &gt; delete from mmall_order_item where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/delete&gt; &lt;insert id="insert" parameterType="com.mmall.pojo.OrderItem" &gt; insert into mmall_order_item (id, user_id, order_no, product_id, product_name, product_image, current_unit_price, quantity, total_price, create_time, update_time) values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;userId,jdbcType=INTEGER&#125;, #&#123;orderNo,jdbcType=BIGINT&#125;, #&#123;productId,jdbcType=INTEGER&#125;, #&#123;productName,jdbcType=VARCHAR&#125;, #&#123;productImage,jdbcType=VARCHAR&#125;, #&#123;currentUnitPrice,jdbcType=DECIMAL&#125;, #&#123;quantity,jdbcType=INTEGER&#125;, #&#123;totalPrice,jdbcType=DECIMAL&#125;, now(), now()) &lt;/insert&gt; &lt;insert id="insertSelective" parameterType="com.mmall.pojo.OrderItem" &gt; insert into mmall_order_item &lt;trim prefix="(" suffix=")" suffixOverrides="," &gt; &lt;if test="id != null" &gt; id, &lt;/if&gt; &lt;if test="userId != null" &gt; user_id, &lt;/if&gt; &lt;if test="orderNo != null" &gt; order_no, &lt;/if&gt; &lt;if test="productId != null" &gt; product_id, &lt;/if&gt; &lt;if test="productName != null" &gt; product_name, &lt;/if&gt; &lt;if test="productImage != null" &gt; product_image, &lt;/if&gt; &lt;if test="currentUnitPrice != null" &gt; current_unit_price, &lt;/if&gt; &lt;if test="quantity != null" &gt; quantity, &lt;/if&gt; &lt;if test="totalPrice != null" &gt; total_price, &lt;/if&gt; &lt;if test="createTime != null" &gt; create_time, &lt;/if&gt; &lt;if test="updateTime != null" &gt; update_time, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides="," &gt; &lt;if test="id != null" &gt; #&#123;id,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="userId != null" &gt; #&#123;userId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="orderNo != null" &gt; #&#123;orderNo,jdbcType=BIGINT&#125;, &lt;/if&gt; &lt;if test="productId != null" &gt; #&#123;productId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="productName != null" &gt; #&#123;productName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="productImage != null" &gt; #&#123;productImage,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="currentUnitPrice != null" &gt; #&#123;currentUnitPrice,jdbcType=DECIMAL&#125;, &lt;/if&gt; &lt;if test="quantity != null" &gt; #&#123;quantity,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="totalPrice != null" &gt; #&#123;totalPrice,jdbcType=DECIMAL&#125;, &lt;/if&gt; &lt;if test="createTime != null" &gt; now(), &lt;/if&gt; &lt;if test="updateTime != null" &gt; now(), &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id="updateByPrimaryKeySelective" parameterType="com.mmall.pojo.OrderItem" &gt; update mmall_order_item &lt;set &gt; &lt;if test="userId != null" &gt; user_id = #&#123;userId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="orderNo != null" &gt; order_no = #&#123;orderNo,jdbcType=BIGINT&#125;, &lt;/if&gt; &lt;if test="productId != null" &gt; product_id = #&#123;productId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="productName != null" &gt; product_name = #&#123;productName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="productImage != null" &gt; product_image = #&#123;productImage,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="currentUnitPrice != null" &gt; current_unit_price = #&#123;currentUnitPrice,jdbcType=DECIMAL&#125;, &lt;/if&gt; &lt;if test="quantity != null" &gt; quantity = #&#123;quantity,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="totalPrice != null" &gt; total_price = #&#123;totalPrice,jdbcType=DECIMAL&#125;, &lt;/if&gt; &lt;if test="createTime != null" &gt; create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="updateTime != null" &gt; update_time = now(), &lt;/if&gt; &lt;/set&gt; where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;update id="updateByPrimaryKey" parameterType="com.mmall.pojo.OrderItem" &gt; update mmall_order_item set user_id = #&#123;userId,jdbcType=INTEGER&#125;, order_no = #&#123;orderNo,jdbcType=BIGINT&#125;, product_id = #&#123;productId,jdbcType=INTEGER&#125;, product_name = #&#123;productName,jdbcType=VARCHAR&#125;, product_image = #&#123;productImage,jdbcType=VARCHAR&#125;, current_unit_price = #&#123;currentUnitPrice,jdbcType=DECIMAL&#125;, quantity = #&#123;quantity,jdbcType=INTEGER&#125;, total_price = #&#123;totalPrice,jdbcType=DECIMAL&#125;, create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;, update_time = now() where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;select id="getByOrderNoAndUserId" resultMap="BaseResultMap" parameterType="map"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_order_item WHERE order_no=#&#123;orderNo&#125; AND user_id=#&#123;uderId&#125; &lt;/select&gt; &lt;insert id="batchInsert" parameterType="list"&gt; insert into mmall_order_item (id, order_no,user_id, product_id, product_name, product_image, current_unit_price, quantity, total_price, create_time, update_time) values &lt;foreach collection="orderItemList" index="index" item="item" separator=","&gt; ( #&#123;item.id&#125;,#&#123;item.orderNo&#125;,#&#123;item.userId&#125;,#&#123;item.productId&#125;,#&#123;item.productName&#125;, #&#123;item.productImage&#125;,#&#123;item.currentUnitPrice&#125;,#&#123;item.quantity&#125;,#&#123;item.totalPrice&#125;, now(),now() ) &lt;/foreach&gt; &lt;/insert&gt; &lt;select id="getByOrderNo" parameterType="long" resultMap="BaseResultMap"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_order_item WHERE order_no=#&#123;orderNo&#125; &lt;/select&gt;&lt;/mapper&gt;]]></content>
      <categories>
        <category>mmall</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支付模块]]></title>
    <url>%2F2018%2F03%2F09%2F%E6%94%AF%E4%BB%98%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[功能介绍支付宝对接、支付回调、查询支付状态 学习目标1. 熟悉支付宝对接核心文档，调通支付宝支付功能官方Demo 2. 解析支付宝SDK对接源码 3. RSA1和RSA2验证签名及加解密 4. 避免支付宝重复通知和数据校验 5. natapp外网穿透和tomcat remote debug 6. 生成二维码，并持久化到图片服务器 7. 支付宝回调 支付宝扫码支付功能对接官方文档1. 沙箱登录：https://openhome.alipay.com/platform/appDaily.htm 2. 沙箱环境使用说明：https://doc.open.alipay.com/doc2/detail.htm?treeId=200&amp;articleId=105311&amp;docType=1 3. 如何使用沙箱环境：https://support.open.alipay.com/support/hotProblemDetail.htm?spm=a219a.7386793.0.0.uS5uZ6&amp;id=251932&amp;tagId=100248 4. 当面付产品介绍：https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.hV5Clx&amp;treeId=193&amp;articleId=105072&amp;docType=1 5. 扫码支付接入指引：https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.Ia6Wqy&amp;treeId=193&amp;articleId=106078&amp;docType=1 6. 当面付快速接入：https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.bROnXf&amp;treeId=193&amp;articleId=105170&amp;docType=1 7. 当面付接入必读：https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.hV5Clx&amp;treeId=193&amp;articleId=105322&amp;docType=1 8. 当面付进阶功能：https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.YFmkxI&amp;treeId=193&amp;articleId=105190&amp;docType=1 9. 当面付异步通知-仅用于扫码支付：https://doc.open.alipay.com/docs/doc.htm?spm=a219a.7629140.0.0.BykVSR&amp;treeId=193&amp;articleId=103296&amp;docType=1 10. 当面付SDK&amp;DEMO：https://support.open.alipay.com/docs/doc.htm?spm=a219a.7386797.0.0.k0rwWc&amp;treeId=193&amp;articleId=105201&amp;docType=1 11. 服务端SDK：https://doc.open.alipay.com/doc2/detail?treeId=54&amp;articleId=103419&amp;docType=1 12. 生成RSA密钥：https://doc.open.alipay.com/docs/doc.htm?treeId=291&amp;articleId=105971&amp;docType=1 13. 线上创建应用说明：https://doc.open.alipay.com/doc2/detail.htm?treeId=200&amp;articleId=105310&amp;docType=1#s0 沙箱调试环境（买家和卖家账号测试）蚂蚁沙箱环境（Beta）：是协助开发者进行接口功能开发以及主要功能和主要逻辑（参考&quot;沙箱支持产品列表&quot;），为保证沙箱稳定， 沙箱环境测试数据回进行定期数据清理，Beta测试阶段每日21：00到次日9：00为维护时间，在此时间内沙箱环境部分功能可能会不可用。 支付宝扫码支付主业务流程 支付宝扫码支付流程 支付宝扫码支付重要字段 支付宝扫码支付重要细节1. 主动轮询和回调的区别2. 避免单边账3. 同步请求的加签和验证签名4. 回调的验证（签名、金额、订单号、订单状态、交易状态、商户id）5. 过滤掉重复的通知6. 验证确保可接收的异步通知是支付宝发出的7. 回调请求的返回 支付宝扫码支付对接技巧1. 回调的调试方式2. 外网远程debug 2.1 保持远端代码版本和本地代码保持一致 2.2 及时关闭开放的debug端口3. 内网穿透(ngrok、natapp、花生壳) 支付宝沙箱登陆支付宝扫码支付官方Demo测试配置导包 支付宝配置 NATAPP 打开Tomcat 修改mmall.properties与zfbinfo.propertiesmmall.properties12345678ftp.server.ip=127.0.0.1ftp.user=blemonftp.pass=blemonftp.server.http.prefix=http://img.blemon.com/alipay.callback.url=http://blemon.s1.natapp.cc/order/alipay_callback.dopassword.salt = geelysdafaqj23ou89ZXcj@#$@#$#@KJdjklj;D../dSF., zfbinfo.properties123456789101112131415161718192021222324252627282930# 支付宝网关名、partnerId和appIdopen_api_domain = https://openapi.alipaydev.com/gateway.domcloud_api_domain = http://mcloudmonitor.com/gateway.dopid = 2088102175186418appid = 2016091100488410# RSA私钥、公钥和支付宝公钥private_key = MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDIj5zoufTqONfJFNBpskKoWZcv60ndBJreBTQp6fSF3qyCzGFV2BPMuVLHayrk/qTuuVIgGBD0SeabA7uDhRV7FxjXv5JQ33vRivWhr330IAk7tNGgbKafMuGaJ6CDTx+1tCYMSkHeq7a1kSCkG6+fUnTK6gZkhbABDiDhegLAHW/5jkySCT3wcVPGzdvIHzcpwlcTLsxJjxtlaHsy/0lOtsuFYE93ddxrUqL3gy0g2pmm0ZIcFIQB3oZW/uKXJ9bNJnEqbH5a2/Pw7h6dHzIyVOh7AU4LZEke9bCatnkCvCseoHLDukhutmW5LkW0yfW/Rq33ymblBlp2jvwycQ8TAgMBAAECggEBALPDbTt3eZr6Sgc0fb1PBsoISyerN/A/MWQwu9mZlg7rUCqIb/HWk6CatySA3NiVmVVTi9WyXHfpSSXGCatPfLpwMFcooUeVmFBvwcwjFLzcfgoi/wVQfWQR4f4e6JLpN53Qk43OfQ3NUR2ar+wH2Ljv2jkJ26L75I59kGEo0BBKehHW1Qw9bBR4iwq6ZlVdSyQzzs6VWPJUbE5IAZFu8pHl09jlSqgXuyGkw6Axa9uUanPVdHoK8kqKVoo+yDLTqM0osTwti5HzIRL+hKLQIPBR08uf3EKExUQjpd83zHS2C6hmmDFQsspgSQRDV59Pwm/4j6NkJ9CZiHV5jMQfvPkCgYEA+pvsCivmhRA5D7/VR5A2c93Xkz49Le2eOlM26N9EvQrNR/y4uqybpmq4NN98/rfFFyF8IkEnPaEgRhmIP+bFkwz4XRxMB4miXhZcFzdb0IIVh2p9VGh1s9v1cIm9e/zrzzJo78W7ddREn006xjwdWm9gEYYTEw4EMzycae4ZatcCgYEAzOAU0lWHd6GIyLV2sIDrAU5WBcFbl7FQlcBF1mUAhHXoHs0yzHzHiRM51ev3vzsKEvKZzSNxrEgVC/q56Od/RzqxcpeLIUzaVrMnLr/1s5NS49LLBYlsfWs7KceMbL/dLdVueCLxqAYxsi4iVKrgyHsUvlMLa7gTzadsYBAakiUCgYBce1fi9QpvxmnYVwmlDCIcJhzc2JYJMew3R+g2jdY3ERpqW2fsc7BI/I8X6/WbpkOUYqYFmheaFbDsTZXLRyVYO+wXqE6iZXdG02eOpb47NxYsz+6KTLZK9nwf2KTVcaOv5cF14nloZTohs4ViDGMksX85WEoHuR9xrQdnzBcTJwKBgHNwA2tsc9MteoQU81aKnV/0ArZld7VmXJC0cOVXrc31HaBVYL0lxcxvv9PQjJz8qDV66rxSr1cymmFQmfYokmfRI3D9AJD328KkWXyW/tt7NGZYPLrW7wFQLVriLDaOeRK9QuyATAevzcqnAgMQ8W0lJNAEvNeqNcZYAtGx4TbdAoGBALaViwh2+QHSeObLLLtDHqBJ/TXGQtC/HFWk/n99Nf8pC5ybDnqprVYKWy0RsOASCBde5hvpM4gK47lxC7g3TuS20M3H1klxdaUlmGbWtQXGKwqOjX8a1S7Gek662s7p4vYtj+eqDOjEhpCK7m1VkaIbZFZffDHZtIxXnsx0DglRpublic_key = MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyI+c6Ln06jjXyRTQabJCqFmXL+tJ3QSa3gU0Ken0hd6sgsxhVdgTzLlSx2sq5P6k7rlSIBgQ9EnmmwO7g4UVexcY17+SUN970Yr1oa999CAJO7TRoGymnzLhmiegg08ftbQmDEpB3qu2tZEgpBuvn1J0yuoGZIWwAQ4g4XoCwB1v+Y5Mkgk98HFTxs3byB83KcJXEy7MSY8bZWh7Mv9JTrbLhWBPd3Xca1Ki94MtINqZptGSHBSEAd6GVv7ilyfWzSZxKmx+Wtvz8O4enR8yMlToewFOC2RJHvWwmrZ5ArwrHqByw7pIbrZluS5FtMn1v0at98pm5QZado78MnEPEwIDAQAB#SHA1withRsa对应支付宝公钥#alipay_public_key = MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDDI6d306Q8fIfCOaTXyiUeJHkrIvYISRcc73s3vF1ZT7XN8RNPwJxo8pWaJMmvyTn9N4HQ632qJBVHf8sxHi/fEsraprwCtzvzQETrNRwVxLO5jVmRGi60j8Ue1efIlzPXV9je9mkjzOmdssymZkh2QhUrCmZYI/FCEa3/cNMW0QIDAQAB#SHA256withRsa对应支付宝公钥alipay_public_key = MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxSO/ZPBK0J5bdii2v3kFRALXE2Pwe8YWE2wcJYAeRc50luEDhVOYhvXrVGkuzHd/o7tDvR/0offA59dQpJYiMyEIuwhU6EFa/pt22Y4/GqjioV6NE/Zcc1cvkS0JF84bLVhhDeA+r50EgC7sCBYK6K5VJOhLm6x4ZxkI7zsDH+XIfDP8LRM78nMKu23rtgjWNS5RGvukc2VbosJikihJzpOzwmJmiBFunyXs2PG0ACh042spgbFW124gr53KPP7r03iyHfFCn1JQ6vuaUBfoAh3KUNorAr9+0ewG3YDWYoRwqvpOTIp275CPraU80fPWBrty+rMRMYfKcVJvwXHqRwIDAQAB# 签名类型: RSA-&gt;SHA1withRsa,RSA2-&gt;SHA256withRsasign_type = RSA2# 当面付最大查询次数和查询间隔（毫秒）max_query_retry = 5query_duration = 5000# 当面付最大撤销次数和撤销间隔（毫秒）max_cancel_retry = 3cancel_duration = 2000# 交易保障线程第一次调度延迟和调度间隔（秒）heartbeat_delay = 5heartbeat_duration = 900 支付Controller1234567891011121314151617181920212223242526272829303132333435@Controller@RequestMapping("/order/")public class OrderController &#123; private static final Logger logger = LoggerFactory.getLogger(OrderController.class); @Autowired private IOrderService iOrderService; /** * 支付功能 * 其实就是根据某用户的某个订单号生成一个支付宝扫码的url，将这个url生成一个图片 * 再把图片上传到FTP服务器，完毕以后，返回给前台这个图片在FTP服务器上的路径。 * @param session * @param orderNo * @param request * @return 返回订单号和订单生成的二维码图片url(所以返回的其实是一个Map) */ @RequestMapping(value = "pay.do",method = RequestMethod.POST) @ResponseBody public ServerResponse&lt;Map&lt;String,String&gt;&gt; pay(HttpSession session, Long orderNo, HttpServletRequest request)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; //生成一个目录 //request.getSession().getServletContext() 获取的是Servlet容器对象，相当于tomcat容器了 //生成的二维码图片上传到FTP服务器上，然后给前台返回我们的图片地址 String path = request.getSession().getServletContext().getRealPath("upload"); return iOrderService.pay(orderNo,user.getId(),path); &#125;&#125; ServiceInterface1ServerResponse pay(Long orderNo,Integer userId,String path); Impl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174@Service("iOrderService")public class OrderServiceImpl implements IOrderService &#123; private static final Logger logger = LoggerFactory.getLogger(OrderServiceImpl.class); @Autowired private OrderMapper orderMapper; @Autowired private OrderItemMapper orderItemMapper; @Autowired private PayInfoMapper payInfoMapper; /** * 根据订单号和用户id查询订单对象 * @param orderNo * @param userId * @param path * @return 返回订单号和订单生成的二维码图片url */ public ServerResponse&lt;Map&lt;String,String&gt;&gt; pay(Long orderNo, Integer userId, String path)&#123; Map&lt;String,String&gt; resultMap = Maps.newHashMap(); Order order = orderMapper.selectByUserIdAndOrderNo(userId,orderNo); if(order==null)&#123; return ServerResponse.createByErrorMessage("this user havn't the order"); &#125; resultMap.put("orderNo",order.getOrderNo().toString()); //alipay_Demo // (必填) 商户网站订单系统中唯一订单号，64个字符以内，只能包含字母、数字、下划线， // 需保证商户系统端不能重复，建议通过数据库sequence生成， String outTradeNo = order.getOrderNo().toString(); // (必填) 订单标题，粗略描述用户的支付目的。如“xxx品牌xxx门店当面付扫码消费” String subject = new StringBuilder().append("happymmall扫码支付，订单号：").append(outTradeNo).toString(); // (必填) 订单总金额，单位为元，不能超过1亿元 // 如果同时传入了【打折金额】,【不可打折金额】,【订单总金额】三者,则必须满足如下条件:【订单总金额】=【打折金额】+【不可打折金额】 String totalAmount = order.getPayment().toString(); // (可选) 订单不可打折金额，可以配合商家平台配置折扣活动，如果酒水不参与打折，则将对应金额填写至此字段 // 如果该值未传入,但传入了【订单总金额】,【打折金额】,则该值默认为【订单总金额】-【打折金额】 String undiscountableAmount = "0"; // 卖家支付宝账号ID，用于支持一个签约账号下支持打款到不同的收款账号，(打款到sellerId对应的支付宝账号) // 如果该字段为空，则默认为与支付宝签约的商户的PID，也就是appid对应的PID String sellerId = ""; // 订单描述，可以对交易或商品进行一个详细地描述，比如填写"购买商品2件共15.00元" String body = new StringBuilder().append("订单").append(outTradeNo).append("购买商品价格共计").append(totalAmount).append("元").toString(); // 商户操作员编号，添加此参数可以为商户操作员做销售统计 String operatorId = "test_operator_id"; // (必填) 商户门店编号，通过门店号和商家后台可以配置精准到门店的折扣信息，详询支付宝技术支持 String storeId = "test_store_id"; // 业务扩展参数，目前可添加由支付宝分配的系统商编号(通过setSysServiceProviderId方法)，详情请咨询支付宝技术支持 ExtendParams extendParams = new ExtendParams(); extendParams.setSysServiceProviderId("2088100200300400500"); // 支付超时，定义为120分钟 String timeoutExpress = "120m"; // 商品明细列表，需填写购买商品详细信息 //GoodsDetail：商品id（使用国标）、商品名称、商品价格（单位为分）、商品数量 List&lt;GoodsDetail&gt; goodsDetailList = new ArrayList&lt;GoodsDetail&gt;(); //从数据库中查询的 //一个用户的一个订单中可能有多个订单条目项 List&lt;OrderItem&gt; orderItemList = orderItemMapper.getByOrderNoAndUserId(orderNo,userId); for (OrderItem orderItem:orderItemList) &#123; GoodsDetail goods = GoodsDetail.newInstance(orderItem.getProductId().toString(),orderItem.getProductName(), BigDecimalUtil.multiply(orderItem.getCurrentUnitPrice().doubleValue(),new Double(100).doubleValue()).longValue(), orderItem.getQuantity()); goodsDetailList.add(goods); &#125; // 创建扫码支付请求builder，设置请求参数 AlipayTradePrecreateRequestBuilder builder = new AlipayTradePrecreateRequestBuilder() .setSubject(subject).setTotalAmount(totalAmount).setOutTradeNo(outTradeNo) .setUndiscountableAmount(undiscountableAmount).setSellerId(sellerId).setBody(body) .setOperatorId(operatorId).setStoreId(storeId).setExtendParams(extendParams) .setTimeoutExpress(timeoutExpress) .setNotifyUrl(PropertiesUtil.getProperty("alipay.callback.url")) .setGoodsDetailList(goodsDetailList); //支付宝服务器主动通知商户服务器里指定的页面http路径,根据需要设置 //setNotifyUrl(PropertiesUtil.getProperty("alipay.callback.url")) /** * 一定要在创建AlipayTradeService之前调用Configs.init()设置默认参数 * Configs会读取classpath下的zfbinfo.properties文件配置信息，如果找不到该文件则确认该文件是否在classpath目录 */ Configs.init("zfbinfo.properties"); /** * 使用Configs提供的默认参数 * AlipayTradeService可以使用单例或者为静态成员对象，不需要反复new */ AlipayTradeService tradeService = new AlipayTradeServiceImpl.ClientBuilder().build(); //扫码支付请求builder，什么参数都在前面封装了 AlipayF2FPrecreateResult result = tradeService.tradePrecreate(builder); switch (result.getTradeStatus()) &#123; case SUCCESS: logger.info("支付宝预下单成功: )"); AlipayTradePrecreateResponse response = result.getResponse(); dumpResponse(response); //1. 本地生成二维码，2.然后把二维码传到我们的FTP服务器，3.最后组装成我们的url（二维码的），4.返回给前端 //1. 本地生成二维码 //保证我们的upload文件存在，不然我们的二维码生成到哪里 File folder = new File(path); if(!folder.exists())&#123; folder.setWritable(true); folder.mkdirs(); &#125; // 需要修改为运行机器上的路径 // 生成二维码在本机上的地址 String qrPath = String.format(path+"/qr-%s.png", response.getOutTradeNo()); //生成一个二维码文件名 String qrFileName = String.format("/qr-%s.png",response.getOutTradeNo()); //在那个二维码的路径上生成我们的二维码图片 ZxingUtils.getQRCodeImge(response.getQrCode(), 256, qrPath); //2.然后把二维码传到我们的FTP服务器 //拿到已经生成的二维码文件（这个时候我们的二维码图片已经存在了，参数是图片的地址和文件名字） File targetFile = new File(path,qrFileName); try &#123; //文件上传到我们的FTP服务器 FTPUtil.uploadFile(Lists.newArrayList(targetFile)); &#125; catch (IOException e) &#123; logger.error("上传二维码异常",e); &#125; logger.info("qrPath:" + qrPath); //3.最后组装成我们的url（二维码的 //生成FTP服务器上二维码的路径 String qrUrl = PropertiesUtil.getProperty("ftp.server.http.prefix")+targetFile.getName(); //4.前台返回 resultMap.put("qrUrl",qrUrl); return ServerResponse.createBySuccess(resultMap); case FAILED: logger.error("支付宝预下单失败!!!"); return ServerResponse.createByErrorMessage("支付宝预下单失败!!!"); case UNKNOWN: logger.error("系统异常，预下单状态未知!!!"); return ServerResponse.createByErrorMessage("系统异常，预下单状态未知!!!"); default: logger.error("不支持的交易状态，交易返回异常!!!"); return ServerResponse.createByErrorMessage("不支持的交易状态，交易返回异常!!!"); &#125; &#125; private void dumpResponse(AlipayResponse response) &#123; if (response != null) &#123; logger.info(String.format("code:%s, msg:%s", response.getCode(), response.getMsg())); if (StringUtils.isNotEmpty(response.getSubCode())) &#123; logger.info(String.format("subCode:%s, subMsg:%s", response.getSubCode(), response.getSubMsg())); &#125; logger.info("body:" + response.getBody()); &#125; &#125;&#125; DaoOrderMapperInterface1Order selectByUserIdAndOrderNo(@Param("userId") Integer userId,@Param("orderNo")Long orderNo); Impl1234567&lt;select id="selectByUserIdAndOrderNo" parameterType="map" resultMap="BaseResultMap"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_order WHERE order_no=#&#123;orderNo&#125; AND user_id=#&#123;userId&#125;&lt;/select&gt; OrderItemMapperInterface1List&lt;OrderItem&gt; getByOrderNoAndUserId(@Param("orderNo") Long orderNo,@Param("uderId") Integer userId); Impl1234567&lt;select id="getByOrderNoAndUserId" resultMap="BaseResultMap" parameterType="map"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_order_item WHERE order_no=#&#123;orderNo&#125; AND user_id=#&#123;uderId&#125;&lt;/select&gt; 回调注意了，这个接口可不是给我们自己调的，这个接口是给支付宝调的 Controller12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 回调 * @param request * @return */@RequestMapping(value = "alipay_callback.do",method = RequestMethod.POST)@ResponseBodypublic ServerResponse&lt;String&gt; alipay_callback(HttpServletRequest request)&#123; Map&lt;String,String&gt; params = Maps.newHashMap(); Map&lt;String,String[]&gt; requestParams = request.getParameterMap(); for (String name : requestParams.keySet()) &#123; String[] values = requestParams.get(name); String valueStr = "";//数组变成字符串 for (int i=0;i&lt;values.length;i++)&#123; valueStr = (i==values.length-1)?valueStr+values[i]:valueStr+values[i]+","; &#125; params.put(name,valueStr); &#125; logger.info("支付宝回调,sign:&#123;&#125;,trade_status:&#123;&#125;,参数:&#123;&#125;", params.get("sign"),params.get("trade_status"),params.toString()); //非常重要,验证回调的正确性,是不是支付宝发的.并且呢还要避免重复通知. params.remove("sign_type");//sign在调用方法中被删除了 try &#123; boolean alipayRSACheckedV2 = AlipaySignature. rsaCheckV2(params, Configs.getAlipayPublicKey(),"utf-8", Configs.getSignType()); if(!alipayRSACheckedV2)&#123; return ServerResponse.createByErrorMessage("非法请求,验证不通过,再恶意请求我就报警找网警了"); &#125; &#125; catch (AlipayApiException e) &#123; logger.error("支付宝验证回调异常",e); &#125; //todo 验证各种数据 // ServerResponse serverResponse = iOrderService.alipayCallback(params); if(serverResponse.isSuccess())&#123; return ServerResponse.createBySuccessMessage(Const.AlipayCallback.RESPONSE_SUCCESS); &#125; return ServerResponse.createByErrorMessage(Const.AlipayCallback.RESPONSE_FAILED);&#125; ServiceInterface1ServerResponse alipayCallback(Map&lt;String,String&gt; params); Impl12345678910111213141516171819202122232425262728293031323334353637/** * 支付宝回调 * @param params * @return */public ServerResponse alipayCallback(Map&lt;String,String&gt; params)&#123; Long orderNo = Long.parseLong(params.get("out_trade_no"));//支付前的订单号 String tradeNo = params.get("trade_no");//支付交易号，28位 String traceStatus = params.get("trade_status"); Order order = orderMapper.selectByOrderNo(orderNo); if(order==null)&#123; return ServerResponse.createByErrorMessage("非使用订单，请忽略"); &#125; if(order.getStatus()&gt;= Const.OrderStatusEnum.PAID.getCode())&#123; return ServerResponse.createBySuccess("支付宝重新调用"); &#125; if(Const.AlipayCallback.TRADE_STATUS_TRADE_SUCCESS.equals(traceStatus))&#123; order.setStatus(Const.OrderStatusEnum.PAID.getCode()); order.setPaymentTime(DateTimeUtil.strToDateByStandard(params.get("gmt_payment"))); orderMapper.updateByPrimaryKeySelective(order); &#125; PayInfo payInfo = new PayInfo(); payInfo.setUserId(order.getUserId()); payInfo.setOrderNo(order.getOrderNo()); payInfo.setPayPlatform(Const.PayPlatformEnum.ALIPAY.getCode()); payInfo.setPlatformNumber(tradeNo); payInfo.setPlatformStatus(traceStatus); payInfoMapper.insert(payInfo); return ServerResponse.createBySuccess();&#125; Dao不需要添加 查询支付状态Controller12345678910111213141516171819202122/** * 查询订单状态 * @param session * @param orderNo * @return */@RequestMapping("query_order_pay_status.do")@ResponseBodypublic ServerResponse&lt;Boolean&gt; query_order_pay_status(HttpSession session, Long orderNo)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; ServerResponse serverResponse = iOrderService.queryOrderPayStatus(user.getId(),orderNo); if(serverResponse.isSuccess())&#123; return ServerResponse.createBySuccess(true); &#125; return ServerResponse.createBySuccess(false);&#125; ServiceInterface1ServerResponse queryOrderPayStatus(Integer userId,Long orderNo); Impl12345678910public ServerResponse queryOrderPayStatus(Integer userId,Long orderNo)&#123; Order order = orderMapper.selectByUserIdAndOrderNo(userId,orderNo); if(order==null)&#123; return ServerResponse.createByErrorMessage("用户没有该订单"); &#125; if(order.getStatus()&gt;=Const.OrderStatusEnum.PAID.getCode())&#123; return ServerResponse.createBySuccess(); &#125; return ServerResponse.createByError();&#125; DaoInterface1Order selectByOrderNo(Long orderNo); Impl123456&lt;select id="selectByOrderNo" parameterType="long" resultMap="BaseResultMap"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_order WHERE order_no=#&#123;orderNo&#125;&lt;/select&gt; 测试1. 开始FTP服务器 2. 开启代理 3. 开启NATAPP 4. Restlet发送请求 5. 生成二维码 6. ftp文件 natapp -authtoken=8217bd565693304bhttp://blemon.s1.natapp.cc 整体Controller123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package com.mmall.controller.portal;import com.alipay.api.AlipayApiException;import com.alipay.api.internal.util.AlipaySignature;import com.alipay.demo.trade.config.Configs;import com.google.common.collect.Maps;import com.mmall.common.Const;import com.mmall.common.ResponseCode;import com.mmall.common.ServerResponse;import com.mmall.pojo.User;import com.mmall.service.impl.IOrderService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpSession;import java.util.Map;/** * Created by Blemon on 2018/3/7. */@Controller@RequestMapping("/order/")public class OrderController &#123; private static final Logger logger = LoggerFactory.getLogger(OrderController.class); @Autowired private IOrderService iOrderService; /** * 支付功能 * 其实就是根据某用户的某个订单号生成一个支付宝扫码的url，将这个url生成一个图片 * 再把图片上传到FTP服务器，完毕以后，返回给前台这个图片在FTP服务器上的路径。 * @param session * @param orderNo * @param request * @return 返回订单号和订单生成的二维码图片url(所以返回的其实是一个Map) */ @RequestMapping(value = "pay.do",method = RequestMethod.POST) @ResponseBody public ServerResponse&lt;Map&lt;String,String&gt;&gt; pay(HttpSession session, Long orderNo, HttpServletRequest request)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; //生成一个目录 //request.getSession().getServletContext() 获取的是Servlet容器对象，相当于tomcat容器了 //生成的二维码图片上传到FTP服务器上，然后给前台返回我们的图片地址 String path = request.getSession().getServletContext().getRealPath("upload"); return iOrderService.pay(orderNo,user.getId(),path); &#125; /** * 回调 * @param request * @return */ @RequestMapping(value = "alipay_callback.do",method = RequestMethod.POST) @ResponseBody public ServerResponse&lt;String&gt; alipay_callback(HttpServletRequest request)&#123; Map&lt;String,String&gt; params = Maps.newHashMap(); Map&lt;String,String[]&gt; requestParams = request.getParameterMap(); for (String name : requestParams.keySet()) &#123; String[] values = requestParams.get(name); String valueStr = "";//数组变成字符串 for (int i=0;i&lt;values.length;i++)&#123; valueStr = (i==values.length-1)?valueStr+values[i]:valueStr+values[i]+","; &#125; params.put(name,valueStr); &#125; logger.info("支付宝回调,sign:&#123;&#125;,trade_status:&#123;&#125;,参数:&#123;&#125;", params.get("sign"),params.get("trade_status"),params.toString()); //非常重要,验证回调的正确性,是不是支付宝发的.并且呢还要避免重复通知. params.remove("sign_type");//sign在调用方法中被删除了 try &#123; boolean alipayRSACheckedV2 = AlipaySignature. rsaCheckV2(params, Configs.getAlipayPublicKey(),"utf-8", Configs.getSignType()); if(!alipayRSACheckedV2)&#123; return ServerResponse.createByErrorMessage("非法请求,验证不通过,再恶意请求我就报警找网警了"); &#125; &#125; catch (AlipayApiException e) &#123; logger.error("支付宝验证回调异常",e); &#125; //todo 验证各种数据 // ServerResponse serverResponse = iOrderService.alipayCallback(params); if(serverResponse.isSuccess())&#123; return ServerResponse.createBySuccessMessage(Const.AlipayCallback.RESPONSE_SUCCESS); &#125; return ServerResponse.createByErrorMessage(Const.AlipayCallback.RESPONSE_FAILED); &#125; /** * 查询订单状态 * @param session * @param orderNo * @return */ @RequestMapping("query_order_pay_status.do") @ResponseBody public ServerResponse&lt;Boolean&gt; query_order_pay_status(HttpSession session, Long orderNo)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; ServerResponse serverResponse = iOrderService.queryOrderPayStatus(user.getId(),orderNo); if(serverResponse.isSuccess())&#123; return ServerResponse.createBySuccess(true); &#125; return ServerResponse.createBySuccess(false); &#125;&#125; ServiceInterface1234567891011121314151617package com.mmall.service.impl;import com.mmall.common.ServerResponse;import java.util.Map;/** * Created by Blemon on 2018/3/7. */public interface IOrderService &#123; ServerResponse pay(Long orderNo,Integer userId,String path); ServerResponse alipayCallback(Map&lt;String,String&gt; params); ServerResponse queryOrderPayStatus(Integer userId,Long orderNo);&#125; Impl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265package com.mmall.service;import com.alipay.api.AlipayResponse;import com.alipay.api.response.AlipayTradePrecreateResponse;import com.alipay.demo.trade.config.Configs;import com.alipay.demo.trade.model.ExtendParams;import com.alipay.demo.trade.model.GoodsDetail;import com.alipay.demo.trade.model.builder.AlipayTradePrecreateRequestBuilder;import com.alipay.demo.trade.model.result.AlipayF2FPrecreateResult;import com.alipay.demo.trade.service.AlipayTradeService;import com.alipay.demo.trade.service.impl.AlipayTradeServiceImpl;import com.alipay.demo.trade.utils.ZxingUtils;import com.google.common.collect.Lists;import com.google.common.collect.Maps;import com.mmall.common.Const;import com.mmall.common.ServerResponse;import com.mmall.dao.OrderItemMapper;import com.mmall.dao.OrderMapper;import com.mmall.dao.PayInfoMapper;import com.mmall.pojo.Order;import com.mmall.pojo.OrderItem;import com.mmall.pojo.PayInfo;import com.mmall.service.impl.IOrderService;import com.mmall.util.BigDecimalUtil;import com.mmall.util.DateTimeUtil;import com.mmall.util.FTPUtil;import com.mmall.util.PropertiesUtil;import org.apache.commons.lang.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.io.File;import java.io.IOException;import java.util.ArrayList;import java.util.List;import java.util.Map;/** * Created by Blemon on 2018/3/7. */@Service("iOrderService")public class OrderServiceImpl implements IOrderService &#123; private static final Logger logger = LoggerFactory.getLogger(OrderServiceImpl.class); @Autowired private OrderMapper orderMapper; @Autowired private OrderItemMapper orderItemMapper; @Autowired private PayInfoMapper payInfoMapper; /** * 根据订单号和用户id查询订单对象 * @param orderNo * @param userId * @param path * @return 返回订单号和订单生成的二维码图片url */ public ServerResponse&lt;Map&lt;String,String&gt;&gt; pay(Long orderNo, Integer userId, String path)&#123; Map&lt;String,String&gt; resultMap = Maps.newHashMap(); Order order = orderMapper.selectByUserIdAndOrderNo(userId,orderNo); if(order==null)&#123; return ServerResponse.createByErrorMessage("this user havn't the order"); &#125; resultMap.put("orderNo",order.getOrderNo().toString()); //alipay_Demo // (必填) 商户网站订单系统中唯一订单号，64个字符以内，只能包含字母、数字、下划线， // 需保证商户系统端不能重复，建议通过数据库sequence生成， String outTradeNo = order.getOrderNo().toString(); // (必填) 订单标题，粗略描述用户的支付目的。如“xxx品牌xxx门店当面付扫码消费” String subject = new StringBuilder().append("happymmall扫码支付，订单号：").append(outTradeNo).toString(); // (必填) 订单总金额，单位为元，不能超过1亿元 // 如果同时传入了【打折金额】,【不可打折金额】,【订单总金额】三者,则必须满足如下条件:【订单总金额】=【打折金额】+【不可打折金额】 String totalAmount = order.getPayment().toString(); // (可选) 订单不可打折金额，可以配合商家平台配置折扣活动，如果酒水不参与打折，则将对应金额填写至此字段 // 如果该值未传入,但传入了【订单总金额】,【打折金额】,则该值默认为【订单总金额】-【打折金额】 String undiscountableAmount = "0"; // 卖家支付宝账号ID，用于支持一个签约账号下支持打款到不同的收款账号，(打款到sellerId对应的支付宝账号) // 如果该字段为空，则默认为与支付宝签约的商户的PID，也就是appid对应的PID String sellerId = ""; // 订单描述，可以对交易或商品进行一个详细地描述，比如填写"购买商品2件共15.00元" String body = new StringBuilder().append("订单").append(outTradeNo).append("购买商品价格共计").append(totalAmount).append("元").toString(); // 商户操作员编号，添加此参数可以为商户操作员做销售统计 String operatorId = "test_operator_id"; // (必填) 商户门店编号，通过门店号和商家后台可以配置精准到门店的折扣信息，详询支付宝技术支持 String storeId = "test_store_id"; // 业务扩展参数，目前可添加由支付宝分配的系统商编号(通过setSysServiceProviderId方法)，详情请咨询支付宝技术支持 ExtendParams extendParams = new ExtendParams(); extendParams.setSysServiceProviderId("2088100200300400500"); // 支付超时，定义为120分钟 String timeoutExpress = "120m"; // 商品明细列表，需填写购买商品详细信息 //GoodsDetail：商品id（使用国标）、商品名称、商品价格（单位为分）、商品数量 List&lt;GoodsDetail&gt; goodsDetailList = new ArrayList&lt;GoodsDetail&gt;(); //从数据库中查询的 //一个用户的一个订单中可能有多个订单条目项 List&lt;OrderItem&gt; orderItemList = orderItemMapper.getByOrderNoAndUserId(orderNo,userId); for (OrderItem orderItem:orderItemList) &#123; GoodsDetail goods = GoodsDetail.newInstance(orderItem.getProductId().toString(),orderItem.getProductName(), BigDecimalUtil.multiply(orderItem.getCurrentUnitPrice().doubleValue(),new Double(100).doubleValue()).longValue(), orderItem.getQuantity()); goodsDetailList.add(goods); &#125; // 创建扫码支付请求builder，设置请求参数 AlipayTradePrecreateRequestBuilder builder = new AlipayTradePrecreateRequestBuilder() .setSubject(subject).setTotalAmount(totalAmount).setOutTradeNo(outTradeNo) .setUndiscountableAmount(undiscountableAmount).setSellerId(sellerId).setBody(body) .setOperatorId(operatorId).setStoreId(storeId).setExtendParams(extendParams) .setTimeoutExpress(timeoutExpress) .setNotifyUrl(PropertiesUtil.getProperty("alipay.callback.url")) .setGoodsDetailList(goodsDetailList); //支付宝服务器主动通知商户服务器里指定的页面http路径,根据需要设置 //setNotifyUrl(PropertiesUtil.getProperty("alipay.callback.url")) /** * 一定要在创建AlipayTradeService之前调用Configs.init()设置默认参数 * Configs会读取classpath下的zfbinfo.properties文件配置信息，如果找不到该文件则确认该文件是否在classpath目录 */ Configs.init("zfbinfo.properties"); /** * 使用Configs提供的默认参数 * AlipayTradeService可以使用单例或者为静态成员对象，不需要反复new */ AlipayTradeService tradeService = new AlipayTradeServiceImpl.ClientBuilder().build(); //扫码支付请求builder，什么参数都在前面封装了 AlipayF2FPrecreateResult result = tradeService.tradePrecreate(builder); switch (result.getTradeStatus()) &#123; case SUCCESS: logger.info("支付宝预下单成功: )"); AlipayTradePrecreateResponse response = result.getResponse(); dumpResponse(response); //1. 本地生成二维码，2.然后把二维码传到我们的FTP服务器，3.最后组装成我们的url（二维码的），4.返回给前端 //1. 本地生成二维码 //保证我们的upload文件存在，不然我们的二维码生成到哪里 File folder = new File(path); if(!folder.exists())&#123; folder.setWritable(true); folder.mkdirs(); &#125; // 需要修改为运行机器上的路径 // 生成二维码在本机上的地址 String qrPath = String.format(path+"/qr-%s.png", response.getOutTradeNo()); //生成一个二维码文件名 String qrFileName = String.format("/qr-%s.png",response.getOutTradeNo()); //在那个二维码的路径上生成我们的二维码图片 ZxingUtils.getQRCodeImge(response.getQrCode(), 256, qrPath); //2.然后把二维码传到我们的FTP服务器 //拿到已经生成的二维码文件（这个时候我们的二维码图片已经存在了，参数是图片的地址和文件名字） File targetFile = new File(path,qrFileName); try &#123; //文件上传到我们的FTP服务器 FTPUtil.uploadFile(Lists.newArrayList(targetFile)); &#125; catch (IOException e) &#123; logger.error("上传二维码异常",e); &#125; logger.info("qrPath:" + qrPath); //3.最后组装成我们的url（二维码的 //生成FTP服务器上二维码的路径 String qrUrl = PropertiesUtil.getProperty("ftp.server.http.prefix")+targetFile.getName(); //4.前台返回 resultMap.put("qrUrl",qrUrl); return ServerResponse.createBySuccess(resultMap); case FAILED: logger.error("支付宝预下单失败!!!"); return ServerResponse.createByErrorMessage("支付宝预下单失败!!!"); case UNKNOWN: logger.error("系统异常，预下单状态未知!!!"); return ServerResponse.createByErrorMessage("系统异常，预下单状态未知!!!"); default: logger.error("不支持的交易状态，交易返回异常!!!"); return ServerResponse.createByErrorMessage("不支持的交易状态，交易返回异常!!!"); &#125; &#125; private void dumpResponse(AlipayResponse response) &#123; if (response != null) &#123; logger.info(String.format("code:%s, msg:%s", response.getCode(), response.getMsg())); if (StringUtils.isNotEmpty(response.getSubCode())) &#123; logger.info(String.format("subCode:%s, subMsg:%s", response.getSubCode(), response.getSubMsg())); &#125; logger.info("body:" + response.getBody()); &#125; &#125; /** * 支付宝回调 * @param params * @return */ public ServerResponse alipayCallback(Map&lt;String,String&gt; params)&#123; Long orderNo = Long.parseLong(params.get("out_trade_no"));//支付前的订单号 String tradeNo = params.get("trade_no");//支付交易号，28位 String traceStatus = params.get("trade_status"); Order order = orderMapper.selectByOrderNo(orderNo); if(order==null)&#123; return ServerResponse.createByErrorMessage("非使用订单，请忽略"); &#125; if(order.getStatus()&gt;= Const.OrderStatusEnum.PAID.getCode())&#123; return ServerResponse.createBySuccess("支付宝重新调用"); &#125; if(Const.AlipayCallback.TRADE_STATUS_TRADE_SUCCESS.equals(traceStatus))&#123; order.setStatus(Const.OrderStatusEnum.PAID.getCode()); order.setPaymentTime(DateTimeUtil.strToDateByStandard(params.get("gmt_payment"))); orderMapper.updateByPrimaryKeySelective(order); &#125; PayInfo payInfo = new PayInfo(); payInfo.setUserId(order.getUserId()); payInfo.setOrderNo(order.getOrderNo()); payInfo.setPayPlatform(Const.PayPlatformEnum.ALIPAY.getCode()); payInfo.setPlatformNumber(tradeNo); payInfo.setPlatformStatus(traceStatus); payInfoMapper.insert(payInfo); return ServerResponse.createBySuccess(); &#125; public ServerResponse queryOrderPayStatus(Integer userId,Long orderNo)&#123; Order order = orderMapper.selectByUserIdAndOrderNo(userId,orderNo); if(order==null)&#123; return ServerResponse.createByErrorMessage("用户没有该订单"); &#125; if(order.getStatus()&gt;=Const.OrderStatusEnum.PAID.getCode())&#123; return ServerResponse.createBySuccess(); &#125; return ServerResponse.createByError(); &#125;&#125; DaoInterface(OrderMapper)12345678910111213141516171819202122package com.mmall.dao;import com.mmall.pojo.Order;import org.apache.ibatis.annotations.Param;public interface OrderMapper &#123; int deleteByPrimaryKey(Integer id); int insert(Order record); int insertSelective(Order record); Order selectByPrimaryKey(Integer id); int updateByPrimaryKeySelective(Order record); int updateByPrimaryKey(Order record); Order selectByUserIdAndOrderNo(@Param("userId") Integer userId,@Param("orderNo")Long orderNo); Order selectByOrderNo(Long orderNo);&#125; Impl(OrderMapper)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.mmall.dao.OrderMapper" &gt; &lt;resultMap id="BaseResultMap" type="com.mmall.pojo.Order" &gt; &lt;constructor &gt; &lt;idArg column="id" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="order_no" jdbcType="BIGINT" javaType="java.lang.Long" /&gt; &lt;arg column="user_id" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="shipping_id" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="payment" jdbcType="DECIMAL" javaType="java.math.BigDecimal" /&gt; &lt;arg column="payment_type" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="postage" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="status" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="payment_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;arg column="send_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;arg column="end_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;arg column="close_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;arg column="create_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;arg column="update_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;/constructor&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List" &gt; id, order_no, user_id, shipping_id, payment, payment_type, postage, status, payment_time, send_time, end_time, close_time, create_time, update_time &lt;/sql&gt; &lt;select id="selectByPrimaryKey" resultMap="BaseResultMap" parameterType="java.lang.Integer" &gt; select &lt;include refid="Base_Column_List" /&gt; from mmall_order where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;delete id="deleteByPrimaryKey" parameterType="java.lang.Integer" &gt; delete from mmall_order where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/delete&gt; &lt;insert id="insert" parameterType="com.mmall.pojo.Order" &gt; insert into mmall_order (id, order_no, user_id, shipping_id, payment, payment_type, postage, status, payment_time, send_time, end_time, close_time, create_time, update_time) values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;orderNo,jdbcType=BIGINT&#125;, #&#123;userId,jdbcType=INTEGER&#125;, #&#123;shippingId,jdbcType=INTEGER&#125;, #&#123;payment,jdbcType=DECIMAL&#125;, #&#123;paymentType,jdbcType=INTEGER&#125;, #&#123;postage,jdbcType=INTEGER&#125;, #&#123;status,jdbcType=INTEGER&#125;, #&#123;paymentTime,jdbcType=TIMESTAMP&#125;, #&#123;sendTime,jdbcType=TIMESTAMP&#125;, #&#123;endTime,jdbcType=TIMESTAMP&#125;, #&#123;closeTime,jdbcType=TIMESTAMP&#125;, now(), now()) &lt;/insert&gt; &lt;insert id="insertSelective" parameterType="com.mmall.pojo.Order" &gt; insert into mmall_order &lt;trim prefix="(" suffix=")" suffixOverrides="," &gt; &lt;if test="id != null" &gt; id, &lt;/if&gt; &lt;if test="orderNo != null" &gt; order_no, &lt;/if&gt; &lt;if test="userId != null" &gt; user_id, &lt;/if&gt; &lt;if test="shippingId != null" &gt; shipping_id, &lt;/if&gt; &lt;if test="payment != null" &gt; payment, &lt;/if&gt; &lt;if test="paymentType != null" &gt; payment_type, &lt;/if&gt; &lt;if test="postage != null" &gt; postage, &lt;/if&gt; &lt;if test="status != null" &gt; status, &lt;/if&gt; &lt;if test="paymentTime != null" &gt; payment_time, &lt;/if&gt; &lt;if test="sendTime != null" &gt; send_time, &lt;/if&gt; &lt;if test="endTime != null" &gt; end_time, &lt;/if&gt; &lt;if test="closeTime != null" &gt; close_time, &lt;/if&gt; &lt;if test="createTime != null" &gt; create_time, &lt;/if&gt; &lt;if test="updateTime != null" &gt; update_time, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides="," &gt; &lt;if test="id != null" &gt; #&#123;id,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="orderNo != null" &gt; #&#123;orderNo,jdbcType=BIGINT&#125;, &lt;/if&gt; &lt;if test="userId != null" &gt; #&#123;userId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="shippingId != null" &gt; #&#123;shippingId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="payment != null" &gt; #&#123;payment,jdbcType=DECIMAL&#125;, &lt;/if&gt; &lt;if test="paymentType != null" &gt; #&#123;paymentType,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="postage != null" &gt; #&#123;postage,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="status != null" &gt; #&#123;status,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="paymentTime != null" &gt; #&#123;paymentTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="sendTime != null" &gt; #&#123;sendTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="endTime != null" &gt; #&#123;endTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="closeTime != null" &gt; #&#123;closeTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="createTime != null" &gt; now(), &lt;/if&gt; &lt;if test="updateTime != null" &gt; now(), &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id="updateByPrimaryKeySelective" parameterType="com.mmall.pojo.Order" &gt; update mmall_order &lt;set &gt; &lt;if test="orderNo != null" &gt; order_no = #&#123;orderNo,jdbcType=BIGINT&#125;, &lt;/if&gt; &lt;if test="userId != null" &gt; user_id = #&#123;userId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="shippingId != null" &gt; shipping_id = #&#123;shippingId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="payment != null" &gt; payment = #&#123;payment,jdbcType=DECIMAL&#125;, &lt;/if&gt; &lt;if test="paymentType != null" &gt; payment_type = #&#123;paymentType,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="postage != null" &gt; postage = #&#123;postage,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="status != null" &gt; status = #&#123;status,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="paymentTime != null" &gt; payment_time = #&#123;paymentTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="sendTime != null" &gt; send_time = #&#123;sendTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="endTime != null" &gt; end_time = #&#123;endTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="closeTime != null" &gt; close_time = #&#123;closeTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="createTime != null" &gt; create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="updateTime != null" &gt; update_time = now(), &lt;/if&gt; &lt;/set&gt; where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;update id="updateByPrimaryKey" parameterType="com.mmall.pojo.Order" &gt; update mmall_order set order_no = #&#123;orderNo,jdbcType=BIGINT&#125;, user_id = #&#123;userId,jdbcType=INTEGER&#125;, shipping_id = #&#123;shippingId,jdbcType=INTEGER&#125;, payment = #&#123;payment,jdbcType=DECIMAL&#125;, payment_type = #&#123;paymentType,jdbcType=INTEGER&#125;, postage = #&#123;postage,jdbcType=INTEGER&#125;, status = #&#123;status,jdbcType=INTEGER&#125;, payment_time = #&#123;paymentTime,jdbcType=TIMESTAMP&#125;, send_time = #&#123;sendTime,jdbcType=TIMESTAMP&#125;, end_time = #&#123;endTime,jdbcType=TIMESTAMP&#125;, close_time = #&#123;closeTime,jdbcType=TIMESTAMP&#125;, create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;, update_time = now() where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;select id="selectByUserIdAndOrderNo" parameterType="map" resultMap="BaseResultMap"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_order WHERE order_no=#&#123;orderNo&#125; AND user_id=#&#123;userId&#125; &lt;/select&gt; &lt;select id="selectByOrderNo" parameterType="long" resultMap="BaseResultMap"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_order WHERE order_no=#&#123;orderNo&#125; &lt;/select&gt;&lt;/mapper&gt; Interface(OrderItemMapper)12345678910111213141516171819202122package com.mmall.dao;import com.mmall.pojo.OrderItem;import org.apache.ibatis.annotations.Param;import java.util.List;public interface OrderItemMapper &#123; int deleteByPrimaryKey(Integer id); int insert(OrderItem record); int insertSelective(OrderItem record); OrderItem selectByPrimaryKey(Integer id); int updateByPrimaryKeySelective(OrderItem record); int updateByPrimaryKey(OrderItem record); List&lt;OrderItem&gt; getByOrderNoAndUserId(@Param("orderNo") Long orderNo,@Param("uderId") Integer userId);&#125; Impl(OrderItemMapper)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.mmall.dao.OrderItemMapper" &gt; &lt;resultMap id="BaseResultMap" type="com.mmall.pojo.OrderItem" &gt; &lt;constructor &gt; &lt;idArg column="id" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="user_id" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="order_no" jdbcType="BIGINT" javaType="java.lang.Long" /&gt; &lt;arg column="product_id" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="product_name" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="product_image" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="current_unit_price" jdbcType="DECIMAL" javaType="java.math.BigDecimal" /&gt; &lt;arg column="quantity" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="total_price" jdbcType="DECIMAL" javaType="java.math.BigDecimal" /&gt; &lt;arg column="create_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;arg column="update_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;/constructor&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List" &gt; id, user_id, order_no, product_id, product_name, product_image, current_unit_price, quantity, total_price, create_time, update_time &lt;/sql&gt; &lt;select id="selectByPrimaryKey" resultMap="BaseResultMap" parameterType="java.lang.Integer" &gt; select &lt;include refid="Base_Column_List" /&gt; from mmall_order_item where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;delete id="deleteByPrimaryKey" parameterType="java.lang.Integer" &gt; delete from mmall_order_item where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/delete&gt; &lt;insert id="insert" parameterType="com.mmall.pojo.OrderItem" &gt; insert into mmall_order_item (id, user_id, order_no, product_id, product_name, product_image, current_unit_price, quantity, total_price, create_time, update_time) values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;userId,jdbcType=INTEGER&#125;, #&#123;orderNo,jdbcType=BIGINT&#125;, #&#123;productId,jdbcType=INTEGER&#125;, #&#123;productName,jdbcType=VARCHAR&#125;, #&#123;productImage,jdbcType=VARCHAR&#125;, #&#123;currentUnitPrice,jdbcType=DECIMAL&#125;, #&#123;quantity,jdbcType=INTEGER&#125;, #&#123;totalPrice,jdbcType=DECIMAL&#125;, now(), now()) &lt;/insert&gt; &lt;insert id="insertSelective" parameterType="com.mmall.pojo.OrderItem" &gt; insert into mmall_order_item &lt;trim prefix="(" suffix=")" suffixOverrides="," &gt; &lt;if test="id != null" &gt; id, &lt;/if&gt; &lt;if test="userId != null" &gt; user_id, &lt;/if&gt; &lt;if test="orderNo != null" &gt; order_no, &lt;/if&gt; &lt;if test="productId != null" &gt; product_id, &lt;/if&gt; &lt;if test="productName != null" &gt; product_name, &lt;/if&gt; &lt;if test="productImage != null" &gt; product_image, &lt;/if&gt; &lt;if test="currentUnitPrice != null" &gt; current_unit_price, &lt;/if&gt; &lt;if test="quantity != null" &gt; quantity, &lt;/if&gt; &lt;if test="totalPrice != null" &gt; total_price, &lt;/if&gt; &lt;if test="createTime != null" &gt; create_time, &lt;/if&gt; &lt;if test="updateTime != null" &gt; update_time, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides="," &gt; &lt;if test="id != null" &gt; #&#123;id,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="userId != null" &gt; #&#123;userId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="orderNo != null" &gt; #&#123;orderNo,jdbcType=BIGINT&#125;, &lt;/if&gt; &lt;if test="productId != null" &gt; #&#123;productId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="productName != null" &gt; #&#123;productName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="productImage != null" &gt; #&#123;productImage,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="currentUnitPrice != null" &gt; #&#123;currentUnitPrice,jdbcType=DECIMAL&#125;, &lt;/if&gt; &lt;if test="quantity != null" &gt; #&#123;quantity,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="totalPrice != null" &gt; #&#123;totalPrice,jdbcType=DECIMAL&#125;, &lt;/if&gt; &lt;if test="createTime != null" &gt; now(), &lt;/if&gt; &lt;if test="updateTime != null" &gt; now(), &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id="updateByPrimaryKeySelective" parameterType="com.mmall.pojo.OrderItem" &gt; update mmall_order_item &lt;set &gt; &lt;if test="userId != null" &gt; user_id = #&#123;userId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="orderNo != null" &gt; order_no = #&#123;orderNo,jdbcType=BIGINT&#125;, &lt;/if&gt; &lt;if test="productId != null" &gt; product_id = #&#123;productId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="productName != null" &gt; product_name = #&#123;productName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="productImage != null" &gt; product_image = #&#123;productImage,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="currentUnitPrice != null" &gt; current_unit_price = #&#123;currentUnitPrice,jdbcType=DECIMAL&#125;, &lt;/if&gt; &lt;if test="quantity != null" &gt; quantity = #&#123;quantity,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="totalPrice != null" &gt; total_price = #&#123;totalPrice,jdbcType=DECIMAL&#125;, &lt;/if&gt; &lt;if test="createTime != null" &gt; create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="updateTime != null" &gt; update_time = now(), &lt;/if&gt; &lt;/set&gt; where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;update id="updateByPrimaryKey" parameterType="com.mmall.pojo.OrderItem" &gt; update mmall_order_item set user_id = #&#123;userId,jdbcType=INTEGER&#125;, order_no = #&#123;orderNo,jdbcType=BIGINT&#125;, product_id = #&#123;productId,jdbcType=INTEGER&#125;, product_name = #&#123;productName,jdbcType=VARCHAR&#125;, product_image = #&#123;productImage,jdbcType=VARCHAR&#125;, current_unit_price = #&#123;currentUnitPrice,jdbcType=DECIMAL&#125;, quantity = #&#123;quantity,jdbcType=INTEGER&#125;, total_price = #&#123;totalPrice,jdbcType=DECIMAL&#125;, create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;, update_time = now() where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;select id="getByOrderNoAndUserId" resultMap="BaseResultMap" parameterType="map"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_order_item WHERE order_no=#&#123;orderNo&#125; AND user_id=#&#123;uderId&#125; &lt;/select&gt;&lt;/mapper&gt; NATAPPhttp://blemon.s1.natapp.cc natapp -authtoken=8217bd565693304b]]></content>
      <categories>
        <category>mmall</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收货地址模块]]></title>
    <url>%2F2018%2F03%2F08%2F%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[功能介绍添加地址、删除地址、更新地址、地址列表、地址分页、地址详情 学习目标1. SpringMVC数据绑定中对象绑定 2. MyBatis自动生成主键、配置和使用 3. 如何避免横向越权漏洞的巩固 增加收货地址Controller1234567891011121314151617181920212223@Controller@RequestMapping("/shipping/")public class ShippingController &#123; @Autowired private IShippingService iShippingService; /** * 添加地址 * @param session * @param shipping * @return */ @RequestMapping(value = "add.do",method = RequestMethod.POST) @ResponseBody public ServerResponse add(HttpSession session, Shipping shipping)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iShippingService.add(user.getId(),shipping); &#125;&#125; ServiceInterface1ServerResponse add(Integer userId, Shipping shipping); Impl123456789101112131415161718@Service("iShippingService")public class ShippingServiceImpl implements IShippingService&#123; @Autowired private ShippingMapper shippingMapper; public ServerResponse add(Integer userId, Shipping shipping)&#123; shipping.setUserId(userId); int rowCount = shippingMapper.insert(shipping); if (rowCount&gt;0)&#123; Map&lt;String,Integer&gt; result =new HashMap&lt;&gt;(); result.put("shippingId",shipping.getId()); return ServerResponse.createBySuccess("create address success",result); &#125; return ServerResponse.createByErrorMessage("create address fail"); &#125;&#125; DaoInterface因为要在插入后直接在对象中直接插入id，从而返回给前台，需要修改Mybatis自动生成的SQL 1int insert(Shipping record); Impl123456789101112&lt;insert id="insert" parameterType="com.mmall.pojo.Shipping" useGeneratedKeys="true" keyProperty="id"&gt; insert into mmall_shipping (id, user_id, receiver_name, receiver_phone, receiver_mobile, receiver_province, receiver_city, receiver_district, receiver_address, receiver_zip, create_time, update_time ) values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;userId,jdbcType=INTEGER&#125;, #&#123;receiverName,jdbcType=VARCHAR&#125;, #&#123;receiverPhone,jdbcType=VARCHAR&#125;, #&#123;receiverMobile,jdbcType=VARCHAR&#125;, #&#123;receiverProvince,jdbcType=VARCHAR&#125;, #&#123;receiverCity,jdbcType=VARCHAR&#125;, #&#123;receiverDistrict,jdbcType=VARCHAR&#125;, #&#123;receiverAddress,jdbcType=VARCHAR&#125;, #&#123;receiverZip,jdbcType=VARCHAR&#125;, now(), now() ) &lt;/insert&gt; 删除地址Controller12345678910111213141516/** * 删除地址 * @param session * @param shippingId * @return */@RequestMapping(value = "delete.do",method = RequestMethod.POST)@ResponseBodypublic ServerResponse delete(HttpSession session, Integer shippingId) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iShippingService.delete(user.getId(), shippingId);&#125; ServiceInterface1ServerResponse delete(Integer userId, Integer shippingId); Impl1234567public ServerResponse delete(Integer userId, Integer shippingId)&#123; int rowCount = shippingMapper.deleteByUserIdShippingId(userId,shippingId); if (rowCount&gt;0)&#123; return ServerResponse.createBySuccess("delete address success"); &#125; return ServerResponse.createByErrorMessage("delete address fail");&#125; DaoInterface1int deleteByUserIdShippingId(@Param("userId") Integer userId, @Param("shippingId")Integer shippingId); Impl12345&lt;delete id="deleteByUserIdShippingId" parameterType="map"&gt; DELETE FROM mmall_shipping WHERE id=#&#123;shippingId&#125; AND user_id=#&#123;userId&#125;&lt;/delete&gt; 修改地址Controller12345678910111213141516/** * 改变地址 * @param session * @param shipping * @return */@RequestMapping(value = "update.do",method = RequestMethod.POST)@ResponseBodypublic ServerResponse update(HttpSession session, Shipping shipping) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iShippingService.update(user.getId(), shipping);&#125; ServiceInterface1ServerResponse update(Integer userId, Shipping shipping); Impl12345678public ServerResponse update(Integer userId, Shipping shipping)&#123; shipping.setUserId(userId); int rowCount = shippingMapper.updateByShipping(shipping); if (rowCount&gt;0)&#123; return ServerResponse.createBySuccess("update address success"); &#125; return ServerResponse.createByErrorMessage("update address fail");&#125; DaoInterface1int updateByShipping(Shipping record); Impl123456789101112131415&lt;update id="updateByShipping" parameterType="com.mmall.pojo.Shipping" &gt; update mmall_shipping set receiver_name = #&#123;receiverName,jdbcType=VARCHAR&#125;, receiver_phone = #&#123;receiverPhone,jdbcType=VARCHAR&#125;, receiver_mobile = #&#123;receiverMobile,jdbcType=VARCHAR&#125;, receiver_province = #&#123;receiverProvince,jdbcType=VARCHAR&#125;, receiver_city = #&#123;receiverCity,jdbcType=VARCHAR&#125;, receiver_district = #&#123;receiverDistrict,jdbcType=VARCHAR&#125;, receiver_address = #&#123;receiverAddress,jdbcType=VARCHAR&#125;, receiver_zip = #&#123;receiverZip,jdbcType=VARCHAR&#125;, update_time = now() where id = #&#123;id,jdbcType=INTEGER&#125; and user_id = #&#123;userId,jdbcType=INTEGER&#125;&lt;/update&gt; 根据收货地址Id查找地址信息Controller12345678910111213141516/** * 查询收货地址 * @param session * @param shippingId * @return */@RequestMapping(value = "select.do",method = RequestMethod.POST)@ResponseBodypublic ServerResponse&lt;Shipping&gt; select(HttpSession session, Integer shippingId) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iShippingService.select(user.getId(), shippingId);&#125; ServiceInterface1ServerResponse&lt;Shipping&gt; select(Integer userId, Integer shippingId); Impl1234567public ServerResponse&lt;Shipping&gt; select(Integer userId, Integer shippingId)&#123; Shipping shipping = shippingMapper.selectByUserIdShippingId(userId,shippingId); if (shipping==null)&#123; return ServerResponse.createByErrorMessage("select address fail"); &#125; return ServerResponse.createBySuccess("select address success",shipping);&#125; DaoInterface1Shipping selectByUserIdShippingId(@Param("userId") Integer userId, @Param("shippingId")Integer shippingId); Impl1234567&lt;select id="selectByUserIdShippingId" parameterType="map" resultMap="BaseResultMap"&gt; select &lt;include refid="Base_Column_List" /&gt; from mmall_shipping where id = #&#123;shippingId&#125; and user_id=#&#123;userId&#125;&lt;/select&gt; 根据用户Id查询用户所有的收货地址（分页）Controller12345678910111213141516171819/** * 查询登陆用户所有收货地址 * @param session * @param pageNum * @param pageSize * @return */@RequestMapping(value = "list.do",method = RequestMethod.POST)@ResponseBodypublic ServerResponse&lt;PageInfo&gt; list(HttpSession session, @RequestParam(value = "pageNum",defaultValue = "1")Integer pageNum, @RequestParam(value = "pageSize",defaultValue = "10")Integer pageSize) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iShippingService.list(user.getId(),pageNum,pageSize);&#125; ServiceInterface1ServerResponse&lt;PageInfo&gt; list(Integer userId, Integer pageNum, Integer pageSize); Impl123456public ServerResponse&lt;PageInfo&gt; list(Integer userId, Integer pageNum,Integer pageSize)&#123; PageHelper.startPage(pageNum,pageSize); List&lt;Shipping&gt; shippingList = shippingMapper.selectByUserId(userId); PageInfo pageResult = new PageInfo(shippingList); return ServerResponse.createBySuccess(pageResult); &#125; DaoInterface1List&lt;Shipping&gt; selectByUserId(Integer userId); Impl123456&lt;select id="selectByUserId" parameterType="int" resultMap="BaseResultMap"&gt; select &lt;include refid="Base_Column_List" /&gt; from mmall_shipping where user_id=#&#123;userId&#125;&lt;/select&gt; 测试 整体Controller123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package com.mmall.controller.portal;import com.github.pagehelper.PageInfo;import com.mmall.common.Const;import com.mmall.common.ResponseCode;import com.mmall.common.ServerResponse;import com.mmall.pojo.Shipping;import com.mmall.pojo.User;import com.mmall.service.IShippingService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpSession;/** * Created by Blemon on 2018/3/7. */@Controller@RequestMapping("/shipping/")public class ShippingController &#123; @Autowired private IShippingService iShippingService; /** * 添加地址 * @param session * @param shipping * @return */ @RequestMapping(value = "add.do",method = RequestMethod.POST) @ResponseBody public ServerResponse add(HttpSession session, Shipping shipping)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iShippingService.add(user.getId(),shipping); &#125; /** * 删除地址 * @param session * @param shippingId * @return */ @RequestMapping(value = "delete.do",method = RequestMethod.POST) @ResponseBody public ServerResponse delete(HttpSession session, Integer shippingId) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iShippingService.delete(user.getId(), shippingId); &#125; /** * 改变地址 * @param session * @param shipping * @return */ @RequestMapping(value = "update.do",method = RequestMethod.POST) @ResponseBody public ServerResponse update(HttpSession session, Shipping shipping) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iShippingService.update(user.getId(), shipping); &#125; /** * 查询收货地址 * @param session * @param shippingId * @return */ @RequestMapping(value = "select.do",method = RequestMethod.POST) @ResponseBody public ServerResponse&lt;Shipping&gt; select(HttpSession session, Integer shippingId) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iShippingService.select(user.getId(), shippingId); &#125; /** * 查询登陆用户所有收货地址 * @param session * @param pageNum * @param pageSize * @return */ @RequestMapping(value = "list.do",method = RequestMethod.POST) @ResponseBody public ServerResponse&lt;PageInfo&gt; list(HttpSession session, @RequestParam(value = "pageNum",defaultValue = "1")Integer pageNum, @RequestParam(value = "pageSize",defaultValue = "10")Integer pageSize) &#123; User user = (User) session.getAttribute(Const.CURRENT_USER); if (user == null) &#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iShippingService.list(user.getId(),pageNum,pageSize); &#125;&#125; ServiceInterface1234567891011121314151617181920package com.mmall.service;import com.github.pagehelper.PageInfo;import com.mmall.common.ServerResponse;import com.mmall.pojo.Shipping;/** * Created by Blemon on 2018/3/7. */public interface IShippingService &#123; ServerResponse add(Integer userId, Shipping shipping); ServerResponse delete(Integer userId, Integer shippingId); ServerResponse update(Integer userId, Shipping shipping); ServerResponse&lt;Shipping&gt; select(Integer userId, Integer shippingId); ServerResponse&lt;PageInfo&gt; list(Integer userId, Integer pageNum, Integer pageSize);&#125; Impl1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.mmall.service.impl;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import com.mmall.common.ServerResponse;import com.mmall.dao.ShippingMapper;import com.mmall.pojo.Shipping;import com.mmall.service.IShippingService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Created by Blemon on 2018/3/7. */@Service("iShippingService")public class ShippingServiceImpl implements IShippingService&#123; @Autowired private ShippingMapper shippingMapper; public ServerResponse add(Integer userId, Shipping shipping)&#123; shipping.setUserId(userId); int rowCount = shippingMapper.insert(shipping); if (rowCount&gt;0)&#123; Map&lt;String,Integer&gt; result =new HashMap&lt;&gt;(); result.put("shippingId",shipping.getId()); return ServerResponse.createBySuccess("create address success",result); &#125; return ServerResponse.createByErrorMessage("create address fail"); &#125; public ServerResponse delete(Integer userId, Integer shippingId)&#123; int rowCount = shippingMapper.deleteByUserIdShippingId(userId,shippingId); if (rowCount&gt;0)&#123; return ServerResponse.createBySuccess("delete address success"); &#125; return ServerResponse.createByErrorMessage("delete address fail"); &#125; public ServerResponse update(Integer userId, Shipping shipping)&#123; shipping.setUserId(userId); int rowCount = shippingMapper.updateByShipping(shipping); if (rowCount&gt;0)&#123; return ServerResponse.createBySuccess("update address success"); &#125; return ServerResponse.createByErrorMessage("update address fail"); &#125; public ServerResponse&lt;Shipping&gt; select(Integer userId, Integer shippingId)&#123; Shipping shipping = shippingMapper.selectByUserIdShippingId(userId,shippingId); if (shipping==null)&#123; return ServerResponse.createByErrorMessage("select address fail"); &#125; return ServerResponse.createBySuccess("select address success",shipping); &#125; public ServerResponse&lt;PageInfo&gt; list(Integer userId, Integer pageNum,Integer pageSize)&#123; PageHelper.startPage(pageNum,pageSize); List&lt;Shipping&gt; shippingList = shippingMapper.selectByUserId(userId); PageInfo pageResult = new PageInfo(shippingList); return ServerResponse.createBySuccess(pageResult); &#125;&#125; DaoInterface12345678910111213141516171819202122232425262728package com.mmall.dao;import com.mmall.pojo.Shipping;import org.apache.ibatis.annotations.Param;import java.util.List;public interface ShippingMapper &#123; int deleteByPrimaryKey(Integer id); int insert(Shipping record); int insertSelective(Shipping record); Shipping selectByPrimaryKey(Integer id); int updateByPrimaryKeySelective(Shipping record); int updateByPrimaryKey(Shipping record); int deleteByUserIdShippingId(@Param("userId") Integer userId, @Param("shippingId")Integer shippingId); int updateByShipping(Shipping record); Shipping selectByUserIdShippingId(@Param("userId") Integer userId, @Param("shippingId")Integer shippingId); List&lt;Shipping&gt; selectByUserId(Integer userId);&#125; Impl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.mmall.dao.ShippingMapper" &gt; &lt;resultMap id="BaseResultMap" type="com.mmall.pojo.Shipping" &gt; &lt;constructor &gt; &lt;idArg column="id" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="user_id" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="receiver_name" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="receiver_phone" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="receiver_mobile" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="receiver_province" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="receiver_city" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="receiver_district" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="receiver_address" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="receiver_zip" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="create_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;arg column="update_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;/constructor&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List" &gt; id, user_id, receiver_name, receiver_phone, receiver_mobile, receiver_province, receiver_city, receiver_district, receiver_address, receiver_zip, create_time, update_time &lt;/sql&gt; &lt;select id="selectByPrimaryKey" resultMap="BaseResultMap" parameterType="java.lang.Integer" &gt; select &lt;include refid="Base_Column_List" /&gt; from mmall_shipping where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;delete id="deleteByPrimaryKey" parameterType="java.lang.Integer" &gt; delete from mmall_shipping where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/delete&gt; &lt;insert id="insert" parameterType="com.mmall.pojo.Shipping" useGeneratedKeys="true" keyProperty="id"&gt; insert into mmall_shipping (id, user_id, receiver_name, receiver_phone, receiver_mobile, receiver_province, receiver_city, receiver_district, receiver_address, receiver_zip, create_time, update_time ) values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;userId,jdbcType=INTEGER&#125;, #&#123;receiverName,jdbcType=VARCHAR&#125;, #&#123;receiverPhone,jdbcType=VARCHAR&#125;, #&#123;receiverMobile,jdbcType=VARCHAR&#125;, #&#123;receiverProvince,jdbcType=VARCHAR&#125;, #&#123;receiverCity,jdbcType=VARCHAR&#125;, #&#123;receiverDistrict,jdbcType=VARCHAR&#125;, #&#123;receiverAddress,jdbcType=VARCHAR&#125;, #&#123;receiverZip,jdbcType=VARCHAR&#125;, now(), now() ) &lt;/insert&gt; &lt;insert id="insertSelective" parameterType="com.mmall.pojo.Shipping" &gt; insert into mmall_shipping &lt;trim prefix="(" suffix=")" suffixOverrides="," &gt; &lt;if test="id != null" &gt; id, &lt;/if&gt; &lt;if test="userId != null" &gt; user_id, &lt;/if&gt; &lt;if test="receiverName != null" &gt; receiver_name, &lt;/if&gt; &lt;if test="receiverPhone != null" &gt; receiver_phone, &lt;/if&gt; &lt;if test="receiverMobile != null" &gt; receiver_mobile, &lt;/if&gt; &lt;if test="receiverProvince != null" &gt; receiver_province, &lt;/if&gt; &lt;if test="receiverCity != null" &gt; receiver_city, &lt;/if&gt; &lt;if test="receiverDistrict != null" &gt; receiver_district, &lt;/if&gt; &lt;if test="receiverAddress != null" &gt; receiver_address, &lt;/if&gt; &lt;if test="receiverZip != null" &gt; receiver_zip, &lt;/if&gt; &lt;if test="createTime != null" &gt; create_time, &lt;/if&gt; &lt;if test="updateTime != null" &gt; update_time, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides="," &gt; &lt;if test="id != null" &gt; #&#123;id,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="userId != null" &gt; #&#123;userId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="receiverName != null" &gt; #&#123;receiverName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="receiverPhone != null" &gt; #&#123;receiverPhone,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="receiverMobile != null" &gt; #&#123;receiverMobile,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="receiverProvince != null" &gt; #&#123;receiverProvince,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="receiverCity != null" &gt; #&#123;receiverCity,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="receiverDistrict != null" &gt; #&#123;receiverDistrict,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="receiverAddress != null" &gt; #&#123;receiverAddress,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="receiverZip != null" &gt; #&#123;receiverZip,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="createTime != null" &gt; now(), &lt;/if&gt; &lt;if test="updateTime != null" &gt; now(), &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id="updateByPrimaryKeySelective" parameterType="com.mmall.pojo.Shipping" &gt; update mmall_shipping &lt;set &gt; &lt;if test="userId != null" &gt; user_id = #&#123;userId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="receiverName != null" &gt; receiver_name = #&#123;receiverName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="receiverPhone != null" &gt; receiver_phone = #&#123;receiverPhone,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="receiverMobile != null" &gt; receiver_mobile = #&#123;receiverMobile,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="receiverProvince != null" &gt; receiver_province = #&#123;receiverProvince,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="receiverCity != null" &gt; receiver_city = #&#123;receiverCity,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="receiverDistrict != null" &gt; receiver_district = #&#123;receiverDistrict,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="receiverAddress != null" &gt; receiver_address = #&#123;receiverAddress,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="receiverZip != null" &gt; receiver_zip = #&#123;receiverZip,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="createTime != null" &gt; create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="updateTime != null" &gt; update_time = now(), &lt;/if&gt; &lt;/set&gt; where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;update id="updateByPrimaryKey" parameterType="com.mmall.pojo.Shipping" &gt; update mmall_shipping set user_id = #&#123;userId,jdbcType=INTEGER&#125;, receiver_name = #&#123;receiverName,jdbcType=VARCHAR&#125;, receiver_phone = #&#123;receiverPhone,jdbcType=VARCHAR&#125;, receiver_mobile = #&#123;receiverMobile,jdbcType=VARCHAR&#125;, receiver_province = #&#123;receiverProvince,jdbcType=VARCHAR&#125;, receiver_city = #&#123;receiverCity,jdbcType=VARCHAR&#125;, receiver_district = #&#123;receiverDistrict,jdbcType=VARCHAR&#125;, receiver_address = #&#123;receiverAddress,jdbcType=VARCHAR&#125;, receiver_zip = #&#123;receiverZip,jdbcType=VARCHAR&#125;, create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;, update_time = now() where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;delete id="deleteByUserIdShippingId" parameterType="map"&gt; DELETE FROM mmall_shipping WHERE id=#&#123;shippingId&#125; AND user_id=#&#123;userId&#125; &lt;/delete&gt; &lt;update id="updateByShipping" parameterType="com.mmall.pojo.Shipping" &gt; update mmall_shipping set receiver_name = #&#123;receiverName,jdbcType=VARCHAR&#125;, receiver_phone = #&#123;receiverPhone,jdbcType=VARCHAR&#125;, receiver_mobile = #&#123;receiverMobile,jdbcType=VARCHAR&#125;, receiver_province = #&#123;receiverProvince,jdbcType=VARCHAR&#125;, receiver_city = #&#123;receiverCity,jdbcType=VARCHAR&#125;, receiver_district = #&#123;receiverDistrict,jdbcType=VARCHAR&#125;, receiver_address = #&#123;receiverAddress,jdbcType=VARCHAR&#125;, receiver_zip = #&#123;receiverZip,jdbcType=VARCHAR&#125;, update_time = now() where id = #&#123;id,jdbcType=INTEGER&#125; and user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;select id="selectByUserIdShippingId" parameterType="map" resultMap="BaseResultMap"&gt; select &lt;include refid="Base_Column_List" /&gt; from mmall_shipping where id = #&#123;shippingId&#125; and user_id=#&#123;userId&#125; &lt;/select&gt; &lt;select id="selectByUserId" parameterType="int" resultMap="BaseResultMap"&gt; select &lt;include refid="Base_Column_List" /&gt; from mmall_shipping where user_id=#&#123;userId&#125; &lt;/select&gt;&lt;/mapper&gt;]]></content>
      <categories>
        <category>mmall</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[购物车模块]]></title>
    <url>%2F2018%2F03%2F07%2F%E8%B4%AD%E7%89%A9%E8%BD%A6%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[功能介绍加入商品、更新商品数、查询商品数、移除商品、单选/取消、 全选/取消 购物车列表 添加到购物车Controller12345678910111213141516171819202122232425262728/** * Created by Blemon on 2018/3/6. */@Controller@RequestMapping("/cart/")public class CartController &#123; @Autowired private ICartService iCartService; /** * 添加用户 * @param session * @param count * @param productId * @return */ @RequestMapping(value = "add.do",method = RequestMethod.POST) @ResponseBody public ServerResponse&lt;CartVo&gt; add(HttpSession session, Integer count, Integer productId)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iCartService.add(user.getId(),productId,count); &#125;&#125; ServiceInterface123456/** * Created by Blemon on 2018/3/6. */public interface ICartService &#123; ServerResponse&lt;CartVo&gt; add(Integer userId, Integer productId, Integer count);&#125; Impl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * Created by Blemon on 2018/3/6. */@Service("iCartService")public class CartServiceImpl implements ICartService&#123; @Autowired private CartMapper cartMapper; @Autowired private ProductMapper productMapper; public ServerResponse&lt;CartVo&gt; add(Integer userId, Integer productId, Integer count)&#123; if(userId==null||productId==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.ILLEGAL_ARGUMENT.getCode(), ResponseCode.ILLEGAL_ARGUMENT.getDesc()); &#125; Cart cart = cartMapper.selectCartByUserIdProductId(userId, productId); int rowResult; if(cart==null)&#123; //这个产品不在这个用户的某个购物车对象中,需要新增 Cart cartItem = new Cart(); cartItem.setChecked(Const.Cart_.CHECKED); cartItem.setQuantity(count); cartItem.setProductId(productId); cartItem.setUserId(userId); rowResult= cartMapper.insert(cartItem); if(rowResult==0)&#123; return ServerResponse.createByErrorMessage("add to cart fail"); &#125; &#125;else&#123; //产品在，更新一个数量就可以了 cart.setQuantity(count+cart.getQuantity()); rowResult=cartMapper.updateByPrimaryKeySelective(cart); if(rowResult==0)&#123; return ServerResponse.createByErrorMessage("add to cart fail"); &#125; &#125; return ServerResponse.createBySuccess(this.getCartVoLimit(userId)); &#125; private CartVo getCartVoLimit(Integer userId)&#123; CartVo cartVo = new CartVo(); List&lt;Cart&gt; cartList = cartMapper.selectCartByUserId(userId); List&lt;CartProductVo&gt; cartProductVoList = Lists.newArrayList(); BigDecimal cartTotalPrice = new BigDecimal("0"); if(CollectionUtils.isNotEmpty(cartList))&#123; for (Cart cartIem:cartList) &#123; CartProductVo cartProductVo = new CartProductVo(); cartProductVo.setId(cartIem.getId()); cartProductVo.setUserId(userId); cartProductVo.setProductId(cartIem.getProductId()); Product product = productMapper.selectByPrimaryKey(cartIem.getProductId()); if(product!=null)&#123; cartProductVo.setProductMainImage(product.getMainImage()); cartProductVo.setProductName(product.getName()); cartProductVo.setProductPrice(product.getPrice()); cartProductVo.setProductStatus(product.getStatus()); cartProductVo.setProductSubtitle(product.getSubtitle()); cartProductVo.setProductStock(product.getStock()); //判断库存 int buyLimitCount = 0; //只有支付了以后产品的库存才会减少，而且cart表中只会出现一条某个用户对应某种商品的cart记录 //这里判断的是这个商品的库存和某个用户这个商品在购物车中需要的个数 //一旦这个用户的这个商品需求大了那么也就只能添加给库存个数 if(product.getStock()&gt;=cartIem.getQuantity())&#123; buyLimitCount = cartIem.getQuantity(); cartProductVo.setLimitQuantity(Const.Cart_.LIMIT_NUM_SUCCESS); &#125;else&#123; buyLimitCount = product.getStock(); cartProductVo.setLimitQuantity(Const.Cart_.LIMIT_NUM_FAIL); //购物车中更新有效库存 Cart cartForQuantity = new Cart(); cartForQuantity.setId(cartIem.getId()); cartForQuantity.setQuantity(buyLimitCount); cartMapper.updateByPrimaryKeySelective(cartForQuantity); &#125; cartProductVo.setQuantity(buyLimitCount); cartProductVo.setProductTotalPrice(BigDecimalUtil.multiply(product.getPrice().doubleValue(), cartProductVo.getQuantity()));//购物车中某一个产品的总价 cartProductVo.setProductChecked(cartIem.getChecked()); &#125; if(cartIem.getChecked()==Const.Cart_.CHECKED)&#123; //已经勾选，增加到我们的总价中 cartTotalPrice = BigDecimalUtil.add(cartTotalPrice.doubleValue(), cartProductVo.getProductTotalPrice().doubleValue()); &#125; cartProductVoList.add(cartProductVo); &#125; &#125; cartVo.setCartTotalPrice(cartTotalPrice); cartVo.setCartProductVosList(cartProductVoList); cartVo.setAllChecked(this.getAllCheckedStatus(userId)); cartVo.setImageHost(PropertiesUtil.getProperty("ftp.server.http.prefix")); return cartVo; &#125; private boolean getAllCheckedStatus(Integer userId)&#123; if (userId==null)&#123; return false; &#125; return cartMapper.selectCartProductCheckedStatusByUserId(userId)==0?true:false; &#125;&#125; voCartProductVo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/** * Created by Blemon on 2018/3/6. * 结合了产品和购物车的一个抽象对象 */public class CartProductVo &#123; private Integer id; private Integer userId; private Integer productId; private Integer quantity; private String productName; private String productSubtitle; private String productMainImage; private BigDecimal productPrice; private Integer productStatus; private BigDecimal productTotalPrice; private Integer productStock; private Integer productChecked; private String limitQuantity;//限制数量的一个返回结果 public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public Integer getProductId() &#123; return productId; &#125; public void setProductId(Integer productId) &#123; this.productId = productId; &#125; public Integer getQuantity() &#123; return quantity; &#125; public void setQuantity(Integer quantity) &#123; this.quantity = quantity; &#125; public String getProductName() &#123; return productName; &#125; public void setProductName(String productName) &#123; this.productName = productName; &#125; public String getProductSubtitle() &#123; return productSubtitle; &#125; public void setProductSubtitle(String productSubtitle) &#123; this.productSubtitle = productSubtitle; &#125; public String getProductMainImage() &#123; return productMainImage; &#125; public void setProductMainImage(String productMainImage) &#123; this.productMainImage = productMainImage; &#125; public BigDecimal getProductPrice() &#123; return productPrice; &#125; public void setProductPrice(BigDecimal productPrice) &#123; this.productPrice = productPrice; &#125; public Integer getProductStatus() &#123; return productStatus; &#125; public void setProductStatus(Integer productStatus) &#123; this.productStatus = productStatus; &#125; public BigDecimal getProductTotalPrice() &#123; return productTotalPrice; &#125; public void setProductTotalPrice(BigDecimal productTotalPrice) &#123; this.productTotalPrice = productTotalPrice; &#125; public Integer getProductStock() &#123; return productStock; &#125; public void setProductStock(Integer productStock) &#123; this.productStock = productStock; &#125; public Integer getProductChecked() &#123; return productChecked; &#125; public void setProductChecked(Integer productChecked) &#123; this.productChecked = productChecked; &#125; public String getLimitQuantity() &#123; return limitQuantity; &#125; public void setLimitQuantity(String limitQuantity) &#123; this.limitQuantity = limitQuantity; &#125;&#125; CartVo1234567891011121314151617181920212223242526272829303132333435363738394041/** * Created by Blemon on 2018/3/6. */public class CartVo &#123; private List&lt;CartProductVo&gt; cartProductVosList; private BigDecimal cartTotalPrice; private Boolean allChecked; private String imageHost; public List&lt;CartProductVo&gt; getCartProductVosList() &#123; return cartProductVosList; &#125; public void setCartProductVosList(List&lt;CartProductVo&gt; cartProductVosList) &#123; this.cartProductVosList = cartProductVosList; &#125; public BigDecimal getCartTotalPrice() &#123; return cartTotalPrice; &#125; public void setCartTotalPrice(BigDecimal cartTotalPrice) &#123; this.cartTotalPrice = cartTotalPrice; &#125; public Boolean getAllChecked() &#123; return allChecked; &#125; public void setAllChecked(Boolean allChecked) &#123; this.allChecked = allChecked; &#125; public String getImageHost() &#123; return imageHost; &#125; public void setImageHost(String imageHost) &#123; this.imageHost = imageHost; &#125;&#125; DaoInterface12345Cart selectCartByUserIdProductId(@Param(value="userId") Integer userId, @Param(value="productId") Integer productId);List&lt;Cart&gt; selectCartByUserId(Integer userId);int selectCartProductCheckedStatusByUserId(Integer userId); Impl123456789101112131415161718&lt;select id="selectCartByUserIdProductId" resultMap="BaseResultMap" parameterType="map"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_cart WHERE user_id=#&#123;userId&#125; AND product_id=#&#123;productId&#125;&lt;/select&gt;&lt;select id="selectCartByUserId" resultMap="BaseResultMap" parameterType="int"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_cart WHERE user_id=#&#123;userId&#125;&lt;/select&gt;&lt;select id="selectCartProductCheckedStatusByUserId" resultType="int" parameterType="int"&gt; SELECT COUNT(1) FROM mmall_cart WHERE checked = 0 AND user_id=#&#123;userId&#125;&lt;/select&gt; 更新用户的购物车Controller123456789101112131415161718/** * 更新购物车 * @param session * @param count * @param productId * @return */@RequestMapping(value = "update.do",method = RequestMethod.POST)@ResponseBodypublic ServerResponse&lt;CartVo&gt; update(HttpSession session, Integer count, Integer productId)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iCartService.update(user.getId(),productId,count);&#125; ServiceInterface1ServerResponse&lt;CartVo&gt; update(Integer userId, Integer productId, Integer count); Impl1234567891011121314public ServerResponse&lt;CartVo&gt; update(Integer userId, Integer productId, Integer count)&#123; if(productId==null||count==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.ILLEGAL_ARGUMENT.getCode(), ResponseCode.ILLEGAL_ARGUMENT.getDesc()); &#125; Cart cart = cartMapper.selectCartByUserIdProductId(userId,productId); if(cart!=null)&#123; cart.setQuantity(count); cartMapper.updateByPrimaryKeySelective(cart); &#125; CartVo cartVo = this.getCartVoLimit(userId); return ServerResponse.createBySuccess(cartVo);&#125; Dao不需要多谢 删除某个商品在购物车中Controller1234567891011121314151617/** * 购物车中删除产品 * @param session * @param productIds * @return */@RequestMapping(value = "delete.do",method = RequestMethod.POST)@ResponseBodypublic ServerResponse&lt;CartVo&gt; delete(HttpSession session,String productIds)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iCartService.delete(user.getId(),productIds);&#125; ServiceInterface1ServerResponse&lt;CartVo&gt; delete(Integer userId, String productIds); Impl1234567891011121314public ServerResponse&lt;CartVo&gt; delete(Integer userId, String productIds)&#123; if(userId==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.ILLEGAL_ARGUMENT.getCode(), ResponseCode.ILLEGAL_ARGUMENT.getDesc()); &#125; List&lt;String&gt; productList = Splitter.on(",").splitToList(productIds); if(CollectionUtils.isEmpty(productList))&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.ILLEGAL_ARGUMENT.getCode(), ResponseCode.ILLEGAL_ARGUMENT.getDesc()); &#125; cartMapper.deleteByUserIdProducts(userId,productList); CartVo cartVo = this.getCartVoLimit(userId); return ServerResponse.createBySuccess(cartVo);&#125; DaoInterface1int deleteByUserIdProducts(@Param(value="userId") Integer userId,@Param(value="productIdList")List&lt;String&gt; productIdList); Impl123456789&lt;delete id="deleteByUserIdProducts" parameterType="map"&gt; DELETE FROM mmall_cart WHERE user_id=#&#123;userId&#125; &lt;if test="productIdList"&gt; &lt;foreach collection="productIdList" index="index" item="item" open="(" close=")" separator=","&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/if&gt;&lt;/delete&gt; 查询某个用户的购物车Controller123456789101112131415/** * 用户的购物车商品 * @param session * @return */@RequestMapping(value = "list.do",method = RequestMethod.POST)@ResponseBodypublic ServerResponse&lt;CartVo&gt; list(HttpSession session)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iCartService.list(user.getId());&#125; ServiceInterface1ServerResponse&lt;CartVo&gt; list(Integer userId); Impl1234public ServerResponse&lt;CartVo&gt; list(Integer userId)&#123; CartVo cartVo = this.getCartVoLimit(userId); return ServerResponse.createBySuccess(cartVo);&#125; Dao不需要多写 全选和全反选Controller1234567891011121314151617181920212223242526/** * 全选/全反选 * @param session * @return */@RequestMapping(value = "select_all.do",method = RequestMethod.POST)@ResponseBodypublic ServerResponse&lt;CartVo&gt; select_all(HttpSession session)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iCartService.selectOrUnSelect(user.getId(),null,Const.Cart_.CHECKED);&#125;@RequestMapping(value = "un_select_all.do",method = RequestMethod.POST)@ResponseBodypublic ServerResponse&lt;CartVo&gt; un_select_all(HttpSession session)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iCartService.selectOrUnSelect(user.getId(),null,Const.Cart_.UN_CHECKED);&#125; ServiceInterface1ServerResponse&lt;CartVo&gt; selectOrUnSelect(Integer userId,Integer productId,Integer checked); Impl1234public ServerResponse&lt;CartVo&gt; selectOrUnSelect(Integer userId,Integer productId,Integer checked)&#123; cartMapper.checkedOrUncheckedAllProduct(userId,productId,checked); return this.list(userId);&#125; DaoInterface12int checkedOrUncheckedAllProduct(@Param(value="userId") Integer userId,@Param(value="productId") Integer productId, @Param(value="checked") Integer checked); Impl123456789&lt;update id="checkedOrUncheckedAllProduct" parameterType="map"&gt; UPDATE mmall_cart SET checked = #&#123;checked&#125;, update_time = now() WHERE user_id=#&#123;userId&#125; &lt;if test="productId!=null"&gt; AND product_id=#&#123;productId&#125; &lt;/if&gt;&lt;/update&gt; 单独选/单独反选Controller123456789101112131415161718192021222324252627/** * 单独选/单独反选 * @param session * @param productId * @return */@RequestMapping(value = "select.do",method = RequestMethod.POST)@ResponseBodypublic ServerResponse&lt;CartVo&gt; select(HttpSession session,Integer productId)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iCartService.selectOrUnSelect(user.getId(),productId,Const.Cart_.CHECKED);&#125;@RequestMapping(value = "un_select.do",method = RequestMethod.POST)@ResponseBodypublic ServerResponse&lt;CartVo&gt; un_select(HttpSession session,Integer productId)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iCartService.selectOrUnSelect(user.getId(),productId,Const.Cart_.UN_CHECKED);&#125; Service/Dao这两层调的和全选/全反选一样。 查询当前用户的购物车里面的产品数量Controller1234567891011121314/** * 查询当前用户的购物车里面的产品数量，如果一个产品有10个，那么数量就是10. * @param session * @return */@RequestMapping(value = "get_cart_product_count.do",method = RequestMethod.POST)@ResponseBodypublic ServerResponse&lt;Integer&gt; un_select(HttpSession session)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createBySuccess(0); &#125; return iCartService.getCartProductCount(user.getId());&#125; ServiceInterface1ServerResponse&lt;Integer&gt; getCartProductCount(Integer userId); Impl123456public ServerResponse&lt;Integer&gt; getCartProductCount(Integer userId)&#123; if(userId==null)&#123; return ServerResponse.createBySuccess(0); &#125; return ServerResponse.createBySuccess(cartMapper.selectCartProductCount(userId));&#125; DaoInterface1int selectCartProductCount(Integer userId); Impl123&lt;select id="selectCartProductCount" parameterType="int" resultType="int"&gt; SELECT IFNULL(SUM(quantity),0) AS COUNT FROM mmall_cart WHERE user_id=#&#123;userId&#125;&lt;/select&gt; 测试 整体Controller123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165package com.mmall.controller.portal;import com.mmall.common.Const;import com.mmall.common.ResponseCode;import com.mmall.common.ServerResponse;import com.mmall.pojo.User;import com.mmall.service.ICartService;import com.mmall.vo.CartVo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpSession;/** * Created by Blemon on 2018/3/6. */@Controller@RequestMapping("/cart/")public class CartController &#123; @Autowired private ICartService iCartService; /** * 用户的购物车商品 * @param session * @return */ @RequestMapping(value = "list.do",method = RequestMethod.POST) @ResponseBody public ServerResponse&lt;CartVo&gt; list(HttpSession session)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iCartService.list(user.getId()); &#125; /** * 添加购物车（某个商品给某个用户的一个购物车Item） * @param session * @param count * @param productId * @return */ @RequestMapping(value = "add.do",method = RequestMethod.POST) @ResponseBody public ServerResponse&lt;CartVo&gt; add(HttpSession session, Integer productId, Integer count)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iCartService.add(user.getId(),productId,count); &#125; /** * 更新购物车 * @param session * @param count * @param productId * @return */ @RequestMapping(value = "update.do",method = RequestMethod.POST) @ResponseBody public ServerResponse&lt;CartVo&gt; update(HttpSession session, Integer count, Integer productId)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iCartService.update(user.getId(),productId,count); &#125; /** * 购物车中删除产品 * @param session * @param productIds * @return */ @RequestMapping(value = "delete.do",method = RequestMethod.POST) @ResponseBody public ServerResponse&lt;CartVo&gt; delete(HttpSession session,String productIds)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iCartService.delete(user.getId(),productIds); &#125; /** * 全选/全反选 * @param session * @return */ @RequestMapping(value = "select_all.do",method = RequestMethod.POST) @ResponseBody public ServerResponse&lt;CartVo&gt; select_all(HttpSession session)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iCartService.selectOrUnSelect(user.getId(),null,Const.Cart_.CHECKED); &#125; @RequestMapping(value = "un_select_all.do",method = RequestMethod.POST) @ResponseBody public ServerResponse&lt;CartVo&gt; un_select_all(HttpSession session)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iCartService.selectOrUnSelect(user.getId(),null,Const.Cart_.UN_CHECKED); &#125; /** * 单独选/单独反选 * @param session * @param productId * @return */ @RequestMapping(value = "select.do",method = RequestMethod.POST) @ResponseBody public ServerResponse&lt;CartVo&gt; select(HttpSession session,Integer productId)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iCartService.selectOrUnSelect(user.getId(),productId,Const.Cart_.CHECKED); &#125; @RequestMapping(value = "un_select.do",method = RequestMethod.POST) @ResponseBody public ServerResponse&lt;CartVo&gt; un_select(HttpSession session,Integer productId)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(), ResponseCode.NEED_LOGIN.getDesc()); &#125; return iCartService.selectOrUnSelect(user.getId(),productId,Const.Cart_.UN_CHECKED); &#125; /** * 查询当前用户的购物车里面的产品数量，如果一个产品有10个，那么数量就是10. * @param session * @return */ @RequestMapping(value = "get_cart_product_count.do",method = RequestMethod.POST) @ResponseBody public ServerResponse&lt;Integer&gt; un_select(HttpSession session)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createBySuccess(0); &#125; return iCartService.getCartProductCount(user.getId()); &#125;&#125; ServiceICartService123456789101112131415161718192021package com.mmall.service;import com.mmall.common.ServerResponse;import com.mmall.vo.CartVo;/** * Created by Blemon on 2018/3/6. */public interface ICartService &#123; ServerResponse&lt;CartVo&gt; list(Integer userId); ServerResponse&lt;CartVo&gt; add(Integer userId, Integer productId, Integer count); ServerResponse&lt;CartVo&gt; update(Integer userId, Integer productId, Integer count); ServerResponse&lt;CartVo&gt; delete(Integer userId, String productIds); ServerResponse&lt;CartVo&gt; selectOrUnSelect(Integer userId,Integer productId,Integer checked); ServerResponse&lt;Integer&gt; getCartProductCount(Integer userId);&#125; Impl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185package com.mmall.service.impl;import com.google.common.base.Splitter;import com.google.common.collect.Lists;import com.mmall.common.Const;import com.mmall.common.ResponseCode;import com.mmall.common.ServerResponse;import com.mmall.dao.CartMapper;import com.mmall.dao.ProductMapper;import com.mmall.pojo.Cart;import com.mmall.pojo.Product;import com.mmall.service.ICartService;import com.mmall.util.BigDecimalUtil;import com.mmall.util.PropertiesUtil;import com.mmall.vo.CartProductVo;import com.mmall.vo.CartVo;import org.apache.commons.collections.CollectionUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.math.BigDecimal;import java.util.List;/** * Created by Blemon on 2018/3/6. */@Service("iCartService")public class CartServiceImpl implements ICartService&#123; @Autowired private CartMapper cartMapper; @Autowired private ProductMapper productMapper; public ServerResponse&lt;CartVo&gt; add(Integer userId, Integer productId, Integer count)&#123; if(userId==null||productId==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.ILLEGAL_ARGUMENT.getCode(), ResponseCode.ILLEGAL_ARGUMENT.getDesc()); &#125; Cart cart = cartMapper.selectCartByUserIdProductId(userId, productId); int rowResult; if(cart==null)&#123; //这个产品不在这个用户的某个购物车对象中,需要新增 Cart cartItem = new Cart(); cartItem.setChecked(Const.Cart_.CHECKED); cartItem.setQuantity(count); cartItem.setProductId(productId); cartItem.setUserId(userId); rowResult= cartMapper.insert(cartItem); if(rowResult==0)&#123; return ServerResponse.createByErrorMessage("add to cart fail"); &#125; &#125;else&#123; //产品在，更新一个数量就可以了 cart.setQuantity(count+cart.getQuantity()); rowResult=cartMapper.updateByPrimaryKeySelective(cart); if(rowResult==0)&#123; return ServerResponse.createByErrorMessage("add to cart fail"); &#125; &#125;// return ServerResponse.createBySuccess(this.getCartVoLimit(userId)); return this.list(userId); &#125; private CartVo getCartVoLimit(Integer userId)&#123; CartVo cartVo = new CartVo(); List&lt;Cart&gt; cartList = cartMapper.selectCartByUserId(userId); List&lt;CartProductVo&gt; cartProductVoList = Lists.newArrayList(); BigDecimal cartTotalPrice = new BigDecimal("0"); if(CollectionUtils.isNotEmpty(cartList))&#123; for (Cart cartIem:cartList) &#123; CartProductVo cartProductVo = new CartProductVo(); cartProductVo.setId(cartIem.getId()); cartProductVo.setUserId(userId); cartProductVo.setProductId(cartIem.getProductId()); Product product = productMapper.selectByPrimaryKey(cartIem.getProductId()); if(product!=null)&#123; cartProductVo.setProductMainImage(product.getMainImage()); cartProductVo.setProductName(product.getName()); cartProductVo.setProductPrice(product.getPrice()); cartProductVo.setProductStatus(product.getStatus()); cartProductVo.setProductSubtitle(product.getSubtitle()); cartProductVo.setProductStock(product.getStock()); //判断库存 int buyLimitCount = 0; //只有支付了以后产品的库存才会减少，而且cart表中只会出现一条某个用户对应某种商品的cart记录 //这里判断的是这个商品的库存和某个用户这个商品在购物车中需要的个数 //一旦这个用户的这个商品需求大了那么也就只能添加给库存个数 if(product.getStock()&gt;=cartIem.getQuantity())&#123; buyLimitCount = cartIem.getQuantity(); cartProductVo.setLimitQuantity(Const.Cart_.LIMIT_NUM_SUCCESS); &#125;else&#123; buyLimitCount = product.getStock(); cartProductVo.setLimitQuantity(Const.Cart_.LIMIT_NUM_FAIL); //购物车中更新有效库存 Cart cartForQuantity = new Cart(); cartForQuantity.setId(cartIem.getId()); cartForQuantity.setQuantity(buyLimitCount); cartMapper.updateByPrimaryKeySelective(cartForQuantity); &#125; cartProductVo.setQuantity(buyLimitCount); cartProductVo.setProductTotalPrice(BigDecimalUtil.multiply(product.getPrice().doubleValue(), cartProductVo.getQuantity()));//购物车中某一个产品的总价 cartProductVo.setProductChecked(cartIem.getChecked()); &#125; if(cartIem.getChecked()==Const.Cart_.CHECKED)&#123; //已经勾选，增加到我们的总价中 cartTotalPrice = BigDecimalUtil.add(cartTotalPrice.doubleValue(), cartProductVo.getProductTotalPrice().doubleValue()); &#125; cartProductVoList.add(cartProductVo); &#125; &#125; cartVo.setCartTotalPrice(cartTotalPrice); cartVo.setCartProductVosList(cartProductVoList); cartVo.setAllChecked(this.getAllCheckedStatus(userId)); cartVo.setImageHost(PropertiesUtil.getProperty("ftp.server.http.prefix")); return cartVo; &#125; private boolean getAllCheckedStatus(Integer userId)&#123; if (userId==null)&#123; return false; &#125; return cartMapper.selectCartProductCheckedStatusByUserId(userId)==0?true:false; &#125; public ServerResponse&lt;CartVo&gt; update(Integer userId, Integer productId, Integer count)&#123; if(productId==null||count==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.ILLEGAL_ARGUMENT.getCode(), ResponseCode.ILLEGAL_ARGUMENT.getDesc()); &#125; Cart cart = cartMapper.selectCartByUserIdProductId(userId,productId); if(cart!=null)&#123; cart.setQuantity(count); cartMapper.updateByPrimaryKeySelective(cart); &#125;// CartVo cartVo = this.getCartVoLimit(userId);// return ServerResponse.createBySuccess(cartVo); return this.list(userId); &#125; public ServerResponse&lt;CartVo&gt; delete(Integer userId, String productIds)&#123; if(userId==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.ILLEGAL_ARGUMENT.getCode(), ResponseCode.ILLEGAL_ARGUMENT.getDesc()); &#125; List&lt;String&gt; productList = Splitter.on(",").splitToList(productIds); if(CollectionUtils.isEmpty(productList))&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.ILLEGAL_ARGUMENT.getCode(), ResponseCode.ILLEGAL_ARGUMENT.getDesc()); &#125; cartMapper.deleteByUserIdProductIds(userId,productList);// CartVo cartVo = this.getCartVoLimit(userId);// return ServerResponse.createBySuccess(cartVo); return this.list(userId); &#125; public ServerResponse&lt;CartVo&gt; list(Integer userId)&#123; CartVo cartVo = this.getCartVoLimit(userId); return ServerResponse.createBySuccess(cartVo); &#125; public ServerResponse&lt;CartVo&gt; selectOrUnSelect(Integer userId,Integer productId,Integer checked)&#123; cartMapper.checkedOrUncheckedAllProduct(userId,productId,checked); return this.list(userId); &#125; public ServerResponse&lt;Integer&gt; getCartProductCount(Integer userId)&#123; if(userId==null)&#123; return ServerResponse.createBySuccess(0); &#125; return ServerResponse.createBySuccess(cartMapper.selectCartProductCount(userId)); &#125;&#125; DaoInterface123456789101112131415161718192021222324252627282930313233package com.mmall.dao;import com.mmall.pojo.Cart;import org.apache.ibatis.annotations.Param;import java.util.List;public interface CartMapper &#123; int deleteByPrimaryKey(Integer id); int insert(Cart record); int insertSelective(Cart record); Cart selectByPrimaryKey(Integer id); int updateByPrimaryKeySelective(Cart record); int updateByPrimaryKey(Cart record); Cart selectCartByUserIdProductId(@Param(value="userId") Integer userId, @Param(value="productId") Integer productId); List&lt;Cart&gt; selectCartByUserId(Integer userId); int selectCartProductCheckedStatusByUserId(Integer userId); int deleteByUserIdProductIds(@Param("userId") Integer userId,@Param("productIdList")List&lt;String&gt; productIdList); int checkedOrUncheckedAllProduct(@Param(value="userId") Integer userId,@Param(value="productId") Integer productId, @Param(value="checked") Integer checked); int selectCartProductCount(Integer userId);&#125; Impl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.mmall.dao.CartMapper" &gt; &lt;resultMap id="BaseResultMap" type="com.mmall.pojo.Cart" &gt; &lt;constructor &gt; &lt;idArg column="id" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="user_id" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="product_id" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="quantity" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="checked" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="create_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;arg column="update_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;/constructor&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List" &gt; id, user_id, product_id, quantity, checked, create_time, update_time &lt;/sql&gt; &lt;select id="selectByPrimaryKey" resultMap="BaseResultMap" parameterType="java.lang.Integer" &gt; select &lt;include refid="Base_Column_List" /&gt; from mmall_cart where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;delete id="deleteByPrimaryKey" parameterType="java.lang.Integer" &gt; delete from mmall_cart where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/delete&gt; &lt;insert id="insert" parameterType="com.mmall.pojo.Cart" &gt; insert into mmall_cart (id, user_id, product_id, quantity, checked, create_time, update_time) values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;userId,jdbcType=INTEGER&#125;, #&#123;productId,jdbcType=INTEGER&#125;, #&#123;quantity,jdbcType=INTEGER&#125;, #&#123;checked,jdbcType=INTEGER&#125;, now(), now()) &lt;/insert&gt; &lt;insert id="insertSelective" parameterType="com.mmall.pojo.Cart" &gt; insert into mmall_cart &lt;trim prefix="(" suffix=")" suffixOverrides="," &gt; &lt;if test="id != null" &gt; id, &lt;/if&gt; &lt;if test="userId != null" &gt; user_id, &lt;/if&gt; &lt;if test="productId != null" &gt; product_id, &lt;/if&gt; &lt;if test="quantity != null" &gt; quantity, &lt;/if&gt; &lt;if test="checked != null" &gt; checked, &lt;/if&gt; &lt;if test="createTime != null" &gt; create_time, &lt;/if&gt; &lt;if test="updateTime != null" &gt; update_time, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides="," &gt; &lt;if test="id != null" &gt; #&#123;id,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="userId != null" &gt; #&#123;userId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="productId != null" &gt; #&#123;productId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="quantity != null" &gt; #&#123;quantity,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="checked != null" &gt; #&#123;checked,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="createTime != null" &gt; now(), &lt;/if&gt; &lt;if test="updateTime != null" &gt; now(), &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id="updateByPrimaryKeySelective" parameterType="com.mmall.pojo.Cart" &gt; update mmall_cart &lt;set &gt; &lt;if test="userId != null" &gt; user_id = #&#123;userId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="productId != null" &gt; product_id = #&#123;productId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="quantity != null" &gt; quantity = #&#123;quantity,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="checked != null" &gt; checked = #&#123;checked,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="createTime != null" &gt; create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="updateTime != null" &gt; update_time = now(), &lt;/if&gt; &lt;/set&gt; where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;update id="updateByPrimaryKey" parameterType="com.mmall.pojo.Cart" &gt; update mmall_cart set user_id = #&#123;userId,jdbcType=INTEGER&#125;, product_id = #&#123;productId,jdbcType=INTEGER&#125;, quantity = #&#123;quantity,jdbcType=INTEGER&#125;, checked = #&#123;checked,jdbcType=INTEGER&#125;, create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;, update_time = now() where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;select id="selectCartByUserIdProductId" resultMap="BaseResultMap" parameterType="map"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_cart WHERE user_id=#&#123;userId&#125; AND product_id=#&#123;productId&#125; &lt;/select&gt; &lt;select id="selectCartByUserId" resultMap="BaseResultMap" parameterType="int"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_cart WHERE user_id=#&#123;userId&#125; &lt;/select&gt; &lt;select id="selectCartProductCheckedStatusByUserId" resultType="int" parameterType="int"&gt; SELECT COUNT(1) FROM mmall_cart WHERE checked = 0 AND user_id=#&#123;userId&#125; &lt;/select&gt; &lt;delete id="deleteByUserIdProductIds" parameterType="map"&gt; delete from mmall_cart where user_id = #&#123;userId&#125; &lt;if test="productIdList != null"&gt; and product_id in &lt;foreach collection="productIdList" item="item" index="index" open="(" separator="," close=")"&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/delete&gt; &lt;update id="checkedOrUncheckedAllProduct" parameterType="map"&gt; UPDATE mmall_cart SET checked = #&#123;checked&#125;, update_time = now() WHERE user_id=#&#123;userId&#125; &lt;if test="productId!=null"&gt; AND product_id=#&#123;productId&#125; &lt;/if&gt; &lt;/update&gt; &lt;select id="selectCartProductCount" parameterType="int" resultType="int"&gt; SELECT IFNULL(SUM(quantity),0) AS COUNT FROM mmall_cart WHERE user_id=#&#123;userId&#125; &lt;/select&gt;&lt;/mapper&gt;]]></content>
      <categories>
        <category>mmall</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[商品模块]]></title>
    <url>%2F2018%2F03%2F06%2F%E5%95%86%E5%93%81%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[前台功能产品搜索、动态排序、商品详情 后台功能商品列表、商品搜索、图片上传、富文本上传、商品详情、商品上下价、增加，更新商品。 学习目标1. FTP服务对接 2. SpringMVC文件上传 3. 流读取Properties配置文件 4. 抽象POJO、BO、VO对象之间的关系以及解决思路 5. joda-time快速入门 6. 静态快 7. MyBatis-PageHelper分页与动态排序 8. MyBatis对List遍历的实现方法 9. MyBstis对where语句动态拼装的几个版本演变 POJO、BO、VO 后台增加产品Controller1234567891011121314151617181920212223242526272829303132333435@Controller@RequestMapping("/manage/product/")public class ProductManagerController &#123; @Autowired private IUserService iUserService; @Autowired private IProductService iProductService; /** * 增加产品 * @param session * @param product * @return */ @RequestMapping(value="proudct_save.do",method= RequestMethod.POST) @ResponseBody public ServerResponse proudct_save(HttpSession session, Product product)&#123; //1. 校验登陆 User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),"user no login"); &#125; //2. 校验角色 if(iUserService.checkAdmin(user).isSuccess())&#123; //是管理员 return iProductService.saveOrUpdateProduct(product); &#125;else &#123; //不是管理员 return ServerResponse.createByErrorMessage("isn't Admin,need Admin's access"); &#125; &#125;&#125; ServiceInterface1ServerResponse saveOrUpdateProduct(Product product); Impl12345678910111213141516171819202122232425262728293031323334@Service("iProductService")public class ProductServiceImpl implements IProductService &#123; @Autowired private ProductMapper productMapper; public ServerResponse saveOrUpdateProduct(Product product)&#123; if(product!=null)&#123; if(StringUtils.isNotBlank(product.getSubImages()))&#123; String[] subImageArray = product.getSubImages().split(","); if(subImageArray.length&gt;0)&#123; product.setMainImage(subImageArray[0]); &#125; &#125; if (product.getId()!=null)&#123; //更新 int rowCount = productMapper.updateByPrimaryKey(product); if(rowCount&gt;0)&#123; return ServerResponse.createByErrorMessage("update product suceess"); &#125; return ServerResponse.createByErrorMessage("update product fail"); &#125;else&#123; //添加 int rowCount = productMapper.insert(product); if(rowCount&gt;0)&#123; return ServerResponse.createByErrorMessage("save product suceess"); &#125; return ServerResponse.createByErrorMessage("save product fail"); &#125; &#125; return ServerResponse.createByErrorMessage("save or update fail"); &#125;&#125; Dao不需要添加代码 后台设置商品上下线Controller12345678910111213141516171819202122232425/** * 设置商品上下线 * @param session * @param productId * @param status * @return */@RequestMapping(value="set_sale_status.do",method= RequestMethod.POST)@ResponseBodypublic ServerResponse set_sale_status(HttpSession session, Integer productId,Integer status)&#123; //1. 校验登陆 User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),"user no login"); &#125; //2. 校验角色 if(iUserService.checkAdmin(user).isSuccess())&#123; //是管理员 return iProductService.setSaleStatus(productId,status); &#125;else &#123; //不是管理员 return ServerResponse.createByErrorMessage("isn't Admin,need Admin's access"); &#125;&#125; ServiceInterface1ServerResponse&lt;String&gt; setSaleStatus(Integer productId,Integer status); Impl12345678910111213public ServerResponse&lt;String&gt; setSaleStatus(Integer productId,Integer status)&#123; if(productId==null||status==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.ILLEGAL_ARGUMENT.getCode(),ResponseCode.ILLEGAL_ARGUMENT.getDesc()); &#125; Product product = new Product(); product.setId(productId); product.setStatus(status); int rowCount = productMapper.updateByPrimaryKeySelective(product); if (rowCount&gt;0)&#123; return ServerResponse.createBySuccess("update success"); &#125; return ServerResponse.createByErrorMessage("update fail");&#125; Dao不需要添加代码 获取商品详情信息Controller123456789101112131415161718@RequestMapping(value="get_product_detail.do",method= RequestMethod.POST)@ResponseBodypublic ServerResponse get_product_detail(HttpSession session, Integer productId)&#123; //1. 校验登陆 User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),"user no login"); &#125; //2. 校验角色 if(iUserService.checkAdmin(user).isSuccess())&#123; //是管理员 return iProductService.manageProductDetail(productId); &#125;else &#123; //不是管理员 return ServerResponse.createByErrorMessage("isn't Admin,need Admin's access"); &#125;&#125; ServiceInterface1ServerResponse&lt;ProductDetailVo&gt; manageProductDetail(Integer productId); Impl12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public ServerResponse&lt;ProductDetailVo&gt; manageProductDetail(Integer productId)&#123; if(productId==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.ILLEGAL_ARGUMENT.getCode(), ResponseCode.ILLEGAL_ARGUMENT.getDesc()); &#125; Product product = productMapper.selectByPrimaryKey(productId); if(product==null)&#123; return ServerResponse.createByErrorMessage("product already out-off"); &#125; //VO value Object //POJO--&gt;BO（Bussiness Object）--&gt;VO（View Object） ProductDetailVo productDetailVo = this.assembleProductDetailVo(product); return ServerResponse.createBySuccess(productDetailVo); &#125; private ProductDetailVo assembleProductDetailVo(Product product)&#123; ProductDetailVo productDetailVo = new ProductDetailVo(); productDetailVo.setId(product.getId()); productDetailVo.setSubtitle(product.getSubtitle()); productDetailVo.setPrice(product.getPrice()); productDetailVo.setMainImage(product.getMainImage()); productDetailVo.setSubImages(product.getSubImages()); productDetailVo.setCategoryId(product.getCategoryId()); productDetailVo.setDetail(product.getDetail()); productDetailVo.setName(product.getName()); productDetailVo.setStatus(product.getStatus()); productDetailVo.setStock(product.getStock()); //imageHost //parentCategoryId //createTime //updateTime productDetailVo.setImageHost(PropertiesUtil.getProperty("ftp.server.http.prefix","http://img.happymmall.com/")); Category category = categoryMapper.selectByPrimaryKey(product.getCategoryId()); //如果当前商品没有所属的分类，默认商品就是根分类 if(category==null)&#123; productDetailVo.setParentCategoryId(0); &#125;else&#123; productDetailVo.setParentCategoryId(category.getParentId()); &#125; //createTime //updateTime //这两个数在DB是一个毫秒数，不利于展示 productDetailVo.setCreateTime(DateTimeUtil.dateToStrByStandard(product.getCreateTime())); productDetailVo.setUpdateTime(DateTimeUtil.dateToStrByStandard(product.getUpdateTime())); return productDetailVo; &#125; UtilPropertiesUtil1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.mmall.util;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.IOException;import java.io.InputStreamReader;import java.util.Properties;/** * Created by Blemon on 2018/3/5. */public class PropertiesUtil &#123; private static Logger logger = LoggerFactory.getLogger(PropertiesUtil.class); private static Properties props; //静态块、构造块、构造器的执行顺序。 static &#123; String fileName = "mmall.properties"; props = new Properties(); try &#123; props.load(new InputStreamReader(PropertiesUtil.class.getClassLoader().getResourceAsStream(fileName),"UTF-8")); &#125; catch (IOException e) &#123; logger.error("配置文件读取异常",e); &#125; &#125; public static String getProperty(String key)&#123; String value = props.getProperty(key.trim()); if(StringUtils.isBlank(value))&#123; return null; &#125; return value.trim(); &#125; public static String getProperty(String key,String defaultValue)&#123; String value = props.getProperty(key.trim()); if(StringUtils.isBlank(value))&#123; value = defaultValue; &#125; return value.trim(); &#125;&#125; DateTimeUtil12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.mmall.util;import org.apache.commons.lang3.StringUtils;import org.joda.time.DateTime;import org.joda.time.format.DateTimeFormat;import org.joda.time.format.DateTimeFormatter;import java.util.Date;/** * Created by Blemon on 2018/3/5. */public class DateTimeUtil &#123; //joda-time public static final String STANDARD_FROMAT = "yyyy-MM-dd HH:mm:ss"; //str--&gt;Date public static Date strToDate(String dateTimeStr,String dateFormatStr)&#123; DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(dateFormatStr); return dateTimeFormatter.parseDateTime(dateTimeStr).toDate(); &#125; public static Date strToDateByStandard(String dateTimeStr)&#123; DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(STANDARD_FROMAT); return dateTimeFormatter.parseDateTime(dateTimeStr).toDate(); &#125; //Date--&gt;str public static String dateToStr(Date date,String dateFormatStr)&#123; if(date==null)&#123; return StringUtils.EMPTY; &#125; DateTime dateTime = new DateTime(date); return dateTime.toString(dateFormatStr); &#125; public static String dateToStrByStandard(Date date)&#123; if(date==null)&#123; return StringUtils.EMPTY; &#125; DateTime dateTime = new DateTime(date); return dateTime.toString(STANDARD_FROMAT); &#125; /* 测试 public static void main(String[] args) &#123; System.out.println(DateTimeUtil.dateToStr(new Date(),"yyyy-MM-dd HH:mm:ss")); System.out.println("2017-03-05 15:31:30","yyyy-MM-dd HH:mm:ss"); &#125; */&#125; Dao不需要多写 后台商品列表动态分页Controller1234567891011121314151617181920212223242526/** * 分页查询 * @param session * @param pageNum * @param pageSize * @return */@RequestMapping(value="get_product_list",method= RequestMethod.POST)@ResponseBodypublic ServerResponse get_product_list(HttpSession session, @RequestParam(value="pageNum",defaultValue = "1") int pageNum, @RequestParam(value="pageSize",defaultValue = "10") int pageSize)&#123; //1. 校验登陆 User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),"user no login"); &#125; //2. 校验角色 if(iUserService.checkAdmin(user).isSuccess())&#123; //是管理员 return iProductService.getProductList(pageNum,pageSize); &#125;else &#123; //不是管理员 return ServerResponse.createByErrorMessage("isn't Admin,need Admin's access"); &#125;&#125; ServiceInterface1ServerResponse&lt;PageInfo&gt; getProductList(int pageNum, int pageSize); Impl1234567891011121314151617181920212223242526272829303132333435363738394041/** * 分页显示 * @param pageNum * @param pageSize * @return */public ServerResponse&lt;PageInfo&gt; getProductList(int pageNum,int pageSize)&#123; //1.startPage--start PageHelper.startPage(pageNum,pageSize); //2.填充自己的sql查询逻辑 List&lt;Product&gt; productList = productMapper.selectList(); List&lt;ProductListVo&gt; productListVoList = new ArrayList&lt;&gt;(); for(Product productItem : productList)&#123; ProductListVo productListVo = assembleProductListVo(productItem); productListVoList.add(productListVo); &#125; //3.pageHelper收尾 PageInfo pageResult = new PageInfo(productList); pageResult.setList(productListVoList); return ServerResponse.createBySuccess(pageResult);&#125;/** * 快照构建 * @param product * @return */private ProductListVo assembleProductListVo(Product product)&#123; ProductListVo productListVo = new ProductListVo(); productListVo.setId(product.getId()); productListVo.setName(product.getName()); productListVo.setCategoryId(product.getCategoryId()); productListVo.setImageHost(PropertiesUtil.getProperty("ftp.server.http.prefix","http://img.happymmall.com/")); productListVo.setMainImage(product.getMainImage()); productListVo.setPrice(product.getPrice()); productListVo.setSubtitle(product.getSubtitle()); productListVo.setStatus(product.getStatus()); return productListVo;&#125; vo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.mmall.vo;import java.math.BigDecimal;/** * Created by Blemon on 2018/3/5. */public class ProductListVo &#123; private Integer id; private Integer categoryId; private String name; private String subtitle; private String mainImage; private BigDecimal price; private Integer status; private String imageHost; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public Integer getCategoryId() &#123; return categoryId; &#125; public void setCategoryId(Integer categoryId) &#123; this.categoryId = categoryId; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSubtitle() &#123; return subtitle; &#125; public void setSubtitle(String subtitle) &#123; this.subtitle = subtitle; &#125; public String getMainImage() &#123; return mainImage; &#125; public void setMainImage(String mainImage) &#123; this.mainImage = mainImage; &#125; public BigDecimal getPrice() &#123; return price; &#125; public void setPrice(BigDecimal price) &#123; this.price = price; &#125; public Integer getStatus() &#123; return status; &#125; public void setStatus(Integer status) &#123; this.status = status; &#125; public String getImageHost() &#123; return imageHost; &#125; public void setImageHost(String imageHost) &#123; this.imageHost = imageHost; &#125;&#125; DaoInterface1List&lt;Product&gt; selectList(); Impl123456&lt;select id="selectList" resultMap="BaseResultMap"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_product ORDER BY id ASC&lt;/select&gt; 后台产品搜索Controller1234567891011121314151617181920212223242526272829/** * 根据产品id和name分页搜索 * @param session * @param productName * @param productId * @param pageNum * @param pageSize * @return */@RequestMapping(value="product_search",method= RequestMethod.POST)@ResponseBodypublic ServerResponse product_search(HttpSession session, String productName,Integer productId, @RequestParam(value="pageNum",defaultValue = "1") int pageNum, @RequestParam(value="pageSize",defaultValue = "10") int pageSize)&#123; //1. 校验登陆 User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),"user no login"); &#125; //2. 校验角色 if(iUserService.checkAdmin(user).isSuccess())&#123; //是管理员 return iProductService.searchProduct(productName,productId,pageNum,pageSize); &#125;else &#123; //不是管理员 return ServerResponse.createByErrorMessage("isn't Admin,need Admin's access"); &#125;&#125; ServiceInterface1ServerResponse&lt;PageInfo&gt; searchProduct(String productName,Integer productId,int pageNum, int pageSize); Impl1234567891011121314151617181920212223242526272829/** * 分页搜索 * @param productName * @param productId * @param pageNum * @param pageSize * @return */public ServerResponse&lt;PageInfo&gt; searchProduct(String productName,Integer productId, int pageNum, int pageSize)&#123; //1. pageHepler开启 PageHelper.startPage(pageNum,pageSize); if(StringUtils.isNotBlank(productName))&#123; productName = new StringBuilder().append("%").append(productName).append("%").toString(); &#125; //2.sql查询 List&lt;Product&gt; productList = productMapper.selectByNameAndProductId(productName,productId); List&lt;ProductListVo&gt; productListVoList = new ArrayList&lt;&gt;(); for(Product productItem : productList)&#123; ProductListVo productListVo = assembleProductListVo(productItem); productListVoList.add(productListVo); &#125; //3.pageHelper收尾 PageInfo pageResult = new PageInfo(productList); pageResult.setList(productListVoList); return ServerResponse.createBySuccess(pageResult);&#125; DaoInterface12List&lt;Product&gt; selectByNameAndProductId(@Param("productName") String productName, @Param("productId") Integer productId); Impl12345678910111213&lt;select id="selectByNameAndProductId" resultMap="BaseResultMap" parameterType="map"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mall_product &lt;where&gt;#第一个and被换成where &lt;if test="productName!=null"&gt; AND name LIKE #&#123;productName&#125; &lt;/if&gt; &lt;if test="productId!=null"&gt; AND id=#&#123;productId&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 后台文件上传Controller1234567891011121314151617181920212223242526272829303132333435/** * 文件上传(SpringMVC) * @param upload_file * @param request * @return */@RequestMapping(value="upload.do",method=RequestMethod.POST)@ResponseBodypublic ServerResponse upload(HttpSession session,MultipartFile upload_file, HttpServletRequest request)&#123; //1. 校验登陆 User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),"user no login"); &#125; //2. 校验角色 if(iUserService.checkAdmin(user).isSuccess())&#123; //是管理员 String path = request.getSession().getServletContext().getRealPath("upload"); String targetFileName = iFileService.upload(upload_file,path); String url = PropertiesUtil.getProperty("ftp.server.http.prefix")+targetFileName; Map&lt;String,String&gt; fileMap = new HashMap&lt;&gt;(); fileMap.put("uri",targetFileName); fileMap.put("url",url); return ServerResponse.createBySuccess(fileMap); &#125;else &#123; //不是管理员 return ServerResponse.createByErrorMessage("isn't Admin,need Admin's access"); &#125;&#125; Service(FileService)Interface12345678910package com.mmall.service;import org.springframework.web.multipart.MultipartFile;/** * Created by Blemon on 2018/3/5. */public interface IFileService &#123; String upload(MultipartFile file,String path);&#125; Impl12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Created by Blemon on 2018/3/5. */@Service("iFileService")public class FileServiceImpl implements IFileService&#123; private Logger logger = LoggerFactory.getLogger(FileServiceImpl.class); public String upload(MultipartFile file, String path)&#123; String filename = file.getOriginalFilename(); //扩展名字 //abc.abc.exe String fileExtensionName = filename.substring(filename.lastIndexOf(".")+1); //A用户：abc.jpg //B用户：abc.jpg String uploadFileName = UUID.randomUUID().toString()+"."+fileExtensionName; logger.info("开始上传文件，上传文件名:&#123;&#125;,上传路径:&#123;&#125;,新文件名:&#123;&#125;",filename,path,uploadFileName); File fileDir = new File(path); if(!fileDir.exists())&#123; fileDir.setWritable(true); fileDir.mkdirs(); &#125; File targetFile = new File(path,uploadFileName); try &#123; file.transferTo(targetFile); //文件已经上传成功 //将targetFile上传到我们的FTP服务器上 List&lt;File&gt; fileList = new ArrayList&lt;&gt;(); fileList.add(targetFile); FTPUtil.uploadFile(fileList); //targetFile上传到我们的FTP服务器成功 //上传完成后，删除upload下的文件 targetFile.delete(); &#125; catch (IOException e) &#123; logger.error("fileupload is execption",e); return null; &#125; return targetFile.getName(); &#125;&#125; FileUtil123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150package com.mmall.util;import org.apache.commons.net.ftp.FTPClient;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.util.*;/** * Created by Blemon on 2018/3/5. */public class FTPUtil &#123; private static String ftpIp = PropertiesUtil.getProperty("ftp.server.ip"); private static String ftpUser = PropertiesUtil.getProperty("ftp.user"); private static String ftpPass = PropertiesUtil.getProperty("ftp.pass"); private String ip; private int port; private String user; private String pwd; private FTPClient ftpClient; private static Logger logger = LoggerFactory.getLogger(FTPUtil.class); public FTPUtil(String ip, int port, String user, String pwd) &#123; this.ip = ip; this.port = port; this.user = user; this.pwd = pwd; &#125; public static String getFtpIp() &#123; return ftpIp; &#125; public static void setFtpIp(String ftpIp) &#123; FTPUtil.ftpIp = ftpIp; &#125; public static String getFtpUser() &#123; return ftpUser; &#125; public static void setFtpUser(String ftpUser) &#123; FTPUtil.ftpUser = ftpUser; &#125; public static String getFtpPass() &#123; return ftpPass; &#125; public static void setFtpPass(String ftpPass) &#123; FTPUtil.ftpPass = ftpPass; &#125; public String getIp() &#123; return ip; &#125; public void setIp(String ip) &#123; this.ip = ip; &#125; public int getPort() &#123; return port; &#125; public void setPort(int port) &#123; this.port = port; &#125; public String getUser() &#123; return user; &#125; public void setUser(String user) &#123; this.user = user; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; public FTPClient getFtpClient() &#123; return ftpClient; &#125; public void setFtpClient(FTPClient ftpClient) &#123; this.ftpClient = ftpClient; &#125; public static boolean uploadFile(List&lt;File&gt; fileList) throws IOException &#123; FTPUtil ftpUtil = new FTPUtil(ftpIp,21,ftpUser,ftpPass); logger.info("start ftp Server"); boolean result = ftpUtil.uploadFile("img",fileList); logger.info("connect Service over,cancel upload,upload:&#123;&#125;",result); return result; &#125; private boolean uploadFile(String remotePath,List&lt;File&gt; fileList) throws IOException &#123; boolean uploaded = true; FileInputStream fis = null; //连接服务器 if (connectServer(ftpIp,21,ftpUser,ftpPass))&#123; try &#123; ftpClient.changeToParentDirectory(); ftpClient.setBufferSize(1024); ftpClient.setControlEncoding("UTF-8"); ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); ftpClient.enterLocalPassiveMode(); for (File fileItem:fileList) &#123; fis = new FileInputStream(fileItem); ftpClient.storeFile(fileItem.getName(),fis); &#125; &#125; catch (IOException e) &#123; logger.error("upload file Exception",e); uploaded = false; e.getStackTrace(); &#125;finally &#123; fis.close(); ftpClient.disconnect(); &#125; &#125; return false; &#125; private boolean connectServer(String ip, int port, String user, String pwd)&#123; boolean isSuccess = false; ftpClient = new FTPClient(); try &#123; ftpClient.connect(ip); isSuccess = ftpClient.login(user,pwd); &#125; catch (IOException e) &#123; logger.error("connect ftpServer Exception",e); &#125; return isSuccess; &#125;&#125; Dao不需要多写 ftp开始上传是没有登陆hosts 123456789101112131415161718192021222324252627282930313233343536# Copyright (c) 1993-2009 Microsoft Corp.## This is a sample HOSTS file used by Microsoft TCP/IP for Windows.## This file contains the mappings of IP addresses to host names. Each# entry should be kept on an individual line. The IP address should# be placed in the first column followed by the corresponding host name.# The IP address and the host name should be separated by at least one# space.## Additionally, comments (such as these) may be inserted on individual# lines or following the machine name denoted by a '#' symbol.## For example:## 102.54.94.97 rhino.acme.com # source server# 38.25.63.10 x.acme.com # x client host# localhost name resolution is handled within DNS itself.# 127.0.0.1 localhost# ::1 localhost127.0.0.1 img.blemon.com``` **重新配一下mmail.properties**```javaftp.server.ip=127.0.0.1ftp.user=blemonftp.pass=blemonftp.server.http.prefix=http://img.blemon.com/alipay.callback.url=http://www.happymmall.com/order/alipay_callback.dopassword.salt = geelysdafaqj23ou89ZXcj@#$@#$#@KJdjklj;D../dSF., 测试一下网址能不能直接进去 img.blemon.com/abc.jpg 重启nginx ftpServer 前台商品详细信息Controller1234567891011121314151617181920212223242526272829303132333435363738394041package com.mmall.controller.portal;import com.github.pagehelper.PageInfo;import com.mmall.common.ServerResponse;import com.mmall.service.IProductService;import com.mmall.vo.ProductDetailVo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;/** * Created by Blemon on 2018/3/6. */@Controller@RequestMapping("/product/")public class ProductController &#123; @Autowired private IProductService iProductService; /** * 查询商品详细信息 * @param productId * @return */ @RequestMapping(value="detail.do",method = RequestMethod.POST) @ResponseBody public ServerResponse&lt;ProductDetailVo&gt; detail(Integer productId)&#123; return iProductService.getProductDetail(productId); &#125;&#125;``` ## Service### Interface```javaServerResponse&lt;ProductDetailVo&gt; getProductDetail(Integer productId); Impl123456789101112131415161718public ServerResponse&lt;ProductDetailVo&gt; getProductDetail(Integer productId)&#123; if(productId==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.ILLEGAL_ARGUMENT.getCode(), ResponseCode.ILLEGAL_ARGUMENT.getDesc()); &#125; Product product = productMapper.selectByPrimaryKey(productId); if(product==null||product.getStatus()!= Const.ProductStatusEnum.ON_SALE.getCode())&#123; return ServerResponse.createByErrorMessage("product already out-off"); &#125; //VO value Object //POJO--&gt;BO（Bussiness Object）--&gt;VO（View Object） ProductDetailVo productDetailVo = this.assembleProductDetailVo(product); return ServerResponse.createBySuccess(productDetailVo);&#125; 修改Const123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package com.mmall.common;import com.google.common.collect.Sets;import java.util.Set;/** * Created by Blemon on 2018/2/28. */public class Const &#123; public static final String CURRENT_USER = "currentUser"; public interface Role&#123; int ROLE_CUSTOMER = 0; int ROLE_ADMIN = 1; &#125; public interface ProductListOrderBy&#123; Set&lt;String&gt; PRICE_ASC_DESC = Sets.newHashSet("price_desc","price_asc"); &#125; public static final String EMAIL = "email"; public static final String USERNAME = "username"; public enum ProductStatusEnum&#123; ON_SALE(1,"on_sale"); //OFF_SALE(0,"off_sale"); private String value; private int code; ProductStatusEnum(String value, int code) &#123; this.value = value; this.code = code; &#125; public String getValue() &#123; return value; &#125; public int getCode() &#123; return code; &#125; &#125;&#125; Dao不需要多写 关键字和分类组合分页查询Controller123456789101112131415161718/** * 关键字和分类组合分页查询 * @param keyword * @param categoryId * @param pageNum * @param pageSize * @param orderBy * @return */@RequestMapping(value="list.do",method = RequestMethod.POST)@ResponseBodypublic ServerResponse&lt;PageInfo&gt; list(@RequestParam(value = "keyword",required = false)String keyword, @RequestParam(value = "categoryId",required = false)Integer categoryId, @RequestParam(value="pageNum",defaultValue = "1")int pageNum, @RequestParam(value="pageSize",defaultValue = "10")int pageSize, @RequestParam(value="orderBy",defaultValue = "")String orderBy)&#123; return iProductService.getProductByKeyandCategory(keyword,categoryId,pageNum,pageSize,orderBy);&#125; ServiceInterface1ServerResponse&lt;PageInfo&gt; getProductByKeyandCategory(String keyword,Integer categoryId,int pageNum, int pageSize,String orderBy); Impl12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public ServerResponse&lt;PageInfo&gt; getProductByKeyandCategory(String keyword,Integer categoryId, int pageNum, int pageSize,String orderBy)&#123; if(StringUtils.isBlank(keyword) &amp;&amp; categoryId==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.ILLEGAL_ARGUMENT.getCode(), ResponseCode.ILLEGAL_ARGUMENT.getDesc()); &#125; List&lt;Integer&gt; categoryIdList = new ArrayList&lt;Integer&gt;(); if(categoryId!=null)&#123; Category category = categoryMapper.selectByPrimaryKey(categoryId); if(category==null&amp;&amp;StringUtils.isBlank(keyword))&#123; //没有该分类，并且还没有关键字，这个时候返回一个空的结果集，不报错。 PageHelper.startPage(pageNum,pageSize); List&lt;ProductListVo&gt; productListVoList = Lists.newArrayList(); PageInfo pageResult = new PageInfo(productListVoList); return ServerResponse.createBySuccess(pageResult); &#125; //当前分类和其所有子分类 categoryIdList = iCategoreService.selectCtagoryAndChildrenById(categoryId).getData(); if(StringUtils.isNotBlank(keyword))&#123; keyword = new StringBuilder().append("%").append(keyword).append("%").toString(); &#125; &#125; PageHelper.startPage(pageNum,pageSize); //排序 if(StringUtils.isNotBlank(orderBy))&#123; if(Const.ProductListOrderBy.PRICE_ASC_DESC.contains(orderBy))&#123; String[] orderByArray = orderBy.split("_"); PageHelper.orderBy(orderByArray[0]+" "+orderByArray[1]); &#125; &#125; List&lt;Product&gt; productList = productMapper.selectByNameAndCategoryIds (StringUtils.isBlank(keyword)?null:keyword,categoryIdList.size()==0?null:categoryIdList); List&lt;ProductListVo&gt; productListVoList = Lists.newArrayList(); for (Product productItem:productList) &#123; ProductListVo productListVo = assembleProductListVo(productItem); productListVoList.add(productListVo); &#125; PageInfo pageResult = new PageInfo(productList);//分页 pageResult.setList(productListVoList);//显示 return ServerResponse.createBySuccess(pageResult);&#125; DaoInterface12List&lt;Product&gt; selectByNameAndCategoryIds(@Param("productName") String productName, @Param("categoryIdList") List&lt;Integer&gt; categoryIdList); Impl12345678910111213141516&lt;select id="selectByNameAndCategoryIds" resultMap="BaseResultMap" parameterType="map"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mall_product &lt;where&gt;#第一个and被换成where &lt;if test="productName!=null"&gt; AND name LIKE #&#123;productName&#125; &lt;/if&gt; &lt;if test="categoryIdList!=null"&gt; AND category_id IN &lt;foreach item="item" index="index" open="(" separator="," close=")" collection="categoryIdList"&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 测试 整体Controller前台1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.mmall.controller.portal;import com.github.pagehelper.PageInfo;import com.mmall.common.ServerResponse;import com.mmall.service.IProductService;import com.mmall.vo.ProductDetailVo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;/** * Created by Blemon on 2018/3/6. */@Controller@RequestMapping("/product/")public class ProductController &#123; @Autowired private IProductService iProductService; /** * 查询商品详细信息 * @param productId * @return */ @RequestMapping(value="detail.do",method = RequestMethod.POST) @ResponseBody public ServerResponse&lt;ProductDetailVo&gt; detail(Integer productId)&#123; return iProductService.getProductDetail(productId); &#125; /** * 关键字和分类组合分页查询 * @param keyword * @param categoryId * @param pageNum * @param pageSize * @param orderBy * @return */ @RequestMapping(value="list.do",method = RequestMethod.POST) @ResponseBody public ServerResponse&lt;PageInfo&gt; list(@RequestParam(value = "keyword",required = false)String keyword, @RequestParam(value = "categoryId",required = false)Integer categoryId, @RequestParam(value="pageNum",defaultValue = "1")int pageNum, @RequestParam(value="pageSize",defaultValue = "10")int pageSize, @RequestParam(value="orderBy",defaultValue = "")String orderBy)&#123; return iProductService.getProductByKeyandCategory(keyword,categoryId,pageNum,pageSize,orderBy); &#125;&#125; 后台123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255package com.mmall.controller.backend;import com.google.common.collect.Maps;import com.mmall.common.Const;import com.mmall.common.ResponseCode;import com.mmall.common.ServerResponse;import com.mmall.pojo.Product;import com.mmall.pojo.User;import com.mmall.service.IFileService;import com.mmall.service.IProductService;import com.mmall.service.IUserService;import com.mmall.util.PropertiesUtil;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.multipart.MultipartFile;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.util.*;/** * Created by Blemon on 2018/3/5. */@Controller@RequestMapping("/manage/product/")public class ProductManagerController &#123; @Autowired private IUserService iUserService; @Autowired private IProductService iProductService; @Autowired private IFileService iFileService; /** * 增加产品 * @param session * @param product * @return */ @RequestMapping(value="proudct_save.do",method=RequestMethod.POST) @ResponseBody public ServerResponse proudct_save(HttpSession session, Product product)&#123; //1. 校验登陆 User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),"user no login"); &#125; //2. 校验角色 if(iUserService.checkAdmin(user).isSuccess())&#123; //是管理员 return iProductService.saveOrUpdateProduct(product); &#125;else &#123; //不是管理员 return ServerResponse.createByErrorMessage("isn't Admin,need Admin's access"); &#125; &#125; /** * 设置商品上下线 * @param session * @param productId * @param status * @return */ @RequestMapping(value="set_sale_status.do",method=RequestMethod.POST) @ResponseBody public ServerResponse set_sale_status(HttpSession session, Integer productId,Integer status)&#123; //1. 校验登陆 User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),"user no login"); &#125; //2. 校验角色 if(iUserService.checkAdmin(user).isSuccess())&#123; //是管理员 return iProductService.setSaleStatus(productId,status); &#125;else &#123; //不是管理员 return ServerResponse.createByErrorMessage("isn't Admin,need Admin's access"); &#125; &#125; /** * 查询商品详细信息 * @param session * @param productId * @return */ @RequestMapping(value="get_product_detail.do",method=RequestMethod.POST) @ResponseBody public ServerResponse get_product_detail(HttpSession session, Integer productId)&#123; //1. 校验登陆 User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),"user no login"); &#125; //2. 校验角色 if(iUserService.checkAdmin(user).isSuccess())&#123; //是管理员 return iProductService.manageProductDetail(productId); &#125;else &#123; //不是管理员 return ServerResponse.createByErrorMessage("isn't Admin,need Admin's access"); &#125; &#125; /** * 分页查询 * @param session * @param pageNum * @param pageSize * @return */ @RequestMapping(value="get_product_list.do",method=RequestMethod.POST) @ResponseBody public ServerResponse get_product_list(HttpSession session, @RequestParam(value="pageNum",defaultValue = "1") int pageNum, @RequestParam(value="pageSize",defaultValue = "10") int pageSize)&#123; //1. 校验登陆 User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),"user no login"); &#125; //2. 校验角色 if(iUserService.checkAdmin(user).isSuccess())&#123; //是管理员 return iProductService.getProductList(pageNum,pageSize); &#125;else &#123; //不是管理员 return ServerResponse.createByErrorMessage("isn't Admin,need Admin's access"); &#125; &#125; /** * 根据产品id和name分页搜索 * @param session * @param productName * @param productId * @param pageNum * @param pageSize * @return */ @RequestMapping(value="product_search.do",method=RequestMethod.POST) @ResponseBody public ServerResponse product_search(HttpSession session, String productName,Integer productId, @RequestParam(value="pageNum",defaultValue = "1") int pageNum, @RequestParam(value="pageSize",defaultValue = "10") int pageSize)&#123; //1. 校验登陆 User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),"user no login"); &#125; //2. 校验角色 if(iUserService.checkAdmin(user).isSuccess())&#123; //是管理员 return iProductService.searchProduct(productName,productId,pageNum,pageSize); &#125;else &#123; //不是管理员 return ServerResponse.createByErrorMessage("isn't Admin,need Admin's access"); &#125; &#125; /** * 文件上传(SpringMVC) * @param upload_file * @param request * @return */ @RequestMapping(value="upload.do",method=RequestMethod.POST) @ResponseBody public ServerResponse upload(HttpSession session,MultipartFile upload_file, HttpServletRequest request)&#123; //1. 校验登陆 User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),"user no login"); &#125; //2. 校验角色 if(iUserService.checkAdmin(user).isSuccess())&#123; //是管理员 String path = request.getSession().getServletContext().getRealPath("upload"); String targetFileName = iFileService.upload(upload_file,path); String url = PropertiesUtil.getProperty("ftp.server.http.prefix")+targetFileName; Map&lt;String,String&gt; fileMap = new HashMap&lt;&gt;(); fileMap.put("uri",targetFileName); fileMap.put("url",url); return ServerResponse.createBySuccess(fileMap); &#125;else &#123; //不是管理员 return ServerResponse.createByErrorMessage("isn't Admin,need Admin's access"); &#125; &#125; /** * 文件上传(富文本) * @param upload_file * @param request * @return */ @RequestMapping(value="richtext_img_upload.do",method=RequestMethod.POST) @ResponseBody public Map richtext_img_upload(HttpSession session, MultipartFile upload_file, HttpServletRequest request, HttpServletResponse response)&#123; Map resultMap = Maps.newHashMap(); //1. 校验登陆 User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; resultMap.put("success",false); resultMap.put("msg","please access By Admin"); return resultMap; &#125; //2. 校验角色 if(iUserService.checkAdmin(user).isSuccess())&#123; //是管理员 //富文本是对于返回值有自己的要求，我们使用的是simditor，所以按照simditor的要求进行返回 String path = request.getSession().getServletContext().getRealPath("upload"); String targetFileName = iFileService.upload(upload_file,path); if(targetFileName==null)&#123; resultMap.put("success",false); resultMap.put("msg","upload fail"); return resultMap; &#125; String url = PropertiesUtil.getProperty("ftp.server.http.prefix")+targetFileName; resultMap.put("success",true); resultMap.put("msg","update success"); resultMap.put("file_path",url); response.addHeader("Access-Control-Allow-Headers","X-File-Name"); return resultMap; &#125;else &#123; //不是管理员 resultMap.put("success",false); resultMap.put("msg","no access"); return resultMap; &#125; &#125;&#125; ServiceInterface(Product)12345678910111213141516171819202122232425package com.mmall.service;import com.github.pagehelper.PageInfo;import com.mmall.common.ServerResponse;import com.mmall.pojo.Product;import com.mmall.vo.ProductDetailVo;/** * Created by Blemon on 2018/3/5. */public interface IProductService &#123; ServerResponse saveOrUpdateProduct(Product product); ServerResponse&lt;String&gt; setSaleStatus(Integer productId,Integer status); ServerResponse&lt;ProductDetailVo&gt; manageProductDetail(Integer productId); ServerResponse&lt;PageInfo&gt; getProductList(int pageNum, int pageSize); ServerResponse&lt;PageInfo&gt; searchProduct(String productName,Integer productId,int pageNum, int pageSize); ServerResponse&lt;ProductDetailVo&gt; getProductDetail(Integer productId); ServerResponse&lt;PageInfo&gt; getProductByKeyandCategory(String keyword,Integer categoryId,int pageNum, int pageSize,String orderBy);&#125; Interface(File)12345678910package com.mmall.service;import org.springframework.web.multipart.MultipartFile;/** * Created by Blemon on 2018/3/5. */public interface IFileService &#123; String upload(MultipartFile file,String path);&#125; Impl(Product)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284package com.mmall.service.impl;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import com.google.common.collect.Lists;import com.mmall.common.Const;import com.mmall.common.ResponseCode;import com.mmall.common.ServerResponse;import com.mmall.dao.CategoryMapper;import com.mmall.dao.ProductMapper;import com.mmall.pojo.Category;import com.mmall.pojo.Product;import com.mmall.service.ICategoreService;import com.mmall.service.IProductService;import com.mmall.util.DateTimeUtil;import com.mmall.util.PropertiesUtil;import com.mmall.vo.ProductDetailVo;import com.mmall.vo.ProductListVo;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.*;/** * Created by Blemon on 2018/3/5. */@Service("iProductService")public class ProductServiceImpl implements IProductService &#123; @Autowired private ProductMapper productMapper; @Autowired private CategoryMapper categoryMapper; @Autowired private ICategoreService iCategoreService; public ServerResponse saveOrUpdateProduct(Product product)&#123; if(product!=null)&#123; if(StringUtils.isNotBlank(product.getSubImages()))&#123; String[] subImageArray = product.getSubImages().split(","); if(subImageArray.length&gt;0)&#123; product.setMainImage(subImageArray[0]); &#125; &#125; if (product.getId()!=null)&#123; //更新 int rowCount = productMapper.updateByPrimaryKey(product); if(rowCount&gt;0)&#123; return ServerResponse.createByErrorMessage("update product suceess"); &#125; return ServerResponse.createByErrorMessage("update product fail"); &#125;else&#123; //添加 int rowCount = productMapper.insert(product); if(rowCount&gt;0)&#123; return ServerResponse.createByErrorMessage("save product suceess"); &#125; return ServerResponse.createByErrorMessage("save product fail"); &#125; &#125; return ServerResponse.createByErrorMessage("save or update fail"); &#125; public ServerResponse&lt;String&gt; setSaleStatus(Integer productId,Integer status)&#123; if(productId==null||status==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.ILLEGAL_ARGUMENT.getCode(), ResponseCode.ILLEGAL_ARGUMENT.getDesc()); &#125; Product product = new Product(); product.setId(productId); product.setStatus(status); int rowCount = productMapper.updateByPrimaryKeySelective(product); if (rowCount&gt;0)&#123; return ServerResponse.createBySuccess("update success"); &#125; return ServerResponse.createByErrorMessage("update fail"); &#125; /** * 查询详细信息 * @param productId * @return */ public ServerResponse&lt;ProductDetailVo&gt; manageProductDetail(Integer productId)&#123; if(productId==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.ILLEGAL_ARGUMENT.getCode(), ResponseCode.ILLEGAL_ARGUMENT.getDesc()); &#125; Product product = productMapper.selectByPrimaryKey(productId); if(product==null)&#123; return ServerResponse.createByErrorMessage("product already out-off"); &#125; //VO value Object //POJO--&gt;BO（Bussiness Object）--&gt;VO（View Object） ProductDetailVo productDetailVo = this.assembleProductDetailVo(product); return ServerResponse.createBySuccess(productDetailVo); &#125; /** * 快照构建 * @param product * @return */ private ProductDetailVo assembleProductDetailVo(Product product)&#123; ProductDetailVo productDetailVo = new ProductDetailVo(); productDetailVo.setId(product.getId()); productDetailVo.setSubtitle(product.getSubtitle()); productDetailVo.setPrice(product.getPrice()); productDetailVo.setMainImage(product.getMainImage()); productDetailVo.setSubImages(product.getSubImages()); productDetailVo.setCategoryId(product.getCategoryId()); productDetailVo.setDetail(product.getDetail()); productDetailVo.setName(product.getName()); productDetailVo.setStatus(product.getStatus()); productDetailVo.setStock(product.getStock()); //imageHost //parentCategoryId //createTime //updateTime productDetailVo.setImageHost(PropertiesUtil.getProperty("ftp.server.http.prefix","http://img.blemon.com/")); Category category = categoryMapper.selectByPrimaryKey(product.getCategoryId()); //如果当前商品没有所属的分类，默认商品就是根分类 if(category==null)&#123; productDetailVo.setParentCategoryId(0); &#125;else&#123; productDetailVo.setParentCategoryId(category.getParentId()); &#125; //createTime //updateTime //这两个数在DB是一个毫秒数，不利于展示 productDetailVo.setCreateTime(DateTimeUtil.dateToStrByStandard(product.getCreateTime())); productDetailVo.setUpdateTime(DateTimeUtil.dateToStrByStandard(product.getUpdateTime())); return productDetailVo; &#125; /** * 分页显示 * @param pageNum * @param pageSize * @return */ public ServerResponse&lt;PageInfo&gt; getProductList(int pageNum,int pageSize)&#123; //1.startPage--start PageHelper.startPage(pageNum,pageSize); //2.填充自己的sql查询逻辑 List&lt;Product&gt; productList = productMapper.selectList(); List&lt;ProductListVo&gt; productListVoList = new ArrayList&lt;&gt;(); for(Product productItem : productList)&#123; ProductListVo productListVo = assembleProductListVo(productItem); productListVoList.add(productListVo); &#125; //3.pageHelper收尾 PageInfo pageResult = new PageInfo(productList); pageResult.setList(productListVoList); return ServerResponse.createBySuccess(pageResult); &#125; /** * 快照构建 * @param product * @return */ private ProductListVo assembleProductListVo(Product product)&#123; ProductListVo productListVo = new ProductListVo(); productListVo.setId(product.getId()); productListVo.setName(product.getName()); productListVo.setCategoryId(product.getCategoryId()); productListVo.setImageHost(PropertiesUtil.getProperty("ftp.server.http.prefix","http://img.happymmall.com/")); productListVo.setMainImage(product.getMainImage()); productListVo.setPrice(product.getPrice()); productListVo.setSubtitle(product.getSubtitle()); productListVo.setStatus(product.getStatus()); return productListVo; &#125; /** * 分页搜索 * @param productName * @param productId * @param pageNum * @param pageSize * @return */ public ServerResponse&lt;PageInfo&gt; searchProduct(String productName,Integer productId, int pageNum, int pageSize)&#123; //1. pageHepler开启 PageHelper.startPage(pageNum,pageSize); if(StringUtils.isNotBlank(productName))&#123; productName = new StringBuilder().append("%").append(productName).append("%").toString(); &#125; //2.sql查询 List&lt;Product&gt; productList = productMapper.selectByNameAndProductId(productName,productId); List&lt;ProductListVo&gt; productListVoList = new ArrayList&lt;&gt;(); for(Product productItem : productList)&#123; ProductListVo productListVo = assembleProductListVo(productItem); productListVoList.add(productListVo); &#125; //3.pageHelper收尾 PageInfo pageResult = new PageInfo(productList); pageResult.setList(productListVoList); return ServerResponse.createBySuccess(pageResult); &#125; public ServerResponse&lt;ProductDetailVo&gt; getProductDetail(Integer productId)&#123; if(productId==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.ILLEGAL_ARGUMENT.getCode(), ResponseCode.ILLEGAL_ARGUMENT.getDesc()); &#125; Product product = productMapper.selectByPrimaryKey(productId); if(product==null||product.getStatus()!= Const.ProductStatusEnum.ON_SALE.getCode())&#123; return ServerResponse.createByErrorMessage("product already out-off"); &#125; //VO value Object //POJO--&gt;BO（Bussiness Object）--&gt;VO（View Object） ProductDetailVo productDetailVo = this.assembleProductDetailVo(product); return ServerResponse.createBySuccess(productDetailVo); &#125; public ServerResponse&lt;PageInfo&gt; getProductByKeyandCategory(String keyword,Integer categoryId, int pageNum, int pageSize,String orderBy)&#123; if(StringUtils.isBlank(keyword) &amp;&amp; categoryId==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.ILLEGAL_ARGUMENT.getCode(), ResponseCode.ILLEGAL_ARGUMENT.getDesc()); &#125; List&lt;Integer&gt; categoryIdList = new ArrayList&lt;Integer&gt;(); if(categoryId!=null)&#123; Category category = categoryMapper.selectByPrimaryKey(categoryId); if(category==null&amp;&amp;StringUtils.isBlank(keyword))&#123; //没有该分类，并且还没有关键字，这个时候返回一个空的结果集，不报错。 PageHelper.startPage(pageNum,pageSize); List&lt;ProductListVo&gt; productListVoList = Lists.newArrayList(); PageInfo pageResult = new PageInfo(productListVoList); return ServerResponse.createBySuccess(pageResult); &#125; //当前分类和其所有子分类 categoryIdList = iCategoreService.selectCtagoryAndChildrenById(categoryId).getData(); &#125; if(StringUtils.isNotBlank(keyword))&#123; keyword = new StringBuilder().append("%").append(keyword).append("%").toString(); &#125; PageHelper.startPage(pageNum,pageSize); //排序 if(StringUtils.isNotBlank(orderBy))&#123; if(Const.ProductListOrderBy.PRICE_ASC_DESC.contains(orderBy))&#123; String[] orderByArray = orderBy.split("_"); PageHelper.orderBy(orderByArray[0]+" "+orderByArray[1]); &#125; &#125; List&lt;Product&gt; productList = productMapper.selectByNameAndCategoryIds (StringUtils.isBlank(keyword)?null:keyword,categoryIdList.size()==0?null:categoryIdList); List&lt;ProductListVo&gt; productListVoList = Lists.newArrayList(); for (Product productItem:productList) &#123; ProductListVo productListVo = assembleProductListVo(productItem); productListVoList.add(productListVo); &#125; PageInfo pageResult = new PageInfo(productList);//分页 pageResult.setList(productListVoList);//显示 return ServerResponse.createBySuccess(pageResult); &#125;&#125; Impl(File)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.mmall.service.impl;import com.google.common.collect.Lists;import com.mmall.service.IFileService;import com.mmall.util.FTPUtil;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Service;import org.springframework.web.multipart.MultipartFile;import java.io.File;import java.io.IOException;import java.util.UUID;/** * Created by Blemon on 2018/3/5. */@Service("iFileService")public class FileServiceImpl implements IFileService&#123; private Logger logger = LoggerFactory.getLogger(FileServiceImpl.class); public String upload(MultipartFile file, String path)&#123; String filename = file.getOriginalFilename(); //扩展名字 //abc.abc.exe String fileExtensionName = filename.substring(filename.lastIndexOf(".")+1); //A用户：abc.jpg //B用户：abc.jpg String uploadFileName = UUID.randomUUID().toString()+"."+fileExtensionName; logger.info("开始上传文件,上传文件的文件名:&#123;&#125;,上传的路径:&#123;&#125;,新文件名:&#123;&#125;",filename,path,uploadFileName); File fileDir = new File(path); if(!fileDir.exists())&#123; fileDir.setWritable(true); fileDir.mkdirs(); &#125; File targetFile = new File(path,uploadFileName); try &#123; file.transferTo(targetFile); //文件已经上传成功 //将targetFile上传到我们的FTP服务器上 FTPUtil.uploadFile(Lists.newArrayList(targetFile)); //targetFile上传到我们的FTP服务器成功 //上传完成后，删除upload下的文件 targetFile.delete(); &#125; catch (IOException e) &#123; logger.error("上传文件异常",e); return null; &#125; return targetFile.getName(); &#125;&#125; DaoInterface123456789101112131415161718192021222324252627282930package com.mmall.dao;import com.mmall.pojo.Product;import org.apache.ibatis.annotations.Param;import java.util.List;public interface ProductMapper &#123; int deleteByPrimaryKey(Integer id); int insert(Product record); int insertSelective(Product record); Product selectByPrimaryKey(Integer id); int updateByPrimaryKeySelective(Product record); int updateByPrimaryKey(Product record); List&lt;Product&gt; selectList(); List&lt;Product&gt; selectByNameAndProductId(@Param("productName") String productName, @Param("productId") Integer productId); List&lt;Product&gt; selectByNameAndCategoryIds(@Param("productName") String productName, @Param("categoryIdList") List&lt;Integer&gt; categoryIdList);&#125; Impl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.mmall.dao.ProductMapper" &gt; &lt;resultMap id="BaseResultMap" type="com.mmall.pojo.Product" &gt; &lt;constructor &gt; &lt;idArg column="id" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="category_id" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="name" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="subtitle" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="main_image" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="sub_images" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="detail" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="price" jdbcType="DECIMAL" javaType="java.math.BigDecimal" /&gt; &lt;arg column="stock" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="status" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="create_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;arg column="update_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;/constructor&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List" &gt; id, category_id, name, subtitle, main_image, sub_images, detail, price, stock, status, create_time, update_time &lt;/sql&gt; &lt;select id="selectByPrimaryKey" resultMap="BaseResultMap" parameterType="java.lang.Integer" &gt; select &lt;include refid="Base_Column_List" /&gt; from mmall_product where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;delete id="deleteByPrimaryKey" parameterType="java.lang.Integer" &gt; delete from mmall_product where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/delete&gt; &lt;insert id="insert" parameterType="com.mmall.pojo.Product" &gt; insert into mmall_product (id, category_id, name, subtitle, main_image, sub_images, detail, price, stock, status, create_time, update_time ) values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;categoryId,jdbcType=INTEGER&#125;, #&#123;name,jdbcType=VARCHAR&#125;, #&#123;subtitle,jdbcType=VARCHAR&#125;, #&#123;mainImage,jdbcType=VARCHAR&#125;, #&#123;subImages,jdbcType=VARCHAR&#125;, #&#123;detail,jdbcType=VARCHAR&#125;, #&#123;price,jdbcType=DECIMAL&#125;, #&#123;stock,jdbcType=INTEGER&#125;, #&#123;status,jdbcType=INTEGER&#125;, now(), now() ) &lt;/insert&gt; &lt;insert id="insertSelective" parameterType="com.mmall.pojo.Product" &gt; insert into mmall_product &lt;trim prefix="(" suffix=")" suffixOverrides="," &gt; &lt;if test="id != null" &gt; id, &lt;/if&gt; &lt;if test="categoryId != null" &gt; category_id, &lt;/if&gt; &lt;if test="name != null" &gt; name, &lt;/if&gt; &lt;if test="subtitle != null" &gt; subtitle, &lt;/if&gt; &lt;if test="mainImage != null" &gt; main_image, &lt;/if&gt; &lt;if test="subImages != null" &gt; sub_images, &lt;/if&gt; &lt;if test="detail != null" &gt; detail, &lt;/if&gt; &lt;if test="price != null" &gt; price, &lt;/if&gt; &lt;if test="stock != null" &gt; stock, &lt;/if&gt; &lt;if test="status != null" &gt; status, &lt;/if&gt; &lt;if test="createTime != null" &gt; create_time, &lt;/if&gt; &lt;if test="updateTime != null" &gt; update_time, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides="," &gt; &lt;if test="id != null" &gt; #&#123;id,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="categoryId != null" &gt; #&#123;categoryId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="name != null" &gt; #&#123;name,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="subtitle != null" &gt; #&#123;subtitle,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="mainImage != null" &gt; #&#123;mainImage,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="subImages != null" &gt; #&#123;subImages,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="detail != null" &gt; #&#123;detail,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="price != null" &gt; #&#123;price,jdbcType=DECIMAL&#125;, &lt;/if&gt; &lt;if test="stock != null" &gt; #&#123;stock,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="status != null" &gt; #&#123;status,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="createTime != null" &gt; now(), &lt;/if&gt; &lt;if test="updateTime != null" &gt; now(), &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id="updateByPrimaryKeySelective" parameterType="com.mmall.pojo.Product" &gt; update mmall_product &lt;set &gt; &lt;if test="categoryId != null" &gt; category_id = #&#123;categoryId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="name != null" &gt; name = #&#123;name,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="subtitle != null" &gt; subtitle = #&#123;subtitle,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="mainImage != null" &gt; main_image = #&#123;mainImage,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="subImages != null" &gt; sub_images = #&#123;subImages,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="detail != null" &gt; detail = #&#123;detail,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="price != null" &gt; price = #&#123;price,jdbcType=DECIMAL&#125;, &lt;/if&gt; &lt;if test="stock != null" &gt; stock = #&#123;stock,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="status != null" &gt; status = #&#123;status,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="createTime != null" &gt; create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="updateTime != null" &gt; update_time = now(), &lt;/if&gt; &lt;/set&gt; where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;update id="updateByPrimaryKey" parameterType="com.mmall.pojo.Product" &gt; update mmall_product set category_id = #&#123;categoryId,jdbcType=INTEGER&#125;, name = #&#123;name,jdbcType=VARCHAR&#125;, subtitle = #&#123;subtitle,jdbcType=VARCHAR&#125;, main_image = #&#123;mainImage,jdbcType=VARCHAR&#125;, sub_images = #&#123;subImages,jdbcType=VARCHAR&#125;, detail = #&#123;detail,jdbcType=VARCHAR&#125;, price = #&#123;price,jdbcType=DECIMAL&#125;, stock = #&#123;stock,jdbcType=INTEGER&#125;, status = #&#123;status,jdbcType=INTEGER&#125;, create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;, update_time = now() where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;select id="selectList" resultMap="BaseResultMap"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_product ORDER BY id ASC &lt;/select&gt; &lt;select id="selectByNameAndProductId" resultMap="BaseResultMap" parameterType="map"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_product &lt;where&gt; &lt;if test="productName!=null"&gt; AND name LIKE #&#123;productName&#125; &lt;/if&gt; &lt;if test="productId!=null"&gt; AND id=#&#123;productId&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;select id="selectByNameAndCategoryIds" resultMap="BaseResultMap" parameterType="map"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_product &lt;where&gt; &lt;if test="productName!=null"&gt; AND name LIKE #&#123;productName&#125; &lt;/if&gt; &lt;if test="categoryIdList!=null"&gt; AND category_id IN &lt;foreach item="item" index="index" open="(" separator="," close=")" collection="categoryIdList"&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt;]]></content>
      <categories>
        <category>mmall</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分类管理模块]]></title>
    <url>%2F2018%2F03%2F05%2F%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[功能介绍获取节点 增加节点 修改名字 获取分类ID 递归子节点ID 学习目标1. 如何设计及封装无限层级的树状数据结构 2. 递归算法的设计思想 3. 如何处理复杂对象排重 4. 重写hashCode和equal的注意事项 添加分类Controller1234567891011121314151617181920212223242526/** * 添加分类 * @param session * @param categoryName * @param parentId * @return */@RequestMapping(value="add_category.do",method= RequestMethod.POST)@ResponseBodypublic ServerResponse&lt;Category&gt; add_category(HttpSession session,String categoryName,@RequestParam(value="parentId",defaultValue = "0")int parentId)&#123; //1. 校验登陆 User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),"user no login"); &#125; //2. 校验角色 if(iUserService.checkAdmin(user).isSuccess())&#123; //是管理员 return iCategoreService.addCategory(categoryName,parentId); &#125;else &#123; //不是管理员 return ServerResponse.createByErrorMessage("isn't Admin,need Admin's access"); &#125;&#125; Service(User)Interface12//backend ServerResponse&lt;String&gt; checkAdmin(User user); Impl1234567@Overridepublic ServerResponse&lt;String&gt; checkAdmin(User user)&#123; if(user!=null &amp;&amp; user.getRole().intValue()==Const.Role.ROLE_ADMIN)&#123; return ServerResponse.createBySuccessMessage("is Admin"); &#125; return ServerResponse.createByErrorMessage("isn't Admin");&#125; Service(Catrgory)Interface1ServerResponse addCategory(String categoryName,Integer parentId); Impl123456789101112131415161718@Overridepublic ServerResponse addCategory(String categoryName,Integer parentId)&#123; if(parentId==null || StringUtils.isBlank(categoryName))&#123; return ServerResponse.createByErrorMessage("params error"); &#125; Category category = new Category(); category.setName(categoryName); category.setParentId(parentId); category.setStatus(true); int rowCount = categoryMapper.insert(category); if(rowCount&gt;0)&#123; return ServerResponse.createBySuccess("addCategory success"); &#125; return ServerResponse.createByErrorMessage("addCategory fail");&#125; Dao因为利用插件自动生成了简单的增删改查，这里就不要自己再写了。 修改分类名称Controller1234567891011121314151617181920212223/** * 修改分类 * @param session * @param categoryId * @param categoryName * @return */@RequestMapping(value="set_category_name.do",method= RequestMethod.POST)@ResponseBodypublic ServerResponse set_category_name(HttpSession session,Integer categoryId,String categoryName)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),"user no login"); &#125; if(iUserService.checkAdmin(user).isSuccess())&#123; //是管理员 return iCategoreService.updateCategoryName(categoryId,categoryName); &#125;else &#123; //不是管理员 return ServerResponse.createByErrorMessage("isn't Admin,need Admin's access"); &#125;&#125; ServiceInterface1ServerResponse updateCategoryName(Integer categoryId,String categoryName); Impl12345678910111213141516@Overridepublic ServerResponse updateCategoryName(Integer categoryId,String categoryName)&#123; if(categoryId==null || StringUtils.isBlank(categoryName))&#123; return ServerResponse.createByErrorMessage("params error"); &#125; Category category = new Category(); category.setId(categoryId); category.setName(categoryName); //选择性更新，但是更新是根据主键更新的，更新的是这个主键对应对象的选择性属性 int rowCount = categoryMapper.updateByPrimaryKeySelective(category); if(rowCount&gt;0)&#123; return ServerResponse.createBySuccess("categoryNameUpdate success"); &#125; return ServerResponse.createByErrorMessage("categoryNameUpdate fail");&#125; Dao直接调用插件生成的。 查询当前节点的下一级节点Controller123456789101112131415161718192021/** * 查询当前节点的下一级同级子节点信息 * @param session * @param categoryId * @return */@RequestMapping(value="get_children_parallel_category.do",method= RequestMethod.POST)@ResponseBodypublic ServerResponse get_children_parallel_category(HttpSession session,@RequestParam(value="categoryId",defaultValue="0")Integer categoryId)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),"user no login"); &#125; if(iUserService.checkAdmin(user).isSuccess())&#123; //是管理员:查询子节点的category信息，并且不递归，保持平级。 return iCategoreService.getChildrenParallelCategory(categoryId); &#125;else &#123; //不是管理员 return ServerResponse.createByErrorMessage("isn't Admin,need Admin's access"); &#125;&#125; ServiceInterface1ServerResponse&lt;List&lt;Category&gt;&gt; getChildrenParallelCategory(Integer categoryId); Impl1234567891011private Logger logger = LoggerFactory.getLogger(CategoryServiceImpl.class);//实例变量@Override public ServerResponse&lt;List&lt;Category&gt;&gt; getChildrenParallelCategory(Integer categoryId)&#123; List&lt;Category&gt; categoryList = categoryMapper.selectCategoryChildrenByParent(categoryId); if(CollectionUtils.isEmpty(categoryList))&#123; logger.info("no subCategories By currentCategory"); &#125; return ServerResponse.createBySuccess(categoryList); &#125; DaoInterface1List&lt;Category&gt; selectCategoryChildrenByParent(Integer parent_id); Impl123456&lt;select id="selectCategoryChildrenByParent" resultMap="BaseResultMap" parameterType="int"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_category WHERE parent_id = #&#123;parent_id&#125;&lt;/select&gt; 查询当前节点所有递归的子节点idController12345678910111213141516171819202122/** * 查询当前节点和当前节点下所有递归的子节点信息 * @param session * @param categoryId * @return */@RequestMapping(value="get_deep_children_parallel_category.do",method= RequestMethod.POST)@ResponseBodypublic ServerResponse get_deep_children_parallel_category(HttpSession session,@RequestParam(value="categoryId",defaultValue="0")Integer categoryId)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),"user no login"); &#125; if(iUserService.checkAdmin(user).isSuccess())&#123; //是管理员:查询当前节点和当前节点下所有递归的子节点信息 //0--&gt;10000--&gt;100000 return iCategoreService.selectCtagoryAndChildrenById(categoryId); &#125;else &#123; //不是管理员 return ServerResponse.createByErrorMessage("isn't Admin,need Admin's access"); &#125;&#125; ServiceInterface1ServerResponse&lt;List&lt;Integer&gt;&gt; selectCtagoryAndChildrenById(Integer categoryId); Impl12345678910111213141516171819202122232425262728293031323334353637383940/** * 递归查询当前节点的所有子节点 * @param categoryId * @return */@Overridepublic ServerResponse&lt;List&lt;Integer&gt;&gt; selectCtagoryAndChildrenById(Integer categoryId)&#123; //需要去重，所以Category对象就需要重写equals和hashCode方法 //注意equals和hashCode方法的区别 Set&lt;Category&gt; categorySet = new HashSet&lt;Category&gt;(); findChildCategroy(categorySet,categoryId); List&lt;Integer&gt; categoryList = new ArrayList&lt;Integer&gt;(); for (Category categoryItem:categorySet) &#123; categoryList.add(categoryItem.getId()); &#125; return ServerResponse.createBySuccess(categoryList);&#125;/** * 递归算法实现 * @param categorySet * @param categoryId * @return */private Set&lt;Category&gt; findChildCategroy(Set&lt;Category&gt; categorySet,Integer categoryId)&#123; Category category = categoryMapper.selectByPrimaryKey(categoryId); if(category!=null)&#123; categorySet.add(category); &#125; //查找子节点，递归算法一定要有一个退出条件 List&lt;Category&gt; categoryList = categoryMapper.selectCategoryChildrenByParent(categoryId); for (Category categoryItem:categoryList) &#123; findChildCategroy(categorySet,categoryItem.getId()); &#125; return categorySet;&#125; Service实现中修改Category的hashCode与equals1234567891011121314@Overridepublic boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Category category = (Category) o; return id != null ? id.equals(category.id) : category.id == null;&#125;@Overridepublic int hashCode() &#123; return id != null ? id.hashCode() : 0;&#125; Dao不需要添加 Restlet测试 整体 Controller123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package com.mmall.controller.backend;import com.mmall.common.Const;import com.mmall.common.ResponseCode;import com.mmall.common.ServerResponse;import com.mmall.pojo.Category;import com.mmall.pojo.User;import com.mmall.service.ICategoreService;import com.mmall.service.IUserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpSession;/** * Created by Blemon on 2018/3/2. */@Controller@RequestMapping("/manage/category")public class CategoryManagerController &#123; @Autowired private IUserService iUserService; @Autowired private ICategoreService iCategoreService; /** * 添加分类 * @param session * @param categoryName * @param parentId * @return */ @RequestMapping(value="add_category.do",method= RequestMethod.POST) @ResponseBody public ServerResponse&lt;Category&gt; add_category(HttpSession session,String categoryName,@RequestParam(value="parentId",defaultValue = "0")int parentId)&#123; //1. 校验登陆 User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),"user no login"); &#125; //2. 校验角色 if(iUserService.checkAdmin(user).isSuccess())&#123; //是管理员 return iCategoreService.addCategory(categoryName,parentId); &#125;else &#123; //不是管理员 return ServerResponse.createByErrorMessage("isn't Admin,need Admin's access"); &#125; &#125; /** * 修改分类名称 * @param session * @param categoryId * @param categoryName * @return */ @RequestMapping(value="set_category_name.do",method= RequestMethod.POST) @ResponseBody public ServerResponse set_category_name(HttpSession session,Integer categoryId,String categoryName)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),"user no login"); &#125; if(iUserService.checkAdmin(user).isSuccess())&#123; //是管理员 return iCategoreService.updateCategoryName(categoryId,categoryName); &#125;else &#123; //不是管理员 return ServerResponse.createByErrorMessage("isn't Admin,need Admin's access"); &#125; &#125; /** * 查询当前节点的下一级同级子节点信息 * @param session * @param categoryId * @return */ @RequestMapping(value="get_children_parallel_category.do",method= RequestMethod.POST) @ResponseBody public ServerResponse get_children_parallel_category(HttpSession session,@RequestParam(value="categoryId",defaultValue="0")Integer categoryId)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),"user no login"); &#125; if(iUserService.checkAdmin(user).isSuccess())&#123; //是管理员:查询子节点的category信息，并且不递归，保持平级。 return iCategoreService.getChildrenParallelCategory(categoryId); &#125;else &#123; //不是管理员 return ServerResponse.createByErrorMessage("isn't Admin,need Admin's access"); &#125; &#125; /** * 查询当前节点和当前节点下所有递归的子节点信息 * @param session * @param categoryId * @return */ @RequestMapping(value="get_deep_children_parallel_category.do",method= RequestMethod.POST) @ResponseBody public ServerResponse get_deep_children_parallel_category(HttpSession session,@RequestParam(value="categoryId",defaultValue="0")Integer categoryId)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),"user no login"); &#125; if(iUserService.checkAdmin(user).isSuccess())&#123; //是管理员:查询当前节点和当前节点下所有递归的子节点信息 //0--&gt;10000--&gt;100000 return iCategoreService.selectCtagoryAndChildrenById(categoryId); &#125;else &#123; //不是管理员 return ServerResponse.createByErrorMessage("isn't Admin,need Admin's access"); &#125; &#125;&#125; ServiceInterface123456789101112131415161718package com.mmall.service;import com.mmall.common.ServerResponse;import com.mmall.pojo.Category;import java.util.*;/** * Created by Blemon on 2018/3/2. */public interface ICategoreService &#123; ServerResponse addCategory(String categoryName,Integer parentId); ServerResponse updateCategoryName(Integer categoryId,String categoryName); ServerResponse&lt;List&lt;Category&gt;&gt; getChildrenParallelCategory(Integer categoryId); ServerResponse&lt;List&lt;Integer&gt;&gt; selectCtagoryAndChildrenById(Integer categoryId);&#125; Impl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package com.mmall.service.impl;import com.mmall.common.ServerResponse;import com.mmall.dao.CategoryMapper;import com.mmall.pojo.Category;import com.mmall.service.ICategoreService;import org.apache.commons.collections.CollectionUtils;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.ArrayList;import java.util.HashSet;import java.util.List;import java.util.Set;/** * Created by Blemon on 2018/3/2. */@Service("iCategoryService")public class CategoryServiceImpl implements ICategoreService&#123; private Logger logger = LoggerFactory.getLogger(CategoryServiceImpl.class); @Autowired private CategoryMapper categoryMapper; @Override public ServerResponse addCategory(String categoryName,Integer parentId)&#123; if(parentId==null || StringUtils.isBlank(categoryName))&#123; return ServerResponse.createByErrorMessage("params error"); &#125; Category category = new Category(); category.setName(categoryName); category.setParentId(parentId); category.setStatus(true); int rowCount = categoryMapper.insert(category); if(rowCount&gt;0)&#123; return ServerResponse.createBySuccess("addCategory success"); &#125; return ServerResponse.createByErrorMessage("addCategory fail"); &#125; @Override public ServerResponse updateCategoryName(Integer categoryId,String categoryName)&#123; if(categoryId==null || StringUtils.isBlank(categoryName))&#123; return ServerResponse.createByErrorMessage("params error"); &#125; Category category = new Category(); category.setId(categoryId); category.setName(categoryName); //选择性更新，但是更新是根据主键更新的，更新的是这个主键对应对象的选择性属性 int rowCount = categoryMapper.updateByPrimaryKeySelective(category); if(rowCount&gt;0)&#123; return ServerResponse.createBySuccess("categoryNameUpdate success"); &#125; return ServerResponse.createByErrorMessage("categoryNameUpdate fail"); &#125; @Override public ServerResponse&lt;List&lt;Category&gt;&gt; getChildrenParallelCategory(Integer categoryId)&#123; List&lt;Category&gt; categoryList = categoryMapper.selectCategoryChildrenByParent(categoryId); if(CollectionUtils.isEmpty(categoryList))&#123; logger.info("no subCategories By currentCategory"); &#125; return ServerResponse.createBySuccess(categoryList); &#125; /** * 递归查询当前节点的所有子节点 * @param categoryId * @return */ @Override public ServerResponse&lt;List&lt;Integer&gt;&gt; selectCtagoryAndChildrenById(Integer categoryId)&#123; //需要去重，所以Category对象就需要重写equals和hashCode方法 //注意equals和hashCode方法的区别 Set&lt;Category&gt; categorySet = new HashSet&lt;Category&gt;(); findChildCategroy(categorySet,categoryId); List&lt;Integer&gt; categoryList = new ArrayList&lt;Integer&gt;(); for (Category categoryItem:categorySet) &#123; categoryList.add(categoryItem.getId()); &#125; return ServerResponse.createBySuccess(categoryList); &#125; /** * 递归算法实现 * @param categorySet * @param categoryId * @return */ private Set&lt;Category&gt; findChildCategroy(Set&lt;Category&gt; categorySet,Integer categoryId)&#123; Category category = categoryMapper.selectByPrimaryKey(categoryId); if(category!=null)&#123; categorySet.add(category); &#125; //查找子节点，递归算法一定要有一个退出条件 List&lt;Category&gt; categoryList = categoryMapper.selectCategoryChildrenByParent(categoryId); for (Category categoryItem:categoryList) &#123; findChildCategroy(categorySet,categoryItem.getId()); &#125; return categorySet; &#125;&#125; DaoInterface1234567891011121314151617181920package com.mmall.dao;import com.mmall.pojo.Category;import java.util.*;public interface CategoryMapper &#123; int deleteByPrimaryKey(Integer id); int insert(Category record); int insertSelective(Category record); Category selectByPrimaryKey(Integer id); int updateByPrimaryKeySelective(Category record); int updateByPrimaryKey(Category record); List&lt;Category&gt; selectCategoryChildrenByParent(Integer parent_id);&#125; Impl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.mmall.dao.CategoryMapper" &gt; &lt;resultMap id="BaseResultMap" type="com.mmall.pojo.Category" &gt; &lt;constructor &gt; &lt;idArg column="id" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="parent_id" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="name" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="status" jdbcType="BIT" javaType="java.lang.Boolean" /&gt; &lt;arg column="sort_order" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="create_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;arg column="update_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;/constructor&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List" &gt; id, parent_id, name, status, sort_order, create_time, update_time &lt;/sql&gt; &lt;select id="selectByPrimaryKey" resultMap="BaseResultMap" parameterType="java.lang.Integer" &gt; select &lt;include refid="Base_Column_List" /&gt; from mmall_category where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;delete id="deleteByPrimaryKey" parameterType="java.lang.Integer" &gt; delete from mmall_category where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/delete&gt; &lt;insert id="insert" parameterType="com.mmall.pojo.Category" &gt; insert into mmall_category (id, parent_id, name, status, sort_order, create_time, update_time) values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;parentId,jdbcType=INTEGER&#125;, #&#123;name,jdbcType=VARCHAR&#125;, #&#123;status,jdbcType=BIT&#125;, #&#123;sortOrder,jdbcType=INTEGER&#125;, now(), now()) &lt;/insert&gt; &lt;insert id="insertSelective" parameterType="com.mmall.pojo.Category" &gt; insert into mmall_category &lt;trim prefix="(" suffix=")" suffixOverrides="," &gt; &lt;if test="id != null" &gt; id, &lt;/if&gt; &lt;if test="parentId != null" &gt; parent_id, &lt;/if&gt; &lt;if test="name != null" &gt; name, &lt;/if&gt; &lt;if test="status != null" &gt; status, &lt;/if&gt; &lt;if test="sortOrder != null" &gt; sort_order, &lt;/if&gt; &lt;if test="createTime != null" &gt; create_time, &lt;/if&gt; &lt;if test="updateTime != null" &gt; update_time, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides="," &gt; &lt;if test="id != null" &gt; #&#123;id,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="parentId != null" &gt; #&#123;parentId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="name != null" &gt; #&#123;name,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="status != null" &gt; #&#123;status,jdbcType=BIT&#125;, &lt;/if&gt; &lt;if test="sortOrder != null" &gt; #&#123;sortOrder,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="createTime != null" &gt; now(), &lt;/if&gt; &lt;if test="updateTime != null" &gt; now(), &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id="updateByPrimaryKeySelective" parameterType="com.mmall.pojo.Category" &gt; update mmall_category &lt;set &gt; &lt;if test="parentId != null" &gt; parent_id = #&#123;parentId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="name != null" &gt; name = #&#123;name,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="status != null" &gt; status = #&#123;status,jdbcType=BIT&#125;, &lt;/if&gt; &lt;if test="sortOrder != null" &gt; sort_order = #&#123;sortOrder,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="createTime != null" &gt; create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="updateTime != null" &gt; update_time = now(), &lt;/if&gt; &lt;/set&gt; where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;update id="updateByPrimaryKey" parameterType="com.mmall.pojo.Category" &gt; update mmall_category set parent_id = #&#123;parentId,jdbcType=INTEGER&#125;, name = #&#123;name,jdbcType=VARCHAR&#125;, status = #&#123;status,jdbcType=BIT&#125;, sort_order = #&#123;sortOrder,jdbcType=INTEGER&#125;, create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;, update_time = now() where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;select id="selectCategoryChildrenByParent" resultMap="BaseResultMap" parameterType="int"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; FROM mmall_category WHERE parent_id = #&#123;parent_id&#125; &lt;/select&gt;&lt;/mapper&gt;]]></content>
      <categories>
        <category>mmall</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户模块]]></title>
    <url>%2F2018%2F03%2F04%2F%E7%94%A8%E6%88%B7%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[功能介绍登陆、用户名验证、注册、忘记密码、提交问题答案、重置密码、获取用户信息、更新用户信息、退出登陆 学习目标1. 横向越权、纵向越权安全漏洞 2. MD5明文加密以及增加salt值 3. Guava缓存的使用 4. 高复用服务响应对象的设计思想以及抽象封装 5. Session使用 6. 方法的局部演进 横向、纵向越权横向：攻击者尝试访问与其拥有相同权限的用户的资源 纵向：低级别尝试访问高级别用户的资源 接口设计用户登陆公用接口类 ResponseCode123456789101112131415161718192021222324/** * 响应编码的枚举类 */public enum ResponseCode &#123; SUCCESS(0,"SUCCESS"), ERROR(1,"ERROR"), NEED_LOGIN(10,"NEED_LOGIN"), ILLEGAL_ARGUMENT(2,"ILLEGAL_ARGUMENT"); private final int code; private final String desc; ResponseCode(int code,String desc)&#123; this.code = code; this.desc = desc; &#125; public int getCode()&#123; return code; &#125; public String getDesc()&#123; return desc; &#125;&#125; ServerResponse12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.mmall.common;import org.codehaus.jackson.annotate.JsonIgnore;import org.codehaus.jackson.map.annotate.JsonSerialize;import java.io.Serializable;/** * Created by Blemon on 2018/2/28. *///保证序列化JSON的时候，如果是null的对象，key也会消失。@JsonSerialize(include = JsonSerialize.Inclusion.NON_NULL)public class ServerResponse&lt;T&gt; implements Serializable&#123; private int status; private String msg; private T data; private ServerResponse(int status)&#123; this.status = status; &#125; private ServerResponse(int status,T data)&#123; this.status = status; this.data = data; &#125; private ServerResponse(int status,String msg)&#123; this.status = status; this.msg = msg; &#125; private ServerResponse(int status,T data,String msg)&#123; this.status = status; this.data = data; this.msg = msg; &#125; @JsonIgnore//序列化的时候不要这个 public boolean isSuccess()&#123; return this.status==ResponseCode.SUCCESS.getCode(); &#125; public int getStatus()&#123; return status; &#125; public String getMsg()&#123; return msg; &#125; public T getData()&#123; return data; &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccess()&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode()); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccessMessage(String msg)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode(),msg); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccess(T data)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode(),data); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccess(String msg,T data)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode(),data,msg); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createByError()&#123; return new ServerResponse&lt;T&gt;(ResponseCode.ERROR.getCode(),ResponseCode.ERROR.getDesc()); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createByErrorMessage(String errorMessage)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.ERROR.getCode(),errorMessage); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createByErrorCodeMessage(int errorCode,String errorMessage)&#123; return new ServerResponse&lt;T&gt;(errorCode,errorMessage); &#125;&#125; Const123public class Const &#123; public static final String CURRENT_USER = "currentUser";&#125; ControllerUserContoller.java1234567891011121314151617181920212223242526@Controller@RequestMapping("/user/")public class UserController &#123; @Autowired private IUserService iUserService; /** * 用户登陆 * @param username * @param password * @param session * @return */ @RequestMapping(value="login.do",method= RequestMethod.POST) @ResponseBody//将函数返回值序列化成JSON public ServerResponse&lt;User&gt; login(String username, String password, HttpSession session)&#123; //service--&gt;mybatis--&gt;dao ServerResponse&lt;User&gt; response = iUserService.login(username,password); if(response.isSuccess())&#123; session.setAttribute(Const.CURRENT_USER,response.getData()); &#125; return response; &#125;&#125; ServiceInterface123public interface IUserService &#123; ServerResponse&lt;User&gt; login(String username, String password);&#125; Implement123456789101112131415161718192021222324252627@Service("iUserService")public class UserServiceImpl implements IUserService &#123; @Autowired private UserMapper userMapper; @Override public ServerResponse&lt;User&gt; login(String username, String password)&#123; //1. 用户名是否存在 int resultCount = userMapper.checkUsername(username); if(resultCount==0)&#123; return ServerResponse.createByErrorMessage("Username not exist"); &#125; //2. // TODO: 2018/2/28 MD5密码登陆 //3. 用户名和密码是否匹配 User user = userMapper.selectLogin(username,password); if(user==null)&#123; return ServerResponse.createByErrorMessage("Password is Error"); &#125; user.setPassword(StringUtils.EMPTY); return ServerResponse.createBySuccess("Success",user); &#125;&#125; DaoInterface1234567891011121314151617public interface UserMapper &#123; int deleteByPrimaryKey(Integer id); int insert(User record); int insertSelective(User record); User selectByPrimaryKey(Integer id); int updateByPrimaryKeySelective(User record); int updateByPrimaryKey(User record); int checkUsername(String username); User selectLogin(@Param("username") String username, @Param("password")String password);//多个参数需要用到注解&#125; mappers/UserMapper.xml123456789101112&lt;select id="checkUsername" resultType="int" parameterType="string"&gt; select count(1) from mmall_user where username=#&#123;username&#125;&lt;/select&gt;&lt;select id="selectLogin" resultMap="BaseResultMap" parameterType="map"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; from mmall_user where username = #&#123;username&#125; and password = #&#123;password&#125;&lt;/select&gt; 登出功能Controller1234567891011/** * 登出功能 * @param session * @return */@RequestMapping(value="logout.do",method= RequestMethod.GET)@ResponseBody//将函数返回值序列化成JSONpublic ServerResponse&lt;String&gt; logout(HttpSession session)&#123; session.removeAttribute(Const.CURRENT_USER);//直接从Session中把当前用户这个属性移除就可以了 return ServerResponse.createBySuccess();&#125; 注册Controller12345678910/** * 注册 * @param user * @return */ @RequestMapping(value="register.do",method= RequestMethod.GET) @ResponseBody//将函数返回值序列化成JSON public ServerResponse&lt;String&gt; register(User user)&#123; return iUserService.register(user); &#125; ServiceInterface1234567public interface IUserService &#123; ServerResponse&lt;User&gt; login(String username, String password); ServerResponse&lt;String&gt; register(User user); ServerResponse&lt;String&gt; checkValid(String str,String type);&#125; Impl1234567891011121314151617181920212223242526272829303132333435@Overridepublic ServerResponse&lt;String&gt; register(User user)&#123; //1. 用户名是否存在 /*int resultCount = userMapper.checkUsername(user.getUsername()); if(resultCount&gt;0) &#123; return ServerResponse.createByErrorMessage("用户名已存在"); &#125;*/ ServerResponse validResponse = this.checkValid(user.getUsername(),Const.USERNAME); if(!validResponse.isSuccess())&#123; return validResponse; &#125; //2. Email是否存在 /*resultCount = userMapper.checkEmail(user.getEmail()); if(resultCount&gt;0) &#123; return ServerResponse.createByErrorMessage("Email已存在"); &#125;*/ validResponse = this.checkValid(user.getEmail(),Const.EMAIL); if(!validResponse.isSuccess())&#123; return validResponse; &#125; //3.默认角色是普通用户 user.setRole(Const.Role.ROLE_CUSTOMER); //4. MD5加密（非对称加密） user.setPassword(MD5Util.MD5EncodeUtf8(user.getPassword())); //5. 插入数据库 int resultCount = userMapper.insert(user); if(resultCount == 0)&#123; return ServerResponse.createByErrorMessage("Register Fail , DB Fail"); &#125; return ServerResponse.createBySuccessMessage("Register Success");&#125; DaoInterface12345678910111213141516171819public interface UserMapper &#123; int deleteByPrimaryKey(Integer id); int insert(User record); int insertSelective(User record); User selectByPrimaryKey(Integer id); int updateByPrimaryKeySelective(User record); int updateByPrimaryKey(User record); int checkUsername(String username); User selectLogin(@Param("username") String username, @Param("password")String password); int checkEmail(String email);&#125; Impl1234567891011121314151617&lt;select id="checkUsername" resultType="int" parameterType="string"&gt; select count(1) from mmall_user where username=#&#123;username&#125;&lt;/select&gt;&lt;select id="selectLogin" resultMap="BaseResultMap" parameterType="map"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; from mmall_user where username = #&#123;username&#125; and password = #&#123;password&#125;&lt;/select&gt;&lt;select id="checkEmail" resultType="int" parameterType="string"&gt; select count(1) from mmall_user where email=#&#123;email&#125;&lt;/select&gt; 前台实时校验Controller1234567891011/** * 前台实时校验 * @param str * @param type * @return */@RequestMapping(value="check_valid.do",method= RequestMethod.GET)@ResponseBody//将函数返回值序列化成JSONpublic ServerResponse&lt;String&gt; checkValid(String str,String type)&#123; return iUserService.checkValid(str,type);&#125; ServiceInterface1234567public interface IUserService &#123; ServerResponse&lt;User&gt; login(String username, String password); ServerResponse&lt;String&gt; register(User user); ServerResponse&lt;String&gt; checkValid(String str,String type);&#125; Impl123456789101112131415161718192021@Overridepublic ServerResponse&lt;String&gt; checkValid(String str,String type)&#123; if(StringUtils.isNotBlank(type))&#123; //开始校验 if(Const.USERNAME.equals(type))&#123; int resultCount = userMapper.checkUsername(str); if(resultCount&gt;0) &#123; return ServerResponse.createByErrorMessage("用户名已存在"); &#125; &#125; if(Const.EMAIL.equals(type))&#123; int resultCount = userMapper.checkEmail(str); if(resultCount&gt;0) &#123; return ServerResponse.createByErrorMessage("Email已存在"); &#125; &#125; &#125;else&#123; return ServerResponse.createByErrorMessage("Params Error"); &#125; return ServerResponse.createBySuccessMessage("Valid Success");&#125; DaoDao层只需要掉之前写好的接口就可以了，不需要多写接口。 Const1.11.0在用户登陆模块中记录 1234567891011public class Const &#123; public static final String CURRENT_USER = "currentUser"; public interface Role&#123; int ROLE_CUSTOMER = 0; int ROLE_ADMIN = 1; &#125; public static final String EMAIL = "email"; public static final String USERNAME = "username";&#125; 获取用户信息Controller1234567891011121314 /** * 获取用户信息 * @param session * @return */@RequestMapping(value="get_user_info.do",method= RequestMethod.GET)@ResponseBody//将函数返回值序列化成JSONpublic ServerResponse&lt;User&gt; getUserInfo(HttpSession session)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user!=null)&#123; return ServerResponse.createBySuccess(user); &#125; return ServerResponse.createByErrorMessage("User no Login");&#125; Service&amp;Dao因为用户信息是直接从登陆的Session中拿的，所以这里不需要在进行调用 根据用户名查找密码提示问题Controller12345678910/** * 通过用户名查找密码提示问题 * @param username * @return */@RequestMapping(value="forget_get_question.do",method= RequestMethod.GET)@ResponseBody//将函数返回值序列化成JSONpublic ServerResponse&lt;String&gt; forgetGetQuestion(String username)&#123; return iUserService.selectQuestion(username);&#125; ServiceInterface1ServerResponse&lt;String&gt; selectQuestion(String username); Impl12345678910111213141516@Overridepublic ServerResponse&lt;String&gt; selectQuestion(String username)&#123; ServerResponse validResponse = this.checkValid(username,Const.USERNAME); if(validResponse.isSuccess())&#123; //validResponse,当用户名存在的时候，状态码不是0，所以当if为true的时候，说明状态码是0，用户名不存在 //用户不存在 return ServerResponse.createByErrorMessage("User no Exits"); &#125; String question = userMapper.selectQuestionByUsername(username); if(StringUtils.isNoneBlank(question))&#123; return ServerResponse.createBySuccessMessage(question); &#125; return ServerResponse.createByErrorMessage("question is void");&#125; DaoInterface1String selectQuestionByUsername(String username); Impl1234&lt;select id="selectQuestionByUsername" resultType="string" parameterType="string"&gt; SELECT question from mmall_user WHERE username = #&#123;username&#125;&lt;/select&gt; 匹配问题答案（本地缓存）Controller123456789101112/** * 根据用户名、问题、键入的答案匹配是否查到(本地缓存检查) * @param username * @param question * @param answer * @return */@RequestMapping(value="forget_check_answer.do",method= RequestMethod.GET)@ResponseBody//将函数返回值序列化成JSONpublic ServerResponse&lt;String&gt; forgetCheckAnswer(String username,String question,String answer)&#123; return iUserService.forgetCheckAnswer(username,question,answer);&#125; ServiceInterface1ServerResponse&lt;String&gt; forgetCheckAnswer(String username,String question,String answer); 本地缓存（TokenCache.java）12345678910111213141516171819202122232425262728293031public class TokenCache &#123; private static Logger logger = LoggerFactory.getLogger(TokenCache.class); //LRU算法 private static LoadingCache&lt;String,String&gt; localCache = CacheBuilder.newBuilder().initialCapacity(1000).maximumSize(10000).expireAfterAccess(12, TimeUnit.HOURS) .build(new CacheLoader&lt;String, String&gt;() &#123; //默认的数据加载实现，当调用get取值的时候，如果key没有对应的值，就调用这个方法进行记载。 @Override public String load(String s) throws Exception &#123; return "null"; &#125; &#125;); public static void setKey(String key,String value)&#123; localCache.put(key,value); &#125; public static String getKey(String key)&#123; String value = null; try&#123; value = localCache.get(key); if("null".equals(value))&#123; return null; &#125; return value; &#125;catch (Exception e)&#123; logger.error("localCache is error",e); &#125; return null; &#125;&#125; Impl1234567891011@Overridepublic ServerResponse&lt;String&gt; forgetCheckAnswer(String username,String question,String answer)&#123; int resultCount = userMapper.checkAnswer(username,question,answer); if(resultCount&gt;0)&#123; //说明问题以及问题答案是这个用户的，并且是正确的 String forgetToken = UUID.randomUUID().toString(); TokenCache.setKey("token_"+username,forgetToken); return ServerResponse.createBySuccess(forgetToken); &#125; return ServerResponse.createByErrorMessage("answer is error");&#125; DaoInterface1int checkAnswer(@Param("username")String username,@Param("question")String question,@Param("answer")String answer); Impl123456&lt;select id="checkAnswer" resultType="int" parameterType="map"&gt; SELECT count(1) from mmall_user WHERE username = #&#123;username&#125; and question = #&#123;question&#125; and answer = #&#123;answer&#125;&lt;/select&gt; 忘记密码后重置密码Controller123456789101112/** * 忘记密码修改密码 * @param username * @param passwordNew * @param forgetToken * @return */@RequestMapping(value="forget_reset_password.do",method= RequestMethod.GET)@ResponseBody//将函数返回值序列化成JSONpublic ServerResponse&lt;String&gt; forgetResetPassword(String username,String passwordNew,String forgetToken)&#123; return iUserService.forgetResetPassword(username,passwordNew,forgetToken);&#125; ServiceInterface1ServerResponse&lt;String&gt; forgetResetPassword(String username,String passwordNew,String forgetToken); Impl1234567891011121314151617181920212223242526272829303132@Overridepublic ServerResponse&lt;String&gt; forgetResetPassword(String username,String passwordNew,String forgetToken)&#123; //1. 校验Token if(StringUtils.isBlank(forgetToken))&#123; return ServerResponse.createByErrorMessage("frogetToken is null"); &#125; //2. 校验用户是否存在 ServerResponse validResponse = this.checkValid(username,Const.USERNAME); if(validResponse.isSuccess())&#123; //validResponse,当用户名存在的时候，状态码不是0，所以当if为true的时候，说明状态码是0，用户名不存在 //用户不存在 return ServerResponse.createByErrorMessage("User no Exits"); &#125; String token = TokenCache.getKey(TokenCache.TOKEN_PREFIX+username); if(StringUtils.isBlank(token))&#123; return ServerResponse.createByErrorMessage("token is invalid"); &#125; //if(token.equals(forgetToken)) if(StringUtils.equals(forgetToken,token))&#123; String md5Password = MD5Util.MD5EncodeUtf8(passwordNew); int rowCount = userMapper.updatePasswordByUsername(username,md5Password); if(rowCount&gt;0)&#123; return ServerResponse.createBySuccessMessage("update password to successful"); &#125; &#125;else&#123; return ServerResponse.createByErrorMessage("token is error"); &#125; return ServerResponse.createByErrorMessage("update password is fail");&#125; DaoInterface1int updatePasswordByUsername(@Param("username")String username,@Param("passwordNew")String passwordNew); Impl12345&lt;update id="updatePasswordByUsername" parameterType="map"&gt; UPDATE mmall_user SET password = #&#123;password&#125;,update_time = now() WHERE username = #&#123;username&#125;&lt;/update&gt; 在线修改密码Controller12345678910111213141516/** * 在线修改密码 * @param session * @param passwordOld * @param passwordNew * @return */@RequestMapping(value="reset_password.do",method= RequestMethod.GET)@ResponseBody//将函数返回值序列化成JSONpublic ServerResponse&lt;String&gt; resetPassword(HttpSession session,String passwordOld,String passwordNew)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorMessage("user is unLogin"); &#125; return iUserService.resetPassword(passwordOld,passwordNew,user);&#125; ServiceInterface1ServerResponse&lt;String&gt; resetPassword(String passwordOld,String passwordNew,User user); Impl1234567891011121314151617181920@Overridepublic ServerResponse&lt;String&gt; resetPassword(String passwordOld,String passwordNew,User user)&#123; //防止横向越权，要校验一下这个用户的旧密码，一定要指定是这个用户。 //因为我们会查询一个count(1)，如果不指定id，那么结果就是true，count&gt;0 int resultCount = userMapper.checkPassword(MD5Util.MD5EncodeUtf8(passwordOld),user.getId()); if(resultCount==0)&#123; return ServerResponse.createByErrorMessage("password is error"); &#125; user.setPassword(MD5Util.MD5EncodeUtf8(passwordNew)); int updateCount = userMapper.updateByPrimaryKeySelective(user); if(updateCount==0)&#123; return ServerResponse.createByErrorMessage("update password fail"); &#125; return ServerResponse.createBySuccessMessage("update password success");&#125; DaoInterface1int checkPassword(@Param("username")String password,@Param("userId")Integer userId); Impl123456789101112131415161718192021222324252627282930313233343536 &lt;select id="checkPassword" resultType="int" parameterType="map"&gt; SELECT count(1) from mmall_user WHERE id = #&#123;userId&#125; AND password = #&#123;password&#125; &lt;/select&gt;``` # 更新个人信息## Controller```java /** * 更新用户信息 * @param session * @param user * @return */ @RequestMapping(value="update_information.do",method= RequestMethod.GET) @ResponseBody//将函数返回值序列化成JSON public ServerResponse&lt;User&gt; update_information(HttpSession session,User user)&#123; User currentUser = (User)session.getAttribute(Const.CURRENT_USER); if(currentUser==null)&#123; return ServerResponse.createByErrorMessage("user is unLogin"); &#125; user.setId(currentUser.getId()); user.setUsername(currentUser.getUsername()); ServerResponse&lt;User&gt; response = iUserService.updateInformation(user); if(response.isSuccess())&#123; response.getData().setUsername(currentUser.getUsername()); session.setAttribute(Const.CURRENT_USER,response); &#125; return response; &#125; ServiceInterface1ServerResponse&lt;User&gt; updateInformation(User user); Impl1234567891011121314151617181920212223242526@Overridepublic ServerResponse&lt;User&gt; updateInformation(User user)&#123; //username不可更新 //eamil也要进行一个校验，校验新的email是否存在， //并且存在的email如果相同的话，不能是我们当前的这个用户的。 int resultCount = userMapper.checkEmailByUserId(user.getEmail(),user.getId()); if(resultCount&gt;0)&#123; return ServerResponse.createByErrorMessage("eamil is exist"); &#125; //快照更新 User updateUser = new User(); updateUser.setId(user.getId()); //updateUser.setUsername(user.getUsername()); updateUser.setEmail(user.getEmail()); updateUser.setPhone(user.getPhone()); updateUser.setQuestion(user.getQuestion()); updateUser.setAnswer(user.getAnswer()); int updateCount = userMapper.updateByPrimaryKeySelective(updateUser); if(updateCount&gt;0)&#123; return ServerResponse.createBySuccess("update success",updateUser); &#125; return ServerResponse.createByErrorMessage("update fail");&#125; DaoInterface1int checkEmailByUserId(@Param("email")String email,@Param("userId")Integer userId); Impl12345&lt;select id="checkEmailByUserId" resultType="int" parameterType="map"&gt; SELECT count(1) from mmall_user WHERE email = #&#123;email&#125; AND id !=#&#123;userId&#125;&lt;/select&gt; 查询用户信息Controller1234567891011121314/** * 查询用户个人信息 * @param session * @return */@RequestMapping(value="get_information.do",method= RequestMethod.GET)@ResponseBody//将函数返回值序列化成JSONpublic ServerResponse&lt;User&gt; get_information(HttpSession session)&#123; User currentUser = (User)session.getAttribute(Const.CURRENT_USER); if(currentUser==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),"please login"); &#125; return iUserService.getInformation(currentUser.getId());&#125; Service&amp;Dao用户信息直接从Session中获取，不需要在写接口。 后台登陆Controller1234567891011121314151617181920212223@Controller@RequestMapping("/manager/user/")public class UserManagerController &#123; @Autowired private IUserService iUserService; @RequestMapping(value="login.do",method= RequestMethod.POST) @ResponseBody//将函数返回值序列化成JSON public ServerResponse&lt;User&gt; login(String username, String password, HttpSession session)&#123; ServerResponse&lt;User&gt; response = iUserService.login(username,password); if(response.isSuccess())&#123; User user = response.getData(); if(user.getRole() == Const.Role.ROLE_ADMIN)&#123; session.setAttribute(Const.CURRENT_USER,user); return response; &#125;else&#123; return ServerResponse.createByErrorMessage("not Manager"); &#125; &#125; return response; &#125;&#125; User接口测试利用Restlet进行接口测试，接收都是以JSON格式接收。 整体 com.mmall.commonConst12345678910111213141516package com.mmall.common;/** * Created by Blemon on 2018/2/28. */public class Const &#123; public static final String CURRENT_USER = "currentUser"; public interface Role&#123; int ROLE_CUSTOMER = 0; int ROLE_ADMIN = 1; &#125; public static final String EMAIL = "email"; public static final String USERNAME = "username";&#125; ResponseCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package com.mmall.common;/** * Created by Blemon on 2018/2/28. *//** * 响应编码的枚举类 */public enum ResponseCode &#123; SUCCESS(0,"SUCCESS"), ERROR(1,"ERROR"), NEED_LOGIN(10,"NEED_LOGIN"), ILLEGAL_ARGUMENT(2,"ILLEGAL_ARGUMENT"); private final int code; private final String desc; ResponseCode(int code,String desc)&#123; this.code = code; this.desc = desc; &#125; public int getCode()&#123; return code; &#125; public String getDesc()&#123; return desc; &#125;&#125;``` ### ServerResponse```javapackage com.mmall.common;import org.codehaus.jackson.annotate.JsonIgnore;import org.codehaus.jackson.map.annotate.JsonSerialize;import java.io.Serializable;/** * Created by Blemon on 2018/2/28. *///保证序列化JSON的时候，如果是null的对象，key也会消失。@JsonSerialize(include = JsonSerialize.Inclusion.NON_NULL)public class ServerResponse&lt;T&gt; implements Serializable&#123; private int status; private String msg; private T data; private ServerResponse(int status)&#123; this.status = status; &#125; private ServerResponse(int status,T data)&#123; this.status = status; this.data = data; &#125; private ServerResponse(int status,String msg)&#123; this.status = status; this.msg = msg; &#125; private ServerResponse(int status,T data,String msg)&#123; this.status = status; this.data = data; this.msg = msg; &#125; @JsonIgnore//序列化的时候不要这个 public boolean isSuccess()&#123; return this.status==ResponseCode.SUCCESS.getCode(); &#125; public int getStatus()&#123; return status; &#125; public String getMsg()&#123; return msg; &#125; public T getData()&#123; return data; &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccess()&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode()); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccessMessage(String msg)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode(),msg); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccess(T data)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode(),data); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createBySuccess(String msg,T data)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.SUCCESS.getCode(),data,msg); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createByError()&#123; return new ServerResponse&lt;T&gt;(ResponseCode.ERROR.getCode(),ResponseCode.ERROR.getDesc()); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createByErrorMessage(String errorMessage)&#123; return new ServerResponse&lt;T&gt;(ResponseCode.ERROR.getCode(),errorMessage); &#125; public static &lt;T&gt; ServerResponse&lt;T&gt; createByErrorCodeMessage(int errorCode,String errorMessage)&#123; return new ServerResponse&lt;T&gt;(errorCode,errorMessage); &#125;&#125; TokenCache12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.mmall.common;import com.google.common.cache.CacheBuilder;import com.google.common.cache.CacheLoader;import com.google.common.cache.LoadingCache;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.concurrent.TimeUnit;/** * Created by Blemon on 2018/3/1. */public class TokenCache &#123; private static Logger logger = LoggerFactory.getLogger(TokenCache.class); public static final String TOKEN_PREFIX = "token_"; //LRU算法 private static LoadingCache&lt;String,String&gt; localCache = CacheBuilder.newBuilder().initialCapacity(1000).maximumSize(10000).expireAfterAccess(12, TimeUnit.HOURS) .build(new CacheLoader&lt;String, String&gt;() &#123; //默认的数据加载实现，当调用get取值的时候，如果key没有对应的值，就调用这个方法进行记载。 @Override public String load(String s) throws Exception &#123; return "null"; &#125; &#125;); public static void setKey(String key,String value)&#123; localCache.put(key,value); &#125; public static String getKey(String key)&#123; String value = null; try&#123; value = localCache.get(key); if("null".equals(value))&#123; return null; &#125; return value; &#125;catch (Exception e)&#123; logger.error("localCache is error",e); &#125; return null; &#125;&#125; com.mmall.controllerportal(UserController)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188package com.mmall.controller.portal;import com.mmall.common.Const;import com.mmall.common.ResponseCode;import com.mmall.common.ServerResponse;import com.mmall.pojo.User;import com.mmall.service.IUserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpSession;/** * Created by Blemon on 2018/2/28. */@Controller@RequestMapping("/user/")public class UserController &#123; @Autowired private IUserService iUserService; /** * 登陆功能 * @param username * @param password * @param session * @return */ @RequestMapping(value="login.do",method= RequestMethod.POST) @ResponseBody//将函数返回值序列化成JSON public ServerResponse&lt;User&gt; login(String username, String password, HttpSession session)&#123; //service--&gt;mybatis--&gt;dao ServerResponse&lt;User&gt; response = iUserService.login(username,password); if(response.isSuccess())&#123; session.setAttribute(Const.CURRENT_USER,response.getData()); &#125; return response; &#125; /** * 登出功能 * @param session * @return */ @RequestMapping(value="logout.do",method= RequestMethod.POST) @ResponseBody//将函数返回值序列化成JSON public ServerResponse&lt;String&gt; logout(HttpSession session)&#123; session.removeAttribute(Const.CURRENT_USER); return ServerResponse.createBySuccess(); &#125; /** * 注册 * @param user * @return */ @RequestMapping(value="register.do",method= RequestMethod.POST) @ResponseBody//将函数返回值序列化成JSON public ServerResponse&lt;String&gt; register(User user)&#123; return iUserService.register(user); &#125; /** * 前台实时校验 * @param str * @param type * @return */ @RequestMapping(value="check_valid.do",method= RequestMethod.POST) @ResponseBody//将函数返回值序列化成JSON public ServerResponse&lt;String&gt; check_valid(String str,String type)&#123; return iUserService.checkValid(str,type); &#125; /** * 获取用户信息 * @param session * @return */ @RequestMapping(value="get_user_info.do",method= RequestMethod.POST) @ResponseBody//将函数返回值序列化成JSON public ServerResponse&lt;User&gt; get_user_info(HttpSession session)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user!=null)&#123; return ServerResponse.createBySuccess(user); &#125; return ServerResponse.createByErrorMessage("User no Login"); &#125; /** * 通过用户名查找密码提示问题 * @param username * @return */ @RequestMapping(value="forget_get_question.do",method= RequestMethod.POST) @ResponseBody//将函数返回值序列化成JSON public ServerResponse&lt;String&gt; forget_get_question(String username)&#123; return iUserService.selectQuestion(username); &#125; /** * 根据用户名、问题、键入的答案匹配是否查到(本地缓存检查) * @param username * @param question * @param answer * @return */ @RequestMapping(value="forget_check_answer.do",method= RequestMethod.POST) @ResponseBody//将函数返回值序列化成JSON public ServerResponse&lt;String&gt; forget_check_answer(String username,String question,String answer)&#123; return iUserService.forgetCheckAnswer(username,question,answer); &#125; /** * 忘记密码修改密码 * @param username * @param passwordNew * @param forgetToken * @return */ @RequestMapping(value="forget_reset_password.do",method= RequestMethod.POST) @ResponseBody//将函数返回值序列化成JSON public ServerResponse&lt;String&gt; forget_reset_password(String username,String passwordNew,String forgetToken)&#123; return iUserService.forgetResetPassword(username,passwordNew,forgetToken); &#125; /** * 在线修改密码 * @param session * @param passwordOld * @param passwordNew * @return */ @RequestMapping(value="reset_password.do",method= RequestMethod.POST) @ResponseBody//将函数返回值序列化成JSON public ServerResponse&lt;String&gt; reset_password(HttpSession session,String passwordOld,String passwordNew)&#123; User user = (User)session.getAttribute(Const.CURRENT_USER); if(user==null)&#123; return ServerResponse.createByErrorMessage("user is unLogin"); &#125; return iUserService.resetPassword(passwordOld,passwordNew,user); &#125; /** * 更新用户信息 * @param session * @param user * @return */ @RequestMapping(value="update_information.do",method= RequestMethod.POST) @ResponseBody//将函数返回值序列化成JSON public ServerResponse&lt;User&gt; update_information(HttpSession session,User user)&#123; User currentUser = (User)session.getAttribute(Const.CURRENT_USER); if(currentUser==null)&#123; return ServerResponse.createByErrorMessage("user is unLogin"); &#125; user.setId(currentUser.getId()); user.setUsername(currentUser.getUsername()); ServerResponse&lt;User&gt; response = iUserService.updateInformation(user); if(response.isSuccess())&#123; response.getData().setUsername(currentUser.getUsername()); session.setAttribute(Const.CURRENT_USER,response); &#125; return response; &#125; /** * 查询用户个人信息 * @param session * @return */ @RequestMapping(value="get_information.do",method= RequestMethod.POST) @ResponseBody//将函数返回值序列化成JSON public ServerResponse&lt;User&gt; get_information(HttpSession session)&#123; User currentUser = (User)session.getAttribute(Const.CURRENT_USER); if(currentUser==null)&#123; return ServerResponse.createByErrorCodeMessage(ResponseCode.NEED_LOGIN.getCode(),"please login"); &#125; return iUserService.getInformation(currentUser.getId()); &#125;&#125; backend(UserManagerController)12345678910111213141516171819202122232425262728293031323334353637383940package com.mmall.controller.backend;import com.mmall.common.Const;import com.mmall.common.ServerResponse;import com.mmall.pojo.User;import com.mmall.service.IUserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.ResponseBody;import javax.servlet.http.HttpSession;/** * Created by Blemon on 2018/3/1. */@Controller@RequestMapping("/manager/user/")public class UserManagerController &#123; @Autowired private IUserService iUserService; @RequestMapping(value="login.do",method= RequestMethod.POST) @ResponseBody//将函数返回值序列化成JSON public ServerResponse&lt;User&gt; login(String username, String password, HttpSession session)&#123; ServerResponse&lt;User&gt; response = iUserService.login(username,password); if(response.isSuccess())&#123; User user = response.getData(); if(user.getRole() == Const.Role.ROLE_ADMIN)&#123; session.setAttribute(Const.CURRENT_USER,user); return response; &#125;else&#123; return ServerResponse.createByErrorMessage("not Manager"); &#125; &#125; return response; &#125;&#125; com.mmall.serviceInterface(IUserService)123456789101112131415161718192021222324252627package com.mmall.service;import com.mmall.common.ServerResponse;import com.mmall.pojo.User;/** * Created by Blemon on 2018/2/28. */public interface IUserService &#123; ServerResponse&lt;User&gt; login(String username, String password); ServerResponse&lt;String&gt; register(User user); ServerResponse&lt;String&gt; checkValid(String str,String type); ServerResponse&lt;String&gt; selectQuestion(String username); ServerResponse&lt;String&gt; forgetCheckAnswer(String username,String question,String answer); ServerResponse&lt;String&gt; forgetResetPassword(String username,String passwordNew,String forgetToken); ServerResponse&lt;String&gt; resetPassword(String passwordOld,String passwordNew,User user); ServerResponse&lt;User&gt; updateInformation(User user); ServerResponse&lt;User&gt; getInformation(Integer userId);&#125; Impl(UserServiceImpl)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224package com.mmall.service.impl;import com.mmall.common.Const;import com.mmall.common.ServerResponse;import com.mmall.common.TokenCache;import com.mmall.dao.UserMapper;import com.mmall.service.IUserService;import com.mmall.pojo.User;import com.mmall.util.MD5Util;import org.apache.commons.lang3.StringUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.UUID;/** * Created by Blemon on 2018/2/28. */@Service("iUserService")public class UserServiceImpl implements IUserService &#123; @Autowired private UserMapper userMapper; @Override public ServerResponse&lt;User&gt; login(String username, String password)&#123; //1. 用户名是否存在 int resultCount = userMapper.checkUsername(username); if(resultCount==0)&#123; return ServerResponse.createByErrorMessage("Username not exist"); &#125; //2. MD5密码登陆 String md5Password = MD5Util.MD5EncodeUtf8(password); //3. 用户名和密码是否匹配 User user = userMapper.selectLogin(username,md5Password); if(user==null)&#123; return ServerResponse.createByErrorMessage("Password is Error"); &#125; user.setPassword(StringUtils.EMPTY); return ServerResponse.createBySuccess("Success",user); &#125; @Override public ServerResponse&lt;String&gt; register(User user)&#123; //1. 用户名是否存在 /*int resultCount = userMapper.checkUsername(user.getUsername()); if(resultCount&gt;0) &#123; return ServerResponse.createByErrorMessage("用户名已存在"); &#125;*/ ServerResponse validResponse = this.checkValid(user.getUsername(),Const.USERNAME); if(!validResponse.isSuccess())&#123; return validResponse; &#125; //2. Email是否存在 /*resultCount = userMapper.checkEmail(user.getEmail()); if(resultCount&gt;0) &#123; return ServerResponse.createByErrorMessage("Email已存在"); &#125;*/ validResponse = this.checkValid(user.getEmail(),Const.EMAIL); if(!validResponse.isSuccess())&#123; return validResponse; &#125; //3.默认角色是普通用户 user.setRole(Const.Role.ROLE_CUSTOMER); //4. MD5加密（非对称加密） user.setPassword(MD5Util.MD5EncodeUtf8(user.getPassword())); //5. 插入数据库 int resultCount = userMapper.insert(user); if(resultCount == 0)&#123; return ServerResponse.createByErrorMessage("Register Fail , DB Fail"); &#125; return ServerResponse.createBySuccessMessage("Register Success"); &#125; @Override public ServerResponse&lt;String&gt; checkValid(String str,String type)&#123; if(StringUtils.isNotBlank(type))&#123; //开始校验 if(Const.USERNAME.equals(type))&#123; int resultCount = userMapper.checkUsername(str); if(resultCount&gt;0) &#123; return ServerResponse.createByErrorMessage("用户名已存在"); &#125; &#125; if(Const.EMAIL.equals(type))&#123; int resultCount = userMapper.checkEmail(str); if(resultCount&gt;0) &#123; return ServerResponse.createByErrorMessage("Email已存在"); &#125; &#125; &#125;else&#123; return ServerResponse.createByErrorMessage("Params Error"); &#125; return ServerResponse.createBySuccessMessage("Valid Success"); &#125; @Override public ServerResponse&lt;String&gt; selectQuestion(String username)&#123; ServerResponse validResponse = this.checkValid(username,Const.USERNAME); if(validResponse.isSuccess())&#123; //validResponse,当用户名存在的时候，状态码不是0，所以当if为true的时候，说明状态码是0，用户名不存在 //用户不存在 return ServerResponse.createByErrorMessage("User no Exits"); &#125; String question = userMapper.selectQuestionByUsername(username); if(StringUtils.isNoneBlank(question))&#123; return ServerResponse.createBySuccessMessage(question); &#125; return ServerResponse.createByErrorMessage("question is void"); &#125; @Override public ServerResponse&lt;String&gt; forgetCheckAnswer(String username,String question,String answer)&#123; int resultCount = userMapper.checkAnswer(username,question,answer); if(resultCount&gt;0)&#123; //说明问题以及问题答案是这个用户的，并且是正确的 String forgetToken = UUID.randomUUID().toString(); //TokenCache.setKey("token_"+username,forgetToken); TokenCache.setKey(TokenCache.TOKEN_PREFIX+username,forgetToken); return ServerResponse.createBySuccess(forgetToken); &#125; return ServerResponse.createByErrorMessage("answer is error"); &#125; @Override public ServerResponse&lt;String&gt; forgetResetPassword(String username,String passwordNew,String forgetToken)&#123; //1. 校验Token if(StringUtils.isBlank(forgetToken))&#123; return ServerResponse.createByErrorMessage("frogetToken is null"); &#125; //2. 校验用户是否存在 ServerResponse validResponse = this.checkValid(username,Const.USERNAME); if(validResponse.isSuccess())&#123; //validResponse,当用户名存在的时候，状态码不是0，所以当if为true的时候，说明状态码是0，用户名不存在 //用户不存在 return ServerResponse.createByErrorMessage("User no Exits"); &#125; String token = TokenCache.getKey(TokenCache.TOKEN_PREFIX+username); if(StringUtils.isBlank(token))&#123; return ServerResponse.createByErrorMessage("token is invalid"); &#125; //if(token.equals(forgetToken)) if(StringUtils.equals(forgetToken,token))&#123; String md5Password = MD5Util.MD5EncodeUtf8(passwordNew); int rowCount = userMapper.updatePasswordByUsername(username,md5Password); if(rowCount&gt;0)&#123; return ServerResponse.createBySuccessMessage("update password to successful"); &#125; &#125;else&#123; return ServerResponse.createByErrorMessage("token is error"); &#125; return ServerResponse.createByErrorMessage("update password is fail"); &#125; @Override public ServerResponse&lt;String&gt; resetPassword(String passwordOld,String passwordNew,User user)&#123; //防止横向越权，要校验一下这个用户的旧密码，一定要指定是这个用户。 //因为我们会查询一个count(1)，如果不指定id，那么结果就是true，count&gt;0 int resultCount = userMapper.checkPassword(MD5Util.MD5EncodeUtf8(passwordOld),user.getId()); if(resultCount==0)&#123; return ServerResponse.createByErrorMessage("password is error"); &#125; user.setPassword(MD5Util.MD5EncodeUtf8(passwordNew)); int updateCount = userMapper.updateByPrimaryKeySelective(user); if(updateCount==0)&#123; return ServerResponse.createByErrorMessage("update password fail"); &#125; return ServerResponse.createBySuccessMessage("update password success"); &#125; @Override public ServerResponse&lt;User&gt; updateInformation(User user)&#123; //username不可更新 //eamil也要进行一个校验，校验新的email是否存在， //并且存在的email如果相同的话，不能是我们当前的这个用户的。 int resultCount = userMapper.checkEmailByUserId(user.getEmail(),user.getId()); if(resultCount&gt;0)&#123; return ServerResponse.createByErrorMessage("eamil is exist"); &#125; //快照更新 User updateUser = new User(); updateUser.setId(user.getId()); //updateUser.setUsername(user.getUsername()); updateUser.setEmail(user.getEmail()); updateUser.setPhone(user.getPhone()); updateUser.setQuestion(user.getQuestion()); updateUser.setAnswer(user.getAnswer()); int updateCount = userMapper.updateByPrimaryKeySelective(updateUser); if(updateCount&gt;0)&#123; return ServerResponse.createBySuccess("update success",updateUser); &#125; return ServerResponse.createByErrorMessage("update fail"); &#125; public ServerResponse&lt;User&gt; getInformation(Integer userId) &#123; User user = userMapper.selectByPrimaryKey(userId); if (user==null)&#123; return ServerResponse.createByErrorMessage("user is unexist"); &#125; user.setPassword(StringUtils.EMPTY); return ServerResponse.createBySuccess(user); &#125;&#125; DaoInterface(UserMapper)12345678910111213141516171819202122232425262728293031323334package com.mmall.dao;import com.mmall.pojo.User;import org.apache.ibatis.annotations.Param;public interface UserMapper &#123; int deleteByPrimaryKey(Integer id); int insert(User record); int insertSelective(User record); User selectByPrimaryKey(Integer id); int updateByPrimaryKeySelective(User record); int updateByPrimaryKey(User record); int checkUsername(String username); User selectLogin(@Param("username")String username, @Param("password")String password); int checkEmail(String email); String selectQuestionByUsername(String username); int checkAnswer(@Param("username")String username,@Param("question")String question,@Param("answer")String answer); int updatePasswordByUsername(@Param("username")String username,@Param("passwordNew")String passwordNew); int checkPassword(@Param("password")String password,@Param("userId")Integer userId); int checkEmailByUserId(@Param("email")String email,@Param("userId")Integer userId);&#125; Impl(UserMapper.xml)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.mmall.dao.UserMapper" &gt; &lt;resultMap id="BaseResultMap" type="com.mmall.pojo.User" &gt; &lt;constructor &gt; &lt;idArg column="id" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="username" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="password" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="email" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="phone" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="question" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="answer" jdbcType="VARCHAR" javaType="java.lang.String" /&gt; &lt;arg column="role" jdbcType="INTEGER" javaType="java.lang.Integer" /&gt; &lt;arg column="create_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;arg column="update_time" jdbcType="TIMESTAMP" javaType="java.util.Date" /&gt; &lt;/constructor&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List" &gt; id, username, password, email, phone, question, answer, role, create_time, update_time &lt;/sql&gt; &lt;select id="selectByPrimaryKey" resultMap="BaseResultMap" parameterType="java.lang.Integer" &gt; select &lt;include refid="Base_Column_List" /&gt; from mmall_user where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;delete id="deleteByPrimaryKey" parameterType="java.lang.Integer" &gt; delete from mmall_user where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/delete&gt; &lt;insert id="insert" parameterType="com.mmall.pojo.User" &gt; insert into mmall_user (id, username, password, email, phone, question, answer, role, create_time, update_time) values (#&#123;id,jdbcType=INTEGER&#125;, #&#123;username,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;, #&#123;email,jdbcType=VARCHAR&#125;, #&#123;phone,jdbcType=VARCHAR&#125;, #&#123;question,jdbcType=VARCHAR&#125;, #&#123;answer,jdbcType=VARCHAR&#125;, #&#123;role,jdbcType=INTEGER&#125;, now(), now()) &lt;/insert&gt; &lt;insert id="insertSelective" parameterType="com.mmall.pojo.User" &gt; insert into mmall_user &lt;trim prefix="(" suffix=")" suffixOverrides="," &gt; &lt;if test="id != null" &gt; id, &lt;/if&gt; &lt;if test="username != null" &gt; username, &lt;/if&gt; &lt;if test="password != null" &gt; password, &lt;/if&gt; &lt;if test="email != null" &gt; email, &lt;/if&gt; &lt;if test="phone != null" &gt; phone, &lt;/if&gt; &lt;if test="question != null" &gt; question, &lt;/if&gt; &lt;if test="answer != null" &gt; answer, &lt;/if&gt; &lt;if test="role != null" &gt; role, &lt;/if&gt; &lt;if test="createTime != null" &gt; create_time, &lt;/if&gt; &lt;if test="updateTime != null" &gt; update_time, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides="," &gt; &lt;if test="id != null" &gt; #&#123;id,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="username != null" &gt; #&#123;username,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="password != null" &gt; #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="email != null" &gt; #&#123;email,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="phone != null" &gt; #&#123;phone,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="question != null" &gt; #&#123;question,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="answer != null" &gt; #&#123;answer,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="role != null" &gt; #&#123;role,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="createTime != null" &gt; now(), &lt;/if&gt; &lt;if test="updateTime != null" &gt; now(), &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id="updateByPrimaryKeySelective" parameterType="com.mmall.pojo.User" &gt; update mmall_user &lt;set &gt; &lt;if test="username != null" &gt; username = #&#123;username,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="password != null" &gt; password = #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="email != null" &gt; email = #&#123;email,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="phone != null" &gt; phone = #&#123;phone,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="question != null" &gt; question = #&#123;question,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="answer != null" &gt; answer = #&#123;answer,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="role != null" &gt; role = #&#123;role,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="createTime != null" &gt; create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;, &lt;/if&gt; &lt;if test="updateTime != null" &gt; update_time = now(), &lt;/if&gt; &lt;/set&gt; where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;update id="updateByPrimaryKey" parameterType="com.mmall.pojo.User" &gt; update mmall_user set username = #&#123;username,jdbcType=VARCHAR&#125;, password = #&#123;password,jdbcType=VARCHAR&#125;, email = #&#123;email,jdbcType=VARCHAR&#125;, phone = #&#123;phone,jdbcType=VARCHAR&#125;, question = #&#123;question,jdbcType=VARCHAR&#125;, answer = #&#123;answer,jdbcType=VARCHAR&#125;, role = #&#123;role,jdbcType=INTEGER&#125;, create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;, update_time = now() where id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;select id="checkUsername" resultType="int" parameterType="string"&gt; select count(1) from mmall_user where username=#&#123;username&#125; &lt;/select&gt; &lt;select id="selectLogin" resultMap="BaseResultMap" parameterType="map"&gt; SELECT &lt;include refid="Base_Column_List"/&gt; from mmall_user where username = #&#123;username&#125; and password = #&#123;password&#125; &lt;/select&gt; &lt;select id="checkEmail" resultType="int" parameterType="string"&gt; select count(1) from mmall_user where email=#&#123;email&#125; &lt;/select&gt; &lt;select id="selectQuestionByUsername" resultType="string" parameterType="string"&gt; SELECT question from mmall_user WHERE username = #&#123;username&#125; &lt;/select&gt; &lt;select id="checkAnswer" resultType="int" parameterType="map"&gt; SELECT count(1) from mmall_user WHERE username = #&#123;username&#125; and question = #&#123;question&#125; and answer = #&#123;answer&#125; &lt;/select&gt; &lt;update id="updatePasswordByUsername" parameterType="map"&gt; UPDATE mmall_user SET password = #&#123;passwordNew&#125;,update_time = now() WHERE username = #&#123;username&#125; &lt;/update&gt; &lt;select id="checkPassword" resultType="int" parameterType="map"&gt; SELECT count(1) from mmall_user WHERE id = #&#123;userId&#125; AND password = #&#123;password&#125; &lt;/select&gt; &lt;select id="checkEmailByUserId" resultType="int" parameterType="map"&gt; SELECT count(1) from mmall_user WHERE email = #&#123;email&#125; AND id !=#&#123;userId&#125; &lt;/select&gt;&lt;/mapper&gt; utilMD5Util1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.mmall.util;import org.springframework.util.StringUtils;import java.security.MessageDigest;/** * Created by geely */public class MD5Util &#123; private static String byteArrayToHexString(byte b[]) &#123; StringBuffer resultSb = new StringBuffer(); for (int i = 0; i &lt; b.length; i++) resultSb.append(byteToHexString(b[i])); return resultSb.toString(); &#125; private static String byteToHexString(byte b) &#123; int n = b; if (n &lt; 0) n += 256; int d1 = n / 16; int d2 = n % 16; return hexDigits[d1] + hexDigits[d2]; &#125; /** * 返回大写MD5 * * @param origin * @param charsetname * @return */ private static String MD5Encode(String origin, String charsetname) &#123; String resultString = null; try &#123; resultString = new String(origin); MessageDigest md = MessageDigest.getInstance("MD5"); if (charsetname == null || "".equals(charsetname)) resultString = byteArrayToHexString(md.digest(resultString.getBytes())); else resultString = byteArrayToHexString(md.digest(resultString.getBytes(charsetname))); &#125; catch (Exception exception) &#123; &#125; return resultString.toUpperCase(); &#125; public static String MD5EncodeUtf8(String origin) &#123; origin = origin + PropertiesUtil.getProperty("password.salt", ""); return MD5Encode(origin, "utf-8"); &#125; private static final String hexDigits[] = &#123;"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"&#125;;&#125; PropertiesUtil12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.mmall.util;import org.apache.commons.lang3.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.IOException;import java.io.InputStreamReader;import java.util.Properties;/** * Created by geely */public class PropertiesUtil &#123; private static Logger logger = LoggerFactory.getLogger(PropertiesUtil.class); private static Properties props; static &#123; String fileName = "mmall.properties"; props = new Properties(); try &#123; props.load(new InputStreamReader(PropertiesUtil.class.getClassLoader().getResourceAsStream(fileName),"UTF-8")); &#125; catch (IOException e) &#123; logger.error("配置文件读取异常",e); &#125; &#125; public static String getProperty(String key)&#123; String value = props.getProperty(key.trim()); if(StringUtils.isBlank(value))&#123; return null; &#125; return value.trim(); &#125; public static String getProperty(String key,String defaultValue)&#123; String value = props.getProperty(key.trim()); if(StringUtils.isBlank(value))&#123; value = defaultValue; &#125; return value.trim(); &#125;&#125; Resources(mmall.properties)12345678ftp.server.ip=127.0.0.1ftp.user=geelyftp.pass=geelyftp.server.http.prefix=http://img.happymmall.com/alipay.callback.url=http://www.happymmall.com/order/alipay_callback.dopassword.salt = geelysdafaqj23ou89ZXcj@#$@#$#@KJdjklj;D../dSF.,]]></content>
      <categories>
        <category>mmall</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目初始化]]></title>
    <url>%2F2018%2F03%2F03%2F%E9%A1%B9%E7%9B%AE%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[数据库初始化利用Navicat创建数据库，直接导入mmall.sql（表和初始数据） 安装IDEA（IDEA 15）1. 下载IDEA 2. 激活IDEA：http://blog.csdn.net/canglingyue/article/details/51034716 IDEA配置JDK第一次打开右下角的configure Maven第一次打开右下角的configure IDEA创建Java项目http://blog.csdn.net/qi_yue_yu/article/details/52627025 IDEA创建Web项目（Tomcat）http://blog.csdn.net/longshehe9319/article/details/78791200 Maven创建Web项目创建Maven项目 配置Tomcat，但是配置完后不能artifact的解决方法 Git创建仓库及初始化Maven之Pom初始化Maven的pom文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com&lt;/groupId&gt; &lt;artifactId&gt;mmall&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;mmall Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt; &lt;org.springframework.version&gt;4.0.0.RELEASE&lt;/org.springframework.version&gt; &lt;org.mybatis.version&gt;3.4.1&lt;/org.mybatis.version&gt; &lt;org.mybatis.spring.version&gt;1.3.0&lt;/org.mybatis.spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt; &lt;artifactId&gt;tomcat-servlet-api&lt;/artifactId&gt; &lt;version&gt;7.0.64&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;org.springframework.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.7.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mybatis.spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;org.mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.6.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;!--&lt;scope&gt;runtime&lt;/scope&gt;--&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-core&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;20.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.2.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;!--&lt;scope&gt;test&lt;/scope&gt;--&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;joda-time&lt;/groupId&gt; &lt;artifactId&gt;joda-time&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- id加密解密 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hashids&lt;/groupId&gt; &lt;artifactId&gt;hashids&lt;/artifactId&gt; &lt;version&gt;1.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- ftpclient --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-net&lt;/groupId&gt; &lt;artifactId&gt;commons-net&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- file upload --&gt; &lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis pager --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.miemiedev&lt;/groupId&gt; &lt;artifactId&gt;mybatis-paginator&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- alipay --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;version&gt;1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-configuration&lt;/groupId&gt; &lt;artifactId&gt;commons-configuration&lt;/artifactId&gt; &lt;version&gt;1.10&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;2.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-core&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;mmall&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- geelynote maven的核心插件之-complier插件默认只支持编译Java 1.4，因此需要加上支持高版本jre的配置，在pom.xml里面加上 增加编译插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;compilerArguments&gt; &lt;extdirs&gt;$&#123;project.basedir&#125;/src/main/webapp/WEB-INF/lib&lt;/extdirs&gt; &lt;/compilerArguments&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 包结构设计 Mybatis三剑客Mybatis-generator自动化生成数据库交互代码 pom.xml中引入了插件的配置 12345678910&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;/configuration&gt; &lt;/plugin&gt; 引入datasource.properties&amp;generatorConfig.xml12345db.driverLocation=C:/Users/Blemon/IdeaProjects/mmail/src/main/tools/mysql-connector-java-5.1.6-bin.jardb.driverClassName=com.mysql.jdbc.Driverdb.url=jdbc:mysql://127.0.0.1:3306/mmall?characterEncoding=utf-8db.username=rootdb.password=7122887 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!--导入属性配置--&gt; &lt;properties resource="datasource.properties"/&gt; &lt;!--指定特定数据库的jdbc驱动jar包的位置--&gt; &lt;classPathEntry location="$&#123;db.driverLocation&#125;"/&gt; &lt;context id="default" targetRuntime="MyBatis3"&gt; &lt;!-- optional，旨在创建class时，对注释进行控制 --&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;!--jdbc的数据库连接 --&gt; &lt;jdbcConnection driverClass="$&#123;db.driverClassName&#125;" connectionURL="$&#123;db.url&#125;" userId="$&#123;db.username&#125;" password="$&#123;db.password&#125;"&gt; &lt;/jdbcConnection&gt; &lt;!-- 非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- Model模型生成器,用来生成含有主键key的类，记录类 以及查询Example类 targetPackage 指定生成的model生成所在的包名 targetProject 指定在该项目下所在的路径 --&gt; &lt;!--&lt;javaModelGenerator targetPackage="com.mmall.pojo" targetProject=".\src\main\java"&gt;--&gt; &lt;javaModelGenerator targetPackage="com.mmall.pojo" targetProject="./src/main/java"&gt; &lt;!-- 是否允许子包，即targetPackage.schemaName.tableName --&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;!-- 是否对model添加 构造函数 --&gt; &lt;property name="constructorBased" value="true"/&gt; &lt;!-- 是否对类CHAR类型的列的数据进行trim操作 --&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;!-- 建立的Model对象是否 不可改变 即生成的Model对象不会有 setter方法，只有构造方法 --&gt; &lt;property name="immutable" value="false"/&gt; &lt;/javaModelGenerator&gt; &lt;!--mapper映射文件生成所在的目录 为每一个数据库的表生成对应的SqlMap文件 --&gt; &lt;!--&lt;sqlMapGenerator targetPackage="mappers" targetProject=".\src\main\resources"&gt;--&gt; &lt;sqlMapGenerator targetPackage="mappers" targetProject="./src/main/resources"&gt; &lt;property name="enableSubPackages" value="false"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 客户端代码，生成易于使用的针对Model对象和XML配置文件 的代码 type="ANNOTATEDMAPPER",生成Java Model 和基于注解的Mapper对象 type="MIXEDMAPPER",生成基于注解的Java Model 和相应的Mapper对象 type="XMLMAPPER",生成SQLMap XML文件和独立的Mapper接口 --&gt; &lt;!-- targetPackage：mapper接口dao生成的位置 --&gt; &lt;!--&lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.mmall.dao" targetProject=".\src\main\java"&gt;--&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.mmall.dao" targetProject="./src/main/java"&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name="enableSubPackages" value="false" /&gt; &lt;/javaClientGenerator&gt; &lt;table tableName="mmall_shipping" domainObjectName="Shipping" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_cart" domainObjectName="Cart" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_cart_item" domainObjectName="CartItem" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_category" domainObjectName="Category" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_order" domainObjectName="Order" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_order_item" domainObjectName="OrderItem" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_pay_info" domainObjectName="PayInfo" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;table tableName="mmall_product" domainObjectName="Product" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt; &lt;columnOverride column="detail" jdbcType="VARCHAR" /&gt; &lt;columnOverride column="sub_images" jdbcType="VARCHAR" /&gt; &lt;/table&gt; &lt;table tableName="mmall_user" domainObjectName="User" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;!-- geelynote mybatis插件的搭建 --&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 自动生成dao&amp;pojo&amp;mappers 生成mappers中xml修改时间戳为now()Mybatis-pluginIDEA的Mybatis插件，可以实现Mybatis接口文件和实现xml子哦对那个跳转，验证正确性，在xml中智能提示等功能 安装好之后重启IDEA 出现右边向下的箭头，用来在接口文件和xml中跳转和相互验证 Mybatis-pagehelperMybatis的分页插件 pom.xml 12345678910111213141516171819&lt;!-- mybatis pager --&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;4.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.miemiedev&lt;/groupId&gt; &lt;artifactId&gt;mybatis-paginator&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt; &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt; &lt;version&gt;0.9.4&lt;/version&gt;&lt;/dependency&gt; web.xml初始化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--字符编码拦截器--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--web容器的监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--web容器和spring结合的监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt; classpath:applicationContext.xml &lt;/param-value&gt; &lt;/context-param&gt; &lt;!--拦截springMVC的东西--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; Spring初始化123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:jdbc="http://www.springframework.org/schema/jdbc" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;context:component-scan base-package="com.mmall" annotation-config="true"/&gt;&lt;!--扫描包--&gt; &lt;!--&lt;context:annotation-config/&gt;--&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;import resource="applicationContext-datasource.xml"/&gt;&lt;!--分离了spring的配置文件--&gt;&lt;/beans&gt; spring-db1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:jdbc="http://www.springframework.org/schema/jdbc" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;context:component-scan base-package="com.mmall" annotation-config="true"/&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="order" value="2"/&gt; &lt;property name="ignoreUnresolvablePlaceholders" value="true"/&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:datasource.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="fileEncoding" value="utf-8"/&gt; &lt;/bean&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;db.driverClassName&#125;"/&gt; &lt;property name="url" value="$&#123;db.url&#125;"/&gt; &lt;property name="username" value="$&#123;db.username&#125;"/&gt; &lt;property name="password" value="$&#123;db.password&#125;"/&gt; &lt;!-- 连接池启动时的初始值 --&gt; &lt;property name="initialSize" value="$&#123;db.initialSize&#125;"/&gt; &lt;!-- 连接池的最大值 --&gt; &lt;property name="maxActive" value="$&#123;db.maxActive&#125;"/&gt; &lt;!-- 最大空闲值.当经过一个高峰时间后，连接池可以慢慢将已经用不到的连接慢慢释放一部分，一直减少到maxIdle为止 --&gt; &lt;property name="maxIdle" value="$&#123;db.maxIdle&#125;"/&gt; &lt;!-- 最小空闲值.当空闲的连接数少于阀值时，连接池就会预申请去一些连接，以免洪峰来时来不及申请 --&gt; &lt;property name="minIdle" value="$&#123;db.minIdle&#125;"/&gt; &lt;!-- 最大建立连接等待时间。如果超过此时间将接到异常。设为－1表示无限制 --&gt; &lt;property name="maxWait" value="$&#123;db.maxWait&#125;"/&gt; &lt;!--#给出一条简单的sql语句进行验证 --&gt; &lt;!--&lt;property name="validationQuery" value="select getdate()" /&gt;--&gt; &lt;property name="defaultAutoCommit" value="$&#123;db.defaultAutoCommit&#125;"/&gt; &lt;!-- 回收被遗弃的（一般是忘了释放的）数据库连接到连接池中 --&gt; &lt;!--&lt;property name="removeAbandoned" value="true" /&gt;--&gt; &lt;!-- 数据库连接过多长时间不用将被视为被遗弃而收回连接池中 --&gt; &lt;!--&lt;property name="removeAbandonedTimeout" value="120" /&gt;--&gt; &lt;!-- #连接的超时时间，默认为半小时。 --&gt; &lt;property name="minEvictableIdleTimeMillis" value="$&#123;db.minEvictableIdleTimeMillis&#125;"/&gt; &lt;!--# 失效检查线程运行时间间隔，要小于MySQL默认--&gt; &lt;property name="timeBetweenEvictionRunsMillis" value="40000"/&gt; &lt;!--# 检查连接是否有效--&gt; &lt;property name="testWhileIdle" value="true"/&gt; &lt;!--# 检查连接有效性的SQL语句--&gt; &lt;property name="validationQuery" value="SELECT 1 FROM dual"/&gt; &lt;/bean&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="mapperLocations" value="classpath*:mappers/*Mapper.xml"/&gt; &lt;!-- 分页插件 --&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;bean class="com.github.pagehelper.PageHelper"&gt; &lt;property name="properties"&gt; &lt;value&gt; dialect=mysql &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean name="mapperScannerConfigurer" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.mmall.dao"/&gt; &lt;/bean&gt; &lt;!-- 使用@Transactional进行声明式事务管理需要声明下面这行 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager" proxy-target-class="true" /&gt; &lt;!-- 事务管理 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="rollbackOnCommitFailure" value="true"/&gt; &lt;/bean&gt;&lt;/beans&gt; 修改datasource.properties12345678910111213db.driverLocation=C:/Users/Blemon/IdeaProjects/mmail/src/main/tools/mysql-connector-java-5.1.6-bin.jardb.driverClassName=com.mysql.jdbc.Driverdb.url=jdbc:mysql://127.0.0.1:3306/mmall?characterEncoding=utf-8db.username=rootdb.password=7122887db.initialSize = 20db.maxActive = 50db.maxIdle = 20db.minIdle = 10db.maxWait = 10db.defaultAutoCommit = truedb.minEvictableIdleTimeMillis = 3600000 SpringMVC初始化123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"&gt; &lt;context:component-scan base-package="com.mmall" annotation-config="true"/&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;bean class="org.springframework.http.converter.StringHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;text/plain;charset=UTF-8&lt;/value&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean class="org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"&gt; &lt;property name="supportedMediaTypes"&gt; &lt;list&gt; &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 文件上传 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="maxUploadSize" value="10485760"/&gt; &lt;!-- 10m --&gt; &lt;property name="maxInMemorySize" value="4096" /&gt; &lt;property name="defaultEncoding" value="UTF-8"/&gt; &lt;/bean&gt;&lt;/beans&gt; Logback初始化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;encoder&gt; &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;][%p][%c&#123;40&#125;][%t] %m%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt; &lt;level&gt;DEBUG&lt;/level&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;appender name="mmall" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!--&lt;File&gt;d:/mmalllog/mmall.log&lt;/File&gt;--&gt; &lt;File&gt;/developer/apache-tomcat-7.0.73/logs/mmall.log&lt;/File&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;/developer/apache-tomcat-7.0.73/logs/mmall.log.%d&#123;yyyy-MM-dd&#125;.gz&lt;/fileNamePattern&gt; &lt;append&gt;true&lt;/append&gt; &lt;maxHistory&gt;10&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;][%p][%c&#123;40&#125;][%t] %m%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;appender name="error" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!--&lt;File&gt;d:/mmalllog/error.log&lt;/File&gt;--&gt; &lt;File&gt;/developer/apache-tomcat-7.0.73/logs/error.log&lt;/File&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;/devsoft/apache-tomcat-7.0.73/logs/error.log.%d&#123;yyyy-MM-dd&#125;.gz&lt;/fileNamePattern&gt; &lt;!--&lt;fileNamePattern&gt;d:/mmalllog/error.log.%d&#123;yyyy-MM-dd&#125;.gz&lt;/fileNamePattern&gt;--&gt; &lt;append&gt;true&lt;/append&gt; &lt;maxHistory&gt;10&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;][%p][%c&#123;40&#125;][%t] %m%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;logger name="com.mmall" additivity="false" level="INFO" &gt; &lt;appender-ref ref="mmall" /&gt; &lt;appender-ref ref="console"/&gt; &lt;/logger&gt; &lt;!-- geelynote mybatis log 日志 --&gt; &lt;logger name="com.mmall.dao" level="DEBUG"/&gt; &lt;!--&lt;logger name="com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate" level="DEBUG" &gt;--&gt; &lt;!--&lt;appender-ref ref="console"/&gt;--&gt; &lt;!--&lt;/logger&gt;--&gt; &lt;!--&lt;logger name="java.sql.Connection" level="DEBUG"&gt;--&gt; &lt;!--&lt;appender-ref ref="console"/&gt;--&gt; &lt;!--&lt;/logger&gt;--&gt; &lt;!--&lt;logger name="java.sql.Statement" level="DEBUG"&gt;--&gt; &lt;!--&lt;appender-ref ref="console"/&gt;--&gt; &lt;!--&lt;/logger&gt;--&gt; &lt;!--&lt;logger name="java.sql.PreparedStatement" level="DEBUG"&gt;--&gt; &lt;!--&lt;appender-ref ref="console"/&gt;--&gt; &lt;!--&lt;/logger&gt;--&gt; &lt;root level="DEBUG"&gt; &lt;appender-ref ref="console"/&gt; &lt;appender-ref ref="error"/&gt; &lt;/root&gt;&lt;/configuration&gt; FTP服务器配置mmall.properties1234ftp.server.ip=127.0.0.1ftp.user=geelyftp.pass=geelyftp.server.http.prefix=http://img.happymmall.com/ 其他配置IDEA注入和实时编译的配置## IDEA使用Mybatis和Spring Scan时，autowired注入时报错处理 ## 开启problem窗口，实时编译 Restlet client &amp; FE助手Chrome应用商店中查找下载即可]]></content>
      <categories>
        <category>mmall</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库表结构设计]]></title>
    <url>%2F2018%2F03%2F02%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[表结构用户表 DROP TABLE IF EXISTS `mmall_user`; CREATE TABLE `mmall_user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;用户表id&apos;, `username` varchar(50) NOT NULL COMMENT &apos;用户名&apos;, `password` varchar(50) NOT NULL COMMENT &apos;用户密码，MD5加密&apos;, `email` varchar(50) DEFAULT NULL, `phone` varchar(20) DEFAULT NULL, `question` varchar(100) DEFAULT NULL COMMENT &apos;找回密码问题&apos;, `answer` varchar(100) DEFAULT NULL COMMENT &apos;找回密码答案&apos;, `role` int(4) NOT NULL COMMENT &apos;角色0-管理员,1-普通用户&apos;, `create_time` datetime NOT NULL COMMENT &apos;创建时间&apos;, `update_time` datetime NOT NULL COMMENT &apos;最后一次更新时间&apos;, PRIMARY KEY (`id`), UNIQUE KEY `user_name_unique` (`username`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8; 分类表 DROP TABLE IF EXISTS `mmall_category`; CREATE TABLE `mmall_category` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;类别Id&apos;, `parent_id` int(11) DEFAULT NULL COMMENT &apos;父类别id当id=0时说明是根节点,一级类别&apos;, `name` varchar(50) DEFAULT NULL COMMENT &apos;类别名称&apos;, `status` tinyint(1) DEFAULT &apos;1&apos; COMMENT &apos;类别状态1-正常,2-已废弃&apos;, `sort_order` int(4) DEFAULT NULL COMMENT &apos;排序编号,同类展示顺序,数值相等则自然排序&apos;, `create_time` datetime DEFAULT NULL COMMENT &apos;创建时间&apos;, `update_time` datetime DEFAULT NULL COMMENT &apos;更新时间&apos;, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=100032 DEFAULT CHARSET=utf8; 产品表 DROP TABLE IF EXISTS `mmall_product`; CREATE TABLE `mmall_product` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;商品id&apos;, `category_id` int(11) NOT NULL COMMENT &apos;分类id,对应mmall_category表的主键&apos;, `name` varchar(100) NOT NULL COMMENT &apos;商品名称&apos;, `subtitle` varchar(200) DEFAULT NULL COMMENT &apos;商品副标题&apos;, `main_image` varchar(500) DEFAULT NULL COMMENT &apos;产品主图,url相对地址&apos;, `sub_images` text COMMENT &apos;图片地址,json格式,扩展用&apos;, `detail` text COMMENT &apos;商品详情&apos;, `price` decimal(20,2) NOT NULL COMMENT &apos;价格,单位-元保留两位小数&apos;, `stock` int(11) NOT NULL COMMENT &apos;库存数量&apos;, `status` int(6) DEFAULT &apos;1&apos; COMMENT &apos;商品状态.1-在售 2-下架 3-删除&apos;, `create_time` datetime DEFAULT NULL COMMENT &apos;创建时间&apos;, `update_time` datetime DEFAULT NULL COMMENT &apos;更新时间&apos;, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=30 DEFAULT CHARSET=utf8; 购物车表 DROP TABLE IF EXISTS `mmall_cart`; CREATE TABLE `mmall_cart` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` int(11) NOT NULL, `product_id` int(11) DEFAULT NULL COMMENT &apos;商品id&apos;, `quantity` int(11) DEFAULT NULL COMMENT &apos;数量&apos;, `checked` int(11) DEFAULT NULL COMMENT &apos;是否选择,1=已勾选,0=未勾选&apos;, `create_time` datetime DEFAULT NULL COMMENT &apos;创建时间&apos;, `update_time` datetime DEFAULT NULL COMMENT &apos;更新时间&apos;, PRIMARY KEY (`id`), KEY `user_id_index` (`user_id`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=146 DEFAULT CHARSET=utf8; 支付表 DROP TABLE IF EXISTS `mmall_pay_info`; CREATE TABLE `mmall_pay_info` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` int(11) DEFAULT NULL COMMENT &apos;用户id&apos;, `order_no` bigint(20) DEFAULT NULL COMMENT &apos;订单号&apos;, `pay_platform` int(10) DEFAULT NULL COMMENT &apos;支付平台:1-支付宝,2-微信&apos;, `platform_number` varchar(200) DEFAULT NULL COMMENT &apos;支付宝支付流水号&apos;, `platform_status` varchar(20) DEFAULT NULL COMMENT &apos;支付宝支付状态&apos;, `create_time` datetime DEFAULT NULL COMMENT &apos;创建时间&apos;, `update_time` datetime DEFAULT NULL COMMENT &apos;更新时间&apos;, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=61 DEFAULT CHARSET=utf8; 订单表 DROP TABLE IF EXISTS `mmall_order`; CREATE TABLE `mmall_order` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;订单id&apos;, `order_no` bigint(20) DEFAULT NULL COMMENT &apos;订单号&apos;, `user_id` int(11) DEFAULT NULL COMMENT &apos;用户id&apos;, `shipping_id` int(11) DEFAULT NULL, `payment` decimal(20,2) DEFAULT NULL COMMENT &apos;实际付款金额,单位是元,保留两位小数&apos;, `payment_type` int(4) DEFAULT NULL COMMENT &apos;支付类型,1-在线支付&apos;, `postage` int(10) DEFAULT NULL COMMENT &apos;运费,单位是元&apos;, `status` int(10) DEFAULT NULL COMMENT &apos;订单状态:0-已取消-10-未付款，20-已付款，40-已发货，50-交易成功，60-交易关闭&apos;, `payment_time` datetime DEFAULT NULL COMMENT &apos;支付时间&apos;, `send_time` datetime DEFAULT NULL COMMENT &apos;发货时间&apos;, `end_time` datetime DEFAULT NULL COMMENT &apos;交易完成时间&apos;, `close_time` datetime DEFAULT NULL COMMENT &apos;交易关闭时间&apos;, `create_time` datetime DEFAULT NULL COMMENT &apos;创建时间&apos;, `update_time` datetime DEFAULT NULL COMMENT &apos;更新时间&apos;, PRIMARY KEY (`id`), UNIQUE KEY `order_no_index` (`order_no`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=118 DEFAULT CHARSET=utf8; 订单明细表 DROP TABLE IF EXISTS `mmall_order_item`; CREATE TABLE `mmall_order_item` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;订单子表id&apos;, `user_id` int(11) DEFAULT NULL, `order_no` bigint(20) DEFAULT NULL, `product_id` int(11) DEFAULT NULL COMMENT &apos;商品id&apos;, `product_name` varchar(100) DEFAULT NULL COMMENT &apos;商品名称&apos;, `product_image` varchar(500) DEFAULT NULL COMMENT &apos;商品图片地址&apos;, `current_unit_price` decimal(20,2) DEFAULT NULL COMMENT &apos;生成订单时的商品单价，单位是元,保留两位小数&apos;, `quantity` int(10) DEFAULT NULL COMMENT &apos;商品数量&apos;, `total_price` decimal(20,2) DEFAULT NULL COMMENT &apos;商品总价,单位是元,保留两位小数&apos;, `create_time` datetime DEFAULT NULL, `update_time` datetime DEFAULT NULL, PRIMARY KEY (`id`), KEY `order_no_index` (`order_no`) USING BTREE, KEY `order_no_user_id_index` (`user_id`,`order_no`) USING BTREE ) ENGINE=InnoDB AUTO_INCREMENT=135 DEFAULT CHARSET=utf8; 收货表 DROP TABLE IF EXISTS `mmall_shipping`; CREATE TABLE `mmall_shipping` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_id` int(11) DEFAULT NULL COMMENT &apos;用户id&apos;, `receiver_name` varchar(20) DEFAULT NULL COMMENT &apos;收货姓名&apos;, `receiver_phone` varchar(20) DEFAULT NULL COMMENT &apos;收货固定电话&apos;, `receiver_mobile` varchar(20) DEFAULT NULL COMMENT &apos;收货移动电话&apos;, `receiver_province` varchar(20) DEFAULT NULL COMMENT &apos;省份&apos;, `receiver_city` varchar(20) DEFAULT NULL COMMENT &apos;城市&apos;, `receiver_district` varchar(20) DEFAULT NULL COMMENT &apos;区/县&apos;, `receiver_address` varchar(200) DEFAULT NULL COMMENT &apos;详细地址&apos;, `receiver_zip` varchar(6) DEFAULT NULL COMMENT &apos;邮编&apos;, `create_time` datetime DEFAULT NULL, `update_time` datetime DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=33 DEFAULT CHARSET=utf8; 表关系 唯一索引和时间戳]]></content>
      <categories>
        <category>mmall</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电商配置]]></title>
    <url>%2F2018%2F03%2F01%2F%E7%94%B5%E5%95%86%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[课程导学1. 环境搭建 2. 数据库及接口 3. 项目初始化 4. 用户模块 5. 分类模块 6. 商品模块 7. 购物车模块 8. 收获地址模块 9. 支付模块 10. 订单模块 11. 云服务器模块 项目架构演进解析文件和数据都在一个服务器 文件和数据开始分离（3台） 开始数据库进行缓存（本地，远程） 引入Load Balancer(负载均衡服务器) 服务器开始均衡 Cooike和Session共享的问题Session Server的引入数据库Master/Salve分离 CDN和反向代理 数据表分类成库（事务连接、水平拆分、分页） 引入搜索引擎服务器集群 配置JDK/Tomcat1. JDK版本：JDK1.8 2. Tomcat：7.0.1 配置Maven1. 用Maven方便创建项目，基于archetype可以创建多种类型的java项目。 2. Maven仓库对jar包(artifact)进行统一管理，避免jar文件的重复拷贝和版本冲突。 3. Maven有Release和Snapshot两个版本。 Maven版本：3.0.5 配置：https://www.cnblogs.com/eagle6688/p/7838224.html 配置vsftpdvery secure FTP（File Transfer Protocol） daemon，是一款在Linux发行版中最受推崇的FTP服务器程序 ftpServer安装因为vsftpd在window中没有官方的东西，所以只能使用自己的ftpserver 配置NginxNginx是一款轻量级Web服务器，也是一款反向代理服务器 1. Nginx可直接支持Rails和PHP程序 2. 可作为Http反向代理服务器 3. 作为负载均衡服务器 4. 作为邮件代理服务器 5. 帮助实现前端动静分离 Nginx安装（Win）1. 安装Nginx，安装完成后打开Nginx.exe。 2. 配置代理 3. 任务管理器中有了nginx的进程后，打开www.mmall.com或者http://localhost都会进入nginx Nginx反向代理1. G:\Nginx\windows-nginx-1.10.2\nginx-1.10.2\conf中的nginx.conf中配置：include vhost/*.conf;//95行 2. 配置image.imooc.com.comf： 2.1 G:\Nginx\windows-nginx-1.10.2\nginx-1.10.2创建vhost文件夹 2.2 创建image.imooc.com.comf： server { listen 80; # 端口号 autoindex off; server_name image.imooc.com; //服务器名字，和在hosts.conf中的一致 access_log c:/access.log combined; index index.html index.htm index.jsp index.php; #error_page 404 /404.html; if ( $query_string ~* &quot;.*[\;&apos;\&lt;\&gt;].*&quot; ){ return 404; } location ~ /(mmall_fe|mmall_admin_fe)/dist/view/* { deny all; } location / { root G:\ftpfile\img; #FTP文件夹中要有这个目录。 add_header Access-Control-Allow-Origin *; } } 3. 修改hosts.conf:127.0.0.1 image.imooc.com 4. DOS进入Nginx文件夹验证是否Successful。 5. 浏览器进入image.imooc.com或image.imooc.com/Demo.jpg 6. 同理配置tomcat.imooc.com.conf 6.1 vhost文件夹中创建conf文件： server { listen 80; autoindex on; server_name tomcat.imooc.com; access_log c:/access.log combined; index index.html index.htm index.jsp index.php; #error_page 404 /404.html; if ( $query_string ~* &quot;.*[\;&apos;\&lt;\&gt;].*&quot; ){ return 404; } location / { proxy_pass http://127.0.0.1:8080; add_header Access-Control-Allow-Origin *; } } 7. hosts中配置:127.0.0.1 tomcat.imooc.com 8. 开启Tomcat，从tomcat.imooc.com可以直接进入Tomcat官网。 FTP文件服务器![](http://oxk1vrcj4.bkt.clouddn.com/00.png) Git]]></content>
      <categories>
        <category>mmall</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux（概述）]]></title>
    <url>%2F2018%2F02%2F01%2FLinux%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Linux OS 学习 Linux作用1. 企业服务器 2. 嵌入式开发 和Window的区别1. 没有exe安装程序 2. 大小写严格区分 3. 一切皆文件 4. 文件后缀名不是那么重要,只是为了方便识别 安装环境1. VMWare/Virtualbox5.1.24 2. Shell 3. CentOS7 4. window中需要开启虚拟化，BIOS开启虚拟化支持 准备工作查询ip 1. ifconfig 2. ip addr 3. vi/etc/sysconfig/network-scripts/ifcfg-xx 4. yum install net-tools 替换默认源 http://mirrors.163.com/.help/centos.html mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup rm -f /etc/yum.repos.d/* http://mirrors.163.com/.help/CentOS7-Base-163.repo wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 安装Vim SSH1. 什么是SSH 2. 服务端安装SSH服务 3. 客户端安装SSH客户端 4. SSH客户端连接服务器 5. SSH config用法详解 6. 免密码登陆，方案SSH key 7. SSH端口 8. 个性化脚本一键登陆服务器 概述1. SSH：Secure Shell 安全外壳协议 2. 建立在应用层基础上的安全协议 3. 可靠，专为远程登陆会话和其他网络服务提供安全性协议 4. 有效防止远程管理过程中的信息泄露问题 5. SSH客户端使用于多种平台 6. SSH服务器几乎支持所有UNIX平台 服务端安装SSH服务安装SSH yum install openssh-server（CentOS本身是一个服务器端的，ssh已经安装了） 启动SSH service sshd start 设置开启运行 chkconfig sshd on 客户端安装SSH工具1. SSH是典型的客户端和服务端的交互模式，支持各个平台 2. Windows使用XShell 其实在我们CentOS的环境下，我们的SSH客户端已经自己下载了，可以自己尝试：yum install openssh-clients 会报：Nothing to do SSH客户端连接SSH服务建立连接：ssh root@10.170.22.55 关闭连接：exit SSH config1. config为了方便我们批量管理多个ssh 2. config存放在~/.ssh/config 3. config配置语法 SSH安全免密码登陆：ssh key1. ssh key使用非对称加密方式生成公钥和私钥 2. 私钥放在本地~/.ssh目录 3. 公钥可以对外公开，放在服务器的~/.ssh/authorized_keys 使用XShell进行配置 SSH安全端口Linux常用命令软件操作命令软件安装包管理器 1. 安装软件 yum install xxx 2. 卸载软件 yum remove xxx 3. 搜索软件 yum serach xxx 4. 清理缓存 yum clean packages 5. 列出已经安装 yum list 6. 软件包信息 yum info xxx 服务器硬件资源和磁盘操作1. 内存 free -m 2. 磁盘 df -h 3. 负载 w/top 文件和文件夹1. Linux文件的目录结构 2. 文件基本操作 3. 文本编辑Vim 4. 文件权限421 5. 文件搜索，查找，读取 6. 文件解压与压缩 文件目录结构1. 根目录 / 2. 家目录 /home 3. 临时目录 /temp 4. 配置目录 /etc 5. 用户程序目录 /usr 文件操作1. ls -al 查看目录下所有文件 2. touch 新建文件 3. mkdir 文件文件夹 4. cd 进入目录 5. rm 删除目录和文件 6. cp 复制 7. mv 移动 8. pwd 显示路径 Vim系统用户操作命令（/home）1. useradd 添加用户 2. adduser 添加用户 3. userdel 删除用户 4. passwd 设置密码 防火墙相关设置service firewalld status service firewalld restart 提权操作sudo和文件传输操作1. 提权：sudo（vissudo） 2. 文件下载（wget、curl） 3. 文件上传（scp） WebServer安装和配置讲解Apache NginxGit]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Computer Network（概述）]]></title>
    <url>%2F2018%2F01%2F27%2FComputer%20Network%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[了解计算机网络的五层协议栈和基本架构 网络层次划分 OSI/RM模型（Open System Interconnection/Reference Model） 物理层（Physical Layer）该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。 物理层记住两个重要的设备名称，中继器（Repeater，也叫放大器）和集线器。 数据链路层（Data Link Layer） 数据链路可以粗略地理解为数据通道。物理层要为终端设备间的数据通信提供传输媒体及其连接.媒体是长期的,连接是有生存期的. 在连接生存期内,收发两端可以进行不等的一次或多次数据通信.每次通信都要经过建立通信联络和拆除通信联络两过程. 这种建立起来的数据收发关系就叫作数据链路. 而在物理媒体上传输的数据难免受到各种不可靠因素的影响而产生差错,为了弥补物理层上的不足,为上层提供无差错的数据传输, 就要能对数据进行检错和纠错.数据链路的建立,拆除,对数据的检错，但是并不纠正错误。 1&gt; 数据链路层为网络层提供可靠的数据传输； 2&gt; 基本数据单位为帧； 3&gt; 主要的协议：以太网协议； 4&gt; 两个重要设备名称：网桥和交换机。 网络层（Network Layer）网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。 Ip地址如数据链路层的MAC地址一样，MAC地址是用来标识同一个链路中不同计算机的一种识别码。 1&gt; 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能； 2&gt; 基本数据单位为IP数据报； 3&gt; 包含的主要协议： IP协议（Internet Protocol，因特网互联协议）; ICMP协议（Internet Control Message Protocol，因特网控制报文协议）; ARP协议（Address Resolution Protocol，地址解析协议）; RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。 4&gt; 重要的设备：路由器。 传输层（Transport Layer）传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能， 负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。 1&gt; 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题； 2&gt; 包含的主要协议： TCP协议（Transmission Control Protocol，传输控制协议） UDP协议（User Datagram Protocol，用户数据报协议） 3&gt; 重要设备：网关。 应用层（application Layer）1&gt; 数据传输基本单位为报文； 2&gt; 包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议）， POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。 IP地址 ip地址分类A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255；(modified @2016.05.31) B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255; C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。 D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）； E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。 注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。 255.255.255.255该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。 注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。 0.0.0.0常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。 回环地址127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。 A、B、C类私有地址私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。 A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255 B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255 C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255 在现在的网络中，IP地址分为公网IP地址和私有IP地址。公网IP是在Internet使用的IP地址，而私有IP地址则是在局域网中使用的IP地址。 私有IP地址是一段保留的IP地址。只使用在局域网中，无法在Internet上使用。 子网掩码及网络划分子网掩码是标志两个IP地址是否同属于一个子网的，也是32位二进制地址，其每一个为1代表该位是网络位，为0代表主机位。它和IP地址一样也是使用点式十进制来表示的。如果两个IP地址在子网掩码的按位与的计算下所得结果相同，即表明它们共属于同一子网中。 在计算子网掩码时，我们要注意IP地址中的保留地址，即“ 0”地址和广播地址，它们是指主机地址或网络地址全为“ 0”或“ 1”时的IP地址，它们代表着本网络地址和广播地址，一般是不能被计算在内的。 子网掩码的计算对于无须再划分成子网的IP地址来说，其子网掩码非常简单，即按照其定义即可写出：如某B类IP地址为 10.12.3.0，无须再分割子网，则该IP地址的子网掩码255.255.0.0。如果它是一个C类地址，则其子网掩码为 255.255.255.0。其它类推，不再详述。下面我们关键要介绍的是一个IP地址，还需要将其高位主机位再作为划分出的子网网络号，剩下的是每个子网的主机号，这时该如何进行每个子网的掩码计算。 题型下面总结一下有关子网掩码和网络划分常见的面试考题： 1）利用子网数来计算 在求子网掩码之前必须先搞清楚要划分的子网数目，以及每个子网内的所需主机数目。 (1) 将子网数目转化为二进制来表示; 如欲将B类IP地址168.195.0.0划分成27个子网：27=11011； (2) 取得该二进制的位数，为N； 该二进制为五位数，N = 5 (3) 取得该IP地址的类子网掩码，将其主机地址部分的的前N位置1即得出该IP地址划分子网的子网掩码。 将B类地址的子网掩码255.255.0.0的主机地址前5位置 1，得到 255.255.248.0 2）利用主机数来计算 如欲将B类IP地址168.195.0.0划分成若干子网，每个子网内有主机700台： (1) 将主机数目转化为二进制来表示； 700=1010111100； (2) 如果主机数小于或等于254（注意去掉保留的两个IP地址），则取得该主机的二进制位数，为N，这里肯定 N&lt;8。如果大于254，则 N&gt;8，这就是说主机地址将占据不止8位； 该二进制为十位数，N=10； (3) 使用255.255.255.255来将该类IP地址的主机地址位数全部置1，然后从后向前的将N位全部置为 0，即为子网掩码值。 将该B类地址的子网掩码255.255.0.0的主机地址全部置1，得到255.255.255.255，然后再从后向前将后 10位置0,即为：11111111.11111111.11111100.00000000，即255.255.252.0。这就是该欲划分成主机为700台的B类IP地址 168.195.0.0的子网掩码。 3）还有一种题型，要你根据每个网络的主机数量进行子网地址的规划和计算子网掩码。这也可按上述原则进行计算。 比如一个子网有10台主机，那么对于这个子网需要的IP地址是： 10＋1＋1＋1＝13 注意：加的第一个1是指这个网络连接时所需的网关地址，接着的两个1分别是指网络地址和广播地址。 因为13小于16（16等于2的4次方），所以主机位为4位。而256－16＝240，所以该子网掩码为255.255.255.240。 如果一个子网有14台主机，不少人常犯的错误是：依然分配具有16个地址空间的子网，而忘记了给网关分配地址。这样就错误了，因为14＋1＋1＋1＝17，17大于16，所以我们只能分配具有32个地址（32等于2的5次方）空间的子网。这时子网掩码为：255.255.255.224。 地址解析协议地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。地址解析协议是建立在网络中各个主机互相信任的基础上的，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。 ARP工作流程举例： 主机A的IP地址为192.168.1.1，MAC地址为0A-11-22-33-44-01； 主机B的IP地址为192.168.1.2，MAC地址为0A-11-22-33-44-02； 当主机A要与主机B通信时，地址解析协议可以将主机B的IP地址（192.168.1.2）解析成主机B的MAC地址，以下为工作流程： （1）根据主机A上的路由表内容，IP确定用于访问主机B的转发IP地址是192.168.1.2。然后A主机在自己的本地ARP缓存中检查主机B的匹配MAC地址。 （2）如果主机A在ARP缓存中没有找到映射，它将询问192.168.1.2的硬件地址，从而将ARP请求帧广播到本地网络上的所有主机。源主机A的IP地址和MAC地址都包括在ARP请求中。本地网络上的每台主机都接收到ARP请求并且检查是否与自己的IP地址匹配。如果主机发现请求的IP地址与自己的IP地址不匹配，它将丢弃ARP请求。 （3）主机B确定ARP请求中的IP地址与自己的IP地址匹配，则将主机A的IP地址和MAC地址映射添加到本地ARP缓存中。 （4）主机B将包含其MAC地址的ARP回复消息直接发送回主机A。 （5）当主机A收到从主机B发来的ARP回复消息时，会用主机B的IP和MAC地址映射更新ARP缓存。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。 TCP/UDP协议TCP TCP/IP协议是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。通俗而言：TCP负责发现传输的问题，一有问题就发出信号，要求重新传输，直到所有数据安全正确地传输到目的地。而IP是给因特网的每一台联网设备规定一个地址。 TCP三次握手和四次挥手 注：seq:&quot;sequance&quot;序列号；ack:&quot;acknowledge&quot;确认号；SYN:&quot;synchronize&quot;请求同步标志；；ACK:&quot;acknowledge&quot;确认标志&quot;；FIN：&quot;Finally&quot;结束标志。 TCP连接建立过程：首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。 Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。 TCP连接断开过程：假设Client端发起中断连接请求，也就是发送FIN报文。 Server端接到FIN报文后，意思是说&quot;我Client端没有数据要发给你了&quot;，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。 所以你先发送ACK，&quot;告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息&quot;。 这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，&quot;告诉Client端，好了，我这边数据发完了，准备好关闭连接了&quot;。 Client端收到FIN报文后，&quot;就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭， 所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。Server端收到ACK后，&quot;就知道可以断开连接了&quot;。 Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！ 为什么要三次握手？在只有两次“握手”的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍； 这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了， 而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据... 问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送 请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，“三次握手”很有必要！ 为什么要四次挥手？试想一下，假如现在你是客户端你想断开跟Server的所有连接该怎么做？ 第一步，你自己先停止向Server端发送数据，并等待Server的回复。 但事情还没有完，虽然你自身不往Server发送数据了，但是因为你们之前已经建立好平等的连接了，所以此时他也有主动权向你发送数据； 故Server端还得终止主动向你发送数据，并等待你的确认。 其实，说白了就是保证双方的一个合约的完整执行！ 使用TCP的协议：FTP（文件传输协议）、Telnet（远程登录协议）、SMTP（简单邮件传输协议）、POP3（和SMTP相对，用于接收邮件）、HTTP协议等。 UDP协议UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。 UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询---应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。 每个UDP报文分UDP报头和UDP数据区两部分。报头由四个16位长（2字节）字段组成，分别说明该报文的源端口、目的端口、报文长度以及校验值。UDP报头由4个域组成，其中每个域各占用2个字节，具体如下： （1）源端口号； （2）目标端口号； （3）数据报长度； （4）校验值。 使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。 TCP 与 UDP 的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。 应用层协议DNS协议DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务，可以简单地理解为将URL转换为IP地址。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。 HTTP协议超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。 HTTP 协议包括哪些请求？ GET：请求读取由URL所标志的信息。 POST：给服务器添加信息（如注释）。 PUT：在给定的URL下存储一个文档。 DELETE：删除给定的URL所标志的资源。 HTTP 中， POST 与 GET 的区别 1）Get是从服务器上获取数据，Post是向服务器传送数据。 2）Get是把参数数据队列加到提交表单的Action属性所指向的URL中，值和表单内各个字段一一对应，在URL中可以看到。 3）Get传送的数据量小，不能大于2KB；Post传送的数据量较大，一般被默认为不受限制。 4）根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。 I. 所谓 安全的 意味着该操作用于获取信息而非修改信息。换句话说，GET请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。 II. 幂等 的意味着对同一URL的多个请求应该返回同样的结果。 在浏览器中输入 www.baidu.com 后执行的全部过程1）客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP请求报文到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。 2）在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。 3）客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。 4）客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。]]></content>
      <categories>
        <category>ComputerNetwork</category>
      </categories>
      <tags>
        <tag>ComputerNetwork</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebService]]></title>
    <url>%2F2018%2F01%2F26%2FWebService%2F</url>
    <content type="text"><![CDATA[WebService学习 WebService什么是WebService WebService入门程序 WebService的应用场景 WebService的三要素 WSDL：web服务描述语言 SOAP：简单对象访问协议 UDDI：目录服务 WebService的四种客户端调用方式 生成客户端调用方式 客户端编程调用方法 HttpURLConnection调用方式 Ajax调用方法 深入开发：使用注解修改WSDL内容 什么是WebService（远程调用技术） 入门程序需求服务端：发布一个天气查询服务，接收客户端城市名，返回天气数据给客户端 客户端：发送城市名称给服务端，接收服务端的返回天气数据，打印 服务端 开发步骤： 1. 创建SEI（Service Endpoint Interface）接口，本质上就是Java接口 2. 创建SEI实现类 3. 发布服务 4. 测试 Weather123456789/** * @ClassName: Weather * @Description: Weather接口 * @author: 天热就吃哈密瓜 * @date: 2018年2月2日 下午3:47:30 */public interface Weather &#123; public String queryWeather(String cityName);&#125; WeatherImpl123456789101112131415/** * @ClassName: WeatherImpl * @Description: Weather实现类 * @author: 天热就吃哈密瓜 * @date: 2018年2月2日 下午3:50:42 */@WebService //@WebService表示该类是一个服务类，需要发布其中的public方法public class WeatherImpl implements Weather&#123; @Override public String queryWeather(String cityName) &#123; System.out.println("from client..."+cityName); String weather = "晴"; return weather; &#125;&#125; WeatherService1234567891011121314/** * @ClassName: WeatherService * @Description: Server发布 * @author: 天热就吃哈密瓜 * @date: 2018年2月2日 下午4:05:48 */public class WeatherService &#123; public static void main(String[] args) &#123; //address：服务地址 //implementor：实现类 Endpoint.publish("http://127.0.0.1:12345/weather", new WeatherImpl()); System.out.println("...."); &#125;&#125; 测试http://127.0.0.1:12345/weather?wsdl 注意，这个xml是从下往上看的！！！ 客户端第一步：wsimport命令生成客户端代码 wsimport -s . http://127.0.0.1:12345/weather?wsdl 第二步：根据使用说明书，使用客户端代码调用服务端 1. 创建服务视图，视图是从service标签的name属性获取 2. 获取服务实现类，实现类从portType的name属性获取 3. 获取查询方法，从portType的operation标签获取 生成客户端代码 根据使用说明书，使用客户端代码调用服务端1234567891011121314151617/** * @ClassName: WeatherClient * @Description: 客户端 * @author: 天热就吃哈密瓜 * @date: 2018年2月2日 下午8:06:25 */public class WeatherClient &#123; public static void main(String[] args) &#123; //根据使用说明书创建使用视图 WeatherImplService service = new WeatherImplService(); //获取服务实现类 WeatherImpl weatherImpl = service.getPort(WeatherImpl.class); //调用查询方法，打印 String weather = weatherImpl.queryWeather("北京"); System.out.println(weather); &#125;&#125; WebService的优缺点优点： 1. 发送方式采用http的post发送，http的默认端口是80，防火墙默认不拦截80，所以跨防火墙 2. 采用XML格式封装数据，XML跨平台的，所以WebService也可以跨平台 3. WebService支持面向对象 缺点： 1. 采用XML格式封装数据，所以在传输过程中，要传输额外的标签，随着SOAP协议的不断完善，标签越来越大，导致WebService性能下降。 WebService应用场景软件集成和复用 适用场景发布一个服务（对内/对外），不考虑客户端类型，不考虑性能，建议使用webservice 服务端已经确定使用webservice，客户端不能选择，必须使用webservice 不适用场景考虑性能时不建议使用webservice 同构程序下不建议使用webservice，比如java 用RMI，不需要翻译成XML的数据 WSDLWSDL指网络服务描述语言（Web Services Description Language）。是一种使用XML编写的文档，这种文档可以描述某个Web Service。它可规定服务的位置，以及此服务提供的操作。 WSDL是一种XML文档，WSDL用于描述网络服务，也可用于定位网络服务 WSDL说明书结构 这里面标签的name属性值就是我们在客户端生成服务器端代码时创建的类名。 &lt;service&gt; 服务视图，webservice的服务结点，它包括了服务端点 &lt;binding&gt; 为每个服务端点定义消息格式和协议细节 &lt;portType&gt; 服务端点，描述 web service可被执行的操作方法，以及相关的消息，通过binding指向portType &lt;message&gt; 定义一个操作（方法）的数据参数(可有多个参数) &lt;types&gt; 定义 web service 使用的全部数据类型 WSDL的阅读方式 SOAPSOAP即简单对象访问协议，他是使用http发送的XML格式的数据，它可以跨平台，跨防火墙，SOAP不是webservice的专有协议。 SOAP=http+xml SOAP是一种网络通信协议 SOAP开始的时候是为了解决传输方式和数据解析（变成了Http和XML），用于解决跨平台应用程序之间的通信。SOAP其实就是通过Http协议发送XML。 所有HTML标签写的东西都可以使用SOAP解析数据 HTTP和SOAP SOAP协议格式1. 必须有Envelope元素，此元素将整个XML文档标识为一条SOAP消息 2. 可选的Header元素，包含头部信息 3. 必须Body元素，包含所有的调用和响应信息 4. 可选的Fault元素，提供有关在处理此消息所发生错误的信息。 TCP/IP Monitor监视Soap协议配置 访问http://127.0.0.1:54321/weather?wsdl，能够访问到，说明代理成功。 SOAP1.1 request1234567891011121314151617181920212223GET /weather?wsdl HTTP/1.1User-Agent: Java/1.8.0_161Host: 127.0.0.1:54321Accept: text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2Connection: keep-alivePOST /weather HTTP/1.1Accept: text/xml, multipart/relatedContent-Type: text/xml; charset=utf-8SOAPAction: "http://service.xd/WeatherImpl/queryWeatherRequest"User-Agent: JAX-WS RI 2.2.9-b130926.1035 svn-revision#5f6196f2b90e9460065a4c2f4e30e065b245e51eHost: 127.0.0.1:54321Connection: keep-aliveContent-Length: 203&lt;?xml version="1.0" ?&gt;&lt;S:Envelope xmlns:S="http://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;S:Body&gt; &lt;ns2:queryWeather xmlns:ns2="http://service.xd/"&gt; &lt;arg0&gt;北京&lt;/arg0&gt; &lt;/ns2:queryWeather&gt; &lt;/S:Body&gt;&lt;/S:Envelope&gt; response 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263HTTP/1.1 200 OKDate: Fri, 02 Feb 2018 13:58:01 GMTTransfer-encoding: chunkedContent-type: text/xml;charset=utf-8848&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- Published by JAX-WS RI (http://jax-ws.java.net). RI's version is JAX-WS RI 2.2.9-b130926.1035 svn-revision#5f6196f2b90e9460065a4c2f4e30e065b245e51e. --&gt;&lt;!-- Generated by JAX-WS RI (http://jax-ws.java.net). RI's version is JAX-WS RI 2.2.9-b130926.1035 svn-revision#5f6196f2b90e9460065a4c2f4e30e065b245e51e. --&gt;&lt;definitions xmlns:wsu="http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd" xmlns:wsp="http://www.w3.org/ns/ws-policy" xmlns:wsp1_2="http://schemas.xmlsoap.org/ws/2004/09/policy" xmlns:wsam="http://www.w3.org/2007/05/addressing/metadata" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:tns="http://service.xd/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="http://schemas.xmlsoap.org/wsdl/" targetNamespace="http://service.xd/" name="WeatherImplService"&gt; &lt;types&gt; &lt;xsd:schema&gt; &lt;xsd:import namespace="http://service.xd/" schemaLocation="http://127.0.0.1:54321/weather?xsd=1"/&gt; &lt;/xsd:schema&gt; &lt;/types&gt; &lt;message name="queryWeather"&gt; &lt;part name="parameters" element="tns:queryWeather"&gt;&lt;/part&gt; &lt;/message&gt; &lt;message name="queryWeatherResponse"&gt; &lt;part name="parameters" element="tns:queryWeatherResponse"&gt;&lt;/part&gt; &lt;/message&gt; &lt;portType name="WeatherImpl"&gt; &lt;operation name="queryWeather"&gt; &lt;input wsam:Action="http://service.xd/WeatherImpl/queryWeatherRequest" message="tns:queryWeather"/&gt; &lt;output wsam:Action="http://service.xd/WeatherImpl/queryWeatherResponse" message="tns:queryWeatherResponse"/&gt; &lt;/operation&gt; &lt;/portType&gt; &lt;binding name="WeatherImplPortBinding" type="tns:WeatherImpl"&gt; &lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"&gt;&lt;/soap:binding&gt; &lt;operation name="queryWeather"&gt; &lt;soap:operation soapAction=""&gt;&lt;/soap:operation&gt; &lt;input&gt; &lt;soap:body use="literal"&gt;&lt;/soap:body&gt; &lt;/input&gt; &lt;output&gt; &lt;soap:body use="literal"&gt;&lt;/soap:body&gt; &lt;/output&gt; &lt;/operation&gt; &lt;/binding&gt; &lt;service name="WeatherImplService"&gt; &lt;port name="WeatherImplPort" binding="tns:WeatherImplPortBinding"&gt; &lt;soap:address location="http://127.0.0.1:54321/weather"&gt;&lt;/soap:address&gt; &lt;/port&gt; &lt;/service&gt;&lt;/definitions&gt;0HTTP/1.1 200 OKDate: Fri, 02 Feb 2018 13:58:01 GMTTransfer-encoding: chunkedContent-type: text/xml; charset=utf-8dc&lt;?xml version="1.0" ?&gt;&lt;S:Envelope xmlns:S="http://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;S:Body&gt; &lt;ns2:queryWeatherResponse xmlns:ns2="http://service.xd/"&gt; &lt;return&gt;晴&lt;/return&gt; &lt;/ns2:queryWeatherResponse&gt; &lt;/S:Body&gt;&lt;/S:Envelope&gt;0 SOAP1.21. 如何发布SOAP1.2服务端 2. Jaxws不支持SOAP1.2服务端发布，直接发布会报如下异常 如果想发布SOAP1.2服务端，需要在服务端引入第三方JAR（jaxws-ri-2.2.8） 在实现类上加入注解:@BindingType(SOAPBinding.SOAP12HTTP_BINDING) request 1234567891011121314151617POST /weather HTTP/1.1Accept: application/soap+xml, multipart/relatedContent-Type: application/soap+xml; charset=utf-8;action="http://ws.jaxws.ws.itcast.cn/WeatherInterfaceImpl/queryWeatherRequest"User-Agent: JAX-WS RI 2.2.4-b01Host: 127.0.0.1:54321Connection: keep-aliveContent-Length: 212&lt;?xml version="1.0" ?&gt;&lt;S:Envelope xmlns:S="http://www.w3.org/2003/05/soap-envelope"&gt; &lt;S:Body&gt; &lt;ns2:queryWeather xmlns:ns2="http://ws.jaxws.ws.itcast.cn/"&gt; &lt;arg0&gt;北京&lt;/arg0&gt; &lt;/ns2:queryWeather&gt; &lt;/S:Body&gt;&lt;/S:Envelope&gt; response 12345678910111213HTTP/1.1 200 OKTransfer-encoding: chunkedContent-type: application/soap+xml; charset=utf-8Date: Thu, 26 Nov 2015 03:25:24 GMT&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;S:Envelope xmlns:S="http://www.w3.org/2003/05/soap-envelope"&gt; &lt;S:Body&gt; &lt;ns2:queryWeatherResponse xmlns:ns2="http://ws.jaxws.ws.itcast.cn/"&gt; &lt;return&gt;晴&lt;/return&gt; &lt;/ns2:queryWeatherResponse&gt; &lt;/S:Body&gt;&lt;/S:Envelope&gt; SOAP1.1和1.2的区别相同点： 1. 请求发送方式相同：都是使用POST 2. 协议内容相同：都有Envelope和Body标签 不同点： 1. 数据格式不同：content-type不同 SOAP1.1：text/xml;charset=utf-8 SOAP1.2：application/soap+xml;charset=utf-8 2. 命名空间不同： SOAP1.1：http://schemas.xmlsoap.org/soap/envelope/ SOAP1.2：http://www.w3.org/2003/05/soap-envelope UDDIUDDI 是一种目录服务，企业可以使用它对 Web services 进行注册和搜索。UDDI，英文为 &quot;Universal Description, Discovery and Integration&quot;，可译为“通用描述、发现与集成服务”。 UDDI 并不像 WSDL 和 SOAP 一样深入人心，因为很多时候，使用者知道 Web 服务的位置（通常位于公司的企业内部网中）。 Webservice的四种客户端调用方式公网地址：http://www.webxml.com.cn/zh_cn/index.aspx 第一种生成客户端调用方式（DOS命令）Wsimport命令介绍Wsimport就是jdk提供的一个工具，他就是根据WSDL地址生成客户端代码 Wsimport在JAVA_HOME/bin Wsimport常用参数： -s：生成java文件 -d：生成class文件的，默认的参数 -p：指定包名，如果不加该参数，默认包名就是WSDL文档中的命名空间的倒序。 Winimport仅支持SOAP1.1客户端的生成。 调用公网手机号归属地查询服务1. Wsimport生成客户端代码 2. 阅读使用说明书，使用生成客户端代码调用服务端 Wsimport生成客户端代码http://webservice.webxml.com.cn/WebServices/MobileCodeWS.asmx?wsdl 客户端代码调用服务端123456789101112public class MobileClient &#123; public static void main(String[] args) &#123; //创建服务视图 MobileCodeWS mobileCodeWS = new MobileCodeWS(); //获取服务实现类 MobileCodeWSSoap mobileCodeWSSoap = mobileCodeWS.getPort(MobileCodeWSSoap.class); //调用查询方法 String reuslt = mobileCodeWSSoap.getMobileCodeInfo("13888888", null); System.out.println(reuslt); &#125;&#125; 该种方式使用简单，但一些关键的元素在代码生成时写死到生成代码中，不方便维护，所以仅用于测试。 第二种：service编程调用方式1234567891011121314151617181920212223public class ServiceClient &#123; public static void main(String[] args) throws IOException &#123; //创建WSDL的URL，注意不是服务地址 URL url = new URL("http://webservice.webxml.com.cn/WebServices/MobileCodeWS.asmx?wsdl"); //创建服务名称 //1.namespaceURI - 命名空间地址 //2.localPart - 服务视图名 QName qname = new QName("http://WebXml.com.cn/", "MobileCodeWS"); //创建服务视图 //参数解释： //1.wsdlDocumentLocation - wsdl地址 //2.serviceName - 服务名称 Service service = Service.create(url, qname); //获取服务实现类 MobileCodeWSSoap mobileCodeWSSoap = service.getPort(MobileCodeWSSoap.class); //调用查询方法 String result = mobileCodeWSSoap.getMobileCodeInfo("1866666666", ""); System.out.println(result); &#125;&#125; 第三种：HttpURLConnection调用方式1234567891011121314151617181920212223242526272829303132333435363738394041public class HttpClient &#123; public static void main(String[] args) throws IOException &#123; //第一步：创建服务地址，不是WSDL地址 URL url = new URL("http://webservice.webxml.com.cn/WebServices/MobileCodeWS.asmx"); //第二步：打开一个通向服务地址的连接 HttpURLConnection connection = (HttpURLConnection) url.openConnection(); //第三步：设置参数 //3.1发送方式设置：POST必须大写 connection.setRequestMethod("POST"); //3.2设置数据格式：content-type connection.setRequestProperty("content-type", "text/xml;charset=utf-8"); //3.3设置输入输出，因为默认新创建的connection没有读写权限， connection.setDoInput(true); connection.setDoOutput(true); //第四步：组织SOAP数据，发送请求 String soapXML = getXML("15226466316"); OutputStream os = connection.getOutputStream(); os.write(soapXML.getBytes()); //第五步：接收服务端响应，打印 int responseCode = connection.getResponseCode(); if(200 == responseCode)&#123;//表示服务端响应成功 InputStream is = connection.getInputStream(); InputStreamReader isr = new InputStreamReader(is); BufferedReader br = new BufferedReader(isr); StringBuilder sb = new StringBuilder(); String temp = null; while(null != (temp = br.readLine()))&#123; sb.append(temp); &#125; System.out.println(sb.toString()); is.close(); isr.close(); br.close(); &#125; os.close(); &#125; Ajax调用方式12345678910111213141516171819202122232425262728293031323334353637383940&lt;!doctype html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script type="text/javascript"&gt; function queryMobile()&#123; //创建XMLHttpRequest对象 var xhr = new XMLHttpRequest(); //打开连接 xhr.open("post","http://webservice.webxml.com.cn/WebServices/MobileCodeWS.asmx",true); //设置数据类型 xhr.setRequestHeader("content-type","text/xml;charset=utf-8"); //设置回调函数 xhr.onreadystatechange=function()&#123; //判断是否发送成功和判断服务端是否响应成功 if(4 == xhr.readyState &amp;&amp; 200 == xhr.status)&#123; alert(xhr.responseText); &#125; &#125; //组织SOAP协议数据 var soapXML = "&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;" +"&lt;soap:Envelope xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt;" +"&lt;soap:Body&gt;" +"&lt;getMobileCodeInfo xmlns=\"http://WebXml.com.cn/\"&gt;" +"&lt;mobileCode&gt;"+document.getElementById("phoneNum").value+"&lt;/mobileCode&gt;" +"&lt;userID&gt;&lt;/userID&gt;" +"&lt;/getMobileCodeInfo&gt;" +"&lt;/soap:Body&gt;" +"&lt;/soap:Envelope&gt;"; alert(soapXML); //发送数据 xhr.send(soapXML); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; 手机号查询：&lt;input type="text" id="phoneNum"/&gt; &lt;input type="button" value="查询" onclick="javascript:queryMobile();"/&gt; &lt;/body&gt;&lt;/html&gt; 深入开发：用注解修改WSDL内容WebService的注解都位于javax.jws包下: @WebService-定义服务，在public class上边 targetNamespace：指定命名空间 name：portType的名称 portName：port的名称 serviceName：服务名称 endpointInterface：SEI接口地址，如果一个服务类实现了多个接口，只需要发布一个接口的方法，可通过此注解指定要发布服务的接口。 @WebMethod-定义方法，在公开方法上边 operationName：方法名 exclude：设置为true表示此方法不是webservice方法，反之则表示webservice方法，默认是false @WebResult-定义返回值，在方法返回值前边 name：返回结果值的名称 @WebParam-定义参数，在方法参数前边 name：指定参数的名称 作用： 通过注解，可以更加形像的描述Web服务。对自动生成的wsdl文档进行修改，为使用者提供一个更加清晰的wsdl文档。 当修改了WebService注解之后，会影响客户端生成的代码。调用的方法名和参数名也发生了变化 CXF介绍 安装配置CXF是一个开源的webservice框架，提供很多完善功能，可以实现快速开发 CXF支持的协议：SOAP1.1/1.2，REST CXF支持数据格式：XML，JSON（仅在REST方式下支持） 安装和配置第一步：安装JDK，建议1.7 第二步：解压apache-cxf-2.7.11.zip到指定目录，创建CXF_HOME 第三步：把CXF_HOME加入到Path路径下 第四步：测试，在cmd下加入wsdl2java –h CXF发布SOAP协议的服务服务端：发布服务，接收客户端的城市名，返回天气数据给客户端 客户端：发送城市名给服务端，接收服务端的响应信息，打印 服务端 1. 导入Jar包 2. 创建SEI接口 3. 创建SEI实现类 4. 发布服务 5. 测试服务是否发布成功 SEI接口和实现类123456789101112131415161718192021222324/** * @ClassName: WeatherInterface * @Description: CXF实现发布接口 * @author: 天热就吃哈密瓜 * @date: 2018年2月3日 下午2:49:59 */@WebServicepublic interface WeatherInterface &#123; public String queryWeather(String cityName);&#125;/** * @ClassName: WeatherInterfaceImpl * @Description: CXF实现发布 * @author: 天热就吃哈密瓜 * @date: 2018年2月3日 下午3:11:49 */public class WeatherInterfaceImpl implements WeatherInterface&#123; @Override public String queryWeather(String cityName) &#123; System.out.println("from"+cityName+":"); return "Sunny"; &#125;&#125; 发布服务1234567891011121314151617181920/** * @ClassName: WeatherServer * @Description: 发布服务 * @author: 天热就吃哈密瓜 * @date: 2018年2月3日 下午3:49:54 */public class WeatherServer &#123; public static void main(String[] args) &#123; //JaxWsServerFactoryBean发布服务 JaxWsServerFactoryBean jaxWsServerFactoryBean = new JaxWsServerFactoryBean(); //设置服务端口 jaxWsServerFactoryBean.setServiceClass(WeatherInterface.class); //设置服务实现类 jaxWsServerFactoryBean.setServiceBean(WeatherInterfaceImpl.class); //设置服务地址 jaxWsServerFactoryBean.setAddress("http://127.0.0.1:12345/weather"); //发布 jaxWsServerFactoryBean.create(); &#125;&#125; 测试发布123456789101112131415http://127.0.0.1:12345/weather&lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt; &lt;soap:Body&gt; &lt;soap:Fault&gt; &lt;faultcode&gt;soap:Server&lt;/faultcode&gt; &lt;faultstring&gt; No binding operation info while invoking unknown method with params unknown. &lt;/faultstring&gt; &lt;/soap:Fault&gt; &lt;/soap:Body&gt;&lt;/soap:Envelope&gt;此时直接访问WSDL说明书http://127.0.0.1:12345/weather?wsdl SOAP1.21. 在接口上加入如下注解：@BindingType(SOAPBinding.SOAP12HTTP_BINDING) 2. 重新发布服务端 客户端第一步：生成客户端代码 1. Wsdl2java命令是CXF提供的生成客户端的工具，他和Wsimport类似，可以根据WSDL生成客户端代码 2. Wsdl2java常用参数： -d：指定输出目录 -p：指定包名，如果不指定该参数，默认包名是WSDL的命名空间倒序，Wsdl2java支持SOAP1.1和SOAP1.2 第二步：使用说明书，使用生成代码调用服务器 调用代码12345678910111213141516171819202122package cxf.client;import org.apache.cxf.jaxws.JaxWsProxyFactoryBean;import cn.itcast.cxf.weather.WeatherInterface;public class WeatherClient &#123; public static void main(String[] args) &#123; //JaxWsProxyFactoryBean调用服务端 JaxWsProxyFactoryBean jaxWsProxyFactoryBean = new JaxWsProxyFactoryBean(); //设置服务接口 jaxWsProxyFactoryBean.setServiceClass(WeatherInterface.class); //设置服务地址 jaxWsProxyFactoryBean.setAddress("http://127.0.0.1:12345/weather"); //获取服务接口实例 WeatherInterface weatherInterface = jaxWsProxyFactoryBean.create(WeatherInterface.class); //调用查询方法 String weather = weatherInterface.queryWeather("保定"); System.out.println(weather); &#125;&#125; CXF和Spring整合CXF和Spring整合发布SOAP协议的服务 服务端第一步：创建Web项目 第二步：创建SEI接口 第三步：创建SEI实现类 第四步：spring配置文件，applicationContext.xml 第五步：配置Web.xml 第六步：部署到Tomcat下，启动Tomcat 第七步：测试服务 客户端]]></content>
      <categories>
        <category>WebService</category>
      </categories>
      <tags>
        <tag>WebService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[COP（Spring中和核心思想）]]></title>
    <url>%2F2018%2F01%2F25%2FCOP%EF%BC%88Spring-IoC-DI-AOP%EF%BC%89%2F</url>
    <content type="text"><![CDATA[重新复习一个Spring的IoC、DI、AOP思想]]></content>
      <categories>
        <category>COP</category>
      </categories>
      <tags>
        <tag>COP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[COP（SringMVC）]]></title>
    <url>%2F2018%2F01%2F24%2FCOP%EF%BC%88SpringMVC%EF%BC%89%2F</url>
    <content type="text"><![CDATA[COP开始学习SSM，SpringMVC 第一天：springmvc的基础知识 什么是springmvc？ springmvc框架原理（掌握） 前端控制器、处理器映射器、处理器适配器、视图解析器 springmvc入门程序 目的：对前端控制器、处理器映射器、处理器适配器、视图解析器学习 非注解的处理器映射器、处理器适配器 注解的处理器映射器、处理器适配器（掌握） springmvc和mybatis整合（掌握） springmvc注解开发：（掌握） 常用的注解学习 参数绑定（简单类型、pojo、集合类型（明天讲）） 自定义参数绑定（掌握） springmvc和struts2区别 第二天：springmvc的高级应用 参数绑定（集合类型） 数据回显 上传图片 json数据交互 RESTful支持 拦截器 SpringMVC Basic什么是SpringMVC springmvc是spring框架的一个模块，springmvc和spring无需通过中间整合层进行整合。（struts2与Spring整合的时候需要借助单独的jar包） springmvc是一个基于mvc的web框架。 什么是Mvcmvc是一个设计模式，mvc在b/s系统下的应用： SpringMVC 流程： 第一步：发起请求到前端控制器(DispatcherServlet) 第二步：前端控制器请求HandlerMapping查找 Handler 可以根据xml配置、注解进行查找 第三步：处理器映射器HandlerMapping向前端控制器返回Handler 第四步：前端控制器调用处理器适配器去执行Handler 第五步：处理器适配器去执行Handler 第六步：Handler执行完成给适配器返回ModelAndView 第七步：处理器适配器向前端控制器返回ModelAndView ModelAndView是springmvc框架的一个底层对象，包括 Model和view 第八步：前端控制器请求视图解析器去进行视图解析 根据逻辑视图名解析成真正的视图(jsp) 第九步：视图解析器向前端控制器返回View 第十步：前端控制器进行视图渲染 视图渲染将模型数据(在ModelAndView对象中)填充到request域 第十一步：前端控制器向用户响应结果 组件： 组件： 1、前端控制器DispatcherServlet（不需要程序员开发） 作用接收请求，响应结果，相当于转发器，中央处理器。 有了DispatcherServlet减少了其它组件之间的耦合度。 2、处理器映射器HandlerMapping(不需要程序员开发) 作用：根据请求的url查找Handler 3、处理器适配器HandlerAdapter 作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler 4、处理器Handler(需要程序员开发) 注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler 5、视图解析器View resolver(不需要程序员开发) 作用：进行视图解析，根据逻辑视图名解析成真正的视图（view） 6、视图View(需要程序员开发jsp) View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf...） SpringMVC入门需求 环境搭建1. MySQL 2. Jar包 3. 创建工程 配置前端控制器在web.xml中配置前端控制器 12345678910111213141516171819202122232425&lt;!-- SpringMVC前端控制器 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 前端控制器需要HandlerMapping、Adapter 如果不配置，默认会加载在WEB-INF/servlet名称-serlvet.xml --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;!-- 第一种：*.action,访问以.action结尾由DispatcherServlet解析 第二种：/，所有访问的地址都由DispatcherServlet进行解析，对于静态文件的解析需要配置不让DispatcherServlet进行解析 这种方式可以实现RESETful风格的url 第三种:/*,这样配置不对，使用这种配置，最终要转发到一个jsp页面时，仍然会由 DispatcherServlet解析jsp地址，不能根据jsp页面找到handler，会报错 --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 配置HandlerMapping、HandlerAdapter、View解析器HandlerAdapter12345678910111213141516在classpath下的springmvc中配置HandlerAdapter&lt;!-- 处理器适配器：所有实现了HandlerAdapter的类 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter" /&gt;public class SimpleControllerHandlerAdapter implements HandlerAdapter&#123; public boolean supports(Object handler)&#123; return (handler instanceof Controller); &#125;&#125;public interface Controller&#123; ModelAndView handlerRequest(HttpServletRequest request,HttpServletResponse response) throws Exception;&#125; 开发Handler1234567891011121314151617181920212223242526272829303132333435363738/** * @ClassName: ItemController * @Description: TODO * @author: 天热就吃哈密瓜 * @date: 2018年1月28日 上午10:48:45 */public class ItemController implements Controller&#123; @Override public ModelAndView handleRequest(HttpServletRequest arg0, HttpServletResponse arg1) throws Exception &#123; //调用service查找数据库，查询商品列表，这里使用静态数据静态模拟 List&lt;Items&gt; list = new ArrayList&lt;Items&gt;(); //向list中填充静态数据 Items items_1 = new Items(); items_1.setName("联想笔记本"); items_1.setPrice(6000f); items_1.setDetail("ThinkPad T430 联想笔记本电脑！"); Items items_2 = new Items(); items_2.setName("苹果手机"); items_2.setPrice(5000f); items_2.setDetail("iphone6苹果手机！"); list.add(items_1); list.add(items_2); //返回ModelAndView ModelAndView modelAndView = new ModelAndView(); //相当于request的setAttribute，在jsp页面中通过itemsList取数据 modelAndView.addObject("itemsList",list); //指定视图 modelAndView.setViewName("/WEB-INF/jsp/items/itemsList.jsp"); return modelAndView; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546items.jsp&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/fmt" prefix="fmt"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;查询商品列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="$&#123;pageContext.request.contextPath &#125;/item/queryItem.action" method="post"&gt;查询条件：&lt;table width="100%" border=1&gt;&lt;tr&gt;&lt;td&gt;&lt;input type="submit" value="查询"/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;商品列表：&lt;table width="100%" border=1&gt;&lt;tr&gt; &lt;td&gt;商品名称&lt;/td&gt; &lt;td&gt;商品价格&lt;/td&gt; &lt;td&gt;生产日期&lt;/td&gt; &lt;td&gt;商品描述&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt;&lt;/tr&gt;&lt;c:forEach items="$&#123;itemsList&#125;" var="item"&gt;&lt;tr&gt; &lt;td&gt;$&#123;item.name&#125;&lt;/td&gt; &lt;td&gt;$&#123;item.price&#125;&lt;/td&gt; &lt;td&gt;&lt;fmt:formatDate value="$&#123;item.createtime&#125;" pattern="yyyy-MM-dd HH:mm:ss"/&gt;&lt;/td&gt; &lt;td&gt;$&#123;item.detail&#125;&lt;/td&gt; &lt;td&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/item/editItem.action?id=$&#123;item.id&#125;"&gt;修改&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt;&lt;/table&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; Handler映射器注意：HandlerMapping也是在.xml中通过bean来找到自己的要的Handler的，所以需要Handler的beanname，也就是Handler也需要在.xml中配置。 1234567&lt;!-- 配置Handler，为了让HandlerMapping找到这个Handler --&gt;&lt;bean name="/queryItems.action" class="xd.ssm.controller.ItemController"/&gt;&lt;!-- 处理器映射器:将bean的name作为url进行查找，需要在配置Handler时指定beanname（url）--&gt;&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping" /&gt; View解析器12345&lt;!-- 视图解析器 解析jsp解析，默认使用jstl标签，classpath下的得有jstl的包--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"/&gt; 部署调试&lt;!-- 配置Handler，为了让HandlerMapping找到这个Handler --&gt; &lt;bean name=&quot;/queryItems.action&quot; class=&quot;xd.ssm.controller.ItemController&quot;/&gt; http://127.0.0.1:8080/SpringMVC/queryItems.action SpringMVC入门（非注解HandllerMapping、HandlerAdapter）HandllerMapping（非注解）123456789方法一：&lt;!-- 配置Handler，为了让HandlerMapping找到这个Handler --&gt;&lt;bean name="/queryItems.action" class="xd.ssm.controller.ItemController"/&gt;&lt;!-- 处理器映射器:将bean的name作为url进行查找，需要在配置Handler时指定beanname（url）--&gt;&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping" /&gt; 1234567891011121314151617181920方法二:&lt;!-- 配置Handler，为了让HandlerMapping找到这个Handler --&gt;&lt;bean id="itemsController" name="/queryItems.action" class="xd.ssm.controller.ItemController"/&gt;&lt;!-- 处理器映射器:将bean的name作为url进行查找，需要在配置Handler时指定beanname（url）--&gt;&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping" /&gt;&lt;!--简单url映射 --&gt;&lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;!-- 对itemsController1进行url映射，url是/queryItems1.action --&gt; &lt;prop key="/queryItems1.action"&gt;itemsController&lt;/prop&gt; &lt;prop key="/queryItems2.action"&gt;itemsController&lt;/prop&gt; &lt;!-- &lt;prop key="/queryItems3.action"&gt;itemsController2&lt;/prop&gt; --&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 方法二中多个映射器可以并存，前端控制器判断url能让哪些映射器映射，就让正确的映射器处理。 HandlerAdapter（非注解）123456方法一：&lt;!-- 处理器适配器：所有实现了HandlerAdapter的类 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter" /&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354方法二：&lt;!-- 处理器适配器：所有实现了HandlerAdapter的类 --&gt;&lt;bean id="httpController" class="xd.ssm.controller.httpController"/&gt;&lt;!--简单url映射 --&gt;&lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;!-- 对itemsController1进行url映射，url是/queryItems1.action --&gt; &lt;prop key="/queryItems1.action"&gt;itemsController&lt;/prop&gt; &lt;prop key="/queryItems2.action"&gt;itemsController&lt;/prop&gt; &lt;prop key="/queryItems3.action"&gt;httpController&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter" /&gt;&lt;bean class="org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter"/&gt;public class HttpController implements HttpRequestHandler&#123; @Override public void handleRequest(HttpServletRequest request, HttpServletResponse reponse) throws ServletException, IOException &#123; //调用service查找数据库，查询商品列表，这里使用静态数据静态模拟 List&lt;Items&gt; list = new ArrayList&lt;Items&gt;(); //向list中填充静态数据 Items items_1 = new Items(); items_1.setName("联想笔记本"); items_1.setPrice(6000f); items_1.setDetail("ThinkPad T430 联想笔记本电脑！"); Items items_2 = new Items(); items_2.setName("苹果手机"); items_2.setPrice(5000f); items_2.setDetail("iphone6苹果手机！"); list.add(items_1); list.add(items_2); //设置模型数据 request.setAttribute("itemsList", list); //设置转发视图 request.getRequestDispatcher("/WEB-INF/jsp/items/itemsList.jsp").forward(request, reponse); &#125;&#125; 方法一要求编写Handler实现Controller接口，方法二要求编写的Handler实现HttpRequestHandler接口 1234567891011121314151617181920212223242526272829303132333435363738/** * @ClassName: HttpController * @Description: Handler控制器 * @author: 天热就吃哈密瓜 * @date: 2018年1月28日 下午12:25:21 */public class HttpController implements HttpRequestHandler&#123; @Override public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //调用service查找数据库，查询商品列表，这里使用静态数据静态模拟 List&lt;Items&gt; list = new ArrayList&lt;Items&gt;(); //向list中填充静态数据 Items items_1 = new Items(); items_1.setName("联想笔记本"); items_1.setPrice(6000f); items_1.setDetail("ThinkPad T430 联想笔记本电脑！"); Items items_2 = new Items(); items_2.setName("苹果手机"); items_2.setPrice(5000f); items_2.setDetail("iphone6苹果手机！"); list.add(items_1); list.add(items_2); //设置模型数据 request.setAttribute("itemsList", list); //设置转发视图 request.getRequestDispatcher("/WEB-INF/jsp/items/itemsList.jsp").forward(request, response); //使用这种方法可以修改response的格式：// response.setCharacterEncoding("UTF-8");// response.setContentType("application/json;charset=utf-8");// response.getWriter().write("json"); &#125;&#125; DispatcherServlet.properties如果我们不在自己的.xml中配置处理器和适配器，那么DispatcherServlet.properties里面自己去默认加载 12345678910111213141516171819org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\ org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMappingorg.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\ org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\ org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter``` ## SpringMVC入门（注解HandllerMapping、HandlerAdapter）### HandllerMapping（注解） 在Sping3.1前使用org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping 在Spring3.2就变了 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping```java&lt;!--注解映射器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/&gt; HandlerAdapter（注解）在Sping3.1前使用org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter 在Spring3.2就变了 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter 12&lt;!--注解适配器 --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/&gt; mvc:annotation-driven（注解）&lt;!-- 使用 mvc:annotation-driven代替上边注解映射器和注解适配器配置 mvc:annotation-driven默认加载很多的参数绑定方法， 比如json转换解析器就默认加载了，如果使用mvc:annotation-driven不用配置上边的RequestMappingHandlerMapping和RequestMappingHandlerAdapter 实际开发时使用mvc:annotation-driven --&gt; &lt;!-- &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; --&gt; Handler开发（注解）使用注解的映射器和注解的适配器（必须成对使用） springmvc.xml 1234567891011121314151617181920212223242526&lt;!-- 对于注解的Handler可以单个配置，但是实际开发中建议使用组件扫描 可以扫描controller、service... 这里扫描controller，指定controller的包--&gt;&lt;bean class="xd.ssm.controller.AnnotationController"/&gt;&lt;!-- &lt;context:component-scan base-package="xd.ssm.controller"/&gt; --&gt;&lt;!--注解映射器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/&gt;&lt;!--注解适配器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/&gt;&lt;!-- 使用 mvc:annotation-driven代替上边注解映射器和注解适配器配置 mvc:annotation-driven默认加载很多的参数绑定方法， 比如json转换解析器就默认加载了，如果使用mvc:annotation-driven不用配置上边的RequestMappingHandlerMapping和RequestMappingHandlerAdapter 实际开发时使用mvc:annotation-driven --&gt;&lt;!-- &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; --&gt;&lt;!-- 视图解析器 解析jsp解析，默认使用jstl标签，classpath下的得有jstl的包--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"/&gt; AnnotationController.java 1234567891011121314151617181920212223242526272829303132333435363738394041/** * @ClassName: AnnotationController * @Description: 注解控制器 * @author: 天热就吃哈密瓜 * @date: 2018年1月28日 下午12:44:48 */@Controller//使用@Controller来注解，这样就不用实现接口了public class AnnotationController &#123; //商品查询 //一般建议注释和方法名一样 //@RequestMapping实现对queryItems方法和url进行映射，一个方法对应一个url //"/queryItems.action",action可写可不写 @RequestMapping("/queryItems") public ModelAndView queryItems() throws Exception &#123; //调用service查找数据库，查询商品列表，这里使用静态数据静态模拟 List&lt;Items&gt; list = new ArrayList&lt;Items&gt;(); //向list中填充静态数据 Items items_1 = new Items(); items_1.setName("联想笔记本"); items_1.setPrice(6000f); items_1.setDetail("ThinkPad T430 联想笔记本电脑！"); Items items_2 = new Items(); items_2.setName("苹果手机"); items_2.setPrice(5000f); items_2.setDetail("iphone6苹果手机！"); list.add(items_1); list.add(items_2); //返回ModelAndView ModelAndView modelAndView = new ModelAndView(); //相当于request的setAttribute，在jsp页面中通过itemsList取数据 modelAndView.addObject("itemsList",list); //指定视图 modelAndView.setViewName("/WEB-INF/jsp/items/itemsList.jsp"); return modelAndView; &#125; SpringMVC入门（流程源码）通过前端控制器源码分析SpringMVC的执行过程 第一步：前端控制器接受请求，调用doDispatch 第二步：前端控制器调用处理器映射器查找Handler 第三步：前端控制器调用处理器适配器执行Handler，得到执行结果ModelAndView 第四步：视图渲染，将model数据填充到request域。 SpringMVC（springmvc.xml中View配置）1234567891011121314&lt;!-- 视图解析器 解析jsp解析，默认使用jstl标签，classpath下的得有jstl的包--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 配置jsp路径的前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;!-- 配置jsp路径的后缀 --&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt;//指定视图(handler中) modelAndView.setViewName("items/itemsList"); return modelAndView; SSM整合需求使用SpringMVC和MyBatis完成商品列表查询。 SpringMVC+MyBatis架构 第一步：整合dao层 mybatis和spring整合，通过spring管理mapper接口。 使用mapper的扫描器自动扫描mapper接口在spring中进行注册。 第二步：整合service层 通过spring管理 service接口。 使用配置方式将service接口配置在spring配置文件中。 实现事务控制。 第三步：整合springmvc springmvc是spring的模块，不需要整合。 整合思路（环境）1. java环境 2. Spring3.2（注意，3.2和jdk1.8不能一起用） 3. jar包 1. 数据库驱动包 2. MyBatis的jar包 3. MyBatis和Spring整合包 4. log4j 5. 数据库连接池 6. spring3.2的jar 整合结构 voItems.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * @ClassName: Items * @Description: 商品类 * @author: 天热就吃哈密瓜 * @date: 2018年1月28日 下午6:10:03 */public class Items &#123; private Integer id; private String name; private Float price; private String pic; private Date createtime; private String detail; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name == null ? null : name.trim(); &#125; public Float getPrice() &#123; return price; &#125; public void setPrice(Float price) &#123; this.price = price; &#125; public String getPic() &#123; return pic; &#125; public void setPic(String pic) &#123; this.pic = pic == null ? null : pic.trim(); &#125; public Date getCreatetime() &#123; return createtime; &#125; public void setCreatetime(Date createtime) &#123; this.createtime = createtime; &#125; public String getDetail() &#123; return detail; &#125; public void setDetail(String detail) &#123; this.detail = detail == null ? null : detail.trim(); &#125;&#125; ItemsCustom.java 123456789/** * @ClassName: ItemsCustom * @Description: 商品信息的扩展类 * @author: 天热就吃哈密瓜 * @date: 2018年1月28日 下午6:10:33 */public class ItemsCustom extends Items &#123; //添加商品信息的扩展属性&#125; ItemsQueryVo.java 123456789101112131415161718192021222324252627282930313233/** * @ClassName: ItemsQueryVo * @Description: 商品包装对象 * @author: 天热就吃哈密瓜 * @date: 2018年1月28日 下午6:11:19 */public class ItemsQueryVo &#123; //商品信息 private Items items; //为了系统 可扩展性，对原始生成的po进行扩展 private ItemsCustom itemsCustom; //用户信息 //private UserCustom userCustom; public Items getItems() &#123; return items; &#125; public void setItems(Items items) &#123; this.items = items; &#125; public ItemsCustom getItemsCustom() &#123; return itemsCustom; &#125; public void setItemsCustom(ItemsCustom itemsCustom) &#123; this.itemsCustom = itemsCustom; &#125;&#125; JDBC&amp;&amp;Log4jjdbc.properties 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssmjdbc.username=rootjdbc.password=7122887 log4j.properties 1234567891011121314151617### direct log messages to stdout ###log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### direct messages to file mylog.log ###log4j.appender.file=org.apache.log4j.FileAppenderlog4j.appender.file.File=c:/mylog.loglog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### set log levels - for more verbose logging change 'info' to 'debug' ######log4j.rootLogger=off, stdout### produce infolog4j.rootLogger=DEBUG, stdout DaosqlMapConfig.xml 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 全局的setting，暂时没用到，延迟加载 --&gt; &lt;!-- 配置别名，批量扫描 --&gt; &lt;typeAliases&gt; &lt;package name="xd.ssm.vo"/&gt; &lt;/typeAliases&gt; &lt;!-- 配置mapper，使用spring和mybatis的整合包进程mapper扫描，这里就不配置了 --&gt; &lt;!-- 遵循：mapper.xml和mapper.java文件同名且在一个目录 --&gt;&lt;/configuration&gt; ItemsMapperCustom.xml 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="xd.ssm.mapper.ItemsMapperCustom" &gt; &lt;!-- 定义商品查询的sql片段，就是商品查询条件 --&gt; &lt;sql id="query_items_where"&gt; &lt;!-- 使用动态sql，通过if判断，满足条件进行sql拼接 --&gt; &lt;!-- 商品查询条件通过ItemsQueryVo包装对象 中itemsCustom属性传递 --&gt; &lt;if test="itemsCustom!=null"&gt; &lt;if test="itemsCustom.name!=null and itemsCustom.name!=''"&gt; items.name LIKE '%$&#123;itemsCustom.name&#125;%' &lt;/if&gt; &lt;/if&gt; &lt;/sql&gt; &lt;!-- 商品列表查询 --&gt; &lt;!-- parameterType传入包装对象(包装了查询条件) resultType建议使用扩展对象 --&gt; &lt;select id="findItemsList" parameterType="itemsQueryVo" resultType="itemsCustom"&gt; SELECT items.* FROM items &lt;where&gt; &lt;include refid="query_items_where"/&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; ItemsCustom.java 12345678910/** * @ClassName: ItemsMapperCustom * @Description: mapper.xml对应接口 * @author: 天热就吃哈密瓜 * @date: 2018年1月29日 上午9:37:05 */public interface ItemsMapperCustom &#123; //商品查询列表 public List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo)throws Exception;&#125; ServiceItemsService.java 12345678910/** * @ClassName: ItemsService * @Description: Service层接口 * @author: 天热就吃哈密瓜 * @date: 2018年1月28日 下午6:39:20 */public interface ItemsService &#123; //商品查询 public List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo) throws Exception;&#125; ItemsServiceImpl.java 1234567891011121314151617/** * @ClassName: ItemsServiceImpl * @Description: Service层实现类 * @author: 天热就吃哈密瓜 * @date: 2018年1月28日 下午6:38:56 */public class ItemsServiceImpl implements ItemsService&#123; @Autowired private ItemsMapperCustom itemsMapperCustom; //通过ItemsMapperCustomer查询数据库 @Override public List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo) throws Exception &#123; return itemsMapperCustom.findItemsList(itemsQueryVo); &#125;&#125; Controllerspringmvc.xml 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt; &lt;!-- 对于注解的Handler可以单个配置，但是实际开发中建议使用组件扫描 可以扫描controller、service... 这里扫描controller，指定controller的包 --&gt; &lt;context:component-scan base-package="xd.ssm.controller"/&gt; &lt;!-- &lt;bean class="xd.ssm.controller.ItemsController"/&gt; --&gt; &lt;!--注解映射器 --&gt; &lt;!-- &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/&gt;--&gt; &lt;!--注解适配器 --&gt; &lt;!-- &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/&gt; --&gt; &lt;!-- 注解驱动 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 视图解析器 解析jsp解析，默认使用jstl标签，classpath下的得有jstl的包 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 配置jsp路径的前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;!-- 配置jsp路径的后缀 --&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt;&lt;/beans&gt; ItemsController.java 12345678910111213141516171819202122232425262728293031/** * @ClassName: ItemsController * @Description: 商品控制器 * @author: 天热就吃哈密瓜 * @date: 2018年1月28日 下午6:58:32 */@Controllerpublic class ItemsController &#123; @Autowired private ItemsService itemsService; //商品查询 //一般建议注释和方法名一样 //@RequestMapping实现对queryItems方法和url进行映射，一个方法对应一个url //"/queryItems.action",action可写可不写 @RequestMapping("/queryItems") public ModelAndView queryItems() throws Exception &#123; //调用service查找数据库，查询商品列表，这里使用静态数据静态模拟 List&lt;ItemsCustom&gt; list = itemsService.findItemsList(null); //返回ModelAndView ModelAndView modelAndView = new ModelAndView(); //相当于request的setAttribute，在jsp页面中通过itemsList取数据 modelAndView.addObject("itemsList",list); //指定视图 modelAndView.setViewName("items/itemsList"); return modelAndView; &#125;&#125; Spring核心配置 applicationContext.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt;&lt;!-- Dao层 --&gt;&lt;!-- 数据库jdbc.properties --&gt; &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/bean&gt;&lt;!-- SqlSessionFactory --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 加载mybatis的全局配置文件 --&gt; &lt;property name="configLocation" value="classpath:mybatis/sqlMapConfig.xml" /&gt; &lt;/bean&gt;&lt;!-- mapper扫描器 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 扫描包路径，如果需要扫描多个包，中间使用半角逗号隔开 --&gt; &lt;property name="basePackage" value="xd.ssm.mapper"/&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt; &lt;/bean&gt;&lt;!-- ============================================================================= --&gt;&lt;!-- Service层 --&gt;&lt;!-- 事务 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt;&lt;!-- 事务：通知 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;!-- 传播行为 --&gt; &lt;tx:method name="save*" propagation="REQUIRED"/&gt; &lt;tx:method name="delete*" propagation="REQUIRED"/&gt; &lt;tx:method name="insert*" propagation="REQUIRED"/&gt; &lt;tx:method name="update*" propagation="REQUIRED"/&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"/&gt; &lt;tx:method name="get*" propagation="SUPPORTS" read-only="true"/&gt; &lt;tx:method name="select*" propagation="SUPPORTS" read-only="true"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt;&lt;!--事务：aop --&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* xd.ssm.service.impl.*.*(..))"/&gt; &lt;/aop:config&gt;&lt;!-- 商品管理类的service --&gt; &lt;bean id="itemsService" class="xd.ssm.service.impl.ItemsServiceImpl"/&gt;&lt;/beans&gt; web.xml123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;display-name&gt;SM&lt;/display-name&gt; &lt;!-- 加载Spring文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/classes/spring/applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 加载Spring的监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- SpringMVC前端控制器 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 部署 1http://127.0.0.1:8080/SSM/queryItems.action SSM整合（注解开发）需求1. 进入商品查询列表页面 2. 点击修改，进入商品修改页面，页面中显示了要修改的商品（从数据库查询，根据商品id查询商品信息） 3. 在商品修改页面，修改商品信息，修改后，点击提交 参数绑定从客户端请求key/value数据，经过参数绑定，将key/value数据绑定到controller方法的形参上。 SpringMVC中，接受页面提交的数据是通过方法形参来接受，而不是在controller类中定义成员变量。 默认支持类型直接在controller方法形参上定义下边类型的对象，就可以使用这些对象。在参数绑定过程中，如果遇到下边类型直接绑定。 HttpServletRequest 通过request对象获取请求信息 HttpServletResponse 通过response处理响应信息 HttpSession 通过session对象得到session中存放的对象 Model/ModelMap Model是一个接口，ModelMap是一个接口实现。 作用：将Model数据填充到request域中。 简单类型通过@RequestParam对简单类型的参数进行绑定 如果不使用@RequestParam，要求request传入参数名称和controller方法的形参一致，方可绑定成功。 如果使用@RequestParam，不用限制request传入参数名称和controller方法的形参名称一致。 pojopost、get提交乱码绑定器 页面中input的name和controller的pojo形参中的属性名称一致，将页面中数据绑定到pojo 所以页面的定义一定要注意！！！ 自定义参数绑定请求日期数据串转换成Date类型 需要向处理器适配器将日期串转成java.util.Date类型。 mapper（dao）1. 根据id查询商品信息 2. 更新items表的数据 service1. 根据id查询商品信息 2. 更新商品信息 123456789101112131415161718192021222324252627282930313233343536373839/** * @ClassName: ItemsServiceImpl * @Description: Service层实现类 * @author: 天热就吃哈密瓜 * @date: 2018年1月28日 下午6:38:56 */public class ItemsServiceImpl implements ItemsService&#123; @Autowired private ItemsMapperCustom itemsMapperCustom; //通过ItemsMapperCustomer查询数据库 @Override public List&lt;ItemsCustom&gt; findItemsList(ItemsQueryVo itemsQueryVo) throws Exception &#123; return itemsMapperCustom.findItemsList(itemsQueryVo); &#125; @Autowired ItemsMapper itemsMapper; @Override public ItemsCustom findItemsById(Integer id) &#123; //Items items = itemsMapper.selectByPrimaryKey(id); //中间对商品信息进行业务处理 //... //返回ItemsCustom Items items = itemsMapper.selectByPrimaryKey(id); ItemsCustom itemsCustom = new ItemsCustom(); BeanUtils.copyProperties(items, itemsCustom); return itemsCustom; &#125; @Override public void updateItemsById(Integer id,ItemsCustom itemsCustom) &#123; //添加业务校验，通常在service接口对关键参数进行校验 //校验id是否为null //updateByPrimaryKeyWithBLOBs需要要有ID// System.out.println(id); itemsMapper.updateByPrimaryKeyWithBLOBs(itemsCustom);//使用id可以更新所有的字段 &#125; controller1. 进入修改页面 2. 修改信息查询数据库 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/** * @ClassName: ItemsController * @Description: 商品控制器 * @author: 天热就吃哈密瓜 * @date: 2018年1月28日 下午6:58:32 */@Controllerpublic class ItemsController &#123; @Autowired private ItemsService itemsService; //商品查询 //一般建议注释和方法名一样 //@RequestMapping实现对queryItems方法和url进行映射，一个方法对应一个url //"/queryItems.action",action可写可不写 @RequestMapping("/queryItems") public ModelAndView queryItems() throws Exception &#123; //调用service查找数据库，查询商品列表， List&lt;ItemsCustom&gt; list = itemsService.findItemsList(null); //返回ModelAndView ModelAndView modelAndView = new ModelAndView(); //相当于request的setAttribute，在jsp页面中通过itemsList取数据 modelAndView.addObject("itemsList",list); //指定视图 modelAndView.setViewName("items/itemsList"); return modelAndView; &#125; //商品信息修改页面显示// @RequestMapping(value="/editItems",method=&#123;RequestMethod.POST,RequestMethod.GET&#125;)// public ModelAndView editItems() throws Exception&#123;// ItemsCustom itemsCustom = itemsService.findItemsById(1);// // ModelAndView modelAndView = new ModelAndView();// modelAndView.addObject("items",itemsCustom);// // modelAndView.setViewName("items/editItems");// return modelAndView;// &#125; @RequestMapping(value="/editItems",method=&#123;RequestMethod.POST,RequestMethod.GET&#125;) //@RequestParam(value="id")里面指定request传入参数名称和形参进行绑定。 //@RequestParam(value="id" required="true")要求这个参数在url中是否一定要传入！！！也就是?id=..必须有 //通过defaultValue，一旦id不存在，默认将默认值和形参绑定 public String editItems(Model model,@RequestParam(value="id")Integer items_id) throws Exception&#123; ItemsCustom itemsCustom = itemsService.findItemsById(items_id); model.addAttribute("items",itemsCustom); return "items/editItems"; &#125; //商品信息修改页面显示// @RequestMapping("/editItemsSubmit")// public ModelAndView editItemsSubmit() throws Exception&#123; // ModelAndView modelAndView = new ModelAndView();// // modelAndView.setViewName("success");// return modelAndView;// &#125; @RequestMapping(value="/editItemsSubmit",method=&#123;RequestMethod.POST,RequestMethod.GET&#125;) public String editItemsSubmit(Integer id,ItemsCustom itemsCustom) throws Exception&#123; //重定向 //return "redirect:queryItems.action"; //请求转发 //return "forward:queryItems.action"; System.out.println(id); System.out.println(itemsCustom.getName()); //itemsService.updateItemsById(id, items); return "success"; &#125;&#125;/** * @ClassName: CustomDateConverter * @Description: 日期转换 * @author: 天热就吃哈密瓜 * @date: 2018年1月29日 下午5:47:14 */public class CustomDateConverter implements Converter&lt;String,Date&gt;&#123; @Override public Date convert(String source) &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); try&#123; return sdf.parse(source); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt; &lt;!-- 对于注解的Handler可以单个配置，但是实际开发中建议使用组件扫描 可以扫描controller、service... 这里扫描controller，指定controller的包 --&gt; &lt;context:component-scan base-package="xd.ssm.controller"/&gt; &lt;!-- &lt;bean class="xd.ssm.controller.ItemsController"/&gt; --&gt; &lt;!--注解映射器 --&gt; &lt;!-- &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/&gt;--&gt; &lt;!--注解适配器 --&gt; &lt;!-- &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/&gt; --&gt; &lt;!-- 注解驱动 --&gt; &lt;mvc:annotation-driven conversion-service="conversionservice"/&gt; &lt;!-- 自定义参数绑定 --&gt; &lt;bean id="conversionservice" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;!-- 转换器 --&gt; &lt;property name="converters"&gt; &lt;list&gt; &lt;!-- 日期类型转换 --&gt; &lt;bean class="xd.ssm.controller.converter.CustomDateConverter"/&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 视图解析器 解析jsp解析，默认使用jstl标签，classpath下的得有jstl的包 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 配置jsp路径的前缀 --&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;!-- 配置jsp路径的后缀 --&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt;&lt;/beans&gt;]]></content>
      <categories>
        <category>COP</category>
      </categories>
      <tags>
        <tag>COP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[COP（MyBatis）]]></title>
    <url>%2F2018%2F01%2F24%2FCOP%EF%BC%88MyBatis%EF%BC%89%2F</url>
    <content type="text"><![CDATA[COP开始学习SSM，MyBatis MyBatis BasicMyBatis 持久层框架 就和Hibernate一样 第一天： 1. 对原生态jdbc程序（单独使用jdbc开发）问题总结 2. MyBatis框架原理 3. MyBatis入门程序 用户的增、删、改、查 4. MyBatis开发Dao两种方法： 1. 原始Dao开发方式（程序需要编写Dao接口和Dao实现类） 2. MyBatis的Mapper接口（相当于Dao接口）代理开发方法 5. MyBitais配置文件：SqlMapConfig.xml 6. MyBatis核心： 1. MyBatis输入映射 2. MyBatis输出映射 7. MyBatis的动态SQL 第二天： 1. 高级映射（一对一、一对多、多对多）---&gt; 订单商品数据模型分析 2. MyBatis延迟加载 3. MyBatis查询缓存 4. MyBatis和Spring进行整合 5. MyBatis逆向工程 MyBatis原理MyBatis是什么？MyBatis是一个持久层的框架，是apache下的顶级项目 MyBatis让程序员将主要精力放在Sql上，通过MyBatis提供的映射放射，自由灵活生成（半自动化，大部分需要程序员自己写Sql） MyBatis可以将向PreparedStatement中的输入参数自动进行映射，将查询结果集灵活映射成Java对象 MyBatis框架 MyBatis入门程序需求1. 根据用户id查询用户 2. 根据用户名称模糊查询 3. 增、删、改 环境java、MyEcplise、MySql、jar 配置MyBatis的运行环境：数据源，事务等1. SqlMapConfig 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 和spring整合后 environments配置将废除--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理，事务控制由mybatis--&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据库连接池，由mybatis管理--&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/ssm?characterEncoding=utf-8"/&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="7122887" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 2. User.xml 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace命名空间，作用就是对sql进行分类化管理，理解sql隔离 注意：使用mapper代理方法开发，namespace有特殊的意义 --&gt; &lt;mapper namespace="test"&gt; &lt;!-- 在映射文件中配置很多SQL语句 --&gt; &lt;!-- 需求：通过id查询用户表的记录 --&gt; &lt;!-- 通过select执行数据库查询 id：标识映射文件中的sql 将sql语句封装到mappedStatement对象中，所以将id称为statement的ID parameterType:指定输入参数的类型，这里指int型 #&#123;&#125;表示一个占位符号 #&#123;id&#125;:其中id表示接受输入的参数，参数写id，这个可以随便写 resultType：指定sql输出结果的所映射的java对象类型，select指定resultType表示将单条记录映射成的java对象 --&gt; &lt;select id="findUserById" parameterType="int" resultType="xd.vo.User"&gt; SELECT * FROM USER WHERE id=#&#123;id&#125;; &lt;/select&gt; &lt;/mapper&gt; SqlMapConfig.xml中加载User.xml 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 和spring整合后 environments配置将废除--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理，事务控制由mybatis--&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据库连接池，由mybatis管理--&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/ssm?characterEncoding=utf-8"/&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="7122887" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="sqlmap/User.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 查询测试代码1. 根据id查询 1234567891011121314151617181920212223242526272829303132/** * 入门程序 * @author whbai_xd@163.com * @date 2018年1月23日 下午10:30:12 */public class MyBatis &#123; //根据id查询用户信息，得到一条记录信息 @Test public void findUserById() throws IOException&#123; //配置文件 String reource = "SqlMapConfig.xml"; //得到配置文件的流 InputStream in = Resources.getResourceAsStream(reource); //创建会话工厂，传入mybatis的配置文件 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); //得到sqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); //第一个参数：映射文件中的Statement的id，等于空间变量名.Select标签id //第二个参数：指定和映射文件所匹配的parameterType类型的参数 User user = sqlSession.selectOne("test.findUserById",1); System.out.println(user); sqlSession.close(); &#125;&#125; 2. 根据用户名查询 1. 配置映射文件 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace命名空间，作用就是对sql进行分类化管理，理解sql隔离 注意：使用mapper代理方法开发，namespace有特殊的意义 --&gt; &lt;mapper namespace="test"&gt; &lt;!-- 在映射文件中配置很多SQL语句 --&gt; &lt;!-- 需求：通过id查询用户表的记录 --&gt; &lt;!-- 通过select执行数据库查询 id：标识映射文件中的sql 将sql语句封装到mappedStatement对象中，所以将id称为statement的ID parameterType:指定输入参数的类型，这里指int型 #&#123;&#125;表示一个占位符号 #&#123;id&#125;:其中id表示接受输入的参数，参数写id，这个可以随便写 resultType：指定sql输出结果的所映射的java对象类型，select指定resultType表示将单条记录映射成的java对象 --&gt; &lt;!-- 根据id查询 --&gt; &lt;select id="findUserById" parameterType="int" resultType="xd.vo.User"&gt; SELECT * FROM USER WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;!-- 根据用户名名查询，可能返回多条 resultType：指定单条记录所映射的java对象 类型 $&#123;&#125;：表示拼接sql串，将接受到参数的内容不加任何修饰的添加进去 使用$&#123;&#125;拼接sql，可能会引起sql注入 $&#123;username&#125;：接受输入参数的内容，如果传入类型是简单类型，$&#123;&#125;中只能使用value。#&#123;&#125;可以使用别的名字 --&gt; &lt;select id="findUserByUsername" parameterType="String" resultType="xd.vo.User"&gt; SELECT * FROM USER WHERE USERNAME LIKE '%$&#123;value&#125;%' &lt;/select&gt; &lt;/mapper&gt; 2. 映射文件放入SqlMapConfig核心配置xml 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 和spring整合后 environments配置将废除--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理，事务控制由mybatis--&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据库连接池，由mybatis管理--&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/ssm?characterEncoding=utf-8"/&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="7122887" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="sqlmap/User.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 3. 测试代码 123456789101112131415161718192021222324//根据用户名查询用户信息，得到记录信息 @Test public void findUserByUsername() throws IOException&#123; //配置文件 String reource = "SqlMapConfig.xml"; //得到配置文件的流 InputStream in = Resources.getResourceAsStream(reource);//其实就是加载 //创建会话工厂，传入mybatis的配置文件 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); //得到sqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); //第一个参数：映射文件中的Statement的id，等于空间变量名.Select标签id //第二个参数：指定和映射文件所匹配的parameterType类型的参数 List&lt;User&gt; list = sqlSession.selectList("test.findUserByUsername","小"); System.out.println(list); sqlSession.close(); &#125; 查询小结1. ParameterType: 在映射文件中通过parameterType指定输入参数的类型 2. resultType： 在映射文件中通过resultType指定输出结果的类型 3. #{}和${} #{}表示一个占位符 ${}表示一个拼接符号，会引起sql注入，所以不建议使用 4. selectOne和selectList selectOne表示查询出一条记录进行映射 selectList表示查询出一个列表进行映射。 增、删、改测试增1. 映射文件 12345678&lt;!-- 添加用户 parameterType：指定输入参数类型是pojo #&#123;&#125;中指定pojo的属性名，接受到pojo对象的属性值，MyBatis也是和Struts2一样使用OGNL拿到对象属性值 --&gt;&lt;insert id="insertUser" parameterType="xd.vo.User"&gt; INSERT INTO user(username,birthday,sex,address)value(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&lt;/insert&gt; 2. 映射文件配置到SqlMapConfig.xml 3. 测试代码 123456789101112131415161718192021222324252627//添加User @Test public void insertUser() throws IOException&#123; //配置文件 String reource = "SqlMapConfig.xml"; //得到配置文件的流 InputStream in = Resources.getResourceAsStream(reource);//其实就是加载 //创建会话工厂，传入mybatis的配置文件 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); //得到sqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); User user = new User(); user.setUsername("白超"); user.setSex("1"); user.setBirthday(new Date()); user.setAddress("陕西西安"); sqlSession.insert("test.insertUser",user); sqlSession.commit(); sqlSession.close(); &#125; 4. 自增主键返回 MySql自增主键，执行INSERT提交之前自动生成一个自增主键 通过MySQL函数获取刚插入记录的自增主键：SELECT LAST_INSERT_ID() 在INSERT语句之后写上这句话 123456789101112131415161718&lt;!-- 添加用户 parameterType：指定输入参数类型是pojo #&#123;&#125;中指定pojo的属性名，接受到pojo对象的属性值，MyBatis也是和Struts2一样使用OGNL拿到对象属性值 --&gt;&lt;insert id="insertUser" parameterType="xd.vo.User"&gt; &lt;!-- 将插入数据的主键返回 SELECT LAST_INSERT_ID():得到刚INSERT进去记录的主键值，只使用于自增主键 keyProperty：将查询到主键值设置到parameterType指定的对象的哪个属性 order：SELECT LAST_INSERT_ID()的执行顺序，相对于INSERT语句来说它的执行顺序 resultType:指定SELECT LAST_INSERT_ID()的返回类型 --&gt; &lt;selectKey keyProperty="id" order="AFTER" resultType="int"&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; INSERT INTO user(username,birthday,sex,address)value(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&lt;/insert&gt; 1234567891011121314151617181920212223242526272829//添加User@Testpublic void insertUser() throws IOException&#123; //配置文件 String reource = "SqlMapConfig.xml"; //得到配置文件的流 InputStream in = Resources.getResourceAsStream(reource);//其实就是加载 //创建会话工厂，传入mybatis的配置文件 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); //得到sqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); User user = new User(); user.setUsername("白超超"); user.setSex("1"); user.setBirthday(new Date()); user.setAddress("陕西西安"); sqlSession.insert("test.insertUser",user); sqlSession.commit(); System.out.println(user.getId()); sqlSession.close();&#125; 5. 非自增主键返回 使用mysql的uuid()函数生成主键，需要修改表中id字段类型为string，长度设置为35位。 执行思路： 先通过uuid()查询到主键，将主键输入到sql语句中。 执行uuid()语句顺序相对于INSERT语句，在其之前执行。 12345678910&lt;!-- 使用mysql的uuid()生成主键执行过程：首先通过uuid()得到主键，将主键设置到user对象的id属性中其次在insert执行时，从user对象中取出id属性值 --&gt;&lt;selectKey keyProperty="id" order="BEFORE" resultType="String"&gt; SELECT uuid()&lt;/selectKey&gt;INSERT INTO user(id,username,birthday,sex,address)value(#&#123;id&#125;,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) 删1. 映射文件123&lt;delete id="deleteUser" parameterType="int"&gt; DELETE FROM user WHERE ID=#&#123;id&#125; &lt;/delete&gt; 2. 映射文件配置进入SqlMapConfig.xml 3. 测试代码 123456789101112131415161718192021//删除User@Testpublic void deleteUser() throws IOException&#123; //配置文件 String reource = "SqlMapConfig.xml"; //得到配置文件的流 InputStream in = Resources.getResourceAsStream(reource);//其实就是加载 //创建会话工厂，传入mybatis的配置文件 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); //得到sqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); sqlSession.delete("test.deleteUser",25); sqlSession.commit(); sqlSession.close();&#125; 改1. 映射文件1234567891011&lt;!-- 更新用户 分析： 需要传入用户的id！！！ 需要传入用户的更新信息 parameterType指定user对象，包括id和更新信息，注意，id必须存在 #&#123;id&#125;:从user对象中获取id属性值 --&gt;&lt;update id="updateUser" parameterType="xd.vo.User"&gt; UPDATE user SET username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125; WHERE id=#&#123;id&#125; &lt;/update&gt; 2. 映射文件配置进入SqlMapConfig.xml 3. 测试代码 12345678910111213141516171819202122232425262728//更新User@Testpublic void updateUser() throws IOException&#123; //配置文件 String reource = "SqlMapConfig.xml"; //得到配置文件的流 InputStream in = Resources.getResourceAsStream(reource);//其实就是加载 //创建会话工厂，传入mybatis的配置文件 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(in); //得到sqlSession SqlSession sqlSession = sqlSessionFactory.openSession(); User user = new User(); user.setId(28); user.setUsername("小方方"); user.setSex("2"); user.setBirthday(new Date()); user.setAddress("陕西西安"); sqlSession.update("test.updateUser",user); sqlSession.commit(); sqlSession.close();&#125; MyBatis和Hibernate本质区别和应用场景Hibernate：是一个标准ORM框架（对象对象映射）。入门门槛较高的，不需要程序写sql，sql语句自动生成了。 对sql语句进行优化、修改比较困难 MyBatis：专注是Sql本身，需要程序员自己去写sql。Mybatis是一个不完全的ORM。 MyBatis开发DaoSqlSession的使用范围SqlSessionFactoryBuilder通过SqlSessionFactoryBuilder来创建会话工厂 SqlSessionFactory通过SqlSessionFactory创建SqlSession，使用单例模式管理（SqlSessionFactory一旦创建，使用一个实例） 将来Mybatis和Spring整合后，使用单例模式管理(SqlSessionFactory) SqlSessionSqlSession是一个面向用户的接口 SqlSession线程不安全。 SqlSession最佳应用场合在方法体内，定义成员局部变量使用。 原始Dao开发（需要写dao和Impl）思路1. 需要向Dao实现类中注入SqlSessionFactory 2. 方法体内通过SqlSessionFactory创建SqlSession Dao接口123456789101112131415/** * 用户管理接口 * @author whbai_xd@163.com * @date 2018年1月24日 上午11:52:27 */public interface UserDao &#123; //根据id查询用户 public User findUserById(int id); //添加用户 public void insertUser(User user); //删除用户 public void deleteUser(int id);&#125; DaoImpl123456789101112131415161718192021222324252627282930313233343536/** * UserDaoImpl * @author whbai_xd@163.com * @date 2018年1月24日 下午12:16:02 */public class UserDaoImpl implements UserDao&#123; //注入SqlSessionFactory private SqlSessionFactory sqlSessionFactory; public UserDaoImpl(SqlSessionFactory sqlSessionFactory) &#123; super(); this.sqlSessionFactory = sqlSessionFactory; &#125; public User findUserById(int id) &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); User user = sqlSession.selectOne("test.findUserById", 28); sqlSession.close(); return user; &#125; public void insertUser(User user) &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); sqlSession.insert("test.insertUser",user); sqlSession.commit(); sqlSession.close(); &#125; public void deleteUser(int id) &#123; SqlSession sqlSession = sqlSessionFactory.openSession(); sqlSession.delete("test.deleteUser", id); sqlSession.commit(); sqlSession.close(); &#125;&#125; 测试123456789101112131415161718192021public class UserDaoTest &#123; private SqlSessionFactory sqlSessionFactory; //此方法是在执行testFindUserById之前 @Before public void setUp()throws Exception&#123; sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream("SqlMapConfig.xml")); &#125; @Test public void testFindUserById()&#123; //创建UserDao UserDao userDao = new UserDaoImpl(sqlSessionFactory); //调用方法 User user = userDao.findUserById(1); System.out.println(user); &#125;&#125; 原始Dao的开发问题1. Dao类接口实现类方法中存在大量模板方法，设想能否将这些代码提取出来。 2. 调用SqlSession的方法时，将Statement的id硬编码了 3. 调用SqlSession方法时，由于SqlSession用的是泛型，就算是变量类型传错了，编译阶段没有报错！！！ mapper代理方法（只需要写mapper接口）mapper接口思路1. 需要写mapper.xml映射文件 2. 只要写一个mapper接口 MyBatis可以自动生成mapper接口实现类的代理对象。 开发规范： 1. 在mapper.xml中namespace等于mapper接口的地址。 2. mapper.java和mapper.xml中Statement的id一致。 3. mapper.java接口的方法参数和mapper.xml中Statement中的parameterType相同。 4. mapper.java接口的返回值和mapper.xml中Statement中的resultType相同。 例如：UserMapper.xml123456789101112131415161718192021&lt;!-- namespace命名空间，作用就是对sql进行分类化管理，理解sql隔离 注意：使用mapper代理方法开发，namespace有特殊的意义 --&gt; &lt;mapper namespace="xd.mapper.UserMapper"&gt; &lt;!-- 在映射文件中配置很多SQL语句 --&gt; &lt;!-- 需求：通过id查询用户表的记录 --&gt; &lt;!-- 通过select执行数据库查询 id：标识映射文件中的sql 将sql语句封装到mappedStatement对象中，所以将id称为statement的ID parameterType:指定输入参数的类型，这里指int型 #&#123;&#125;表示一个占位符号 #&#123;id&#125;:其中id表示接受输入的参数，参数写id，这个可以随便写 resultType：指定sql输出结果的所映射的java对象类型，select指定resultType表示将单条记录映射成的java对象 --&gt; &lt;!-- 根据id查询 --&gt; &lt;select id="findUserById" parameterType="int" resultType="xd.vo.User"&gt; SELECT * FROM USER WHERE id=#&#123;id&#125; &lt;/select&gt;&lt;mapper/&gt; UserMapper.java123456789/** * mapper接口，相当于Dao接口，用户管理 * @author whbai_xd@163.com * @date 2018年1月25日 下午4:04:37 */public interface UserMapper &#123; //根据id查询 public User findUserById(int id);&#125; 总结： 以上开发规范主要是对下边的代码进行统一生成： User user = sqlSession.selectOne(&quot;test.findUserById&quot;,id); sqlSession.insert(&quot;test.insertUser&quot;,user); .... 其他的比如关闭会话（sqlSession），得到会话，都被代理对象生产代码 mapper接口实现1. 如果Mapper方法返回单个pojo对象，代理对象内部通过selectOne 2. 如果Mapper方法返回单个pojo对象，代理对象内部通过selectList SqlMapConfig.xml 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 和spring整合后 environments配置将废除--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理，事务控制由mybatis--&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据库连接池，由mybatis管理--&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/ssm?characterEncoding=utf-8"/&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="7122887" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="sqlmap/User.xml"/&gt; &lt;mapper resource="mapper/UserMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; UserMapper.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace命名空间，作用就是对sql进行分类化管理，理解sql隔离 注意：使用mapper代理方法开发，namespace有特殊的意义 --&gt; &lt;mapper namespace="xd.mapper.UserMapper"&gt; &lt;!-- 在映射文件中配置很多SQL语句 --&gt; &lt;!-- 需求：通过id查询用户表的记录 --&gt; &lt;!-- 通过select执行数据库查询 id：标识映射文件中的sql 将sql语句封装到mappedStatement对象中，所以将id称为statement的ID parameterType:指定输入参数的类型，这里指int型 #&#123;&#125;表示一个占位符号 #&#123;id&#125;:其中id表示接受输入的参数，参数写id，这个可以随便写 resultType：指定sql输出结果的所映射的java对象类型，select指定resultType表示将单条记录映射成的java对象 --&gt; &lt;!-- 根据id查询 --&gt; &lt;select id="findUserById" parameterType="int" resultType="xd.vo.User"&gt; SELECT * FROM USER WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;!-- 根据用户名名查询，可能返回多条 resultType：指定单条记录所映射的java对象 类型 $&#123;&#125;：表示拼接sql串，将接受到参数的内容不加任何修饰的添加进去 使用$&#123;&#125;拼接sql，可能会引起sql注入 $&#123;username&#125;：接受输入参数的内容，如果传入类型是简单类型，$&#123;&#125;中只能使用value。#&#123;&#125;可以使用别的名字 --&gt; &lt;select id="findUserByUsername" parameterType="String" resultType="xd.vo.User"&gt; SELECT * FROM USER WHERE USERNAME LIKE '%$&#123;value&#125;%' &lt;/select&gt; &lt;!-- 添加用户 parameterType：指定输入参数类型是pojo #&#123;&#125;中指定pojo的属性名，接受到pojo对象的属性值，MyBatis也是和Struts2一样使用OGNL拿到对象属性值 --&gt; &lt;insert id="insertUser" parameterType="xd.vo.User"&gt; &lt;!-- 将插入数据的主键返回 SELECT LAST_INSERT_ID():得到刚INSERT进去记录的主键值，只使用于自增主键 keyProperty：将查询到主键值设置到parameterType指定的对象的哪个属性 order：SELECT LAST_INSERT_ID()的执行顺序，相对于INSERT语句来说它的执行顺序 resultType:指定SELECT LAST_INSERT_ID()的返回类型 --&gt; &lt;selectKey keyProperty="id" order="AFTER" resultType="int"&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; INSERT INTO user(username,birthday,sex,address)value(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) &lt;!-- 使用mysql的uuid()生成主键 执行过程： 首先通过uuid()得到主键，将主键设置到user对象的id属性中 其次在insert执行时，从user对象中取出id属性值 --&gt; &lt;!-- &lt;selectKey keyProperty="id" order="BEFORE" resultType="String"&gt; SELECT uuid() &lt;/selectKey&gt; INSERT INTO user(id,username,birthday,sex,address)value(#&#123;id&#125;,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) --&gt; &lt;/insert&gt; &lt;!-- 删除用户 --&gt; &lt;delete id="deleteUser" parameterType="int"&gt; DELETE FROM user WHERE ID=#&#123;id&#125; &lt;/delete&gt; &lt;!-- 更新用户 分析： 需要传入用户的id！！！ 需要传入用户的更新信息 parameterType指定user对象，包括id和更新信息，注意，id必须存在 #&#123;id&#125;:从user对象中获取id属性值 --&gt; &lt;update id="updateUser" parameterType="xd.vo.User"&gt; UPDATE user SET username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125; WHERE id=#&#123;value&#125; &lt;/update&gt; &lt;/mapper&gt; UserMapper.java 123456789101112131415161718/** * mapper接口，相当于Dao接口，用户管理 * @author whbai_xd@163.com * @date 2018年1月25日 下午4:04:37 */public interface UserMapper &#123; //根据id查询 public User findUserById(int id); //根据用户名查询用户列表 public List&lt;User&gt; findUserByUsername(String username); //插入用户 public void insertUser(User user); //删除用户 public void deleteUser(int id);&#125; UserMapperTest.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class UserMapperTest &#123; private SqlSessionFactory sqlSessionFactory; //此方法是在执行testFindUserById之前 @Before public void setUp()throws Exception&#123; sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream("SqlMapConfig.xml")); &#125; @Test public void testFindUserById()&#123; //创建UserMapper对象 UserMapper userMapper = sqlSessionFactory.openSession().getMapper(UserMapper.class); //调用方法 User user = userMapper.findUserById(1); System.out.println(user); &#125; @Test public void testFindUserByUsername()&#123; //创建UserMapper对象 UserMapper userMapper = sqlSessionFactory.openSession().getMapper(UserMapper.class); //调用方法 List&lt;User&gt; list = userMapper.findUserByUsername("小"); System.out.println(list); &#125; @Test public void testInsertUser()&#123; //创建UserMapper对象 SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = new User(); user.setUsername("白baibai"); user.setSex("1"); user.setBirthday(new Date()); user.setAddress("陕西西安"); //调用方法 userMapper.insertUser(user); sqlSession.commit(); &#125; @Test public void testdeleteUser()&#123; //创建UserMapper对象 SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //调用方法 userMapper.deleteUser(16); sqlSession.commit(); &#125;&#125; SqlMapConfig.xmlproperties属性处理数据库的配置 jdbc.properties 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssmjdbc.username=rootjdbc.password=7122887 SqlMapConfig.xml 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 数据库文件加载 --&gt; &lt;properties resource="jdbc.properties"/&gt; &lt;!-- 和spring整合后 environments配置将废除--&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理，事务控制由mybatis--&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据库连接池，由mybatis管理--&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="sqlmap/User.xml"/&gt; &lt;mapper resource="mapper/UserMapper.xml"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; settings配置MyBatis框架运行时可以调整一些运行参数。 比如：开启二级缓存，开启延迟加载。 全局参数将会影响MyBatis的运行行为。 typeAliases（别名-重点）需求在mapper.xml中，定义了很多的statement，statement需要parameterType指定输入参数的类型，需要resultType指定输出结果 映射类型。 如果在指定类型时输入类型全路径，不方便进行开发，可以针对parameterType或resultType指定的类型定义一些别名，在mapper.xml中通过别名来定义 别名定义1. 单个别名定义 1234567&lt;!-- 定义别名 --&gt;&lt;typeAliases&gt; &lt;!-- 针对单个别名定义，type：类型路径；alias：别名 --&gt; &lt;typeAlias type="xd.vo.User" alias="user"/&gt; &lt;/typeAliases&gt; 2. 批量别名定义 1234567891011&lt;!-- 定义别名 --&gt;&lt;typeAliases&gt; &lt;!-- 针对单个别名定义，type：类型路径；alias：别名 --&gt; &lt;!-- &lt;typeAlias type="xd.vo.User" alias="user"/&gt; --&gt; &lt;!-- 针对一个包中的类定义别名，别名就是这个包中的类中的名字，首字母大小写都可以 --&gt; &lt;package name="xd.vo"/&gt;&lt;/typeAliases&gt; typeAHandlers（类型加载器）Mybatis中通过typeHandlers完成jdbc类型和java类型的转换。 通常情况下，Mybatis提供的类型处理器满足日常需要，不需要自定义。 mappers（映射配置）1. 通过resource方法加载 12345&lt;mappers&gt; &lt;!-- 通过resource一次加载一个映射文件 --&gt; &lt;mapper resource="sqlmap/User.xml"/&gt; &lt;mapper resource="mapper/UserMapper.xml"/&gt; &lt;/mappers&gt; 2. 通过mapper接口加载映射文件 1234567891011&lt;mappers&gt; &lt;!-- 通过resource一次加载一个映射文件 --&gt; &lt;mapper resource="sqlmap/User.xml"/&gt; &lt;mapper resource="mapper/UserMapper.xml"/&gt; &lt;!-- 类加载 通过mapper接口加载映射文件（使用mapper代理的方法） 需要将mapper接口类名和mapper.xml映射文件名称保持一致并在一个目录下！！！ --&gt;&lt;/mappers&gt; 3. 批量加载 123456789101112131415161718&lt;mappers&gt; &lt;!-- 通过resource一次加载一个映射文件 --&gt; &lt;mapper resource="sqlmap/User.xml"/&gt; //&lt;mapper resource="mapper/UserMapper.xml"/&gt; &lt;!-- 类加载 通过mapper接口加载映射文件（使用mapper代理的方法） 需要将mapper接口类名和mapper.xml映射文件名称保持一致并在一个目录下！！！ --&gt; &lt;!-- 批量加载 通过mapper接口加载映射文件（使用mapper代理的方法） 需要将mapper接口类名和mapper.xml映射文件名称保持一致并在一个目录下！！！ --&gt; &lt;package name="xd.mapper"/&gt;&lt;/mappers&gt; 输入映射通过parameterType指定输入参数的类型，类型可以是简单类型，hashmap、pojo的包装类型 传递pojo的包装对象需求 完成用户信息的综合查询，需要传入查询条件和复杂，针对上边需求，建议使用自定义的Pojo 定义包装类pojo 123456789101112131415161718192021222324252627282930/** * User对象的查询对象:包装类型 * @author whbai_xd@163.com * @date 2018年1月25日 下午5:34:06 */public class UserQuery &#123; //包装需要的查询条件 //用户的查询条件 private UserCustomer userCustomer; public UserCustomer getUserCustomer() &#123; return userCustomer; &#125; public void setUserCustomer(UserCustomer userCustomer) &#123; this.userCustomer = userCustomer; &#125; //订单、商品....&#125;/** * 扩充User类 * @author whbai_xd@163.com * @date 2018年1月25日 下午6:11:29 */public class UserCustomer extends User&#123;&#125; mapper.xml 1234&lt;!-- 综合查询 --&gt;&lt;select id="findUserList" parameterType="xd.vo.UserQuery" resultType="xd.vo.UserCustomer"&gt; SELECT * FROM user WHERE user.sex=#&#123;userCustomer.sex&#125; AND user.username LIKE '%$&#123;userCustomer.username&#125;%'&lt;/select&gt; mapper.java 123456789101112131415161718192021/** * mapper接口，相当于Dao接口，用户管理 * @author whbai_xd@163.com * @date 2018年1月25日 下午4:04:37 */public interface UserMapper &#123; //根据id查询 public User findUserById(int id); //根据用户名查询用户列表 public List&lt;User&gt; findUserByUsername(String username); //插入用户 public void insertUser(User user); //删除用户 public void deleteUser(int id); //查询pojo public List&lt;UserCustomer&gt; findUserList(UserQuery userQuery);&#125; 测试1234567891011121314151617@Testpublic void testfindUserList()&#123; //创建UserMapper对象 SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //查询条件 UserQuery userQuery = new UserQuery(); UserCustomer userCustomer = new UserCustomer(); userCustomer.setSex("1"); userCustomer.setUsername("白"); userQuery.setUserCustomer(userCustomer); //调用方法 List&lt;UserCustomer&gt; list = userMapper.findUserList(userQuery); System.out.println(list);&#125; 输出映射ResultType使用ResultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。 输出简单类型需求 用户信息的综合查询列表总数，通过查询总数和上边用户综合查询列表才可以实现分页 mapper.xml 123456789&lt;!-- 综合查询 --&gt;&lt;select id="findUserList" parameterType="UserQuery" resultType="UserCustomer"&gt; SELECT * FROM user WHERE user.sex=#&#123;userCustomer.sex&#125; AND user.username LIKE '%$&#123;userCustomer.username&#125;%'&lt;/select&gt;&lt;!-- 综合查询记录数 创建分页用 --&gt;&lt;select id="findUserCount" parameterType="UserQuery" resultType="int"&gt; SELECT count(*) FROM user WHERE user.sex=#&#123;userCustomer.sex&#125; AND user.username LIKE '%$&#123;userCustomer.username&#125;%'&lt;/select&gt; mapper.java 123456789101112131415161718192021222324/** * mapper接口，相当于Dao接口，用户管理 * @author whbai_xd@163.com * @date 2018年1月25日 下午4:04:37 */public interface UserMapper &#123; //根据id查询 public User findUserById(int id); //根据用户名查询用户列表 public List&lt;User&gt; findUserByUsername(String username); //插入用户 public void insertUser(User user); //删除用户 public void deleteUser(int id); //查询pojo public List&lt;UserCustomer&gt; findUserList(UserQuery userQuery); //查询pojo个数 public int findUserCount(UserQuery userQuery);&#125; 测试 1234567891011121314151617@Testpublic void testfindUserCount()&#123; //创建UserMapper对象 SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //查询条件 UserQuery userQuery = new UserQuery(); UserCustomer userCustomer = new UserCustomer(); userCustomer.setSex("1"); userCustomer.setUsername("白"); userQuery.setUserCustomer(userCustomer); //调用方法 int count = userMapper.findUserCount(userQuery); System.out.println(count);&#125; 输出pojo类型不管是输出的pojo单个对象还是一个列表（list中包括pjo），reslutType都是pojo，只是在mapper.java中方法的返回值不同pojo或者list ResultMapMyBatis中使用resultMap完成高级输出结果映射 如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo的属性名进行映射。 使用别名完成User映射12345678910111213141516171819&lt;!-- 使用resultMap进行输出映射 --&gt;&lt;!-- 定义ResultMap： 将ELECT id id_,username username_ FROM user和User类中的属性作为一个映射关系 type：resultMap最终映射的java对象类型，可以使用别名 id：对resultMap的唯一标识 --&gt; &lt;resultMap type="User" id="userResultMap"&gt; &lt;!-- column:查询出来的列名 property：type指定的pojo类型中的属性名 --&gt; &lt;id column="id_" property="id"/&gt; &lt;result column="username_" property="username"/&gt; &lt;/resultMap&gt; &lt;select id="findUserByIdMap" parameterType="int" resultMap="userResultMap"&gt; SELECT id id_,username username_ FROM user WHERE id=#&#123;value&#125; &lt;/select&gt; 测试1234567891011121314 @Test public void testfindUserByIdMap()&#123; //创建UserMapper对象 SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //调用方法 User user = userMapper.findUserByIdMap(28); System.out.println(user); &#125;/**User [id=28, username=小方方, sex=null, birthday=null, address=null]*/ resultType和resultMap使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。 如果查询出来的列名和pojo属性名不一致，通过顶一个resultMap对列名和pojo属性名之间作一个映射关系。 动态SQLMybatis核心对sql语句进行灵活操作，通过表达式进行判断，对sql进行灵活拼接、组合。 需求用户信息综合查询列表和用户信息查询列表总数这两个statement的定义使用动态sql。 对查询条件进行判断，如果输入参数不为空才进行查询条件拼接。 mapper.xml1234567891011121314151617181920212223242526272829&lt;!-- 综合查询 --&gt;&lt;select id="findUserList" parameterType="UserQuery" resultType="UserCustomer"&gt; SELECT * FROM user &lt;where&gt; &lt;!-- where可以自动去掉第一个and--&gt; &lt;if test="userCustomer!=null"&gt; &lt;if test="userCustomer.sex!=null and userCustomer.sex!=''"&gt; and user.sex=#&#123;userCustomer.sex&#125; &lt;/if&gt; &lt;if test="userCustomer.username!=null and userCustomer.username!=''"&gt; and user.username LIKE '%$&#123;userCustomer.username&#125;%' &lt;/if&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt;&lt;!-- 综合查询记录数 创建分页用 --&gt;&lt;select id="findUserCount" parameterType="UserQuery" resultType="int"&gt; SELECT count(*) FROM user &lt;where&gt; &lt;!-- where可以自动去掉第一个and--&gt; &lt;if test="userCustomer!=null"&gt; &lt;if test="userCustomer.sex!=null and userCustomer.sex!=''"&gt; and user.sex=#&#123;userCustomer.sex&#125; &lt;/if&gt; &lt;if test="userCustomer.username!=null and userCustomer.username!=''"&gt; and user.username LIKE '%$&#123;userCustomer.username&#125;%' &lt;/if&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; mapper.java测试1234567891011121314151617181920212223242526272829303132333435@Testpublic void testfindUserList()&#123; //创建UserMapper对象 SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //查询条件 UserQuery userQuery = new UserQuery(); UserCustomer userCustomer = new UserCustomer(); userCustomer.setSex("1"); //userCustomer.setUsername("白"); userQuery.setUserCustomer(userCustomer); //调用方法 List&lt;UserCustomer&gt; list = userMapper.findUserList(userQuery); System.out.println(list);&#125;@Testpublic void testfindUserCount()&#123; //创建UserMapper对象 SqlSession sqlSession = sqlSessionFactory.openSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //查询条件 UserQuery userQuery = new UserQuery(); UserCustomer userCustomer = new UserCustomer(); userCustomer.setSex("1"); //userCustomer.setUsername("白"); userQuery.setUserCustomer(userCustomer); //调用方法 int count = userMapper.findUserCount(userQuery); System.out.println(count);&#125; sql片段12345678910111213141516171819202122232425262728293031 &lt;!-- 定义sql片段，id：sql片段的唯一标识 经验：是基于单表来定义sql片段，这样sql片段的可重用性比较高 --&gt; &lt;sql id="query_user_where"&gt; &lt;if test="userCustomer!=null"&gt; &lt;if test="userCustomer.sex!=null and userCustomer.sex!=''"&gt; and user.sex=#&#123;userCustomer.sex&#125; &lt;/if&gt; &lt;if test="userCustomer.username!=null and userCustomer.username!=''"&gt; and user.username LIKE '%$&#123;userCustomer.username&#125;%' &lt;/if&gt; &lt;/if&gt; &lt;/sql&gt;&lt;!-- 综合查询 --&gt;&lt;select id="findUserList" parameterType="UserQuery" resultType="UserCustomer"&gt; SELECT * FROM user &lt;where&gt; &lt;!-- where可以自动去掉第一个and--&gt; &lt;include refid="query_user_where"/&gt; &lt;/where&gt;&lt;/select&gt;&lt;!-- 综合查询记录数 创建分页用 --&gt;&lt;select id="findUserCount" parameterType="UserQuery" resultType="int"&gt; SELECT count(*) FROM user &lt;where&gt; &lt;!-- where可以自动去掉第一个and--&gt; &lt;include refid="query_user_where"/&gt; &lt;/where&gt;&lt;/select&gt; 总结一MyBatis是什么 mybatis是一人持久层框架，mybatis是一个不完全的ORM框架。sql语句需要程序员自己去编写，但是mybatis也有映射（输入参数映射、输出结果映射）。 mybatis入门门槛不高，学习成本低，让程序员把精力放在sql语句上，对sql语句优化非常方便，适用与需求变化较多项目，比如互联网项目。 mybatis框架执行过程： 1. 配置mybatis的配置文件，SqlMapConfig.xml（名称不固定） 2. 通过配置文件，加载mybatis运行环境，创建SqlSessionFactory会话工厂。SqlSessionFactory在实际使用时按单例方式。 3. 通过SqlSessionFactory创建SqlSession SqlSession是一个面向用户接口（提供操作数据库方法），实现对象是线程不安全的，建议sqlSession应用场合在方法体内。 4. 调用sqlSession的方法去操作数据。 如果需要提交事务，需要执行SqlSession的commit()方法。 5. 释放资源，关闭SqlSession mybatis开发dao的方法： 1. 原始dao 的方法 需要程序员编写dao接口和实现类 需要在dao实现类中注入一个SqlSessionFactory工厂。 2. mapper代理开发方法（建议使用） 只需要程序员编写mapper接口（就是dao接口） 程序员在编写mapper.xml(映射文件)和mapper.java需要遵循一个开发规范： 1. mapper.xml中namespace就是mapper.java的类全路径。 2. mapper.xml中statement的id和mapper.java中方法名一致。 3. mapper.xml中statement的parameterType指定输入参数的类型和mapper.java的方法输入 参数类型一致。 4. mapper.xml中statement的resultType指定输出结果的类型和mapper.java的方法返回值类型一致。 SqlMapConfig.xml配置文件：可以配置properties属性、别名、mapper加载… 输出映射： parameterType：指定输入参数类型可以简单类型、pojo、hashmap。。 对于综合查询，建议parameterType使用包装的pojo，（将各种pojo包装在一个单独的类）有利于系统 扩展。 输出映射： resultType： 查询到的列名和resultType指定的pojo的属性名一致，才能映射成功。 reusltMap： 可以通过resultMap 完成一些高级映射。 如果查询到的列名和映射的pojo的属性名不一致时，通过resultMap设置列名和属性名之间的对应关系（映射关系）。可以完成映射。 高级映射： 将关联查询的列映射到一个pojo属性中。（一对一） 将关联查询的列映射到一个List&lt;pojo&gt;中。（一对多） 动态sql：（重点） if判断（掌握） where foreach sql片段（掌握） Mybatis Up对订单商品数据模型进行分析。 高级映射：（了解） 实现一对一查询、一对多、多对多查询。 延迟加载 查询缓存 一级缓存 二级缓存（了解mybatis二级缓存使用场景） mybatis和spirng整合（掌握） 逆向工程（会用） 表关系分析 usre和orders： user----&gt;orders：一个用户可以创建多个订单，一对多 orders---&gt;user：一个订单只由一个用户创建，一对一 orders和orderdetail： orders---》orderdetail：一个订单可以包括 多个订单明细，因为一个订单可以购买多个商品，每个商品的购买信息在orderdetail记录，一对多关系 orderdetail--&gt; orders：一个订单明细只能包括在一个订单中，一对一 orderdetail和itesm： orderdetail---》itesms：一个订单明细只对应一个商品信息，一对一 items--&gt; orderdetail:一个商品可以包括在多个订单明细 ，一对多 再分析数据库级别没有关系的表之间是否有业务关系： orders和items： orders和items之间可以通过orderdetail表建立 关系。 一对一查询模型 需求查询订单信息，关联查询创建订单的用户信息 确定查询的主表：订单表 确定查询的关联表：用户表 关联查询使用内链接？还是外链接？ 由于orders表中有一个外键（user_id），通过外键关联查询用户表只能查询出一条记录，可以使用内链接。 SELECT orders.*, USER.username, USER.sex, USER.address FROM orders, USER WHERE orders.user_id = user.id resultTypeOrdersCustomMapper.xml 123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="xd.mapper.OrdersCustomMapper"&gt; &lt;!-- 查询关联查询用户信息 --&gt; &lt;select id="findOrdersByUser" resultType="OrdersCustom"&gt; SELECT orders.*, user.username, user.sex, user.address FROM orders, user WHERE orders.user_id = user.id &lt;/select&gt; &lt;/mapper&gt; OrdersCustomMapper.java 12345678/** * 订单的mapper * @author whbai_xd@163.com * @date 2018年1月25日 下午9:55:33 */public interface OrdersCustomMapper &#123; public List&lt;OrdersCustom&gt; findOrdersByUser();&#125; 测试 12345678910111213141516171819202122232425/** * 测试类 * @author whbai_xd@163.com * @date 2018年1月25日 下午10:04:01 */public class MapperTest &#123;private SqlSessionFactory sqlSessionFactory; //此方法是在执行testFindUserById之前 @Before public void setUp()throws Exception&#123; sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream("SqlMapConfig.xml")); &#125; @Test public void testfindOrdersByUser()&#123; //创建UserMapper对象 OrdersCustomMapper ordersCustomMapper = sqlSessionFactory.openSession().getMapper(OrdersCustomMapper.class); //调用方法 List&lt;OrdersCustom&gt; list = ordersCustomMapper.findOrdersByUser(); System.out.println(list); &#125;&#125; resultMap使用resultMap将查询结构中的订单信息映射到Order对象中，在orders类中添加User属性，将关联查询出来的用户信息映射到order对象中的user属性中。 OrdersCustomMapper.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="xd.mapper.OrdersCustomMapper"&gt; &lt;!-- 查询关联查询用户信息 --&gt; &lt;select id="findOrdersByUser" resultType="OrdersCustom"&gt; SELECT orders.*, user.username, user.sex, user.address FROM orders, user WHERE orders.user_id = user.id &lt;/select&gt; &lt;!-- 查询关联查询用户信息 resultMap --&gt; &lt;resultMap type="Orders" id="OrderUserResultMap"&gt; &lt;!-- 配置映射的订单信息 --&gt; &lt;!-- id：指定订单查询列的唯一标识，一般就是主键(对应表)。如果有多个列才能组成唯一标识，那么就多个id --&gt; &lt;!-- column,主键在表中的名字；property：主键在模型中对应的属性名称 --&gt; &lt;id column="id" property="id"/&gt; &lt;!-- result：其他字段 --&gt; &lt;result column="user_id" property="userid"/&gt; &lt;result column="number" property="number"/&gt; &lt;result column="createtime" property="createtime"/&gt; &lt;result column="note" property="note"/&gt; &lt;!-- 配置映射的关联的用户信息 --&gt; &lt;!-- association:用于映射关联查询单个对象的信息 --&gt; &lt;!-- property：要将关联查询的用户信息映射到Orders中的属性 --&gt; &lt;association property="user" javaType="User"&gt; &lt;!-- id：指定用户查询列的唯一标识，一般就是主键(对应表)。如果有多个列才能组成唯一标识，那么就多个id --&gt; &lt;!-- column,主键在orders表中的名字；property：主键在orders模型中对应的属性名称 --&gt; &lt;id column="user_id" property="id"/&gt; &lt;!-- result：其他字段 --&gt; &lt;result column="username" property="username"/&gt; &lt;result column="sex" property="username"/&gt; &lt;result column="address" property="username"/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="findOrdersByUserMap" resultMap="OrderUserResultMap"&gt; SELECT orders.*, user.username, user.sex, user.address FROM orders, user WHERE orders.user_id = user.id &lt;/select&gt;&lt;/mapper&gt; OrdersCustomMapper.java 12345678910111213/** * 订单的mapper * @author whbai_xd@163.com * @date 2018年1月25日 下午9:55:33 */public interface OrdersCustomMapper &#123; //综合查询 --&gt; ResultType public List&lt;OrdersCustom&gt; findOrdersByUser(); //综合查询 --&gt; ResultMap public List&lt;Orders&gt; findOrdersByUserMap();&#125; 测试 123456789101112131415161718192021222324252627282930313233343536/** * 测试类 * @author whbai_xd@163.com * @date 2018年1月25日 下午10:04:01 */public class MapperTest &#123;private SqlSessionFactory sqlSessionFactory; //此方法是在执行testFindUserById之前 @Before public void setUp()throws Exception&#123; sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream("SqlMapConfig.xml")); &#125; @Test public void testfindOrdersByUser()&#123; //创建UserMapper对象 OrdersCustomMapper ordersCustomMapper = sqlSessionFactory.openSession().getMapper(OrdersCustomMapper.class); //调用方法 List&lt;OrdersCustom&gt; list = ordersCustomMapper.findOrdersByUser(); System.out.println(list); &#125; @Test public void testfindOrdersByUserMap()&#123; //创建UserMapper对象 OrdersCustomMapper ordersCustomMapper = sqlSessionFactory.openSession().getMapper(OrdersCustomMapper.class); //调用方法 List&lt;Orders&gt; list = ordersCustomMapper.findOrdersByUserMap(); System.out.println(list); &#125;&#125; resultType和resultMap的区别resultType：使用resultType实现较为简单，如果pojo中没有包括查询出来的列名，需要增加列名对应的属性，即可完成映射。 如果没有查询结果的特殊要求建议使用resultType。 resultMap：需要单独定义resultMap，实现有点麻烦，如果对查询结果有特殊的要求，使用resultMap可以完成将关联查询映射pojo的属性中。 resultMap可以实现延迟加载，resultType无法实现延迟加载。 一对多需求查询订单及订单明细的信息。 SELECT orders.*, user.username, user.sex, user.address, orderdetail.id orderdetail_id, orderdetail.items_id, orderdetail.items_num, orderdetail.orders_id FROM orders, user, orderdetail WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id resultMap实现OrdersCustomMapper.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="xd.mapper.OrdersCustomMapper"&gt; &lt;!-- 查询关联查询用户信息 --&gt; &lt;select id="findOrdersByUser" resultType="OrdersCustom"&gt; SELECT orders.*, user.username, user.sex, user.address FROM orders, user WHERE orders.user_id = user.id &lt;/select&gt; &lt;!-- 查询关联查询用户信息 resultMap --&gt; &lt;resultMap type="Orders" id="OrderUserResultMap"&gt; &lt;!-- 配置映射的订单信息 --&gt; &lt;!-- id：指定订单查询列的唯一标识，一般就是主键(对应表)。如果有多个列才能组成唯一标识，那么就多个id --&gt; &lt;!-- column,主键在表中的名字；property：主键在模型中对应的属性名称 --&gt; &lt;id column="id" property="id"/&gt; &lt;!-- result：其他字段 --&gt; &lt;result column="user_id" property="userId"/&gt; &lt;result column="number" property="number"/&gt; &lt;result column="createtime" property="createtime"/&gt; &lt;result column="note" property="note"/&gt; &lt;!-- 配置映射的关联的用户信息 --&gt; &lt;!-- association:用于映射关联查询单个对象的信息 --&gt; &lt;!-- property：要将关联查询的用户信息映射到Orders中的属性 --&gt; &lt;association property="user" javaType="User"&gt; &lt;!-- id：指定用户查询列的唯一标识，一般就是主键(对应表)。如果有多个列才能组成唯一标识，那么就多个id --&gt; &lt;!-- column,主键在orders表中的名字；property：主键在orders模型中对应的属性名称 --&gt; &lt;id column="user_id" property="id"/&gt; &lt;!-- result：其他字段 --&gt; &lt;result column="username" property="username"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="address" property="address"/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id="findOrdersByUserMap" resultMap="OrderUserResultMap"&gt; SELECT orders.*, user.username, user.sex, user.address FROM orders, user WHERE orders.user_id = user.id &lt;/select&gt; &lt;!-- 查询关联查询用户信息 resultMap 还可以使用继承！！！ --&gt; &lt;resultMap type="Orders" id="OrdersAndOrderDetailResultMap" extends="OrderUserResultMap"&gt; &lt;!-- association:用于映射关联查询多个对象的信息 --&gt; &lt;!-- property：将关联查询到多条记录映射到Orders中的按个属性 --&gt; &lt;!-- ofType:集合泛型中pojo的类型 --&gt; &lt;collection property="orderdetails" ofType="OrderDetail"&gt; &lt;!-- id：指定用户查询列的唯一标识，一般就是主键(对应表)。如果有多个列才能组成唯一标识，那么就多个id --&gt; &lt;!-- column,主键在orders表中的名字；property：主键在orders模型中对应的属性名称 --&gt; &lt;id column="orderdetail_id" property="id"/&gt; &lt;!-- result：其他字段 --&gt; &lt;result column="items_id" property="itemsId"/&gt; &lt;result column="items_num" property="itemsNum"/&gt; &lt;result column="orders_id" property="ordersId"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="findOrdersByUserOrderMap" resultMap="OrdersAndOrderDetailResultMap"&gt; SELECT orders.*, user.username, user.sex, user.address, orderdetail.id orderdetail_id, orderdetail.items_id, orderdetail.items_num, orderdetail.orders_id FROM orders, user, orderdetail WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id &lt;/select&gt; &lt;/mapper&gt; OrdersCustomMapper.java 12345678910111213141516/** * 订单的mapper * @author whbai_xd@163.com * @date 2018年1月25日 下午9:55:33 */public interface OrdersCustomMapper &#123; //综合查询 --&gt; ResultType public List&lt;OrdersCustom&gt; findOrdersByUser(); //综合查询订单中的用户 --&gt; ResultMap public List&lt;Orders&gt; findOrdersByUserMap(); //综合查询订单中的用户和每个订单的订单明细 --&gt; ResultMap public List&lt;Orders&gt; findOrdersByUserOrderMap();&#125; 测试、 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 测试类 * @author whbai_xd@163.com * @date 2018年1月25日 下午10:04:01 */public class MapperTest &#123;private SqlSessionFactory sqlSessionFactory; //此方法是在执行testFindUserById之前 @Before public void setUp()throws Exception&#123; sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream("SqlMapConfig.xml")); &#125; @Test public void testfindOrdersByUser()&#123; //创建UserMapper对象 OrdersCustomMapper ordersCustomMapper = sqlSessionFactory.openSession().getMapper(OrdersCustomMapper.class); //调用方法 List&lt;OrdersCustom&gt; list = ordersCustomMapper.findOrdersByUser(); System.out.println(list); &#125; @Test public void testfindOrdersByUserMap()&#123; //创建UserMapper对象 OrdersCustomMapper ordersCustomMapper = sqlSessionFactory.openSession().getMapper(OrdersCustomMapper.class); //调用方法 List&lt;Orders&gt; list = ordersCustomMapper.findOrdersByUserMap(); System.out.println(list); &#125; @Test public void testfindOrdersByUOrderMap()&#123; //创建UserMapper对象 OrdersCustomMapper ordersCustomMapper = sqlSessionFactory.openSession().getMapper(OrdersCustomMapper.class); //调用方法 List&lt;Orders&gt; list = ordersCustomMapper.findOrdersByUserOrderMap(); System.out.println(list); &#125;&#125; 多对多需求查询用户及用户购买商品信息。 查询主表是：用户表 关联表：由于用户和商品没有直接关联，通过订单和订单明细进行关联，所以关联表： orders、orderdetail、items SELECT orders.*, USER.username, USER.sex, USER.address, orderdetail.id orderdetail_id, orderdetail.items_id, orderdetail.items_num, orderdetail.orders_id, items.name items_name, items.detail items_detail, items.price items_price FROM orders, USER, orderdetail, items WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id AND orderdetail.items_id = items.id 将用户信息映射到user中。 在user类中添加订单列表属性List&lt;Orders&gt; orderslist，将用户创建的订单映射到orderslist 在Orders中添加订单明细列表属性List&lt;OrderDetail&gt;orderdetials，将订单的明细映射到orderdetials 在OrderDetail中添加Items属性，将订单明细所对应的商品映射到Items resultMap实现OrdersCustomMapper.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!-- 查询关联查询用户信息 resultMap--&gt;&lt;resultMap type="User" id="UserAndItemsResultMap"&gt; &lt;!-- 用户信息 --&gt; &lt;id column="user_id" property="id"/&gt; &lt;result column="username" property="username"/&gt; &lt;result column="sex" property="sex"/&gt; &lt;result column="address" property="address"/&gt; &lt;!-- 订单信息 一个用户对应多个订单，使用collection映射 --&gt; &lt;collection property="ordersList" ofType="Orders"&gt; &lt;id column="id" property="id"/&gt; &lt;result column="user_id" property="userId"/&gt; &lt;result column="number" property="number"/&gt; &lt;result column="createtime" property="createtime"/&gt; &lt;result column="note" property="note"/&gt; &lt;!-- 订单明细 一个订单包括 多个明细 --&gt; &lt;collection property="orderdetails" ofType="Orderdetail"&gt; &lt;id column="orderdetail_id" property="id"/&gt; &lt;result column="items_id" property="itemsId"/&gt; &lt;result column="items_num" property="itemsNum"/&gt; &lt;result column="orders_id" property="ordersId"/&gt; &lt;!-- 商品信息 一个订单明细对应一个商品 --&gt; &lt;association property="items" javaType="Items"&gt; &lt;id column="items_id" property="id"/&gt; &lt;result column="items_name" property="name"/&gt; &lt;result column="items_detail" property="detail"/&gt; &lt;result column="items_price" property="price"/&gt; &lt;/association&gt; &lt;/collection&gt; &lt;/collection&gt;&lt;/resultMap&gt;&lt;select id="findUserByMap" resultMap="UserAndItemsResultMap"&gt; SELECT orders.*, USER.username, USER.sex, USER.address, orderdetail.id orderdetail_id, orderdetail.items_id, orderdetail.items_num, orderdetail.orders_id, items.name items_name, items.detail items_detail, items.price items_price FROM orders, USER, orderdetail, items WHERE orders.user_id = user.id AND orderdetail.orders_id=orders.id AND orderdetail.items_id = items.id&lt;/select&gt; OrdersCustomMapper.java 12345678910111213141516171819/** * 订单的mapper * @author whbai_xd@163.com * @date 2018年1月25日 下午9:55:33 */public interface OrdersCustomMapper &#123; //综合查询 --&gt; ResultType public List&lt;OrdersCustom&gt; findOrdersByUser(); //综合查询订单中的用户 --&gt; ResultMap public List&lt;Orders&gt; findOrdersByUserMap(); //综合查询订单中的用户和每个订单的订单明细 --&gt; ResultMap public List&lt;Orders&gt; findOrdersByUserOrderMap(); //综合查询，直接查用户查到订单和每个订单的信息 public List&lt;User&gt; findUserByMap();&#125; 测试 12345678910@Testpublic void testfindUserByMap()&#123; //创建UserMapper对象 OrdersCustomMapper ordersCustomMapper = sqlSessionFactory.openSession().getMapper(OrdersCustomMapper.class); //调用方法 List&lt;User&gt; list = ordersCustomMapper.findUserByMap(); System.out.println(list);&#125; resultMap总结将查询用户购买的商品信息明细清单，（用户名、用户地址、购买商品名称、购买商品时间、购买商品数量） 针对上边的需求就使用resultType将查询到的记录映射到一个扩展的pojo中，很简单实现明细清单的功能。 一对多是多对多的特例，如下需求： 查询用户购买的商品信息，用户和商品的关系是多对多关系。 需求1： 查询字段：用户账号、用户名称、用户性别、商品名称、商品价格(最常见) 企业开发中常见明细列表，用户购买商品明细列表， 使用resultType将上边查询列映射到pojo输出。 需求2： 查询字段：用户账号、用户名称、购买商品数量、商品明细（鼠标移上显示明细） 使用resultMap将用户购买的商品明细列表映射到user对象中。 总结： 使用resultMap是针对那些对查询结果映射有特殊要求的功能，，比如特殊要求映射成list中包括 多个list。 resultType： 作用： 将查询结果按照sql列名pojo属性名一致性映射到pojo中。 场合： 常见一些明细记录的展示，比如用户购买商品明细，将关联查询信息全部展示在页面时，此时可直接使用resultType将每一条记录映射到pojo中，在前端页面遍历list（list中是pojo）即可。 resultMap： 使用association和collection完成一对一和一对多高级映射（对结果有特殊的映射要求）。 association： 作用： 将关联查询信息映射到一个pojo对象中。 场合： 为了方便查询关联信息可以使用association将关联订单信息映射为用户对象的pojo属性中，比如：查询订单及关联用户信息。 使用resultType无法将查询结果映射到pojo对象的pojo属性中，根据对结果集查询遍历的需要选择使用resultType还是resultMap。 collection： 作用： 将关联查询信息映射到一个list集合中。 场合： 为了方便查询遍历关联信息可以使用collection将关联信息映射到list集合中，比如：查询用户权限范围模块及模块下的菜单，可使用collection将模块映射到模块list中，将菜单列表映射到模块对象的菜单list属性中，这样的作的目的也是方便对查询结果集进行遍历查询。 如果使用resultType无法将查询结果映射到list集合中。 Spring和MyBatic整合整合思路需要spring通过单例方式管理SqlSessionFactory 持久层的mapper都需要由Spring进行管理。（Spring单例生成SqlSessionFactory） 搭建环境1. Jar包 2. applicationContext 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "&gt; &lt;!-- 加载配置文件 --&gt; &lt;context:property-placeholder location="classpath:jdbc.properties" /&gt; &lt;!-- 数据源，使用dbcp --&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;property name="maxActive" value="10" /&gt; &lt;property name="maxIdle" value="5" /&gt; &lt;/bean&gt; &lt;!-- sqlSessinFactory --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 加载mybatis的配置文件 --&gt; &lt;property name="configLocation" value="SqlMapConfig.xml" /&gt; &lt;!-- 数据源 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;!-- mapper配置 MapperFactoryBean：根据mapper接口生成代理对象 --&gt; &lt;!-- &lt;bean id="userMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt; mapperInterface指定mapper接口 &lt;property name="mapperInterface" value="cn.itcast.ssm.mapper.UserMapper"/&gt; &lt;property name="sqlSessionFactory" ref="sqlSessionFactory"/&gt; &lt;/bean&gt; --&gt; &lt;!-- mapper批量扫描，从mapper包中扫描出mapper接口，自动创建代理对象并且在spring容器中注册 遵循规范：将mapper.java和mapper.xml映射文件名称保持一致，且在一个目录 中 自动扫描出来的mapper的bean的id为mapper类名（首字母小写） --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 指定扫描的包名 如果扫描多个包，每个包中间使用半角逗号分隔 --&gt; &lt;property name="basePackage" value="xd.mapper"/&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt; &lt;/bean&gt;&lt;/beans&gt; 3. SqlMapConfig 12345678910111213&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;typeAliases&gt; &lt;package name="xd.vo"/&gt; &lt;/typeAliases&gt; &lt;mappers&gt; &lt;package name="xd.mapper"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; mapper代理开发 mapper.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!-- namespace命名空间，作用就是对sql进行分类化管理，理解sql隔离 注意：使用mapper代理方法开发，namespace有特殊的意义 --&gt; &lt;mapper namespace="xd.mapper.UserMapper"&gt; &lt;!-- 在映射文件中配置很多SQL语句 --&gt; &lt;!-- 需求：通过id查询用户表的记录 --&gt; &lt;!-- 通过select执行数据库查询 id：标识映射文件中的sql 将sql语句封装到mappedStatement对象中，所以将id称为statement的ID parameterType:指定输入参数的类型，这里指int型 #&#123;&#125;表示一个占位符号 #&#123;id&#125;:其中id表示接受输入的参数，参数写id，这个可以随便写 resultType：指定sql输出结果的所映射的java对象类型，select指定resultType表示将单条记录映射成的java对象 --&gt; &lt;!-- 根据id查询 --&gt; &lt;select id="findUserById" parameterType="int" resultType="user"&gt; SELECT * FROM USER WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;!-- 根据用户名名查询，可能返回多条 resultType：指定单条记录所映射的java对象 类型 $&#123;&#125;：表示拼接sql串，将接受到参数的内容不加任何修饰的添加进去 使用$&#123;&#125;拼接sql，可能会引起sql注入 $&#123;username&#125;：接受输入参数的内容，如果传入类型是简单类型，$&#123;&#125;中只能使用value。#&#123;&#125;可以使用别的名字 --&gt; &lt;select id="findUserByUsername" parameterType="String" resultType="xd.vo.User"&gt; SELECT * FROM USER WHERE USERNAME LIKE '%$&#123;value&#125;%' &lt;/select&gt; &lt;!-- 添加用户 parameterType：指定输入参数类型是pojo #&#123;&#125;中指定pojo的属性名，接受到pojo对象的属性值，MyBatis也是和Struts2一样使用OGNL拿到对象属性值 --&gt; &lt;insert id="insertUser" parameterType="xd.vo.User"&gt; &lt;!-- 将插入数据的主键返回 SELECT LAST_INSERT_ID():得到刚INSERT进去记录的主键值，只使用于自增主键 keyProperty：将查询到主键值设置到parameterType指定的对象的哪个属性 order：SELECT LAST_INSERT_ID()的执行顺序，相对于INSERT语句来说它的执行顺序 resultType:指定SELECT LAST_INSERT_ID()的返回类型 --&gt; &lt;selectKey keyProperty="id" order="AFTER" resultType="int"&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; INSERT INTO user(username,birthday,sex,address)value(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) &lt;!-- 使用mysql的uuid()生成主键 执行过程： 首先通过uuid()得到主键，将主键设置到user对象的id属性中 其次在insert执行时，从user对象中取出id属性值 --&gt; &lt;!-- &lt;selectKey keyProperty="id" order="BEFORE" resultType="String"&gt; SELECT uuid() &lt;/selectKey&gt; INSERT INTO user(id,username,birthday,sex,address)value(#&#123;id&#125;,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) --&gt; &lt;/insert&gt; &lt;!-- 删除用户 --&gt; &lt;delete id="deleteUser" parameterType="int"&gt; DELETE FROM user WHERE ID=#&#123;id&#125; &lt;/delete&gt; &lt;!-- 更新用户 分析： 需要传入用户的id！！！ 需要传入用户的更新信息 parameterType指定user对象，包括id和更新信息，注意，id必须存在 #&#123;id&#125;:从user对象中获取id属性值 --&gt; &lt;update id="updateUser" parameterType="xd.vo.User"&gt; UPDATE user SET username=#&#123;username&#125;,birthday=#&#123;birthday&#125;,sex=#&#123;sex&#125;,address=#&#123;address&#125; WHERE id=#&#123;value&#125; &lt;/update&gt; &lt;!-- 综合查询 --&gt; &lt;select id="findUserList" parameterType="UserQuery" resultType="UserCustomer"&gt; SELECT * FROM user &lt;where&gt; &lt;!-- where可以自动去掉第一个and--&gt; &lt;include refid="query_user_where"/&gt; &lt;/where&gt; &lt;/select&gt; &lt;!-- 综合查询记录数 创建分页用 --&gt; &lt;select id="findUserCount" parameterType="UserQuery" resultType="int"&gt; SELECT count(*) FROM user &lt;where&gt; &lt;!-- where可以自动去掉第一个and--&gt; &lt;include refid="query_user_where"/&gt; &lt;/where&gt; &lt;/select&gt; &lt;!-- 使用resultMap进行输出映射 --&gt; &lt;!-- 定义ResultMap： 将ELECT id id_,username username_ FROM user和User类中的属性作为一个映射关系 type：resultMap最终映射的java对象类型，可以使用别名 id：对resultMap的唯一标识 --&gt; &lt;resultMap type="User" id="userResultMap"&gt; &lt;!-- column:查询出来的列名 property：type指定的pojo类型中的属性名 --&gt; &lt;id column="id_" property="id"/&gt; &lt;result column="username_" property="username"/&gt; &lt;/resultMap&gt; &lt;select id="findUserByIdMap" parameterType="int" resultMap="userResultMap"&gt; SELECT id id_,username username_ FROM user WHERE id=#&#123;value&#125; &lt;/select&gt; &lt;!-- 定义sql片段，id：sql片段的唯一标识 经验：是基于单表来定义sql片段，这样sql片段的可重用性比较高 --&gt; &lt;sql id="query_user_where"&gt; &lt;if test="userCustomer!=null"&gt; &lt;if test="userCustomer.sex!=null and userCustomer.sex!=''"&gt; and user.sex=#&#123;userCustomer.sex&#125; &lt;/if&gt; &lt;if test="userCustomer.username!=null and userCustomer.username!=''"&gt; and user.username LIKE '%$&#123;userCustomer.username&#125;%' &lt;/if&gt; &lt;/if&gt; &lt;/sql&gt; &lt;/mapper&gt; mapper.java123456789101112131415161718192021222324252627/** * mapper接口，相当于Dao接口，用户管理 * @author whbai_xd@163.com * @date 2018年1月25日 下午4:04:37 */public interface UserMapper &#123; //根据id查询 public User findUserById(int id); //根据用户名查询用户列表 public List&lt;User&gt; findUserByUsername(String username); //插入用户 public void insertUser(User user); //删除用户 public void deleteUser(int id); //查询pojo public List&lt;UserCustomer&gt; findUserList(UserQuery userQuery); //查询pojo个数 public int findUserCount(UserQuery userQuery); //resultMap public User findUserByIdMap(int id);&#125; 测试1234567891011121314151617public class UserMapperTest &#123; private ApplicationContext applicationContext; //在setUp这个方法得到spring容器 @Before public void setUp() throws Exception &#123; applicationContext = new ClassPathXmlApplicationContext("classpath:applicationContext.xml"); &#125; @Test public void testFindUserById() throws Exception &#123; UserMapper userMapper = (UserMapper) applicationContext.getBean("userMapper"); User user = userMapper.findUserById(1); System.out.println(user); &#125;&#125;]]></content>
      <categories>
        <category>COP</category>
      </categories>
      <tags>
        <tag>COP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[COP（Socket）]]></title>
    <url>%2F2018%2F01%2F23%2FCOP%EF%BC%88Socket%EF%BC%89%2F</url>
    <content type="text"><![CDATA[COP 开始了解Socket编程 InteAdress123456789101112131415161718192021222324/** * InetAddress类 * @author whbai_xd@163.com * @date 2018年1月23日 下午4:41:42 */public class Test &#123; public static void main(String[] args) throws UnknownHostException &#123; //获取本机的InetAddress实例 InetAddress address = InetAddress.getLocalHost(); System.out.println(address.getHostName());//本地名称 System.out.println(address.getHostAddress());//主机地址 System.out.println(Arrays.toString(address.getAddress()));//字节形式IP地址 System.out.println(address);//PC-20170919LNTY/10.170.55.190 System.out.println(InetAddress.getByName("10.170.55.190"));//参数是主机名可以全拿到，是IP地址，就拿不到主机名 &#125;&#125;/**PC-20170919LNTY10.170.55.190[10, -86, 55, -66]PC-20170919LNTY/10.170.55.190/10.170.55.190*/ URL1234567891011121314/** * URL类 * @author whbai_xd@163.com * @date 2018年1月23日 下午4:41:42 */public class Test &#123; public static void main(String[] args) throws MalformedURLException&#123; //获取本机的InetAddress实例 URL bb = new URL("http://www.baidu.com"); System.out.println(bb.getHost());//主机 System.out.println(bb.getProtocol());//协议 System.out.println(bb.getPort());//端口，http默认端口号是80，一旦是默认端口，返回的就是-1 &#125;&#125; Socket TCP 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * TCP Socket Server * @author whbai_xd@163.com * @date 2018年1月23日 下午5:03:19 */public class Server &#123; public static void main(String[] args) &#123; try &#123; //1.创建服务器端ScoketServer，指定绑定的端口，并监听这个端口(1023以后的端口) ServerSocket serverSocket = new ServerSocket(8888); //2. 调用accept()方法，开始监听，等待客户端连接 System.out.println("开始启动"); Socket socket = serverSocket.accept(); System.out.println("监听到数据了"); //3. 获取输入流，获取客户端信息 InputStream in = socket.getInputStream();//Stream结尾的都是字节流 InputStreamReader reader = new InputStreamReader(in);//字节流变成字符流，加快速度 BufferedReader buffer = new BufferedReader(reader);//输入流缓冲 //4. 读取资源 String info = null; while((info = buffer.readLine())!=null)&#123; System.out.println(info); &#125; socket.shutdownInput(); //5. 响应客户端 PrintWriter pw = new PrintWriter(socket.getOutputStream()); pw.write("回馈"); pw.flush(); //6. 关闭流 pw.close(); buffer.close(); reader.close(); in.close(); socket.close(); serverSocket.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;/** * TCP Socket Client * @author whbai_xd@163.com * @date 2018年1月23日 下午5:03:19 */public class Client &#123; public static void main(String[] args) &#123; try &#123; //1. 创建客户端Socket，指定服务器地址和端口 Socket scoket = new Socket("localhost",8888); //2. 创建输出流，向服务器端发送信息 OutputStream out = scoket.getOutputStream();//字节流 PrintWriter ps = new PrintWriter(out); //3. 写出数据 ps.write("用户名"); ps.flush();//刷新 scoket.shutdownOutput(); //4. 读取服务端响应 BufferedReader buffer = new BufferedReader(new InputStreamReader(scoket.getInputStream())); String info = null; while((info = buffer.readLine())!=null)&#123; System.out.println(info); &#125; //5. 关闭流 buffer.close(); ps.close(); out.close(); scoket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 多线程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120/** * 服务器线程处理类 * @author whbai_xd@163.com * @date 2018年1月23日 下午5:39:37 */public class ServerThread extends Thread&#123; //和本线程相关的Socket Socket socket = null; public ServerThread(Socket socket) &#123; super(); this.socket = socket; &#125; @Override public void run() &#123; InputStream in = null; InputStreamReader reader = null; BufferedReader buffer = null; PrintWriter pw = null; try &#123; //3. 获取输入流，获取客户端信息 in = socket.getInputStream();//Stream结尾的都是字节流 reader = new InputStreamReader(in);//字节流变成字符流，加快速度 buffer = new BufferedReader(reader);//输入流缓冲 //4. 读取资源 String info = null; while((info = buffer.readLine())!=null)&#123; System.out.println(info); &#125; socket.shutdownInput(); //5. 响应客户端 pw = new PrintWriter(socket.getOutputStream()); pw.write("回馈"); pw.flush(); //6. 关闭流 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; try &#123; pw.close(); buffer.close(); reader.close(); in.close(); socket.close(); &#125; catch (Exception e2) &#123; e2.printStackTrace(); &#125; &#125; &#125;&#125;/** * TCP Socket Server * @author whbai_xd@163.com * @date 2018年1月23日 下午5:03:19 */public class Server &#123; public static void main(String[] args) &#123; try &#123; //1.创建服务器端ScoketServer，指定绑定的端口，并监听这个端口(1023以后的端口) ServerSocket serverSocket = new ServerSocket(8888); Socket socket = null; //int count = 0; //2. 调用accept()方法，开始监听，等待客户端连接 System.out.println("开始启动"); while(true)&#123; socket = serverSocket.accept(); ServerThread serverThread = new ServerThread(socket); serverThread.start(); //System.out.println(++count+"..."+socket.getInetAddress()); //System.out.println("监听到数据了"); &#125; &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;/** * TCP Socket Client * @author whbai_xd@163.com * @date 2018年1月23日 下午5:03:19 */public class Client &#123; public static void main(String[] args) &#123; try &#123; //1. 创建客户端Socket，指定服务器地址和端口 Socket scoket = new Socket("localhost",8888); //2. 创建输出流，向服务器端发送信息 OutputStream out = scoket.getOutputStream();//字节流 PrintWriter ps = new PrintWriter(out); //3. 写出数据 ps.write("用户名second"); ps.flush();//刷新 scoket.shutdownOutput(); //4. 读取服务端响应 BufferedReader buffer = new BufferedReader(new InputStreamReader(scoket.getInputStream())); String info = null; while((info = buffer.readLine())!=null)&#123; System.out.println(info); &#125; //5. 关闭流 buffer.close(); ps.close(); out.close(); scoket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Heart Socket网络中的接收和发送数据都是使用操作系统中的SOCKET进行实现。但是如果此套接字已经断开，那发送数据和接收数据的时候就一定 会有问题。可是如何判断这个套接字是否还可以使用呢？这个就需要在系统中创建心跳机制。其实TCP中已经为我们实现了一个叫做心 跳的机制。如果你设置了心跳，那TCP就会在一定的时间（比如你设置的是3秒钟）内发送你设置的次数的心跳（比如说2次）， 并且此信息不会影响你自己定义的协议。所谓“心跳”就是定时发送一个自定义的结构体（心跳包或心跳帧），让对方知道自己“在线”。 以确保链接的有效性。 所谓的心跳包就是客户端定时发送简单的信息给服务器端告诉它我还在而已。代码就是每隔几分钟发送一个固定信息给服务端，服务端 收到后回复一个固定信息如果服务端几分钟内没有收到客户端信息则视客户端断开。比如有些通信软件长时间不使用，要想知道它的状态 是在线还是离线就需要心跳包，定时发包收包。发包方：可以是客户也可以是服务端，看哪边实现方便合理。一般是客户端。服务器也可 以定时轮询发心跳下去。心跳包之所以叫心跳包是因为：它像心跳一样每隔固定时间发一次，以此来告诉服务器，这个客户端还活着。 事实上这是为了保持长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。 在TCP的机制里面，本身是存在有心跳包的机制的，也就是TCP的选项：SO_KEEPALIVE。系统默认是设置的2小时的心跳频率。 但是它检查不到机器断电、网线拔出、防火墙这些断线。而且逻辑层处理断线可能也不是那么好处理。一般，如果只是用于保活还是可以的。 1. 客户端每隔一个时间间隔发生一个探测包给服务器 2. 客户端发包时启动一个超时定时器 3. 服务器端接收到检测包，应该回应一个包 4. 如果客户机收到服务器的应答包，则说明服务器正常，删除超时定时器 5. 如果客户端的超时定时器超时，依然没有收到应答包，则说明服务器挂了 参考：http://coach.iteye.com/blog/2024444 客户端： 通过持有Client对象，可以随时（使用sendObject方法）发送Object给服务端。 如果keepAliveDelay毫秒（程序中是2秒）内未发送任何数据，则，自动发送一个KeepAlive对象给服务端， 用于维持连接。 由于，我们向服务端，可以发送很多不同的对象，服务端也可以返回不同的对象。 所以，对于返回对象的处理，要编写具体的ObjectAction实现类进行处理。 通过Client.addActionMap方法进行添加。这样，程序会回调处理。 服务端： 由于客户端会定时（keepAliveDelay毫秒）发送维持连接的信息过来，所以，服务端要有一个检测机制。 即当服务端receiveTimeDelay毫秒（程序中是3秒）内未接收任何数据，则，自动断开与客户端的连接。 ActionMapping的原理与客户端相似（相同）。 通过添加相应的ObjectAction实现类，可以实现不同对象的响应、应答过程。]]></content>
      <categories>
        <category>COP</category>
      </categories>
      <tags>
        <tag>COP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试（杂-2）]]></title>
    <url>%2F2018%2F01%2F18%2FJava%E9%9D%A2%E8%AF%95%EF%BC%88JavaWeb%EF%BC%89%2F</url>
    <content type="text"><![CDATA[开始复习JavaWeb：JSP/Servlet 1. Tomcat，Apache，JBoss的区别？ 1. Apache是Http服务器，Tomcat是Web服务器，JBoss是应用服务器。 2. Apache解析静态的html文件；Tomcat解析jsp，也可以充当Servlet容器。 2. 什么是Servlet？ 1. API：狭义的说，Servlet是一个Servlet接口，广义的Servlet是指任何实现Servlet接口的类。我们一般指第二种，Servlet的作用就是接受浏览器发给服务器的请求Request，经过处理后，将返回响应Response给浏览器。 2. 组件：服务器端用来处理客户端请求的组件，需要在web.xml中配置。 3. Servlet是用来处理客户端请求并产生动态页面的Java类。Servlet主要用来处理或者存储HTML表单提交的数据，产生动态内容，在无状态的HTTP协议下管理状态信息。 3. Tomcat的优化经验？ 1. 去掉对Web.xml的监视，把JSP提前编辑成Servlet； 2. 有富余物理内存的情况下，加大Tomcat使用的JVM内存。 4. Servlet的生命周期？ Servlet的生命周期分为加载、创建、初始化、处理客户端请求和卸载5个阶段。 1. 加载，容器通过类加载器使用Servlet类对应的文件来加载Servlet。 2. 创建，通过调用Servlet的构造函数来创建一个Servlet实例。 3. 初始化，通过调用Servlet的init()方法来完成初始化工作，这个方法是在Servlet被创建的时候就被调用了，init()方法只会被调用一次。 4. 处理客户请求，每当有一个请求来到时，容器都会创建一个新的线程来处理该请求，接着调用Servlet的service方法来完成客户端请求。 5. 卸载，只能调用一次。 步骤： 1. Web Client向Servelt容器（Tomcat）发出Http请求 2. Servlet容器接受Web Client请求 3. Servlet容器创建一个HttpRequest对象，将Web Client请求的信息封装到这个对象中。 4. Servlet容器创建一个HttpResponse对象 5. Servlet容器调用HttpServlet对象的时service方法，把HttpRequest和HttpResponse对象作为参数传给HttpServlet 6. HttpServlet调用HttpRequest对象的有关方法，获取Http请求信息 7. HttpServlet调用HttpResponse对象的有关方法，生成响应数据 8. Servlet容器把HttpServlet的响应结果传给Web Client 创建对象： 1.初始化阶段： 1. 将编译后的Servlet字节码文件读入内存； 2. Servlet容器创建ServletConfig，并与ServletContext对象建立关联关系，即调用ServletConfig的getServletContext()得到ServletContext对象 3. 创建Servlet对象 4. 调用GenericServlet的init(ServletConfig config)，建立Servlet和ServletConfig对象的关联。 2. 运行时阶段： 调用Servlet类的Service方法，当Servlet将响应返回后，Servlet容器会销毁HttpServletRequest对象与HttpServletResponse对象。 3. 销毁阶段： 在web容器终止时，会先调用所有Servlet的destroy()方法。 5. Servlet和CGI的区别？ CGI（Common Gateway Interface，公共网关接口），用来生成动态页面 1. CGI针对每个请求都会创建一个进程来处理，而Servlet针对每个请求创建一个线程来执行。Servlet一个实例可以服务于多个请求。 2. Servlet可以和Web服务器（Tomcat）进行交互，而CGI却无法和Web服务器直接交互。 6. Servlet API中的forward和redirect？ 1. 浏览器显示：forward不会改变URL地址（请求转发），redirect会改变（重定向） 2. 资源共享：forward可以资源共享，而redirect不可以 3. 功能：forward只能在一个Web应用程序内资源转发，而重定向可以用URL绝对路径访问其他的Web服务器资源 4. 效率：redirect效率低，请求了两次；forward效率高。 5. 请求转发在服务端完成，重定向在客户端完成 7. get和post的区别？ 1. 在客户端，Get方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放置在HTML HEADER内提交。 2. 对于get方式，服务器端用Request.QueryString获取变量的值，对于post方式，服务器端用Request.Form获取提交的数据。 3. GET方式提交的数据最多只能有1024字节，而POST则没有此限制。 4. 安全性问题。 8. request.getParameter()和request.getAttribute()的区别？ 1. request.getParameter()获取的类型是String； request.getAttribute()获取的类型是Object 2. request.getPrameter()获取的是POST/GET传递的参数值和URL中的参数； request.getAttribute()获取的是对象容器中的数据值/对象 3. request.setAttribute()和request.getAttribute()可以发送、接收对象； request.getParamter()只能接收字符串，官方不开放request.setParamter()（也就是没有这个方法） 9. 什么是JSP？ JSP是一种后端脚本语言，是为了解决Html是静态的，而Servlet输出动态页面又太复杂的问题而出现的，通过JSP标签、动作、内置对象提供方便的生成动态网页功能，是一种后端渲染技术。 JSP其实就是基于Servlet实现的，JSP编译后就是Servlet 10. JSP九大内置对象？ 1、request对象——代表javax.servlet.http.HttpServletRequest对象 2、response对象——代表javax.servlet.http.HttpServletResponse对象 3、session对象——代表javax.servlet.http.HttpSession对象 4、application对象——代表javax.servlet.ServletContext对象 5、pageContext对象——代表javax.servlet.jsp.pageContext对象 6、page对象——代表this 7、config对象——代表javax.servlet.ServletConfig对象 8、out对象——代表javax.servlet.jsp.jspWriter对象 9、exception对象——代表java.lang.Exception对象 11. JSP中动态include和静态include的区别？ 1. 静态include：&lt;%@ include file=&quot;文件名&quot; %&gt;，相当于复制，编辑时将对应的文件包含进来，当内容变化时，不会再一次对其编译，不易维护。 2. 动态include：&lt;jsp:include page=&quot;文件名&quot;&gt;,能够自动检查被包含文件，当客户端对JSP文件进行请求时，会重新将对应的文件包含进来，进行实时的更新。 12. 页面间对象传递的方法（四大域）？ page、request、session、cookie 13. MVC Model：处理业务逻辑模块 View：负责页面显示，数据到页面的转换 Controller：负责每个请求的分发，把Form的数据给Model处理后，把处理结果返回给相应的View显示。 14. 我们在web应用开发过程中经常遇到输出某种编码的字符，如iso-8859-1等，如何输出一个某种编码的字符串？ 1234567891011public String Translate(String str)&#123; String s=""; try&#123; s=new String(str.getBytes("iso-8859-1"),"UTF-8"); s=str.trim(); &#125;catch(Exception e)&#123; System.err.println(e.getMessage()); &#125; return s;&#125; 15. 会话跟踪技术 cookie、url重写、hidden表单隐藏域、session 16. Session和cookie的区别？ 1. cookie数据保存在客户端，session数据保存在服务端 2. cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗。 3. session会在一定的时间内保持在服务器上，但是会占内存 4. 单个cookie保存的数据不能超过4k。多个浏览器的限制站点是20个cookie 5. session能够存储任意的Java对象，cookie只能存储String类型的对象。 17. Tomcat根目录下有哪些文件？ 1. config：配置文件存放路径 2. webapps：项目部署的目录 3. lib：项目运行时所需要的jar目录 4. temp：临时文件的存放目录 5. logs:记录日志的目录 18. 实例化Servlet有几种方式？ 1. 第一次请求时，实例化Servlet对象 2. 在web.xml文件中，在servlet标签中加load-on-startup标签，tomcat启动时就会实例化servlet对象。 19.说一下Servlet体系结构？ 所有的Servlet都必须要实现的核心接口是javax.servlet.Servlet。每一个Servlet都必须要直接或者间接实现这个接口，或者继承javax.servlet.GenericServlet或者javax.http.HTTPServlet。最后，Servlet使用多线程可以并行的为多个请求服务。 20. GenericServlet和HttpServlet有什么区别？ GenericServlet类实现了Servlet和ServletConfig接口。实现了除了service()之外的其他方法，在创建Servlet对象时，可以继承GenericServlet来简化程序的代码，但是需要实现sevice方法。 而HttpServlet继承了GenericServlet，同时提供了service方法。 21. 什么是Servlet链(Servlet Chaining)？ Servlet链是把一个Servlet的输出发送给另一个Servlet的方法。第二个Servlet的输出可以发送给第三个Servlet，依次类推。链条上最后一个Servlet负责把响应发送给客户端。 22. JSP请求是如何被处理的？ 浏览器首先要请求一个以.jsp扩展名结尾的页面，发起JSP请求，然后，Web服务器读取这个请求，使用JSP编译器把JSP页面转化成一个Servlet类。需要注意的是，只有当第一次请求页面或者是JSP文件发生改变的时候JSP文件才会被编译，然后服务器调用servlet类，处理浏览器的请求。一旦请求执行结束，servlet会把响应发送给客户端。这里看下如何在JSP中获取请求参数。]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java刷题(树)]]></title>
    <url>%2F2018%2F01%2F11%2FJava%E5%88%B7%E9%A2%98-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[关于树的题目 树的深度1234567891011121314151617181920212223/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public int TreeDepth(TreeNode root) &#123; if(root==null)&#123; return 0; &#125; int left = TreeDepth(root.left); int right = TreeDepth(root.right); return left&gt;right?left+1:right+1; &#125;&#125; 树的遍历1234567891011121314151617181920212223242526272829303132333435363738class Node &#123; Node left; Node right; int data; Node(int newData) &#123; left = null; right = null; data = newData; &#125; &#125; public class Main&#123; public static void preOrderTraverse(Node node)&#123; if(node==null)&#123; return ; &#125; System.out.println(node.data+" ");//显示结点数据，可以变成别的对结点的操作 preOrderTraverse(node.left); preOrderTraverse(node.right); &#125; public static void inOrderTraverse(Node node)&#123; if(node==null)&#123; return ; &#125; preOrderTraverse(node.left); System.out.println(node.data+" ");//显示结点数据，可以变成别的对结点的操作 preOrderTraverse(node.right); &#125; public static void postOrderTraverse(Node node)&#123; if(node==null)&#123; return ; &#125; preOrderTraverse(node.left); preOrderTraverse(node.right); System.out.println(node.data+" ");//显示结点数据，可以变成别的对结点的操作 &#125;&#125; 树的层级遍历二叉树的镜像123456789101112131415161718192021222324252627/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public void Mirror(TreeNode root) &#123; if(root==null)&#123; return ; &#125; TreeNode temp = null; temp = root.left; root.left = root.right; root.right = temp; Mirror(root.left); Mirror(root.right); &#125;&#125; 判断一个树是不是平衡二叉树注意：AVL说的是，左子树和右子树高度差不大与1，这个判断同时可以找到树的高度 1234567891011121314151617181920public class Solution &#123; private boolean isBalanced=true; public boolean IsBalanced_Solution(TreeNode root) &#123; getDepth(root); return isBalanced; &#125; public int getDepth(TreeNode root)&#123; if(root==null)&#123; return 0; &#125; int left=getDepth(root.left); int right=getDepth(root.right); if(Math.abs(left-right)&gt;1)&#123; isBalanced=false; &#125; return left&gt;right?left+1:right+1; &#125;&#125; 二叉树的层级遍历12345678910111213141516171819202122232425262728293031323334/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; private ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; if(root==null)&#123; return list; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; TreeNode node = queue.poll(); list.add(node.val); if(node.left!=null)&#123; queue.offer(node.left); &#125; if(node.right!=null)&#123; queue.offer(node.right); &#125; &#125; return list; &#125;&#125; 二叉树中某一值的路径123456789101112131415161718192021222324252627282930/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); private ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; if(root==null)&#123; return listAll; &#125; list.add(root.val); target -= root.val; if(target == 0 &amp;&amp; root.left == null &amp;&amp; root.right == null) listAll.add(new ArrayList&lt;Integer&gt;(list)); FindPath(root.left, target); FindPath(root.right, target); list.remove(list.size()-1); return listAll; &#125;&#125;]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java刷题(链表)]]></title>
    <url>%2F2018%2F01%2F11%2FJava%E5%88%B7%E9%A2%98-%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[和链表有关的题目 链表从尾打印1234567891011121314151617181920212223242526/*** public class ListNode &#123;* int val;* ListNode next = null;** ListNode(int val) &#123;* this.val = val;* &#125;* &#125;**/import java.util.*;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; Stack&lt;ListNode&gt; stack = new Stack&lt;ListNode&gt;(); while(listNode!=null)&#123; stack.push(listNode); listNode = listNode.next; &#125; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); while(stack.size()!=0)&#123; list.add(stack.pop().val); &#125; return list; &#125;&#125; 反转链表12345678910111213141516171819202122232425/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; if(head==null)&#123; return head; &#125; ListNode preNode = null; ListNode nextNode = null; while(head!=null)&#123; nextNode = head.next;//拿到当前结点的下一个结点 head.next = preNode;//重新指定当前结点的下一个结点，断开链表 preNode = head;//当前结点成为下一次循环的前一个结点 head = nextNode;//当前结点的下一个结点成为新的当前结点 &#125; return preNode; &#125;&#125; 链表的倒数第K个值1234567891011121314151617181920212223242526272829/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/import java.util.*;public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; Stack&lt;ListNode&gt; stack = new Stack&lt;ListNode&gt;(); int count = 0; while(head!=null)&#123; stack.push(head); head = head.next; count++; &#125; if(count&lt;k)&#123; return null; &#125; ListNode tempNode=null; for(int i=0;i&lt;k;i++)&#123; tempNode = stack.pop(); &#125; return tempNode; &#125;&#125; 链表合并123456789101112131415161718192021222324/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; if(list1 == null) return list2; if(list2 == null) return list1; if(list1.val &lt;= list2.val) &#123; list1.next = Merge(list1.next, list2); return list1; &#125;else&#123; list2.next = Merge(list1, list2.next); return list2; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Operating System（杂一）]]></title>
    <url>%2F2018%2F01%2F09%2FOperating%20System%EF%BC%88%E6%9D%82%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[操作系统的概念有关 杂1. 文件系统的主要目的是实现对文件的按名存取 2. 临界区并不是方法，而是进程访问临界资源的那部分代码。 3. 自动变量外部不可见，不需要互斥量保护。 4. 多线程并不能提高内存利用率，但是可以提高程序响应和CPU利用率。 5. 执行系统调用可以被中断。 6. 操作系统在计算机系统中位于硬件和用户软件之间。 7. 分页的东西都会产生内部碎片。在内存的连续分配中，动态分配产生外部碎片、固定分区产生内部碎片。 8. 一条指令的功能通过执行一个微程序来实现 9. SPOOLing技术可以实现设备的虚拟分配。 10. 模块并不是一个独立程序，因此进行单元测试之前，需要开发驱动软件或者存根软件。在软件结构中，底层模块无需编写存根软件。 11. 进程调度的关键问题是调度算法的选择。 12. 能直接与 CPU 交换信息的存储器是内存储器 13. LRU 算法的实现需要很高的时间消耗，这是因为需要对所有页面的移位寄存器进行比较。 14. 动态分区分配算法：首次适应、循环首次适应、最佳适应、最坏适应、快速适应、伙伴系统、哈希算法。 15. 本地用户通过键盘登录系统时，首先获得键盘输入信息的程序是中断处理程序。 16. 对于记录型信号量，当 s&lt;0 的时候，请求进程会阻塞。 对于整型信号量，当s&lt;=0的时候，请求进程不会阻塞，而是进入盲等状态 17. 多级反馈队列的调度中就绪队列的设置不是像多级队列调度一样按作业性质划分，而是按时间片的大小划分 18. 对于多关键字而言，倒排文件组织方便而又高效 19. 磁盘和主存可以用来存储页表 20. 信箱通信的最大好处是，发送方和接受方不必直接建立联系，没有处理时间上的限制。 发送方可以在任何时间发送信息，接收方也可以在任何时间收信。 信箱通信是一种间接通信。 21. 命名空间大多数有一个顶级的命名空间System.net。 22. 进程间的基本关系为同步与互斥（相互独立和相互制约） 23. 文件系统中的最小存储逻辑单元就是Block，Block越大，inode越小，越适合大文件存储，反之成立。一个Block最多存放一个文件，一个Block放不下一个文件，就会占用另一个Block。 24. 无论是中断程序还是子程序调用都不需要保存通用数据寄存器和通用地址寄存器的内容。在中断的时候程序计数器（PC）和程序状态字（PSW）需要保存，而子程度调动的时候，只需要保存程序计数器的内容。 25. 单缓冲，在这里系统缓冲区是单工操作。 即，读写不能同时进行。 26. 主存地址寄存器MAR和程序计数器PC的位数都取决于主存储器的容量，二者位数相等 27. UNIX 的一个目录项包含了两个域，文件名（ 14 个字节）和节点的编号（ 2 个字节），这些参数决定了每个文件系统的文件数目为 64K 28. 33MHz*32b=1056Mb/s=132MB/s 29. 编译后形成的目标文件可以理解为一个小块一个小块的程序碎片，这样的小块一般都是具有从0开始的逻辑地址。 在和相应的库函数链接以后形成一个可执行的文件，需要修改这些小块的逻辑地址，使之统一有序。 所以在链接的过程中又把每个小段的逻辑地址按照一定的顺序组装成一个统一的逻辑地址范围，用来标识出此程序。 虽然编辑后的目标文件形成的小块内的也叫逻辑地址，但是和链接后形成的逻辑地址是截然不同的。 30. |页号|物理块号|状态位P|访问字段A|修改位M|外存地址| 1）状态位P:用于指示该页是否已调入内存，供程序访问时参考； 2）访问字段A:用于记录本页在一段时间内被访问次数，供选择换出页面时参考； 3）修改位M：表示该页在调入内存后是否被修改过，供置换页面时参考； 4）外存地址：用于指出该页在外存上的地址，通常是物理块号，供调入该页时参考； 31. 廉价磁盘冗余队列（RAID），用一台磁盘阵列控制器来同一管理和控制一组磁盘驱动器，从而组成一个大的磁盘系统（OS p266） RAID分级： 1) RAID0，必须要有两个以上的硬盘驱动器。在所有的级别中，RAID 0的速度是最快的。但是RAID 0没有冗余功能的，如果一个磁盘(物理)损坏，则所有的数据都无法使用。RAID0实现了带区组，数据并不是保存在一个硬盘上，而是分成数据块保存在不同驱动器上。 2) RAID1，当主硬盘损坏时，镜像硬盘就可以代替主硬盘工作。镜像硬盘相当于一个备份盘，可想而知，这种硬盘模式的安全性是非常高的，RAID 1的数据安全性在所有的RAID级别上来说是最好的。但是其磁盘的利用率却只有50%，是所有RAID级别中最低的。把用户写入硬盘的数据百分之百地自动复制到另外一个硬盘上。 3）RAID3，具有并行传输功能的磁盘阵列，只利用一台奇偶校验盘来完成数据的校验功能。例如，当阵列中只有7个盘的时候，可利用6个盘作为数据盘，一个盘作为校验盘，利用率6/7 4)RAID5，分布式奇偶校验的独立磁盘结构，把数据和相对应的奇偶校验信息存储到组成RAID5的各个磁盘上。 32. 文件系统在内存中维护唯一的一张文件分区表，其中保存了系统所有已打开文件的FCB。 33. CPU不直接访问的存储器是硬盘存储器 34. 虚存管理和实存管理的主要区别是实存要求一程序全部装入内存才开始运行，虚存允许程序在执行的过程中逐步装入 35. 读写锁在写加锁状态时，其他进行写操作线程会阻塞. 写锁就是防止其他进程读或写. 读锁就是防止在读的时候有写进程进入 36. 分段：不定长，连续;分页：定长，可能连续可能不连续 37. 动态分区的内存回收，只有上下都相邻空闲区的时候，才会使空闲区数减少，而上下都不是的话，空闲区数增加，如果一个是一个不是，那么并不会改变空闲区数。 38. 符号链接就是快捷方式啊，删除文件，快捷方式不会被删除，但是会失效 39. 虚存是充分利用了地址空间 40. 顺序文件也可以用随机存储的方式；链接文件只能根据链去找下一个，依次访问。 41. 线程共享的内容：进程代码块、进程公有数据、进程打开的文件描述符、信号的处理器、进程的当前目录、进程用户ID和进程组ID、地址空间。 42. 线程独有的内容：线程ID、寄存器组的值、线程的堆栈、错误返回码、线程的信号屏蔽量。 43. 分页式存储管理中，地址转换工作是由硬件完成的。 44. CSCAN并不能避免磁臂粘着现象。在SSTF、SCAN及CSCAN几种调度算法中，都有可能出现磁臂停留在某个位置不动的情况。 有一个或几个进程对某一磁道有着较高的访问频率，即他们反复地请求对一个磁道进行了I/O请求，从而垄断了整个磁盘设备，这一现象称为磁臂粘着。 45. 位示图是用来磁盘空间管理的，分配磁盘空间给文件。 46. 进程通信没有全局变量，别看错了。共享内存才能传递信息。 47. 数据总线位数对应相同的部件就是CPU。 48. 虚拟存储器的物质基础就是大容量的辅存，一定容量的主存，和地址变换机构。 49. 不管是分页，分区，分段，都是将一部分程序先调到内存中运行，对并发性并没有影响。但是内存的利用率和系统的吞吐量肯定是提高了。 50. 操作系统对进程的管理和控制主要是通过控制原语言实现的。 51. 文件的物理结构不仅与外存的分配方式相关，还与存储介质的特性相关，通常在磁带上只适合使用顺序结构。采用顺序结构的文件既适合进行顺序访问，也适合进行随机访问。 52. 进程主要组成部分包括：程序、数据、PCB 53. 动态重定位过程依赖于，重定位寄存器，地址变换机构，目标程序。 54. Unix是一个分时OS 55. 资源静态分配法破坏了死锁产生的请求-保持条件来预防死锁的发生。 56. 文件的保密是防止文件被窃取。 57. 主线程改变会影响到其他线程；线程之间可以直接通信，但是进程之间必须通过IPC。 58. I/O交通管制程序的主要功能是管理设备、控制器和通道。 59. 在段页式存储管理系统中,当访问主存中的一条指令或数据时最多访问三次主存。 60. 文件操作的唯一依据是文件句柄。 61. fork生成的进程是当前进程的一个相同副本，fork系统调用与clone系统调用的工作原理基本相同 62. 引入缓冲的原因：缓冲CPU和I/O设备间速度不匹配的矛盾、减少对CPU的中断频率，放宽对蓄洪大响应时间的限制、提高CPU和I/O设备之间的并行性 63. 解决死锁问题通常意味着牺牲资源的效率 64. 总线位宽是指总线能够同时传送的二进制数据的位数。 65. 在采用请求分页存储管理的系统中，如果页面不在内存则发生缺页中断，它属于程序中断。 66. 管道是指用于连接一个读进程和一个写进程以实现进程之间通信的一种共享文件。向管道提供输入的是发送进程，也称为 写进程，负责向管道输入数据，数据的格式是字符流。接受管道 数据的接受进程为读进程。 67. mrb用于win平台，gpt主要用于mac（苹果） 68. 高优先级的抢占CPU，使得原来处于运行状态的进程转变为就绪状态。 69. 获得spinlock未果，进程会进入等待状态。 70. 当前微机上运行的Windows属于多任务操作系统 71. 进程上下文实际上是进程执行活动全过程的静态描述。 72. 用P,V操作管理临界区的时候，信号量的初值一般应定义为1. 73. 进程从CPU退下时，进程会将“现场&quot;信息保存在自己的栈空间里，不是系统栈，系统栈用作它用。 74. 磁盘簇个数：10*1024*1024KB/4KB=2621440bit，一个簇能容纳的bit数：4*1024*8= 32768bit 。则存放该位图所需簇的个数 2621440/ 32768=80个簇 75. 外部中断处理过程， PC 值由中断隐指令自动保存，而通用寄存器内容由操作系统保存。 76. 导致进程灌浆的典型操作只有四个：用户登录、作业调度、提供服务、应用请求。 77. FCFS置换算法中可能会产生&quot;分配给进程的内存块增加后，反而可能导致缺页次数增加&quot;的现象。 78. FCFS调度算法不利于短作业 79. CPU发出的访问存储器的地址是物理地址 80. 操作系统中采用缓冲技术，能够减少CPU的中断次数，从而提高资源的利用率。 81. 在UNIX中，文件系统和设备驱动程序之间的接口是设备开关表 82. 顺序文件不可随机存取。而随机存取的文件都是可以顺序存取的。 83. PC的硬盘接口大多采用SATA接口 84. 系统调用，指的是运行在使用者空间的程序向操作系统内核请求需要更高权限运行的服务。 85. 处理越界，只有已经加载到内存的数组或其他单元才可能出现访问越界的情况，而发生缺页中断，说明还没有把数据装载到内存。 86. 一旦缺页，就会置换页和分配内存。 87. 单缓冲系统，从磁盘到缓冲区的时间，缓冲区到用户区，CPU处理总的时长等于，max(磁盘到缓冲区，CPU处理)+缓冲区到用户区 88. 文件的逻辑结构：连续、多重、转置、顺序；物理存储结构：顺序（连续，串联）、链接、索引；目录结构：一级、二级、树形、无环图 89. 操作系统就只是核心系统软件。 90. 文件管理系统管理的对象有文件、目录和磁盘存储空间。一切皆文件。 91. 虚拟存储的实现是基于程序局部性原理，其实质是借助外存将内存较小的物理地址空间转化为较大的逻辑地址空间 92. 在硬件和环境相同的条件下，一个作业在分页存储管理系统中运行的时间最长。 93. 位示图用于管理&quot;页式存储管理&quot;中的主存空间，磁盘空间的分配和回收。 94. 响应时间，从发出请求到系统做出反应的时间。请求--&gt;处理--&gt;回显 95. 在哪个硬盘逻辑盘上设置虚拟内存以及虚拟内存的容量都可以由用户来设定 96. 进程之间的通讯还有文件和记录锁定。 97. 分页或者分段每要访问一个数据，都须访问两次内存。而在段页式系统中，为了获得一条指令或数据，须三次访问内存。 98. 进程调度并不需要硬件的支持。而中断系统、地址映射、时钟管理都是需要硬件支持的。 99. 在Linux文件系统中，是以块为单位存储信息的，为了找到某一个文件在存储空间中存放的位置，用I结点对一个文件进行索引。I节点包含了描述一个文件所必须的全部信息。所以I结点是文件系统管理的一个数据结构。 100. 上下切换，也就是进程切换，就是指CPU从一个进程或线程切换到另一个进程或线程。 同时进程切换只能发生在内核态。 上下文切换的内容有，CPU寄存器，进程状态，内存管理信息。 进程调度并不属于上下文切换的内容。 101. 进程间通讯的方式中共享内存的访问速度最快。 102. CPU可以直接访问内存，通道在内存和设备管理器中间的一级。 103. Client-Server模式的进程间通信方式：远程方法调用、远程过程调用、套接字编程。而共享内存是进程间通信速度最快的，但必须是一个主机，比如共享内存中的消息传递系统。 104. 在Window操作系统中，剪贴板就是内存中的一块区域。 105. 文件系统中分配存储空间的基本但是就是块。 106. 顺序文件适合建立在顺序存储的设备上，而不适合建立在磁盘上。 107. 计数定时查询方式下，若每次技术都从0开始，则设备号小的设备优先级高 108. 伙伴系统中，一个内存块大小是8KB，起始地址是224KB，则其伙伴的地址是224+8=232 109. 银行家算法中的数据结构包括有可利用资源向量Avaliable、最大需求矩阵Max、分配矩阵Allocation、需求矩阵Need，则Need[i,j]=Max[i,j]-Allocation[i,j]； 110. 死锁预防：静态资源分配法（破坏&quot;请求保持&quot;），资源顺序分配（破坏&quot;循环等待&quot;），剥夺控制法（破坏&quot;不可抢占&quot;） 111. 避免死锁：银行家算法，避免从进去不安全区域 112. 预防死锁：资源分配图、资源分配图简化 113. 解除死锁：抢占资源（从一个或多个进程中抢占足够多的资源）、终止进程（终止所有进程、逐个终止进程） 114. 请求页式存储管理中，采用动态重定位和内存动态分配。 115. 在X86上x=y可不是一个原子操作。 116. 即时是就绪队列为空，唤醒的线程也不一定能马上执行，因为可能还有进程就在运行态。而对于抢占式调度方式，唤醒进程优先级比执行进程高，可以直接抢占。 117. 虚存的基础是局部性原理 118. 线程的粒度小于进程，通常多线程比多进程并发性更高 119. 在MS-DOS中采用的是显式链接文件结构。 120. 隐式链接分配，每个文件对应一个磁盘块的链表，磁盘块分布在磁盘的任何地方，除了最后一个盘块外，每一个盘块都有指向下一个盘块的指针，这些指针对用户是透明的。 121. 显式链接分配：是指把用于链接文件各物理块的指针，显式地存放在内存的一张链接表中。 该表在整个磁盘仅设置一张，每个表项中存放链接指针，即下一个盘块号。 122. yield（）暂时交出 cpu 控制权，从 running 状态转为 runnalbe 状态，但是仍有 可能被调度，sleep（）线程指定休眠一段时间。 123. 计算机开机后，操作系统最终被加载到RAM 124. 硬盘的存取访问时间分为三个部分： 寻道时间Ts，旋转延迟时间Tr和传送时间Tt。注意，没有定位时间！！！ 125. 死锁的四个条件那可是必要条件，不是充分条件，也就是说不满足一定不死锁，满足了也不一定死锁。 126. 时间片轮转法和高响应比优先调度算法对时间短的进程有利。 127. 指令一般由两部分组成。操作码：该指令完成操作的类型或性质；地址码：操作对象的地址。 128. 连续文件不利于文件的动态增长。 129. 进程的执行过程是从CPU开始，然后I/O，然后两个交替执行，最后在CPU区间停止。 130. 总线的主要技术指标有3个，其中的总线带宽是指单位时间内总线上传送的数据量，反映了总线数据传输速率。 131. 碎片整理的目的是优化次磁盘文件存储。 132. 每按键一次，或者鼠标点击一次，都产生一个中断，称为按键中断，执行中断响应程序， 133. 周转时间=等待时间+运行时间 134. 在存储管理中，采用覆盖与交换技术的目的是减少程序占用的主存空间，使用的方式是利用虚存在逻辑上扩充主存容量。 135. 临界资源是定义在共享资源上的，临界资源一定是共享资源。 而定义是，每次仅允许一个进程访问的资源。 属于临界资源的硬件有打印机、磁带机等，软件有消息缓冲队列、变量、数组、缓冲区等。诸进程间应采取互斥方式，实现对这种资源的共享。 136. UNIX中的文件系统采用的是索引文件结构，在索引节点中建立有13个地址项。 137. 在Window中，快速格式化只能对曾经格式化过的磁盘。 138. 在Linux系统中，硬链接不可以跨文件系统，链接文件的i节点与被链接文件的i节点相同。 139. 请求分页的时候，物理内存指的是实际的内存，而虚拟内存是指磁盘交换区，并不是真正的虚拟内存的意思。 对于页面置换算法而言，当发生缺页中断时，都是要从内存中找到一个不需要的块换出去（物理内存的释放），然后将需要的页面从磁盘的交换区中换进来（虚拟内存的分配）。 140. 当所分配的物理块数增大而页故障数不减反增,这就是Belady异常。 只有FIFO算法可能出现Belady 异常，而LRU和OPT算法永远不会出现Belady异常。 141. 进程之间存在直接制约关系（同步问题）和间接制约关系（互斥问题）；同步问题是存在逻辑关系的进程之间相互等待所产生的制约关系，互斥问题是存在逻辑关系的进程竞争使用资源所发生的制约关系。 142. 短作业优先调度，平均周转时间最短，等待时间最短 143. Dos是磁盘操作系统，就是人与机器之前的沟通的桥梁，并不具有线程管理的特性。 144. 计算机的资源只有硬件资源和软件资源的区别 145. 抖动的根本原因就是因为系统中运行的进程太多了，所以分配给每一个进程的物理块太少，不能满足进程正常运行的基本要求，致使每个进程在运行时，频繁的出现缺页，必须请求系统将所缺的页调度内存。 146. 程序是没有状态的，只有进程才有状态。 147. I/O通道控制方式是CPU干预最少的方式 148. PCB中并不存在程序的完整代码 149. 特权指令是只允许OS使用的，而不允许用户使用。系统调用这个时候就不是特权指令了。 150. 页式-内零头，段式-外零头 151. UNIX系统中，磁盘空闲空间管理所采用的方法是成组链接法！！！ 152. 当所读文件的数据不在内存时，产生中断（缺页中断），原进程进入阻塞状态，直到所需数据从外存调入内存后，才将进程唤醒。 153. read系统调用通过陷入（内中断）将CPU从用户态转到核心态，从而获取OS提供的服务。 154. 读一个文件，首先用Open系统调用打开文件。Open中的参数包括文件的路径名和文件名。但是read只需要使用Open返回的文件描述符，并不使用文件名作为参数。 155. Linux进程间通信：管道、信号、消息队列、共享内存、信号量、套接字(socket) Linux线程间通信：互斥量（mutex），信号量，条件变量 Windows进程间通信：管道、消息队列、共享内存、信号量 （semaphore） 、套接字(socket) Windows线程间通信：互斥量（mutex），信号量（semaphore）、临界区（critical section）、事件（event） 156. 并发性：指多个进程实体同存于内存中，且在一段时间内同时运行。并发性是进程的重要特征，同时也成为操作系统的重要特征。 动态性：进程的实质是进程实体的一次执行过程，因此，动态性是进程最基本的特征。 独立性：进程实体是一个独立运行、独立分配资源和独立接受调度的基本单位。 异步性：指进程按各自独立的、不可预知的速度向前推进，或者说实体按异步方式运行。 157. 单缓冲区总时间=(磁盘写入缓冲区时间+缓冲区读出时间)*磁盘块数+CPU处理最后一块数据的时间=(80+60)*10+40=1440us 158. 双缓冲总时间=磁盘写入缓冲区时间*磁盘块数+读出最后一块数据时间+CPU分析最后一块数据时间=80*10+60+40=900us 159. 访问局部性（locality of reference）满足进程要求时可以减少换页错误。 160. 虚拟存储器的目的就是为了扩充内存容量。 161. 多线程没有内存隔离，单个线程崩溃会导致整个应用程序的退出。 162. PCB只有OS可以修改 163. 页表的长度=2^n,n为页表长度 164. 进程的特点：动态性、并发性、独立性、异步性（即不确定性） 165. 系统调用：调用程序是运行在用户态，而被调用的程序是运行在系统态 166. 批处理系统不允许用户随时干涉自己程序的运行。 167. 磁带、磁盘都是顺序存取存储器 168.]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Operating System（磁盘管理&IO设备管理）]]></title>
    <url>%2F2018%2F01%2F09%2FOperating%20System%EF%BC%88%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86%26IO%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. 磁盘管理； 2. 设备管理 磁盘存储器管理磁盘结构 磁盘(Disk)是由表面涂有磁性物质的金属或塑料构成的圆形盘片，通过一个称为磁头的导体线圈从磁盘中存取数据。 磁盘的盘面上的数据存储在一组同心圆中，称为磁道。 磁道又划分为几百个扇区，每个扇区固定存储大小（通常为512B), 一个扇区称为一个盘块。 由于扇区按固定圆心角度划分，所以密度从最外最内道的最大记录密度。道向里道增加，磁盘的存储能力受限于 扇区就是磁盘可寻址的最小存储单位，磁盘地址 用&quot;柱面号 • 盘面号 • 扇区号（或块号）&quot;表示。 磁盘访问时间1. 寻道时间，把磁头移动到指定磁道上所经历的时间。该时间是启动磁臂的时间s与磁头移动n条磁道所花费的时间之和。 2. 旋转延迟时间，指定扇区移动到磁头下面所经历的时间 3. 传输时间，把数据从磁盘读出或者向磁盘写入数据所经历的时间。 注意：这个磁盘访问时间比重最大的就是寻道时间。 磁盘调度算法调度算法直接决定寻找时间，从而决定了总的存取时间。 先来先服务(First Come First Served, FCFS)算法 FCFS算法根据进程请求访问磁盘的先后顺序进行调度。 例如，磁盘请求队列中的请求顺序分别为55、58、39、18、90、160、150、38、184，磁头初始位置是100磁道，釆用FCFS算法磁头的运动过程如图所示。磁头共移动了 (45+3+19+21+72+70+10+112+146)=498 个磁道，平均寻找长度=498/9=55.3。 最短寻找时间优先(Shortest Seek Time First, SSTF)算法 SSTF算法选择调度处理的磁道是与当前磁头所在磁道距离最近的磁道，以使每次的寻找时间最短。当然，总是选择最小寻找时间并不能保证平均寻找时间最小，但是能提供比 FCFS算法更好的性能。这种算法会产生“饥饿”现象。 若某时刻磁头正在 18号磁道，而在18号磁道附近频繁地增加新的请求，那么SSTF算法使得磁头长时间在18 号磁道附近工作，将使184号磁道的访问被无限期地延迟，即被“饿死”。 例如，磁盘请求队列中的请求顺序分别为55、58、39、18、90、160、150、38、184，磁头初始位置是100磁道，釆用SSTF算法磁头的运动过程如图4-26所示。磁头共移动了 (10+32+3+16+1+20+132+10+24)=248 个磁道，平均寻找长度=248/9=27.5。 扫描(SCAN)算法（又称电梯算法） SCAN算法在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象，如图4-27所示。由于磁头移动规律与电梯运行相似，故又称为电梯调度算法。SCAN算法对最近扫描过的区域不公平，因此，它在访问局部性方面不如FCFS算法和 SSTF算法好。 例如，磁盘请求队列中的请求顺序分别为55、58、39、18、90、160、150、38、184，磁头初始位置是100 磁道。釆用SCAN算法时，不但要知道磁头的当前位置，还要知道磁头的移动方向，假设磁头沿磁道号增大的顺序移动，则磁头的运动过程如图4-27所示。磁头共移动了(50+10+24+94+32+3+16+1+20)=250 个磁道，平均寻找长度=250/9=27.8。 循环扫描(Circulair SCAN, C-SCAN)算法 在扫描算法的基础上规定磁头单向移动来提供服务，回返时直接快速移动至起始端而不服务任何请求。由于SCAN算法偏向于处理那些接近最里或最外的磁道的访问请求，所以使用改进型的C-SCAN算法来避免这个问题。 釆用SCAN算法和C-SCAN算法时磁头总是严格地遵循从盘面的一端到另一端，显然，在实际使用时还可以改进，即磁头移动只需要到达最远端的一个请求即可返回，不需要到达磁盘端点。这种形式的SCAN算法和C-SCAN算法称为LOOK和C-LOOK调度。这是因为它们在朝一个给定方向移动前会查看是否有请求。注意，若无特别说明，也可以默认SCAN 算法和C-SCAN算法为LOOK和C-LOOK调度。 四种调度算法的比较 外存组织方式外存的组织方式有连续、链接、索引。 感觉这个组织方式就这么三种，很多都是这三种！！！文件的是顺序、索引、索引顺序 连续组织方式文件的连续组织方式，为每个文件分配了一片连续的磁盘空间，由此所形成的文件物理结构也就是顺序式的文件结构。 链接组织方式为文件分配多个不连续的盘块，再通过每个盘块上的链接指针，将同属于一个文件的多个离散的盘块链接成一个链表。 隐式链接这个链接方式用的就是两个指针，但是只能用于顺序访问，随机访问的效率特别低！！！ 显式链接把文件物理块的指针显式的存放在内存的一张链接表中，这个表一个磁盘中只有一个。 分配给文件的所有盘块号都放在该表中，故把这个表叫做文件分配表（FAT--File Allocation Table） FAT和NTFSFAT中引入了卷的概念，一个物理磁盘分成四个逻辑磁盘，每个逻辑磁盘就是一个卷！！！每个卷都专门划出一个单独的区域来存放自己的目录和FAT。（FAT12，FAT16，FAT32） FAT一开始是用盘块为分配单位的，后来变成了簇。 簇是一组相邻的扇区，在FAT中它是作为一个虚拟扇区。在进行盘块分配时，是用簇来进行分配的。簇的大小一般是2n个盘块。 NTFS（New Technology File System），使用的是64位磁盘地址。 NTFS用簇来作为磁盘空间分配和回收的基本单位。一个文件占用若干个簇，一个簇只属于一个文件。NTFS具有与磁盘物理块无关的独立性。 NTFS以卷为单位进行文件存储，存储在MFT（Master File Table）主控文件表。 索引组织方式单级、多级、增量式 文件存储空间的管理不管是哪一种文件组织方式，都需要磁盘为文件分配盘块，所以必须要知道磁盘上哪些盘块是可用于分配的。故在文件分配磁盘的时候，除了FAT，还需要DAT，用于记录可供分配的存储空间的情况。 注意，存储空间的基本分配单位都是盘块，不是字节。 空闲表法和空闲链表法位示图法位示图是利用二进制的一位来表示磁盘中一个盘块的使用情况，0表示盘块空闲，1表示盘块已被分配。磁盘上所有的盘块都有一个二进制与之对应。这样，所有盘块的位构成的一个集合，称为位示图。 成组链接法提高IO速度的途径1. Disk Cache 高速缓存，说的是CPU和内存之间的小容量高速存储器 磁盘高速缓存，说的是内存中为磁盘盘块设置的一个缓冲区，在缓冲区保存了一些盘块的副本。 2. 提前读 3. 延迟写 4. 优化物理块布局 5. 虚拟盘 IO设备管理I/O管理概述（I/O控制方式、I/O软件层次结构）和I/O核心子系统（I/O调度概念、局速缓存与缓冲区、设备分配与回收、假脱机技术(SPOOLing)）。 I/O设备的层级结构 四个层次 1. 用户I/O软件，实现与用户交互的接口。产生I/O请求，格式化I/O，SPOOLing 2. 设备独立性软件，映射、保护、分块、缓冲、分配 3. 设备驱动程序，设置设备寄存器 4. 中断处理程序 5. 硬件，执行I/O操作 I/O系统中个模块层次视图OS p181 1. I/O系统的上下接口 （1）I/O系统接口，I/O系统和上层软件的接口。 * 块设备接口，数据的存取和传递都是以数据块为单位，磁盘和光盘。传输速率高，可寻址。磁盘设备的I/O基本就用DMA方式 * 流设备接口，数据的存取和传递都是以字符为单位，键盘、打印机。速率低，不可寻址。流设备I/O基本使用中断驱动方式。字符设备不可寻址，get和put只能使用顺序存取方式。 * 网络通信接口， （2）软件/硬件接口，这个接口上面是各种中断处理程序和设备驱动程序，下面就是各种设备的控制器。 2. I/O系统 （1）底层是中断处理程序，直接与硬件交互 （2）中间层是设备驱动程序，是进程和设备控制器的通信程序，把上层发来的抽象I/O请求转换成对I/O设备的具体命令和参数，并把它们装到设备控制器中的命令和参数寄存器中。 （3）设备独立性软件，I/O软件独立于具体的物理设备（有编号） I/O设备和设备控制器执行I/O操作的机械部分就是一般的I/O设备，执行控制I/O的电子部件则是设备控制器。 I/O设备1. 分类 2. 设备和设备控制器的接口 注意，设备本身也不会和CPU直接通信，而是设备去找设备控制器。 设备控制器 设备控制器的主要功能是控制一个或多个I/O设备，实现I/O设备和计算机的数据交换。 设备控制器是CPU和I/O设备的接口。 设备控制器既需要和CPU通信，还要和设备通信。组成： 1. 设备控制器和处理机的接口。三个信号线：数据线，地址线，控制线 2. 设备控制器和I/O设备的接口。 3. I/O逻辑。用于实现对设备的控制。 I/O通道虽然CPU和I/O设备之间已经有了设备控制器，但是CPU的负担还是很大，所以在CPU和设备控制器之间又加了I/O通道，简称通道。 其实就是把一些原来CPU处理的I/O任务转由I/O通道来执行。 在设置了通道后，CPU只需要向通道发送一条I/O指令。通道在收到该指令后，便从内存中取出本次要执行的通道程序，然后执行该通道程序，仅当通道完成了I/O任务后，才向CPU发出中断请求。 实际上，I/O通道就是一种特殊的处理机。它具有执行I/O指令的能力，并通过执行通道程序来控制I/O操作。 1. 通道指令类型单一，这是由于通道硬件比较简单，其所能执行的命令，主要局限于与I/O操作有关的指令。 2. 通道没有自己的内存，通道执行的通道程序是放在主机的内存中的，通道和CPU共享内存。 中断机构和中断处理程序中断是多道程序实现的基础，也是设备管理的基础。也是整个I/O系统的基础。 中断简介中断和陷入中断是指CPU对I/O设备发来的中断信号的一种响应。CPU暂停正在执行的程序，保留CPU环境后，自动地转去执行该I/O设备的中断处理程序，执行完成后，再回到断点，继续执行原来的程序。 由于中断是外部设备引起的，所以叫做外中断。 还有一种中断是由CPU内部事件所引起的中断，这类中断叫做内中断或者陷入。 中断和陷入的区别主要就是这个信号的原来，一个来自外部设备，一个来自CPU内部。 中断向量表和中断优先级通常为每种设备配备对应的中断处理程序，并把程序的入口地址放在中断向量表的一个表项中，并为每一个设备的请求中断规定一个中断号，直接连接中断表。 中断也是分优先级去执行中断处理程序的。 对多中断的处理1. 中断屏蔽：处理机执行一个中断处理程序的时候，屏蔽到所有的中断。 2. 嵌套中断：CPU优先响应优先级高的中断，高优先级中断可以抢断低优先级的中断。 中断处理程序1. 测定是否有未响应的中断信号。 2. 保护被中断进程的CPU环境。 3. 转入响应的设备处理程序。 4. 中断处理 5. 恢复CPU线程并退出中断 设备驱动程序概述设备驱动程序属于低级的系统进程，它和一般的应用程序以及系统程序有明显的差异： 1. 驱动程序是实现与设备无关软件和设备控制器之间通信和转换的程序，具体说，它将抽象的I/O请求转成了具体的I/O操作后传入了控制器。又把设备控制器中所记录的设备状态和I/O操作完成情况，及时的反映给请求I/O的进程。 2. 驱动程序与设备控制器以及I/O设备的硬件特性紧密相关。 3. 驱动程序与I/O设备使用的I/O控制方式有关。常用的I/O控制方式有中断驱动和DMA方式。 4. 驱动程序的一部分是用汇编语言写的。 5. 驱动程序可重入。也就是一个驱动程序在一次调用完成前可以被再次调用、 设备驱动程序的处理过程1. 将抽象要求转成具体指令 2. 对请求服务进行校验，这个请求是不是能够被执行。 3. 检查设备的状态 4. 传送必要的参数 5. 启动I/O设备 I/O设备控制方式程序直接控制方式 计算机从外部设备读取数据到存储器，每次读一个字的数据。对读入的每个字，CPU需要对外设状态进行循环检查，直到确定该字已经在I/O控制器的数据寄存器中。在程序直接控制方式中，由于CPU的高速性和I/O设备的低速性，致使CPU的绝大部分时间都处于等待I/O设备完成数据I/O的循环测试中，造成了 CPU资源的极大浪费。在该方式中，CPU之所以要不断地测试I/O设备的状态，就是因为在CPU中没有釆用中断机构，使I/O设备无法向CPU报告它已完成了一个字符的输入操作。 中断驱动方式 从I/O控制器的角度来看，I/O控制器从CPU接收一个读命令，然后从外围设备读数据。一旦数据读入到该I/O控制器的数据寄存器，便通过控制线给CPU发出一个中断信号，表示数据已准备好，然后等待CPU请求该数据。I/O控制器收到CPU发出的取数据请求后，将数据放到数据总线上，传到CPU的寄存器中。至此，本次I/O操作完成，I/O控制器又可幵始下一次I/O操作。 从CPU的角度来看，CPU发出读命令，然后保存当前运行程序的上下文（现场，包括程序计数器及处理机寄存器），转去执行其他程序。在每个指令周期的末尾，CPU检查中断。当有来自I/O控制器的中断时，CPU保存当前正在运行程序的上下文，转去执行中断处理程序处理该中断。这时，CPU从I/O控制器读一个字的数据传送到寄存器，并存入主存。接着， CPU恢复发出I/O命令的程序（或其他程序）的上下文，然后继续运行。 中断驱动方式比程序直接控制方式有效，但由于数据中的每个字在存储器与I/O控制器之间的传输都必须经过CPU,这就导致了中断驱动方式仍然会消耗较多的CPU时间。 因为中断驱动I/O比程序I/O方式更有效。但它仍是以字节为单位进行I/O的。每当完成一个字节的I/O时，控制器便要向CPU请求一次中断。 DMA方式(直接内存存取，Direct Memory Access) 在中断驱动方式中，I/O设备与内存之间的数据交换必须要经过CPU中的寄存器，所以速度还是受限，而DMA（直接存储器存取）方式的基本思想是在I/O设备和内存之间开辟直接的数据交换通路，彻底“解放” CPU。DMA方式的特点是： * 基本单位是数据块。 * 所传送的数据，是从设备直接送入内存的，或者相反。 * 仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在DMA控制器的控制下完成的。 DMA控制器 CPU读写数据时，它给I/O控制器发出一条命令，启动DMA控制器，然后继续其他工作。之后CPU就把控制操作委托给DMA控制器，由该控制器负责处理。DMA控制器直接与存储器交互，传送整个数据块，每次传送一个字，这个过程不需要CPU参与。当传送完成后，DMA控制器发送一个中断信号给处理器。因此只有在传送开始和结束时才需要CPU的参与。 DMA控制方式与中断驱动方式的主要区别是中断驱动方式在每个数据需要传输时中断CPU，而DMA控制方式则是在所要求传送的一批数据全部传送结束时才中断CPU；此外，中断驱动方式数据传送是在中断处理时由CPU控制完成的，而DMA控制方式则是在DMA 控制器的控制下完成的。 I/O通道控制方式DMA是把由字节单位的干预减少到了以数据块为单位的干预。 I/O通道控制方式是把一个数据块的干预减少到了一组数据块的干预。 通道是通过执行通道程序并与设备控制器共同实现对I/O设备的控制的。通道程序是由一系列通道指令所构成的。 与设备无关的I/O软件与I/O设备无关的软件是I/O系统的最高层软件。 用户层I/O软件SPOOLing技术(假脱机技术) 为了缓和CPU的高速性与I/O设备低速性之间的矛盾而引入了脱机输入/输出技术。该技术是利用专门的外围控制机，将低速I/O设备上的数据传送到高速磁盘上；或者相反。 SPOOLing的意思是外部设备同时联机操作，又称为假脱机输入/输出操作，是操作系统中釆用的一项将独占设备改造成共享设备的技术。 SPOOLing系统的主要特点有：提高了 I/O的速度；将独占设备改造为共享设备；实现 了虚拟设备功能。 缓冲区管理]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Operating System（存储器管理&文件管理）]]></title>
    <url>%2F2018%2F01%2F08%2FOperating%20System%EF%BC%88%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86%26%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. 存储器管理； 2. 虚存； 3. 文件管理 存储器管理存储管理包括内存管理和虚拟内存管理 内存管理包括，内存管理的概念，交换与覆盖，连续（单一、固定、动态）/非连续分配管理方式（分页、分段、段页） 虚拟内存管理包括，虚拟内存的概念，请求分页管理方式、页面置换算法、页面分配策略、工作集、抖动 存储层次 CPU寄存器 主存 ----&gt; 高速缓存，主存储器，磁盘缓存 辅存 ----&gt; 固定磁盘，可移动存储截至 寄存器和主存被称为可执行存储器 注意：由于磁盘I/O的速度远远低于主存的访问速度，为了缓和两者之间在速度上的不匹配，才有了磁盘缓存，用来暂存频繁使用的一部分磁盘数据和信息，以减少访问磁盘的次数。但是这个东西和高速缓存还不一样，它本身不是一个实际存在的存储器，只是把主存中的部分存储空间画出来暂时存放从磁盘读过来的数据。 概念操作系统对内存的划分和动态分配，就是内存管理的概念。 内存管理的功能 1. 内存空间的分配与回收：由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率。 2. 地址转换：在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址。 3. 内存空间的扩充：利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存。 4. 存储保护：保证各道作业在各自的存储空间内运行，互不干扰。 程序的链接和装入 编译：由编译程序将用户源代码编译成若干个目标模块。 链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块。 装入：由装入程序将装入模块装入内存运行。 程序链接程序链接是为了把目标模块和所需的库函数装配成一个装入模块。 有三种链接方式： 1. 静态链接 2. 装入时动态链接 3. 运行时动态链接 程序装入1. 绝对装入，装入模块装入到内存中事先指定的位置。 2. 静态重定位装入，把装入模块程序中的指令和数据地址进行修改，这个过程就叫做重定向。又因为这个过程是在装入时一次性完成的，以后不会再改变，又叫做静态重定向。 同时，因为是一次性装入的，一旦内存中没有这么大的空间，就不能装入了。也就是说一旦内存允许，装入模块可以装入任何允许位置，但是不允许程序在运行时在内存中有位置移动。 实际物理地址=逻辑地址+程序在内存的起始地址 3. 动态重定位装入。装入程序把装入模块装入内存时，并不会进行地址转换，而是把这个转换推迟到了程序真正要执行的时候。因此，装入内存后的所有地址均为相对地址。这种方式需要一个重定位寄存器的支持。 实际物理地址=逻辑地址+重定向寄存器地址 注意：之所以会重定位，就是因为在多道程序中，编译程序不可能知道装入地址。这样装入模块的逻辑地址和实际装入的逻辑地址肯定不同，也就需要地址重定位。 内存连续分配存储器管理单一连续分配内存在此方式下分为系统区和用户区，系统区仅提供给操作系统使用，通常在低地址部分；用户区是为用户提供的、除系统区之外的内 存空间。这种方式无需进行内存保护。 固定分区分配1. 分区大小相等：用于利用一台计算机去控制多个相同对象的场合，缺乏灵活性。 2. 分区大小不等：划分为含有多个较小的分区、适量的中等分区及少量的大分区。 这种分区方式存在两个问题：一是程序可能太大而放不进任何一个分区中，这时用户不得不使用覆盖技术来使用内存空间； 二是主存利用率低，当程序小于固定分区大小时，也占用了一个完整的内存分区空间，这样分区内部有空间浪费，这种现象称 为内部碎片。 动态分区分配 数据结构:空闲分区表，空闲分区链 系统有64MB内存空间，其中低8MB固定分配给操作系统，其余为用户可用内存。开始时装入前三个进程，在它们分别分配到所需空间后，内存只剩下4MB，进程4无法装入。在某个时刻，内存中没有一个就绪进程，CPU出现空闲，操作系统就换出进程2，换入进程4。由于进程4比进程2小，这样在主存中就产生了一个6MB的内存块。之后CPU又出现空闲，而主存无法容纳进程2,操作系统就换出进程1，换入进程2。 动态分区在开始分配时是很好的，但是之后会导致内存中出现许多小的内存块。随着时间的推移，内存中会产生越来越多的碎片（图3-6中最后的4MB和中间的6MB，且随着进程的换入/换出，很可能会出现更多更小的内存块)，内存的利用率随之下降。 这些小的内存块称为外部碎片，指在所有分区外的存储空间会变成越来越多的碎片，这与固定分区中的内部碎片正好相对。 克服外部碎片可以通过紧凑（Compaction)技术来解决，就是操作系统不时地对进程进行移动和整理。但是这需要动态重定位寄存器的支持，且相对费时。紧凑的过程实际上类似于Windows系统中的磁盘整理程序，只不过后者是对外存空间的紧凑。但是其实这就是动态可重定向分区。 动态可重定位分配其实也就是把动态分区产生的外部碎片通过紧凑的方式进行处理。但是要注意，每一次的紧凑带来的也是用户程序在内存中位置的改变。 所以每次紧凑后，需要对移动了的程序进行重定位。 连续分配存储器管理算法1. 首次适应算法（FF），闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。（这个最好） 2. 最佳适应算法（BF），空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。 3. 最坏适应算法（Worst Fit）：又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。 4. 邻近适应算法（Next Fit）：又称循环首次适应算法，由首次适应算法演变而成。不同之处是分配内存时从上次查找结束的位置开始继续查找。 5. 快速适应算法 6. 伙伴系统 7. 哈希算法 内存离散分配存储器管理内存连续分配会会形成很多的碎片，就算是有&quot;紧凑的方式&quot;，但是开销特别大，为了把一个进程直接分散的装入许多不连续的分区中， 有了离散分配。 离散分配允许一个程序分散地装入到不相邻的内存分区中，根据分区的大小是否固定（分配地址的基本单位不同）分为分页存储管理方 式和分段存储管理方式。 基本分页存储管理 分页存储管理方式中，又根据运行作业时是否要把作业的所有页面都装入内存才能运行分为基本分页存储管理方式和请求分页存储管理方式。 在内存连续分配中，固定分区会产生内部碎片，动态分区会产生外部碎片。 分页：把用户程序分成若干固定大小的区域，称为&quot;页&quot;或&quot;页面&quot;，相应的把内存空间也分为若干个物理块或页框。页和块大小相同。 分页存储的基本概念 1)页面和页面大小。 进程中的块称为页(Page)，内存中的块称为页框（Page Frame，或页帧）。外存也以同样的单位进行划分，直接称为块(Block)。进程在执行时需要申请主存空间，就是要为每个页面分配主存中的可用页框，这就产生了页和页框的一一对应。 为方便地址转换，页面大小应是2的整数幂。 2)地址结构 页号+页内位移量（页内地址） 若一个逻辑地址空间中的地址是A，页面大小是L，页号是P，页内地址是d，则P=A/L,d=A%L。 3)页表。为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般存放在内存中。 在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射。 基本地址变换机构 在系统中通常设置一个页表寄存器(PTR)，存放页表在内存的始址F和页表长度M。进程未执行时，页表的始址和长度存放在进程控制块 中，当进程执行时，才将页表始址和长度存入页表寄存器。设页面大小为L，逻辑地址A到物理地址E的变换过程如下： 1. 计算页号P(P=A/L)和页内偏移量W (W=A%L)。 2. 比较页号P和页表长度M，若P &gt;= M，则产生越界中断，否则继续执行。 3. 页表中页号P对应的页表项地址 = 页表起始地址F + 页号P * 页表项长度，取出该页表项内容b，即为物理块号。 4. 计算E=b*L+W，用得到的物理地址E去访问内存。 以上整个地址变换过程均是由硬件自动完成的。 若页面大小L为1K字节，页号2对应的物理块为b=8，计算逻辑地址A=2500 的物理地址E的过程如下：P=2500/1K=2，W=2500%1K=452，查找得到页号2对应的物理块的块号为 8，E=8*1024+452=8644。 下面讨论分页管理方式存在的两个主要问题： 1. 每次访存操作都需要进行逻辑地址到物理地址的转换，地址转换过程必须足够快，否则访存速度会降低； 2. 每个进程引入了页表，用于存储映射机制，页表不能太大，否则内存利用率会降低。 具有快表的地址变换机构 页表是在内存中的，CPU每次存取一个数据，都要访问两次内存。第一次是得到物理地址，第二次是从第一次得到的地址三种得到数据。 为此，在地址变换机构中增设了一个具有并行查找能力的高速缓冲存储器——快表，又称联想寄存器(TLB)，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，主存中的页表也常称为慢表。 1. CPU给出逻辑地址后，由硬件进行地址转换并将页号送入高速缓存寄存器，并将此页号与快表中的所有页号进行比较。 2. 如果找到匹配的页号，说明所要访问的页表项在快表中，则直接从中取出该页对应的页框号，与页内偏移量拼接形成物理地址。 这样，存取数据仅一次访存便可实现。 3. 如果没有找到，则需要访问主存中的页表，在读出页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满， 则必须按照一定的算法对旧的页表项进行替换。 二级页表基本分段存储管理分页管理方式是从计算机的角度考虑设计的，以提高内存的利用率，提升计算机的性能, 且分页通过硬件机制实现，对用户完全透明；而分段管理方式的提出则是考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。 分段存储的基本概念 段式管理方式按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这 个用户进程划分为5个段，每段从0 开始编址，并分配一段连续的地址空间（段内要求连续，段间不要求连续，因此整个作业的地 址空间是二维的）。其逻辑地址由段号S与段内偏移量W两部分组成。 在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的（不可见），但在段式系统中，段号和段内偏移量必须由用户显示提供， 在髙级程序设计语言中，这个工作由编译程序完成。 段表 每个进程都有一张逻辑空间与内存空间映射的段表，其中每一个段表项对应进程的一个段，段表项记录该段在内存中的起始地址 和段的长度。 地址变换机构 1. 从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W。 2. 比较段号S和段表长度M，若S多M，则产生越界中断，否则继续执行。 3. 段表中段号S对应的段表项地址 = 段表起始地址F + 段号S * 段表项长度，取出该段表项的前几位得到段长C。若段内偏移量&gt;=C， 则产生越界中断，否则继续执行。 4. 取出段表项中该段的起始地址b，计算 E = b + W，用得到的物理地址E去访问内存。 段页式管理方式页式存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享。 在段页式系统中，作业的地址空间首先被分成若干个逻辑段，每段都有自己的段号，然后再将每一段分成若干个大小固定的页。 系统为每个进程建立一张段表，而每个分段有一张页表。 注意：在一个进程中，段表只有一个，而页表可能有多个。 段页式系统中，为了获得一条指令或数据，需要访问三次内存。第一次，访问段表，得到页表始址；第二次，访问页表，得到物理地址；第三次，利用物理地址拿到数据。 分页和分段的区别1. 页是信息的物理单位，分页是为了消除内存的碎片，提高内存利用率。同时分页只是系统管理的行为，对用户不可见。而分段中的段是信息的逻辑单位，而且分段也只是为了方便用户。 2. 页的大小固定而且只和系统有关，每个系统中只能有一种大小的页面。而段的长度不固定，决定于用户的程序。 3. 分页的用户程序地址是一维的，而分段的用户程序地址是二维的。 虚存基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序执行过程中， 当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内 容换出到外存上，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器， 称为虚拟存储器。 之所以将其称为虚拟存储器，是因为这种存储器实际上并不存在，只是由于系统提供了部分装入、请求调入和置换功能后（对用户完全 透明），给用户的感觉是好像存在一个比实际物理内存大得多的存储器。虚拟存储器的大小由计算机的地址结构决定，并非是内存和外 存的简单相加。 虚拟内存的大小=min(内存+外存，2^n),其中n为计算机的位数。 在传统存储器管理方式中，一次性和驻留性 虚拟存储器管理方式中，多次性，对换性，虚拟性。 多次性和对换性是基础。多次性最重要。多次性和对换性又建立在离散分配的基础上。 注意：虚拟存储器的实现都是建立在离散分配存储管理方式的基础上的。 请求分页存储管理方式分页请求系统是在分页系统的基础上增加了请求调页功能和页面置换功能。 硬件支持请求页表机制、缺页中断、地址变换机构 请求页表 状态位P，用于指示该页是否已经调入内存，供程序访问时参考。 访问字段A，用于记录本页一段时间内被访问的次数，或记录本页最近已有多长时间未被访问，供置换算法换出页面时参考。 修改位M，标识该页在调入内存后是否被修改过 外存地址，用于指出该页在外存上的地址，通常是物理块号，供调入该页时参考。 缺页中断 请求分页系统中，每当所要访问的页面不再内存中时，便产生一缺页中断，请求OS将所缺的页调入内存。 在指令执行期间产生和处理中断信号，而非一条指令执行完后，属于内部中断。 一条指令在执行期间，可能产生多次缺页中断。 地址变换机构 请求分页中的内存分配最小物理块数和进程需要的最少物理块 最小物理块，是指保证进程正常运行所需的最小物理块数。 进程需要的最少物理块，与计算机的硬件结构有关，取决于指令的格式、功能和寻址方式。 内存分配策略： 请求分页中可采取两种内存分配策略，固定和可变分配策略。在进行页面置换时，也可采用两种策略，全局和局部置换。 1. 固定分配局部置换 它为每个进程分配一定数目的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。实现这种策略难以确定为每个进程应分配的物理块数目：太少会频繁出现缺页中断，太多又会使CPU和其他资源利用率下降。 2. 可变分配全局置换 这是最易于实现的物理块分配和置换策略，为系统中的每个进程分配一定数目的物理块,操作系统自身也保持一个空闲物理块队列。当某进程发生缺页时，系统从空闲物理块队列中取出一个物理块分配给该进程，并将欲调入的页装入其中。 3. 可变分配局部置换 它为每个进程分配一定数目的物理块，当某进程发生缺页时，只允许从该进程在内存的页面中选出一页换出，这样就不会影响其他进程的运行。如果进程在运行中频繁地缺页，系统再为该进程分配若干物理块，直至该进程缺页率趋于适当程度； 反之，若进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。 物理块分配算法： 1. 平均分配算法 2. 按比例分配算法 3. 考虑优先权的分配算法 页面调入策略1. 何时调入页面 （1）预调页策略 （2）请求调页策略 2. 从何处调入页面 请求分页系统中的外存分为两部分，存放文件的文件区和存放对换页面的对换区。对换区使用的是连续分配方式， 文件区采用的离散分配的方式。 从何处调入页面和对换区的空间大小有关，足够时，都从对换区调入。不够时，没有修改的文件直接从文件区调入。 （1）系统拥有足够的对换区空间：可以全部从对换区调入所需页面，以提髙调页速度。为此，在进程运行前，需将与该进程有关的文件从文件区复制到对换区。 （2）系统缺少足够的对换区空间：凡不会被修改的文件都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出。但对于那些可能被修改的部分，在将它们换出时须调到对换区，以后需要时再从对换区调入。 （3）UNIX方式：与进程有关的文件都放在文件区，故未运行过的页面，都应从文件区调入。曾经运行过但又被换出的页面，由于是被放在对换区，因此下次调入时应从对换区调入。进程请求的共享页面若被其他进程调入内存，则无需再从对换区调入。 3. 页面调入过程 每当程序所要访问的页面不再内存中时，便向CPU发出缺页中断，中断处理程序首先保存CPU环境，分析中断原因后转入缺页 中断处理程序。该程序通过查找页表得到该表在外存的物理块后，如果此时内存时可以容纳新页，则启动I/O，将所缺少的页 调入内存，修改页表。如果内存已经满了，就按照某个置换算法，从内存中选出一页准备换出，如果该页没有被修改过就不如 写回磁盘，如果修改过，则必须把这也写入磁盘，然后把缺页调入内存，并修改页表和快表。 4. 缺页率 f=F/A;(F是访问页面失败的次数，A是总的页面访问次数) 页面置换算法(五种)当所分配的物理块数增大而页故障数不减反增,这就是Belady异常。 只有FIFO算法可能出现Belady 异常，而LRU和OPT算法永远不会出现Belady异常。 1. 最佳置换算法(OPT) 最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证 获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。 2. 先进先出(FIFO)页面置换算法 优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面。该算法实现简单，只需把调入内存的页面根据先后次序链接成队列， 设置一个指针总指向最早的页面。 3. 最近最久未使用(LRU)置换算法 选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。 该算法为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。 LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类的算法。理论上可以证明，堆栈类算法不可能出现Belady异常。 FIFO算法基于队列实现，不是堆栈类算法。 4. 时钟(CLOCK)置换算法 LRU算法的改进 5. 页面缓冲算法（PBA） 页面抖动在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种频繁的页面调度行为称为抖动，或颠簸。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。 频繁的发生缺页中断（抖动），其主要原因是某个进程频繁访问的页面数目高于可用的物理页帧数目。虚拟内存技术可以在内存中保留更多的进程以提髙系统效率。在稳定状态，几乎主存的所有空间都被进程块占据，处理机和操作系统可以直接访问到尽可能多的进程。但如果管理不当，处理机的大部分时间都将用于交换块，即请求调入页面的操作，而不是执行进程的指令，这就会大大降低系统效率。 工作集工作集（或驻留集）是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。 请求分段存储管理方式分页分段管理 文件管理1. 文件系统基础：包括文件概念、文件的逻辑结构（顺序文件，索引文件，索引顺序文件）、目录结构（文件控制块和索引结点，单级目录结构和两级目录结构，树形目录结构，图形目录结构）、文件共享和文件保护（访问类型，访问控制）。 2. 文件系统实现：包括文件系统层次结构、目录实现、文件实现。 3. 磁盘组织与管理：包括磁盘的结构、磁盘调度算法、磁盘的管理。 文件概念在系统运行时，计算机以进程为基本单位进行资源的调度和分配；而在用户进行的输入、输出中，则以文件为基本单位。 文件是由记录组成的，而记录是一组有意义的数据项的集合。 1. 数据项 数据项是文件系统中最低级的数据组织形式，可分为以下两种类型: * 基本数据项：用于描述一个对象的某种属性的一个值，如姓名、日期或证件号等，是数据中可命名的最小逻辑数据单位，即原子数据。 * 组合数据项：由多个基本数据项组成。 2. 记录 记录是一组相关的数据项的集合，用于描述一个对象在某方面的属性，如一个考生报名记录包括考生姓名、出生日期、报考学校代号、身份证号等一系列域。 3. 文件 文件是指由创建者所定义的一组相关信息的集合，逻辑上可分为有结构文件和无结构文件两种。 在有结构文件中，文件由一组相似记录组成，如报考某学校的所有考生的报考信息记录，又称记录式文件；而无结构文件则被看成是一个字符流，比如一个二进制文件或字符文件，又称流式文件。 在操作系统中将程序和数据组织成文件。文件可以是数字、字母或二进制代码，基本访问单元可以是字节、 行或记录。文件可以长期存储于硬盘或其他二级存储器中,允许可控制的进程间共享访问，能够被组织成复杂的结构。 文件属性&amp;文件类型文件属性包括： ①名称：文件名称唯一，以容易读取的形式保存。 ②标识符：标识文件系统内文件的唯一标签,通常为数字，它是对人不可读的一种内部名称。 ③类型：被支持不同类型的文件系统所使用。 ④位置：指向设备和设备上文件的指针。 ⑤大小：文件当前大小（用字节、字或块表示），也可包含文件允许的最大值。 ⑥保护：对文件进行保护的访问控制信息。 ⑦时间、日期和用户标识：文件创建、上次修改和上次访问的相关信息，用于保护、 安全和跟踪文件的使用。 所有文件的信息都保存在目录结构中，而目录结构也保存在外存上。 文件的类型： ①用途分类：系统文件、用户文件、库文件 ②文件中数据的形式：源文件、目标文件、可执行文件 ③存取控制属性：只执行文件、只读文件、读写文件 ④组织形式和处理方式：普通文件、目录文件、特殊文件（特制系统中的I/O设备） 文件系统的层次文件系统的模型可以分为三个层次：最底层是对象及其属性，中间层是对对象进行操纵和管理的软件集合，最高层是文件系统提供给用户的接口。 1. 对象及其属性 （1）文件 （2）目录 （3）磁盘存储空间 2. 对对象操纵和管理的软件集合 （1）I/O控制层，文件系统的最底层，主要由磁盘驱动程序等组成，也可以说是设备驱动程序层。 （2）基本文件系统层，主要用于处理内存与磁盘之间数据块的交换。 （3）基本I/O管理程序，用于完成与磁盘I/O有关的事务。 （4）逻辑文件系统，用于处理记录和文件相关的操作。 3. 文件系统的接口 （1）命令接口 （2）程序接口 文件逻辑结构用户看到的文件都是逻辑文件，它是由一系列的逻辑记录组成的。 文件的结构可以分为：文件的逻辑结构和文件的物理结构 逻辑结构从是否有结构分为记录式文件和流式文件（字节单位）。 文件的组织方式又可以把文件分为顺序、索引、索引顺序文件。 顺序文件1. 顺序文件的排列方式 （1）串结构，和关键字无关。 （2）顺序结构，由用户指定一个关键字。 2. 寻址方式 （1）隐式寻址，定长、不定长记录都可以寻址 （2）显式寻址，不定长记录不可以寻址（文件中记录的位置），但是使用关键字可以寻址。 索引文件 按照关键字建立索引 索引顺序文件 文件目录文件目录也是一种数据结构，用于标识系统文件中的文件及其物理地址，供索引时使用。 目录管理通过树形结构来解决和实现。 文件控制块和索引结点1. FCB 文件控制块(FCB)是用来存放控制文件需要的各种信息的数据结构，以实现“按名存取”。FCB的有序集合称为文件目录，一个FCB就是一个文件目录项。为了创建一个新文件，系统将分配一个FCB并存放在文件目录中，成为目录项。 2. 索引结点 每个文件有唯一的一个磁盘索引结点 目录结构单级目录结构 二级目录结构 多级目录结构（树型） 文件共享1. 基于有向无循环图实现文件共享 2. 利用符号链接实现文件共享 文件保护1. 访问权 2. 保护域]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试（HashMap&TreeMap&红黑二叉树）]]></title>
    <url>%2F2017%2F12%2F28%2FJava%E9%9D%A2%E8%AF%95%EF%BC%88HashMap%26TreeMap%26%E7%BA%A2%E9%BB%91%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节纯分析源码，不说区别。区别之前已经复习过了，记忆的东西 JDK1.8中的HashMap我们知道在JDK1.8之前，我们的HashMap是一个数组（table[]）+链表的存储形式，数组和链表都放的是K-V对象，利用K的hashCode 方法（Object方法）得到的hash值后，将hash值高低16位异或运算后的int值，最后在put/get方法时候，是利用这个int值和table[]的长度-1进行与运算得到对象在table[]插入或者查找的角标，一旦两个对象的hash值相同，也就是说定位在table[]中的角标是一样的，那么从这个角标开始遍历，也就是就调用equals方法（这也 是Object的方法(不改写的话就和==一样，比较的是两个对象的物理地址），如果不同，就在对应的角标项后开始链，一旦和数组连接 链中的某个一致，直接就覆盖Value。 在JDK1.7中我们使用的是Entry&lt;K,V&gt;类来存储数据，Entry&lt;K,V&gt;实现了Map.Entry&lt;K,V&gt;。 这个Map.Entry&lt;K,V&gt;，也就是Entry&lt;K,V&gt;是Map的一个内部接口--&gt;Map$Entry.class。 但是在JDK1.8中，HashMap不再是简单的table[]+链表，而是在这个基础上同时引入了红黑树的概念，当桶（bucket）中链表的长度大于 等于8时，链表转成红黑树，红黑树的长度小于等于6时，又将红黑树转成链表！！ 同时，在JDK1.8中也开始使用Node&lt;K,V&gt;来存储数据。但是要注意，这个Node&lt;K,V&gt;实现了Map.Entry接口的。 table[]也存放的是Node&lt;K,V&gt; : transient Node&lt;K,V&gt;[] table; 我们在遍历Map的时候，想要拿到所有的键值对对象，map.entrySet();返回的是一个Set&lt;Map.Entry&lt;K,V&gt;&gt;，对应过来直接就是 Set&lt;Entry&lt;Integer,String&gt;&gt;。在HashMap内部是有一个EntrySet类，final的，同时继承自AbstractSet。 内部成员 之前也说了就是Node&lt;K,V&gt; table[]+链表+红黑树。 看一下HashMap中的成员 1. transient Node&lt;K,V&gt; table; //用来存放数据的hashMap表 2. transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; //HashMap将数据转成Set的另一种存储形式，这个变量主要用于迭代功能。 3. transient int size; //HashMap中的table[]实际有的Node&lt;K,V&gt;个数，注意这个不是表的长度，而且这个数字有可能会大于表的长度，因为表可以链(有点问题) 4. transient int modCount; //HashMap的数据被修改的次数，这个变量就是用于迭代过程中的Fail-Fast机制，存在的意义也就是这个，当操作前备份的count和当前的modCount不相等的时候，就直接抛出ConcurrentModifiedException并停止操作 5. int threshold;//HashMap的扩容阈值，当HashMap中存储的Node&lt;K,V&gt;个数超过这个数量时，自动扩容为原来的两倍。 6. final float loadFactor;//HashMap的负载因子，当表新建或者扩容后，计算一次新的阈值，threshold = loadFactor * table.length。 7. static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; //table[]的长度，默认是16，必须是2的次幂 8. static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//表的最大容量 9. static final float DEFAULT_LOAD_FACTOR = 0.75f;//默认的负载因子。 10. static final int TREEIFY_THRESHOLD = 8;//put一个元素的时候，当这个Node&lt;K,V&gt;对应表中的结点长度达到8的时候将这个链表转成一个红黑树 11. static final int UNTREEIFY_THRESHOLD = 6;//链表长度小于6时，解散红黑树 12. static final int MIN_TREEIFY_CAPACITY = 64;//默认的最小的扩容量64，为避免重新扩容冲突，至少为4 * TREEIFY_THRESHOLD=32，即默认初始容量的2倍 13. 注意，一旦我们的map初始容量小于16，而且不是2的次幂，那么table[]的长度是大于这个容量的最小2的次幂，2，4，8。 Node 123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; table[]中定位Node对于HashMap而言，我们不管是增加、删除、还是查找键值对，定位到table[]的位置的都是很关键的第一步。 在JDK1.8中我们是这么做的： 1. 在hash()方法中利用K的hashCode方法得到K的hash值，然后K的hash值高位参与运算（高16位异或低16位），用这个 数字作为K最终的hash值。 2. 在put、get等方法中，利用前面得到的hash值&amp;(table.length-1)来得到这个Node&lt;K,V&gt;在数组中的位置！！ 12345678static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;put方法中： if ((p = tab[i = (n - 1) &amp; hash]) == null)//此处通过（n - 1） &amp; hash 计算出的值作为tab的下标i，并另p表示tab[i]，也就是该链表第一个节点的位置。并判断p是否为null。 注意：我们在进行hash&amp;(table.length-1)来得到Node&lt;K,V&gt;在table[]中的位置时，非常厉害，因为table[]的长度总是2的次幂， 所以hash&amp;(table.length-1)运算等价于对length取模，也就是hash%length，但是&amp;远比%效率更高。 put(K,V) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evic)&#123; //这里onlyIfAbsent表示只有在该key对应原来的value为null的时候才插入，也就是说如果value之前存在了， //就不会被新put的元素覆盖。 //evict参数用于LinkedHashMap中的尾部操作，这里没有实际意义。 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //定义变量tab是将要操作的Node数组引用，p表示tab上的某Node节点，n为tab的长度，i为tab的下标。 if ((tab = table) == null || (n = tab.length) == 0)&#123; //判断当table为null或者tab的长度为0时，即table尚未初始化，此时通过resize()方法得到初始化的table。 //这种情况是可能发生的，HashMap的注释中提到：The table, initialized on first use, and //resized as necessary。 n = (tab = resize()).length; &#125; if ((p = tab[i = (n - 1) &amp; hash]) == null)&#123; //此处通过（n - 1） &amp; hash 计算出的值作为tab的下标i，并另p表示tab[i]，也就是该链表第一个节点的位置。 //并判断p是否为null。 tab[i] = newNode(hash, key, value, null); //这是Node类的构造方法，只有这一个！！！ //当p为null时，表明tab[i]上没有任何元素，那么接下来就new第一个Node节点，调用newNode方法返回新节点赋值给tab[i]。 &#125;else &#123; //下面进入p不为null的情况，有三种情况：p为链表节点；p为红黑树节点；p是链表节点但长度为临界长度 //TREEIFY_THRESHOLD，再插入任何元素就要变成红黑树了。 Node&lt;K,V&gt; e; K k; //定义e引用即将插入的Node节点，并且下文可以看出 k = p.key。 if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))&#123; //HashMap中判断key相同的条件是key的hash相同，并且符合equals方法。这里判断了p.key是否和插入的key相 //等，如果相等，则将p的引用赋给e。也就是插入的e一旦和已经在结点头的p的hash值一样，同时e的k==插入的k //（这就相当于是Object的equals方法） //这一步的判断其实是属于一种特殊情况，即HashMap中table[]的首结点已经存在了key，于是插入操作就不需要 //了，只要把原来的value覆盖就可以了。 e = p; //这里为什么要把p赋值给e，而不是直接覆盖原值呢？答案很简单，现在我们只判断了第一个节点，后面还可能出现 //key相同，所以需要在最后一并处理. &#125;else if (p instanceof TreeNode)&#123; //现在开始了第一种情况，p是红黑树节点，那么肯定插入后仍然是红黑树节点，所以我们直接强制转型p后调用 //TreeNode.putTreeVal方法，返回的引用赋给e。 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //你可能好奇，这里怎么不遍历tree看看有没有key相同的节点呢？其实，putTreeVal内部进行了遍历，存在相同 //hash时返回被覆盖的TreeNode，否则返回null。 &#125;else&#123; //接下里就是p为链表节点的情形，也就是上述说的另外两类情况：插入后还是链表/插入后转红黑树。另外，上行转型 //代码也说明了TreeNode是Node的一个子类。 for (int binCount = 0; ; ++binCount)&#123; //我们需要一个计数器来计算当前链表的元素个数，并遍历链表，binCount就是这个计数器。 if ((e = p.next) == null)&#123; //遍历过程中当发现p.next为null时，说明链表到头了，直接在p的后面插入新的链表节点，即把新节点的引用赋给 //p.next，插入操作就完成了。注意此时e赋给p。 p.next = newNode(hash, key, value, null); //最后一个参数为新节点的next，这里传入null，保证了新节点继续为该链表的末端。 if (binCount &gt;= TREEIFY_THRESHOLD - 1)&#123;// -1 for 1st //插入成功后，要判断是否需要转换为红黑树，因为插入后链表长度加1，而binCount并不包含新节点，所以判断时要 //将临界阈值减1。 treeifyBin(tab, hash); //当新长度满足转换条件时，调用treeifyBin方法，将该链表转换为红黑树。 &#125; break; &#125; //当然如果不满足转换条件，那么插入数据后结构也无需变动，所有插入操作也到此结束了，break退出即可。 if (e.hash == hash &amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equ(k))))&#123; //在遍历链表的过程中，我之前提到了，有可能遍历到与插入的key相同的节点，此时只要将这个节点引用赋值给e， //最后通过e去把新的value覆盖掉就可以了。 //老样子判断当前遍历的节点的key是否相同。 break; //找到了相同key的节点，那么插入操作也不需要了，直接break退出循环进行最后的value覆盖操作。 &#125; p = e; // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表 //在第21行我提到过，e是当前遍历的节点p的下一个节点，p = e 就是依次遍历链表的核心语句。每次循环时p都是下一个node节点。 &#125; &#125; if (e != null) &#123; // 表示在桶中找到key值、hash值与插入元素相等的结点 V oldValue = e.value; //定义oldValue，即原存在的节点e的value值。记录e的value（e表示的是原来的，所以得到旧值） if (!onlyIfAbsent || oldValue == null) //前面提到，onlyIfAbsent表示存在key相同时不做覆盖处理，这里作为判断条件，可以看出当onlyIfAbsent为false或者oldValue为null时，进行覆盖操作。 e.value = value; //覆盖操作，将原节点e上的value设置为插入的新value。 afterNodeAccess(e); //这个函数在hashmap中没有任何操作，是个空函数，他存在主要是为了linkedHashMap的一些后续处理工作。 return oldValue; //这里很有意思，他返回的是被覆盖的oldValue。我们在使用put方法时很少用他的返回值，甚至忘了它的存在，这 //里我们知道，他返回的是被覆盖的oldValue。 &#125; &#125; ++modCount; //收尾工作，值得一提的是，对key相同而覆盖oldValue的情况，在前面已经return，不会执行这里，所以那一类情 //况不算数据结构变化，并不改变modCount值。 if (++size &gt; threshold) //同理，覆盖oldValue时显然没有新元素添加，除此之外都新增了一个元素，这里++size并与threshold判断是否达 //到了扩容标准。 resize(); //当HashMap中存在的node节点大于threshold时，hashmap进行扩容。 afterNodeInsertion(evict); //这里与前面的afterNodeAccess同理，是用于linkedHashMap的尾部操作，HashMap中并无实际意义。1 return null; //最终，对于真正进行插入元素的情况，put函数一律返回null。&#125; 具体步骤 1. 判断table[]是否为null或者table.length==0,若为true，进行resize(); 2. 根据要插入的Node&lt;K,V&gt;的K，调用K.hash()，讲K的hashCode高16位与低16位进行异或，得到K的hash值，得到hash值后，hash&amp;(table.length-1)，得到要插入Node&lt;K,V&gt;在table[]中的角标i。 3. 如果table[i]为null，直接进行插入，也就是table[i] = new Node(hash,K,V,null); 4. 如果table[i]不为null： 4.2 定义Node&lt;K,V&gt; e,e作为插入表示节点 4.1 插入Node&lt;K,V&gt;与table[i]处的节点相同，e = p; 4.3 插入Node&lt;K,V&gt;与table[i]处的节点不同： 4.3.1 table[i]链的是一个RBT，那么直接直接插入。e = putTreeVal 4.3.2 table[i]链的是只是一个链表： 4.3.2.1 开始遍历，e = p.next 4.3.2.2 如果e为null，直接进行插入，p.next = new Node(hash,K,V,null)；插入后，判断当前链表长度，如果为8,链表转RBT，然后break。 4.3.2.3 如果e直接等于了我们插入的Node，那么直接break。 4.3.2.4 如果e不为null，而且也不是我们要的，那么p = e，又回去遍历。 4.4 判断完了，如果e不为null，那么就说明在table[]中查到了和插入Node的K相同的对象，那么返回原来对象的值，把新的value，给e。 5. 如果没有找到相同的，那么++modCount，++size，一旦size大于threshold，进行resize(),最后返回null get(K,V)123456789101112131415161718192021222324252627282930public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; //根据key及其hash值查询node节点，如果存在，则返回该节点的value值。 &#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; //根据key搜索节点的方法。记住判断key相等的条件：hash值相同 并且 符合equals方法。 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;(first = tab[(n - 1) &amp; hash]) != null)&#123; //根据输入的hash值，可以直接计算出对应的下标（n - 1）&amp; hash，缩小查询范围，如果存在结果，则必定在table的这个位置上。 if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; //判断第一个存在的节点的key是否和查询的key相等。如果相等，直接返回该节点。 if ((e = first.next) != null) &#123; //遍历该链表/红黑树直到next为null。 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); //当这个table节点上存储的是红黑树结构时，在根节点first上调用getTreeNode方法，在内部遍历红黑树节点，查看是否有匹配的TreeNode。 do &#123; if (e.hash == hash &amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; //当这个table节点上存储的是链表结构时，用跟第11行同样的方式去判断key是否相同。 //如果key不同，一直遍历下去直到链表尽头，e.next == null。 &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; resize() （这个方法很厉害，没怎么看懂）其实resize就是创建了一个新的table[]，然后把旧表中的数据都导入新表。 在JDK1.7的时候，进行resize需要重新计算hash，也就是执行了indexFor方法，重新计算数据在表中的位置，但是在1.8的时候不需要这么做。 123456789101112131415161718192021222324252627282930313233JDK1.7中的源码void resize(int newCapacity) &#123; //传入新的容量 Entry[] oldTable = table; //引用扩容前的Entry数组 int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; //扩容前的数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE; //修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return; &#125; Entry[] newTable = new Entry[newCapacity]; //初始化一个新的Entry数组 transfer(newTable); //！！将数据转移到新的Entry数组里 table = newTable; //HashMap的table属性引用新的Entry数组 threshold = (int)(newCapacity * loadFactor);//修改阈值&#125;void transfer(Entry[] newTable) &#123; Entry[] src = table; //src引用了旧的Entry数组 int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; //遍历旧的Entry数组 Entry&lt;K,V&gt; e = src[j]; //取得旧Entry数组的每个元素 if (e != null) &#123; src[j] = null;//释放旧Entry数组的对象引用（for循环后，旧的Entry数组不再引用任何对象） do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); //！！重新计算每个元素在数组中的位置 e.next = newTable[i]; //标记[1] newTable[i] = e; //将元素放在数组上 e = next; //访问下一个Entry链上的元素 &#125; while (e != null); &#125; &#125;&#125; JDK1.7中，newTable[i]的引用赋给了e.next，也就是使用了单链表的头插入方式，同一位置上新元素总会被放在链表的头部位置； 这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话），这一点和Jdk1.8有区别， 在旧数组中同一条Entry链上的元素，通过重新计算索引位置后，有可能被放到了新数组的不同位置上。 可是在JDK1.8的时候，在计算了hash之后，我们发现，因为用的是2的次幂进行扩容，那么元素的位置要不就 是在原位置，要不就是在原来的位置再移动2次幂的位置。（也就是原位置+旧表长度） 看下面的图，n表示表长。 元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： 因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0 就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图： 这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的， 因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788final Node&lt;K,V&gt;[] resize() &#123; // 当前table保存 Node&lt;K,V&gt;[] oldTab = table; // 保存table大小 int oldCap = (oldTab == null) ? 0 : oldTab.length; // 保存当前阈值 int oldThr = threshold; int newCap, newThr = 0; // 之前table大小大于0 if (oldCap &gt; 0) &#123; // 之前table大于最大容量 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; // 阈值为最大整形 threshold = Integer.MAX_VALUE; return oldTab; &#125; // 容量翻倍，使用左移，效率更高 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) // 阈值翻倍 newThr = oldThr &lt;&lt; 1; // double threshold &#125; // 之前阈值大于0 else if (oldThr &gt; 0) newCap = oldThr; // oldCap = 0并且oldThr = 0，使用缺省值（如使用HashMap()构造函数，之后再插入一个元素会调用resize函数，会进入这一步） else &#123; newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 新阈值为0 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) // 初始化table Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 之前的table已经初始化过 if (oldTab != null) &#123; // 复制元素，重新进行hash for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; // 将同一桶中的元素根据(e.hash &amp; oldCap)是否为0进行分割，分成两个不同的链表，完成rehash do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; LinkedHashMap这个Map感觉就是HashMap+LinkedList，因为这个本来就是HashMap的子类，基本就是多态实现的。 红黑树R-B Tree是一个特殊的二叉查找数。红黑树的每个节点都有存储位表示节点的颜色。 特性： 1. 每个节点都有色 2. 根节点和叶子节点都是黑色 3. 一个节点是红色，那么它的子节点必须是黑色。 4. 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 树的基本操作就是添加和删除，基本添加和删除后都需要旋转，不然这个树就不是一个RBT了 左旋 TreeMap]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java刷题（剑指Offer）]]></title>
    <url>%2F2017%2F12%2F28%2FJava%E5%88%B7%E9%A2%98%EF%BC%88%E5%89%91%E6%8C%87Offer%EF%BC%89%2F</url>
    <content type="text"><![CDATA[剑指Offer 单例模式12345678910111213141516171819202122232425262728293031分析：通过getInstance得到实例时，因为加锁是一个很麻烦的过程，所以我们每次在加锁前，先判断实例是否null，也就是当实例没有创建的时候，我们才需要加锁。加锁里面的判断就是为了创建了。/** * 设计一个类，单例模式。只能生成这个类的一个实例 * @author whbai_xd@163.com * @date 2018年1月11日 上午10:07:12 */class SingletonClass&#123; private static volatile SingletonClass instance; private SingletonClass()&#123; &#125; public static SingletonClass getInstance()&#123; if(instance==null)&#123; synchronized (SingletonClass.class) &#123; if(instance==null)&#123; instance = new SingletonClass(); &#125; &#125; &#125; return instance; &#125;&#125; 二维数组的查找题目描述：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下的顺序排序。 完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否包含该整数; 123456789101112131415161718192021222324252627282930313233343536public class Main&#123; /** * 与最右上角的数字比较： * 1. 相等：直接返回 * 2. 右上角的数字大：说明这一列的数字都比它大，列-- * 3. 右上角的数字小：说明这一行的数字都比它小，行++ * @param array * @param number * @return */ public static boolean find(int array[][],int number)&#123; int rows = array.length; int columns = array[0].length; boolean flag = false; int curRow = 0; int curColumn = columns-1; while(curRow&lt;rows&amp;&amp;curColumn&gt;=0)&#123; if(array[curRow][curColumn]==number)&#123; flag = true; break; &#125;else if(array[curRow][curColumn]&gt;number)&#123; curColumn--; &#125;else&#123; curRow++; &#125; &#125; return flag; &#125; public static void main(String[] args) &#123; int array[][] = &#123;&#123;1,2,8,9&#125;,&#123;2,4,9,12&#125;,&#123;4,7,10,13&#125;,&#123;6,8,11,15&#125;&#125;; System.out.println(find(array, 7)); &#125;&#125; 替换空格题目描述：实现一个函数，把字符串中的每个空格替换成&quot;%20&quot;。 12345678910111213141516public class Main&#123; /** * 利用String的实例方法replaceAll(String regex,String otherString) * 这个方法本质上是用到Pattern.compile(regex).matcher(this).replaceAll(replacement); * StringBuffer重新new了一个新的String * @param str * @return */ public static String replace(String str)&#123; return str.replaceAll(" ", "%20"); &#125; public static void main(String[] args) &#123; System.out.println(replace("We are happy")); &#125;&#125; 从尾到头打印一个链表利用栈做比较好想到，就是先进去的后出来。 利用递归的话，就是判断当前对象和下一个都不为null，进入递归。 但是递归的话，一旦链表特别长就会导致函数调用的层级特别深。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Node&#123; public int value; public Node next; public Node(int value)&#123; this.value = value; &#125;&#125;public class Main&#123; /** * 利用栈的前进后出来实现翻转 * @param head */ public static void reverse(Node head)&#123; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); while(head!=null)&#123; stack.push(head); head = head.next; &#125; while(stack.size()!=0)&#123; System.out.println(stack.pop().value+" "); &#125; &#125; /** * 利用递归来实现，先输出最后的那个 * @param head */ public static void recursion(Node head)&#123; if(head!=null)&#123; if(head.next!=null)&#123; recursion(head.next); &#125; System.out.println(head.value+" "); &#125; &#125; public static void main(String[] args) &#123; Node one = new Node(1); Node two = new Node(2); Node three = new Node(3); one.next = two; two.next = three; reverse(one); recursion(one); &#125;&#125; 重建二叉树利用两个栈实现队列其实就是push的时候让一个栈里面放，但是pop的时候，把第一个栈中的全部弹出到另一个里面，只要这个不为null就一直弹出这 里面的。一旦为null，就从第一个里面再取。 123456789101112131415161718192021222324252627282930313233343536373839404142class CQueue&lt;T&gt;&#123; private Stack&lt;T&gt; stack1; private Stack&lt;T&gt; stack2; public CQueue()&#123; this.stack1 = new Stack&lt;T&gt;(); this.stack2 = new Stack&lt;T&gt;(); &#125; public void push(T node)&#123; stack1.push(node); &#125; public T pop()&#123; if(stack2.size()&lt;0)&#123; try &#123; throw new Exception("CQueue is null"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; while(stack1.size()!=0)&#123; stack2.push(stack1.pop()); &#125; return stack2.pop(); &#125; &#125;public class Main&#123; public static void main(String[] args) &#123; CQueue&lt;Integer&gt; cq = new CQueue&lt;Integer&gt;(); for(int i=1;i&lt;=7;i++)&#123; cq.push(i); &#125; for(int i=1;i&lt;=7;i++)&#123; System.out.print(cq.pop()+" "); &#125; System.out.println(); cq.pop(); &#125;&#125; 旋转数组的最小数字(其实就是查找)123456789101112131415public class Main&#123; /** * 就用快排做一下 * @param array * @return */ public int minNumberInRotateArray(int [] array) &#123; Arrays.sort(array); if(array.length==0)&#123; return 0; &#125;else&#123; return array[0]; &#125; &#125;&#125; 斐波那契数列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283一般递归，效率并不高（时间复杂度是以n的指数方式递增的）public class Main&#123; public static int Fibonacci(int num)&#123; if(num&lt;=0)&#123; return 0; &#125;else if(num==1)&#123; return 1; &#125;else&#123; return Fibonacci(num-1)+Fibonacci(num-2); &#125; &#125;&#125;时间复杂度O（n），从下向上计算，保存已经计算过的数值public class Main&#123; public static long Fibonacci(int num)&#123; long one = 0; long second = 0; long FibN = 0; int result[] = &#123;0,1&#125;; if(num&lt;2)&#123; return result[num]; &#125;else&#123; for(int i=2;i&lt;=num;i++)&#123; FibN = one+second; one = second; second = FibN; &#125; &#125; return FibN; &#125;&#125;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 跳台阶，注意：跳第一个一种，第二个2种，第3个3种，第n个JumpFloor(n-1)+JumpFloor(n-2)public class Solution &#123; public int JumpFloor(int target) &#123; int one = 1; int second = 2; int FibN = 0; if(target&lt;=2)&#123; return target; &#125;else&#123; for(int i=3;i&lt;=target;i++)&#123; FibN = one+second; one = second; second = FibN; &#125; &#125; return FibN; &#125;&#125;一只青蛙一次可以跳上1级台阶，也可以跳上2级,...，也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 f(n) = 2^n-1(n&gt;=1)public class Solution &#123; public int JumpFloorII(int target) &#123; if(target&lt;1)&#123; return 0; &#125;else&#123; return (int)Math.pow(2,target-1); &#125; &#125;&#125;我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？public class Solution &#123; public int RectCover(int target) &#123; if(target&lt;=2)&#123; return target; &#125;else&#123; return RectCover(target-1)+RectCover(target-2); &#125; &#125;&#125; 二进制中的112345678910111213141516/**分析： 一个数是1100，减一称为1011，而1100&amp;1011，就是1000，这样不断循环，循环此时就是1的个数。*/public class Solution &#123; public int NumberOf1(int n) &#123; int count = 0; while(n!=0)&#123; n = n&amp;(n-1); count++; &#125; return count; &#125;&#125; 数值的整数次方题目描述：给定一个double类型的浮点数base和int类型的整数exponent。 求base的exponent次方。 12345678910111213141516171819public class Solution &#123; public double Power(double base, int exponent) &#123; if(exponent==0)&#123; return 1; &#125; if(exponent==1)&#123; return base; &#125; int n = Math.abs(exponent); double result = 1.0; for(int i=0;i&lt;n;i++)&#123; result *= base; &#125; if(exponent&lt;0)&#123; result = 1/result; &#125; return result; &#125;&#125; 链表中倒数第K个结点1234567891011121314151617181920212223利用了栈import java.util.*;public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; Stack&lt;ListNode&gt; stack = new Stack&lt;ListNode&gt;(); ListNode node = null; int count = 0; while(head!=null)&#123; stack.push(head); head = head.next; count++; &#125; if(count&lt;k)&#123; return null; &#125; for(int i=0;i&lt;k;i++)&#123; node = stack.pop(); &#125; return node; &#125;&#125; 链表翻转123456789101112131415161718192021222324252627282930/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/// 1-&gt;2-&gt;3-&gt;4-&gt;5 // 1&lt;-2&lt;-3 4-&gt;5 指针断裂后循环。public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; if(head==null) return null; ListNode preNode = null; ListNode nextNode = null; while(head!=null)&#123; nextNode = head.next; head.next = preNode; preNode = head; head = nextNode; &#125; return preNode; &#125;&#125; 合并两个排序的链表123456789101112131415161718192021222324/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; if(list1 == null) return list2; if(list2 == null) return list1; if(list1.val &lt;= list2.val) &#123; list1.next = Merge(list1.next, list2); return list1; &#125;else&#123; list2.next = Merge(list1, list2.next); return list2; &#125; &#125;&#125; 树的子结构二叉树的镜像顺时针打印矩阵包含min函数的栈1234567891011121314151617181920212223242526272829303132333435363738394041/** * 找到栈中的最小值 * @author whbai_xd@163.com * @date 2018年1月11日 下午8:25:40 */class CStack&#123; private Stack&lt;Integer&gt; dataStack; private Stack&lt;Integer&gt; minStack; public CStack()&#123; this.dataStack = new Stack&lt;Integer&gt;(); this.minStack = new Stack&lt;Integer&gt;(); &#125; public void push(Integer node)&#123; dataStack.push(node); if(minStack.empty())&#123; minStack.push(node); &#125;else&#123; if(node&lt;=minStack.peek())&#123; minStack.push(node); &#125; &#125; &#125; public Integer pop()&#123; int temp = dataStack.pop(); if(temp == minStack.peek())&#123; minStack.pop(); &#125; return temp; &#125; public int top()&#123; return dataStack.peek(); &#125; public int min()&#123; return minStack.peek(); &#125;&#125; 栈的压入、弹出序列题目描述：输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出序列。假设压入栈的所有数字均不相等。 例如序列1/2/3/4/5是某栈的压栈序列，序列4/5/3/2/1是该压栈序列对应的一个弹出序列，但4/3/5/1/2就不可能是该压栈序列的弹出序列 1234567891011121314151617public class Solution &#123; public boolean IsPopOrder(int [] pushA,int [] popA) &#123; if(pushA.length==0||popA.length==0)&#123; return false; &#125; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int popIndex=0; for(int i=0;i&lt;popA.length;i++)&#123; stack.push(pushA[i]); while(stack.size()!=0&amp;&amp;stack.peek()==popA[popIndex])&#123; stack.pop(); popIndex++; &#125; &#125; return stack.isEmpty(); &#125;&#125; 二叉树的层序遍历12345678910111213141516171819202122232425262728293031323334353637层级遍历需要用到Queue,offer,poll,peek/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; private ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; if(root==null)&#123; return list; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.offer(root); while(queue.size()!=0)&#123; TreeNode temp = queue.poll(); list.add(temp.val); if(temp.left!=null)&#123; queue.offer(temp.left); &#125; if(temp.right!=null)&#123; queue.offer(temp.right); &#125; &#125; return list; &#125;&#125; 二叉数的后序遍历二叉树中和为某一个值的路径复制复杂链表题目描述：输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.*;/*public class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125;&#125;*/public class Solution &#123; public RandomListNode Clone(RandomListNode pHead)&#123; //第一步，复制原始链表上的结点每个结点N创建N’，按照N的链接顺序链接 //第二步，讲上面的&lt;N,N'&gt;放到一个LinkedHashMap中 //第三步，复制原始结点N'的random结点，并链接 if(pHead==null)&#123; return null; &#125; LinkedHashMap&lt;RandomListNode,RandomListNode&gt; map = new LinkedHashMap&lt;RandomListNode,RandomListNode&gt;(); RandomListNode newHead = new RandomListNode(pHead.label); RandomListNode pre = pHead; RandomListNode newPre = newHead; map.put(pre,newPre); while(pre.next!=null)&#123; newPre.next = new RandomListNode(pre.next.label); pre = pre.next; newPre = newPre.next; map.put(pre,newPre); &#125; pre = pHead; newPre = newHead; while(newPre!=null)&#123; newPre.random = map.get(pre.random); pre = pre.next; newPre = newPre.next; &#125; return newHead; &#125;&#125; BST转双向链表12 丑数题目描述：把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 丑数计算 * @author whbai_xd@163.com * @date 2018年1月12日 上午11:24:35 */public class Main&#123; public static boolean isUgly(int number)&#123; while(number%2==0)&#123; number /= 2; &#125; while(number%3==0)&#123; number /= 3; &#125; while(number%5==0)&#123; number /= 5; &#125; return (number==1)?true:false; &#125; public static int GetUglyNumber_Solution(int index) &#123; if(index&lt;=0)&#123; return 0; &#125; int number = 0; int ugly = 0; while(ugly&lt;index)&#123; number++; if(isUgly(number))&#123; ugly++; &#125; &#125; return number; &#125; public static void main(String[] args) &#123; System.out.println(GetUglyNumber_Solution(7));//8 &#125;&#125;//比较吊的做法 public int GetUglyNumber_Solution(int n) &#123; if(n==0)return 0; ArrayList&lt;Integer&gt; res=new ArrayList&lt;Integer&gt;(); res.add(1); int i2=0,i3=0,i5=0; while(res.size()&lt;n) &#123; int m2=res.get(i2)*2; int m3=res.get(i3)*3; int m5=res.get(i5)*5; int min=Math.min(m2,Math.min(m3,m5)); res.add(min); if(min==m2)i2++; if(min==m3)i3++; if(min==m5)i5++; &#125; return res.get(res.size()-1); &#125;]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Operating System（引论&进程&处理机调度）]]></title>
    <url>%2F2017%2F12%2F28%2FOperating%20System%EF%BC%88%E5%BC%95%E8%AE%BA%26%E8%BF%9B%E7%A8%8B%26%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. 操作系统引论； 2. 进程的描述和控制； 3. 处理机调度和死锁 引论计算机系统发展史一、无操作系统 1. 人工操作：单用户，CPU内存长度空闲。 2. 脱机输入、输出（OFF-LINE I/O）:装好卡片再上机。节约了CPU空闲时间、提高了I/O速度。 二、单道批操作系统 1. 有个监督程序将磁带上的作业调入计算机。 2. 缺点：I/O太慢，CPU太快。 三、多道批操作系统 1. A在I/O，B趁机占用CPU 2. 优点：资源利用率高，系统吞吐量大 3. 缺点：平均周转时间长、无交互能力 4. 未解决难题：内存、外存、I/O、作业管理、接口 5. 推动多批道操作系统形成和发展的主要动力就是提高资源利用率和系统吞吐量 四、分时系统 1. 解决人机交互问题 2. 优点：有了人机交互、多用户共享主机 3. 分时系统的关键在于及时接受和及时处理。 多道批操作系统不能实现人机交互就是因为作业都是先驻留在外存上，即时以后被调入了内存，也要经过较长时间的等待后才能运行 用户也就无法与自己的作业进行交互。 所以人机交互的关键就在于怎么实现用户和作业之间的交互。 首先，系统要能提供多个终端，同时被多个用户使用 其次，系统要能及时接受和及时处理。 及时接受只需要在系统中配置一个多路卡，这个多路卡就是为了实现分时多路复用。 及时处理的方法有两种： 作业直接进入内存，作业在磁盘上也是不能运行的么，直接把作业调入内存 采用轮转运行方式，系统规定每个作业每次只能运行一个时间片，然后就这个作业中运行的进程就要回到就绪队列的尾部，并立即调用下一个作业进行运行。 4. 分时系统就是为了人机交互出来的。 5. 分时系统的特征：多路性、独立性、及时性、交互性。 五、实时系统 1. 周期性和非周期性实时： 周期性：字面意思 非周期性：必须关联一个截止时间：开始截止时间或完成截止时间 2. 硬实时（HRT，Hard Real-time Task）和软实时（SRT，Soft Real-time Task）： 硬实时：一旦出错，后果严重 软实时：出错了只要不是特别大，没事 3. 特点：多路性、独立性、及时性、交互性、可靠性。 六、微机时代 1. 单用户单任务：8位机的CP/M、16位机的MS-DOS 2. 单用户多任务：目前的32位系统，如Window 3. 多用户多任务：UNIX、Linux 操作系统共同特性：一、并发 1. 并行：多处理机系统，微观上同时运行 2. 并发：单处理机系统，微观上交替运行 进程：在系统中能够独立运行并作为资源分配的基本单位，由机器指令，数据和堆栈等组成，能独立运行的活动实体。 有了进程就可以并发执行了。 二、共享 1. 互斥共享：就是加锁了，只有拿到锁才能执行 2. 同时访问：就是并发。 3. 并发和共享是多用户OS的两个最基本特征。 4. 临界资源和临界区的概念 1. 临界资源说的是系统中只能被互斥共享的资源，也就是资源一次只能被一个进程访问。 2. 临界区说的是进程在访问临界资源时候的那段代码。 三、虚拟 1. 时分复用技术 2. 空分复用技术：将程序分成若干部分，然后各部分分时进入内存运行 四、异步 1. 因为要并发，所以需要一个机制调度进程 操作系统的主要功能一、处理机管理 处理机的分配和运行都是以进程为单位的。 1. 进程控制：为作业创建进程、撤销进程、控制进程在运行过程中的状态转换。 2. 进程同步 3. 进程通信： 4. 调度 1. 作业调度：从后备队列中选择若干作业，为作业分配资源后，调入内存，分别为作业建立若干进程，进程插入就绪队列 2. 进程调度：从就绪队列中找到一个进程，把处理机给这个进程。 二、存储器管理 1. 内存分配 1. 静态分配：每个作业的内存空间是在作业装入时确定的，作业一旦装入内存，整个运行期间不允许作业再申请新的空间，也不允许作业在内存中移动 2. 动态分配：每个作业的基本内存也实在作业装入时确定的，但这只是部分内存，允许作业在运行的时候申请新的空间，也允许作业在内存中移动 2. 内存保护 1. 确保每道程序仅在自己的内存空间运行，彼此互不干扰 2. 不允许用户程序访问操作系统的程序和数据 3. 内存保护机制，在正在执行程序的上下界放两个界限寄存器。 3. 地址映射 多道程序的环境下，每道程序在编译和链接后形成的可装入程序其地址都是从0开始的，也就需要从逻辑地址到物理地址的转换 4. 内存扩充 内存扩容并不是说物理上扩充了内存的容量，而是借助虚存从逻辑上扩充了内存容量。 1. 请求调入功能：允许在仅装入部分用户程序和数据的时候启动程序。 2. 置换功能：当内存不足，不能再装入时，系统将内存中一部分暂时不用的程序和数据调入硬盘，再调入当前需要的。 三、设备管理 CPU--&gt;I/O通道--&gt;设备管理器--&gt;设备处理程序 CPU本身基本不会和外设打交道，基本都是通过I/O通道。 四、文件管理 1. 文件存储空间的管理 2. 目录管理 3. 文件的读写管理与保护 五、OS与用户接口 1. 用户接口 2. 程序接口：用户程序访问系统资源时，是用户程序取得OS服务的唯一途径。 OS结构设计一、传统操作系统结构 1. 无结构OS 2. 模块化结构OS：高内聚低耦合 3. 分层式结构OS：有序分层，自底向上法铺设中间层，单向调用！ 二、C/S架构 1. 组成：客户机、服务器、网络系统 2. 交互：客户发送请求消息，服务器接受消息，服务器回送消息，客户机接受消息 3. 有点：数据分布处理和存储，便于集中管理，灵活性和可扩充性，易于改编应用软件 三、OOP 1. 概念：抽象具体事物为对象 2. 封装好，可继承 四、微内核OS结构 1. 足够小的内核，基于C/S架构，应用&quot;机制和策略分离&quot;原理，采用OOP技术 2. 基本功能：进程管理、低级存储器管理、中断和陷入处理 在微内核OS中，一个请求至少需要上下问切换4次！！！ 1. 客户发请求给内核，请求某服务器的服务 2. 内核发请求给服务器 3. 服务器完成请求，响应消息传回内核 4. 内核将响应传给客户 进程描述、调度进程描述在多道程序环境下，允许多个程序并发执行，但是这样程序本身就失去了封闭性（程序之间可能会交叉），同时程序开始有了间断性和不可再现性。所以我们才引入了进程，一个进程就是一个完整程序的一次执行!!! 为了使参与并发的程序可以独立的运行，引入了进程控制块PCB。 程序段、相关数据段、PCB三部分构成了进程实体（进程映像）。所谓创建进程，实质上是创建进程映像中的PCB。 注意：PCB是进程存在的唯一标识。 进程其他定义（OS p36）： 1. 进程是程序的一次执行 2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。 3. 进程是系统进行资源分配和调度的一个独立单元。 OS定义：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。 注意：进程是进程实体的运行过程，说明进程是动态的，而进程实体是静态的。 进程的特征： 1. 动态性 2. 并发性 3. 独立性：没有PCB的程序都是不能作为一个独立的单位参与运行的。 4. 异步性 进程状态转换 进程有三个基本状态：Ready就绪，Running运行，Block阻塞。 注意：Ready有就绪队列，Block有阻塞队列 后来又引入了创建、撤销、挂起、激活。 注意，在进程状态转换的时候，只有三对是相互转换的。而且两个还是激活和挂机有关。另一个只有就绪和运行可以相互转换！！！ 进程的控制都是在管态下进行的，也都执行了原语！！！ 进程创建 1. 进程申请空白PCB，并向PCB中填写控制和管理进程的信息 2. 为进程分配运行时需要的资源，包括逻辑和物理的 3. 进程转入就绪状态并插入就绪队列 注意：进程不能拒绝其子进程的继承。但是也存在没有父进程的进程。 在WindowOS中不存在任何进程层次结构的概念，也就是说，所有的进程都是相同的地位。 进入就绪 1. 进程已经在就绪队列中了，这个时候进程已经得到了除CPU外所有必要的资源 进程执行 1. 进程得到处理机（CPU），进程执行ing 进程阻塞 1. 正在执行的进程由于发生某种事件（I/O请求，申请缓冲区失败，访问临界资源，临界资源被占用）暂时无法继续执行，这个时候引起进程调度，OS把处理机（CPU）分配给另一个就绪进程 2. 注意，线程阻塞的时候，我们会进行进程调度，也就涉及到了进程切换： 1. 保存处理机上下文，包括程序计数器和其他寄存器 2. 更新PCB信息 3. 把进程PCB出入阻塞队列 4. 选择新的进程，更新其PCB 5. 更新内存管理的数据结构 6. 恢复处理机上下文 进程终止 1. OS进行善后 2. 将进程PCB清零，并将PCB空间返还系统。 PCB（Process Control Block）PCB的作用 PCB作为进程实体的一部分，记录了操作系统所需的，用于描述当前进程情况已经管理进程的一切信息。 PCB的作用是在多道程序的环境下，让不能独立运行的程序成为一个独立运行的基本单位。 PCB内容 1. 进程标识符：一个进程通常有两个标识符，外部标识符由用户设置，内部标识符由OS自己建立。 2. 处理机状态（处理机上下文）：处理机中各种寄存器的内容 3. 进程调度信息 4. 进程控制信息 组织方式 感觉组织方式很多都是连续、链式、索引 OS内核通常将一些与硬件紧密相关的模块，各种常用设备的驱动程序，以及运行频率较高的模块都放在紧靠硬件的软件层次中，将他们常驻内存，这些东西统称为内核。 处理机的执行状态分为管态（核心态）和目态（用户态），管态可以执行一切指令，而目态只能执行某些指令。应用程序只能在目态运行。 OS内核的功能 1. 支撑功能 1. 中断处理，这是OS的基础 2. 时钟管理 3. 原语操作：原语（Primitive），就是若干条指令组成的，用于完成一定功能的一个过程。原语都是原子操作。原语只能在管态下执行！！！ 2. 资源管理功能 进程、存储器、设备管理 进程通信进程通信的方式 Linux线程间通信：互斥量（mutex），信号量，条件变量 Windows进程间通信：管道、有名管道、消息队列、共享内存、信号量（semaphore）、套接字(socket) Windows线程间通信：互斥量（mutex），信号量（semaphore）、临界区（critical section）、事件（event） 整形信号量定义为一个用于表示资源数目的整形量S，除了初始化外，只能通过两个标准的原子操作wait（P）、Singal（V）来操作。 其实就是说，S等于多少，就代表现在还有几个空闲的资源，为负数就说明没有了，还有线程在等待资源。但是信号量不能用于大批数据交换。 管道是一种半双工的通信方式，数据只能单向流动，而且只能在有亲缘关系的进程中使用 有名管道也是一种半双工的通信方式，但是它允许无亲缘关系进程间的通信。 线程、线程和进程的联系与区别线程描述在OS中引入进程的目的是为了在多道环境下，多个进程并发执行，以提高资源利用率和系统吞吐量。那么引入线程就是为了减小程序在并发执行时所付出的时空开销，让OS具有更好的并发性。 TCB（Thread Control Block）1. 线程标识符，每个线程是唯一的。 2. 一组寄存器：程序计数器PC、状态寄存器、通用寄存器 3. 线程运行状态 4. 优先级 5. 线程专有存储区，用于线程切换时存放现场保护信息 6. 信号屏蔽 7. 堆栈指针，每个线程有自己的堆栈，用来保存局部变量和返回地址，而TCB中也就有了两个对应的指向堆栈的指针：指向用户自己堆栈的指针（线程运行在目态）和指向核心栈的指针（线程运行在管态）。 线程状态与实现Ready&lt;–&gt;Running–&gt;Block 内核支持线程 OS的所有线程都要在管态下运行，这样每次从目态--&gt;管态就比较麻烦 用户级线程 OS的所有线程都在目态下运行，直接就和内核没关系 注意：如果OS是用户级线程，调度的基本可是进程！！！而OS是内核支持线程，调度的基本就是线程了 组合方式 1. 多对一：多个用户级线程映射到一个内核支持线程 2. 一对一：每个用户级线程都映射到对应的一个内核支持线程 3. 多对多：多个用户级线程映射到小于等于数目的内核支持线程 说明 无论是进程还是线程，都必须直接或间接的取得内核的支持！！ 内核支持线程可以直接利用系统调用为它服务，而用户级线程必须借助于某种形式的中间系统来取得内核的服务，也就体现了线程和内核的无关性！ 用户级线程都有相同的结构，它们都运行在一个中间系统上。中间系统有两种实现方式：运行时系统和内核控制线程。 进程和线程的比较1. 调度的基本单元：进程是系统可拥有资源的基本单位；进程是调度和分派的基本单位（能独立运行的基本单元） 2. 并发性：线程是轻量级的进程，一个进程中的多个线程可以并发执行。 3. 拥有资源：进程可以拥有资源，而线程本身并不拥有系统资源，而是仅有一点必不可少、能保证独立运行的资源（TCB、程序计数器、保留局部变量、少数状态参数和返回地址等一组寄存器和堆栈）。 线程除了有自己的资源外，还共享了自己所属进程的资源。属于同一进程的所有线程都具有相同的地址空间，线程可以访问这个地址上的每一个虚地址！！！同时可以访问：已打开的文件、定时器、信号量机构等内存空间和进程所申请到的I/O设备等 4. 独立性：每个进程都有自己独立的地址空间和其他资源，除了共享全局变量外，不允许其他进程的访问。而同一进程的所有线程都可以访问所属进程空间中的所有地址。 5. 系统开销：创建、切换、撤销进程的开销比较大 注意：一个进程中至少有一个线程，CPU上可以没有运行的进程；一个线程只能属于某一个特定的进程； 处理机的调度调度的概念调度实际上一种资源的分配，处理机调度是对处理机资源进行分配。 处理机调度是多道OS的基础，它是OS设计的核心问题 操作员把用户提交的作业通过相应的输入设备输入到磁盘存储器，并保存在一个后备作业队列中。再有作业调度程序将作业从外存调入内存。 调度的层次 高级调度（作业调度） 直白一点，就是把后备队列的哪几个队列调度内存，为它们创建进程，分配必要的资源，并将它们放入进程的就绪队列。 作业调度基本都是在多道批处理系统中，而在分时和实时系统中不设置高级调度。 中级调度（内存调度） 就是把就绪队列上的暂时不用的进程挂起，放入挂起队列，而进程一旦被激活，则有中级调度把进程从挂机队列放回到就绪队列的尾部。 其实中级调度的作用就是提高内存利用率和系统吞吐量 低级调度（进程调度） 根据调度算法，由分派程序把处理机分派给选中的进程。 所有的OS都要用这个调度 调度算法的目的处理机调度算法的共同目标 1. 资源利用率 2. 公平性 3. 平衡性 4. 策略强制执行 批处理系统的目标 1. 平均周转时间短。 周转时间：作业在外存的后备队列上等待的时间；进程在就绪队列上等待进程调度的时间；进程在CPU上执行的时间；进程等待I/O的时间 2. 系统吞吐量大。 吞吐量是说单位时间内系统所完成的作业数 3. 处理机利用率高。 分时系统的目标 1. 响应时间块 2. 均衡性 实时系统的目标 1. 截止时间的保证 2. 可预测性 作业调度注意：作业调度只有在多道处理OS中才有！！！ 作业，不仅包括了通常的程序和数据而且还有一份作业说明书，系统根据这个说明书来对程序运行进行控制。在批处理系统中，是以作业为基本单位从外存进入内存的！！！ 作业步，作业运行期间的加工步骤。 JCB 作业在系统中存放在标志，在进入后备队列的时候就被创建了。 作业运行的步骤 1. 收容：操作员把用户提交的作业通过某种输入方式或者是SPOOLing系统输入到外存上（硬盘），再为作业创建JCB，并把作业放入后备队列。 2. 运行：作业被作业调度程序选中，程序为作业分配资源和建立需要的进程（可能不是一个），并把进程放入就绪队列。注意，一个作业只有一次就绪状态！！！ 3. 完成。 作业调度的主要任务 1. 接纳多少个作业 2. 接纳哪些作业 作业调度算法（四个）1. 先来先服务（FCFS） 这个调度算法作业和进程都可以用。 从后备队列中选择几个最先进入该队列的，也就是等待时间最长的进入内存，并为它们分配资源和创建进程，然后把进程放入就绪队列。 2. 短作业优先（SJF） 用作业的长度，也就是执行时间来作为优先级。 也可以用在进程调度中 3. 优先级调度（PSA） 人为的设置优先级 4. 高响应比（HRRN） 优先级=响应时间/服务时间 ,优先级&gt;1(响应时间=等待时间+服务时间) 进程调度进程调度的任务 1. 保存处理机的现场信息 2. 选取进程 3. 把处理机分配给选中的进程 进程调度调度方式 1. 非抢占方式 2. 抢占方式 进程调度的算法（五个）1. 时间片轮转算法（分时OS基本比较多,RR） 如果一个时间片还没有用完，进程已经结束了，就立即激活调度程序，将执行完的进程删除，再调度就绪队列中对首的进程调度，并启动一个新的时间片 一个时间片用完，计时器中断处理程序被激活。调度程序将把进程送到就绪队列的末尾。 2. 优先级调度算法 第一种，非抢占式优先级调度算法。一旦处理机被分配给了就绪队列中优先级最高的进程后，该进程会一直执行到完毕或者阻塞后，OS才会把处理机重新分配给另一个优先级最高的进程。 第二种，抢占式优先级调度算法。一旦处理机在执行的过程中，就绪队列中进入了比执行进程优先级还高的进程，调度程序会立刻把处理机进行重新分配！！！ 如何确定进程优先级： 静态优先级，创建进程时确定。可能会出现进程饥饿 动态优先级，优先级随着进程的推进和等待时间的增加而改变！！！比如，采用抢占式调度方式，如果规定当前进程的优先级随着运行时间的推移而下降，就可以防止长作业长期垄断处理机。 3. 多队列调度算法 将就绪队列一个分为多个，不同的就绪队列分别使用不同的调度算法。 4. 多级反馈队列 第一，设置多个就绪队列 第二，每个队列采用FCFS算法。 第三，按队列优先级调度 5. 基于公平原则的调度算法 第一种，保证调度算法 第二种，公平分享调度算法 实时调度 死锁死锁描述采用互斥访问的方式访问了临界资源。也就是多个线程对资源的争夺，可能会引起死锁。 如果一组进程的每一个进程都在等待仅由改组进程中的其他进程才能引发的事件，那么该组进程是死锁的。 死锁的必要条件1. 互斥条件，进程对锁分配到的资源进行排他性使用，也就是说在一段时间呢，某资源只能被一个进程占用。 2. 请求-保持条件，一个进程本身有一个资源，还要去请求新的资源，而这个新的资源也已经被别的进程占有。 3. 不可抢占条件，一个进程的资源不能被抢占，只能让进程自己去释放。 4. 循环等待条件，死锁的时候，必然存在一个进程-资源的循环链。 处理死锁的方式预防死锁 事先预防策略，设置某些限制条件，去破坏产生锁死的四个必要条件来预防死锁。 由于互斥条件是非共享设备必须的，不仅不能改变，还要加以保证。所以只能破坏死锁的另外三个 1. 破坏&quot;请求-保持&quot;条件 当一个进程在请求资源的时候，它不能持有不可抢占资源。 第一种协议：所有进程在开始运行之前，必须一次性申请其整个运行过程中所需的所有资源 第二种协议：允许进程在获得初期所需的资源后，便开始运行，运行过程中逐步释放已分配给自己的而且用完了的资源。 2. 破坏&quot;不可抢占&quot;条件 当一个已经有不可抢占资源的进程，又开始申请新的资源而不能满足的时候，直接释放进程的所有资源，待以后需要的时候再重新申请。 3. 破坏&quot;循环等待&quot;条件 对系统的所有资源进行线性排序，并赋予不同的序号，每个进程必须按序号递增的顺序请求资源。 避免死锁 也是事先预防策略，但不是事先采取某种限制破坏死锁的必要条件，而是在资源的动态分配过程中，防止系统进入不安全状态。 安全状态，就是说，系统能按某种进程推进顺序(p1,p2,...,pn)为每个进程pi分配其所需的资源，直到满足每个进程对资源的最大需求，使每个进程都可以顺利的完成。这个时候(p1,p2,...,pn)就是安全序列。如果系统找不到这样的一个序列，那么系统就处于不安全状态。 虽然不是所有的不安全状态都会变成死锁，但是有可能。同时安全状态一定不会死锁！！！ 银行家算法也就是这个思想，当一个进程请求可用资源的时候，OS就会先对进程的请求进行计算，只有计算后发现存在安全序列后，才会把资源分配给进程。 检测死锁 当系统在状态S下，资源分配图不能简化，系统死锁。 解除死锁 1. 抢占资源。从一个或多个进程中抢占足够多的资源，分配给死锁进程，以解除死锁状态。 2. 终止进程。终止系统中的一个或多个进程，直到打破循环环路。 1. 终止所有死锁进程 2. 逐个终止进程 杂1. 操作系统中不能被系统中断的特殊系统调用称为原语。 2. 外设控制接口电路中有的是数据、控制、状态寄存器，而标志寄存器是在内部的。 3. 为了实现多道程序设计，计算机需要更大的内存 4. 动态重定位装入方式：多道程序环境，是在程序执行时由CPU硬件进行地址重定位。程序在内存中可以浮动，需要重定位寄存器支持 5. 可重定位装入方式：多道程序环境，无需硬件支持，程序不能在内存中移动，要求程序的存储空间是连续的，不能把程序放在若干不连续区域 6. 绝对装入方式：单批道程序环境 7. 磁盘空间的分配单位是簇 8. 申请设备时使用逻辑设备名将使设备分配的灵活性更强 9. 通道和CPU共享存储器，是一种不含存储器，只含CPU的外部设备 10. 银行家算法：系统处于安全状态时，一定不会发生死锁；系统处于不安全状态时，不一定会发生死锁。 11. 有n个进程，共享的同类资源数是m，则避免死锁的最小资源数是n*(m-1)+1; 12. OS是系统软件不是应用软件！！！ 13. 只有共享设备不需要安装设备驱动程序 14. malloc与free是C/C++标准库函数，而new和delete是C++的运算符 15. new初始化对象，调用对象的构造函数，malloc仅仅分配内存 16. new/delete返回的是所分配类型变量的指针，malloc/free返回的是void指针 17. 能够装入内存任何位置的代码程序必须是可动态链接的 18. 管道（Pipe），是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进制间使用。进程的亲缘关系通常说的只是父子进程关系。 19. 信号量（Semophore），信号量是一个计数器，可以用来控制多个进程对共享资源的访问，常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问 20. 消息队列（message quque），由消息的链表，存放在内核中并由消息队列标识符标识。 21. 共享内存（shared memory），映射一段能够被其他进程所访问的内存 22. 套接字，可用于不同及其间的进程通信 23. 回调，只是一种编程机制 24. 计算机系统的虚拟存储器，其最大容量取决于机器的地址结构（即页面大小）以及系统的逻辑地址结构，而实际容量则取决于系统中内、外存容量总和。 25. 虚拟寄存器的最大容量只有计算机的地址结构决定，2^n，n为计算机系统的地址寄存器的位数。 26. 每一个进程至少要有一个线程 27. 每个进程都有自己独立的栈，而线程只能共享当前进程的栈 28. 线程必须属于一个进程。 29. 线程可能在不同进程中切换，但是一个线程不能改变所属的进程 30. 分时OS中，进程调度采用的是时间片轮转算法 31. 多个进程使用fork共享一个监听端口，fork函数会复制父进程的所有数据，当然也包括监听套接字 32. 单道批处理注重顺序性；多道批处理注重资源利用率和吞吐量，而且没有交互性；分时系统为了实现人机交互，特点是多路性独立性及时性交互性；实时系统特征是实时性和可靠性。 33. 线程池（Thread Pool）使得任一时刻内处于等待状态的线程的数量可以是无限个。 34. 存储设备的特性决定了文件的存取方式，磁带是顺序存储 35. CPU正在工作的时候，突然想要与外设通信，于是发命令给通道，然后接着做自己的工作。通道接到命令后，接通外设和内存，并在他们之间数据传输，等待数据传输完成后，通知CPU进行处理。 36. 虚拟存储只能基于非连续分配技术 37. 虚存的特征：多次性、对换性、虚拟性 38. 注意，信号量概念本身指的就是当前可用的资源数，若为负数，说明有几个进程在等待资源 39. 在UNIX操作系统中，把输入/输出设备看作是特殊文件！！！ 40. 临界资源为m，共享进程是n，单个进程最多可申请x个资源 m&gt;n时，m&gt;=n(x-1)，不会死锁 m&lt;=n时，x=1才不会死锁 41. 系统态也就是内核态，三种情况下会出现由用户态转为内核态，中断、异常、系统调用 42. 位示图来实现磁盘空间的管理。 43. SPOOLing（外部设备联机并行操作），关于慢速字符设备如何和计算机主机交换信息，牛逼在把独占设备变成了共享设备 44. 降低进程优先级的最好是在进程的时间片用完 45. Windows操作系统中，文件组织采用树形目录结构 46. 进程阻塞的原因：等待I/O、进程sleep、等待解锁。 47. 一个Running的进程，一旦时间片用完而没有执行完，会进入就绪队列。 48. 多道程序技术的前提之一就是系统具有中断功能 49. 操作系统的功能：进程与处理机管理，作业管理，存储管理，设备管理，文件管理。编译是应用软件的东西。 50. 但处理机OS中，多道程序执行宏观上并行，微观上并发，设备和处理机可以并行。 51. 注意周转时间的概念：进程提交到进程完成的时间间隔。等待进入内存的时间，就绪队列等待的时间，在CPU中执行的时间，I/O操作的时间。 52. 通过SPOOLing技术便可将一台物理I/O设备虚拟为多台逻辑I/O设备。 53. 分配延迟（Dispatch Lantency）：分配器停止一个进程到开启另一个进程的时间 54. 管态又叫做特权态，系统态，核心态，当CPU处理系统程序的时候，CPU就会转为管态，CPU在管态下可以执行指令系统的全集。 55. 形成逻辑地址的阶段是链接。 56. 内存屏障可以限制CPU对内存的访问，表现在高级编程语言中就是加锁。 57. 信箱通信是一种间接通信方式 58. 位示图法可用于磁盘空闲空间的管理 59. 优先队列使用堆来实现 60. 实现进程之间同步与互斥的通信工具是P,V操作，也就是信号量 61. 高速设备一般会被设置为共享设备 62. 共享设备在同一时刻只能被一个作业访问 63. 进程不是程序，是程序的一次具体执行。 64. 页表表项中存在的存在位是操作系统置位的。 65. 级别优先级：处理机--&gt;I/O通道--&gt;设备控制器--&gt;I/O设备 66. 从设备分配角度来说，设备分为独享设备、虚拟设备、共享设备。 67. 构成文件的基本单元是记录 68. 为了提高设备分配的灵活性，用户申请设备时应指定设备相对号 69. 并发进程执行的相对速度与进程调度策略有关。 70. 虚拟内存的容量 = min（内存+外存，2^N）,N为计算机地址总线的位数 80. 多道程序系统的运行必须要依赖中断和通道硬件机构的支持 81. 全局变量也只能在一个进程中供多个线程使用，并不能用于进程的通信 82. 注意，产生进程死锁的条件有4个，但是互斥条件是非共享设备必须的！！！不仅不能改变，而且需要加以保证，所以预防只有另外三个。 破坏&quot;请求-保持&quot;：就是说一个进程请求资源的时候，不能占有不可抢占的资源。 第一种协议：所有进程在开始运行的时候，必须一次性申请其在整个运行过程中所需要的所有资源。 第二中协议：允许一个进程只获得运行初期需要的资源后就开始运行。进程在运行过程中，再逐步释放已经用过的，然后再请求新的 破坏不可抢占条件：一个已经占有了不可抢占资源的进程，提出新的资源请求而得不到满足的时候，就必须释放自己所有的资源！注意是所有的资源 破坏&quot;循环等待&quot;条件：通过对系统所有资源类型进行线性排序，并赋予不同的序号。规定每个进程必须按照序号递增的顺序请求资源。 83. 虚拟内存的扩大是时间换空间。 84. 虚拟内存的目的是扩充主存，注意，辅存就是外存！！！ 85. linux下一切都是文件，无论普通的文件还是硬件设备管理 86. 页面调度（置换）算法： 虚拟寄存器中，主存页面的替换 Cache中的块替换 虚拟寄存器的快慢表中，快表的替换 虚拟寄存器中，用户基地址寄存器的替换 87. 磁盘访问总时间：寻道时间+旋转时间+传输时间。寻道时间最长 88. 系统内可以有无父进程的进程。 89. 单道程序系统中程序的执行也需要同步和互斥。 90. 链接文件只能顺序访问，不能随机访问 91. 通道可以用来执行I/O指令集 92. 磁盘存储器是由磁盘、驱动器结构、控制器组成的 93. 段式存储管理的系统中，若地址是24位，8为代表段号，那么每段允许的最大长度是2^16 94. 临界区是访问临界资源的一段代码 95. 最近最少使用LRU，需要对所有页面的移位寄存器进行比较 96. 处理机--&gt;通道--&gt;设备控制器--&gt;设备 97. 系统中的资源分为可剥夺和不可剥夺资源，CPU和内存都是可剥夺资源，而磁盘和磁带机却不是 98. 时间片轮转法说的是进程单位！！！ 99. 线程并不共享进程的寄存器 100. 临界区说的是每个进程中访问临界资源的那段代码。临界资源说的是一次仅允许一个进程使用的共享资源。 101. Linux进程间通信：管道、信号、消息队列、共享内存、信号量、套接字(socket) Linux线程间通信：互斥量（mutex），信号量，条件变量 Windows进程间通信：管道、消息队列、共享内存、信号量 （semaphore） 、套接字(socket) Windows线程间通信：互斥量（mutex），信号量（semaphore）、临界区（critical section）、事件（event） 102. 程序的动态链接可以发生在装入时和调用时。 103. 段页式系统中，为了获得一条指令或数据，需要三次访问内存。 104. 在页式存储管理中，当前进程的页表起始地址存放在PTBR中。 105. 进程和程序的本质区别是前者是动态的，而后者是静态的。 106. 为了实现CPU与外部设备间最大的并行性，应采用通道设备 107. 通道完成的是内存和设备之间的信息传递，与CPU并行执行 108. 进程切换只能在管态发生 109. 内核线程只能运行在内核态，不受用户态上下文的影响，而用户线程的调度并不需要经过内核态]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java刷题（排序问题）]]></title>
    <url>%2F2017%2F12%2F25%2FJava%E5%88%B7%E9%A2%98%EF%BC%88%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. Map利用List和Collections.sort改写Comparator； 2. 查找所有子串； 3. 四则运算（逆波兰法，如何拆分数字和符号； 4. 素数判断 5. 正则判断； 6. 兄弟单词； 7.Collections和Arrays中的sort Map中利用Value排序我们知道我们的TreeMap中使用K来进行字典排序的，而做题的时候我们经常需要对值进行排序，例如我们的的成绩，基本上就是人名不同，但是我们不同人的成绩可能会相同，这个时候要求按照输入顺序进行排序。 一个原理，先排K，再排V排K的时候，看题目说是输入顺序还是字典顺序，如果是输入顺序就用LinkedHashMap，如果是字典升序就用TreeMap（ASCII升序或者是String的字典升序） 其实就是把我们Map.Entry对象利用map.enrtySet()直接写入一个ArryList。 再利用Collections中的sort方法，有Comparator的那个重载，重写我们的比较器。 重写比较器其实就是要重写compare方法，参数就是我们Entry对象o1.getValue().compareTo(o2.getValue())就是升序，反之就是降序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667输入描述： 一行或多行字符串。每行包括带路径文件名称，行号，以空格隔开。 文件路径为windows格式 如：E:\V1R2\product\fpgadrive.c 1325输出描述： 将所有的记录统计并将结果输出，格式：文件名代码行数数目，一个空格隔开，如: fpgadrive.c 1325 1 结果根据数目从多到少排序，数目相同的情况下，按照输入第一次出现顺序排序。 如果超过8条记录，则只输出前8条记录. 如果文件名的长度超过16个字符，则只输出后16个字符输入例子： E:\V1R2\product\fpgadrive.c 1325输出例子： fpgadrive.c 1325 1实现：import java.util.*;import java.util.Map.*;public class Main&#123; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); LinkedHashMap&lt;String,Integer&gt; map = new LinkedHashMap&lt;String,Integer&gt;(); while(scanner.hasNextLine())&#123; String lineArr[] = scanner.nextLine().split("\\s+"); String lineNum = lineArr[1]; String filePaths[] = lineArr[0].split("\\\\"); String fileName = filePaths[filePaths.length-1]; if(fileName.length()&gt;16)&#123; fileName = fileName.substring(fileName.length()-16); &#125; String errorName = fileName+" "+lineNum; if(map.containsKey(errorName))&#123; map.put(errorName,map.get(errorName)+1); &#125;else&#123; map.put(errorName,1); &#125; &#125; scanner.close(); List&lt;Entry&lt;String,Integer&gt;&gt; list = new ArrayList&lt;Entry&lt;String,Integer&gt;&gt;(map.entrySet()); Collections.sort(list,new Comparator&lt;Entry&lt;String,Integer&gt;&gt;()&#123; @Override public int compare(Entry&lt;String,Integer&gt; o1,Entry&lt;String,Integer&gt; o2)&#123; return o2.getValue().compareTo(o1.getValue());//o2在前面就是降序 &#125; &#125;); int count = 0; for(Entry&lt;String,Integer&gt; entry : list)&#123; count++; if(count&lt;=8)&#123; System.out.println(entry.getKey()+" "+entry.getValue()); &#125;else&#123; break; &#125; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152输入描述： 输入一串字符。输出描述: 对字符中的各个英文字符（大小写分开统计），数字，空格进行统计，并按照统计个数由多到少输出,如果统计的个数相同，则按照ASII码由小到大排序输出 。如果有其他字符，则对这些字符不用进行统计。输入实例： aadddccddc输出实例： dca实现：import java.util.*;import java.util.Map.Entry;public class Main&#123; public static void main(String args[])&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String line = scanner.nextLine(); TreeMap&lt;Character,Integer&gt; map = new TreeMap&lt;Character, Integer&gt;(); //需要用到字典排序（升序）的时候用TreeMap //输入输出排序的时候用LinkedHashMap for(int i=0;i&lt;line.length();i++)&#123; if(map.containsKey(line.charAt(i)))&#123; map.put(line.charAt(i), map.get(line.charAt(i))+1); &#125;else&#123; map.put(line.charAt(i), 1); &#125; &#125; List&lt;Map.Entry&lt;Character, Integer&gt;&gt; list = new ArrayList&lt;Entry&lt;Character,Integer&gt;&gt;(map.entrySet()); Collections.sort(list,new Comparator&lt;Entry&lt;Character,Integer&gt;&gt;()&#123; @Override public int compare(Entry&lt;Character, Integer&gt; o1,Entry&lt;Character, Integer&gt; o2) &#123; //return o1.getValue().compareTo(o2.getValue()); //实现了对Value的排序，也就是Integer大的在后面 //Character中ASCII大的在后面 //String按照字典排序。 //当Value一致的时候按照输入排序(也就是第一次出现的顺序) return o2.getValue().compareTo(o1.getValue());//降序 &#125; &#125;); //System.out.println(list); StringBuilder sb = new StringBuilder(); for (Entry&lt;Character, Integer&gt; entry : list) &#123; sb.append(entry.getKey()); &#125; System.out.println(sb.toString()); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293题目：输入任意（用户，成绩）序列，可以获得成绩从高到低或从低到高的排列,相同成绩 都按先录入排列在前的规则处理。 例示： jack 70 peter 96 Tom 70 smith 67 从高到低 成绩 peter 96 jack 70 Tom 70 smith 67 从低到高 smith 67 Tom 70 jack 70 peter 96 输入描述:输入多行，先输入要排序的人的个数，然后分别输入他们的名字和成绩，以一个空格隔开输出描述:按照指定方式输出名字和成绩，名字和成绩之间以一个空格隔开输入30fang 90yang 50ning 70输出fang 90ning 70yang 50实现import java.util.*;import java.util.Map.Entry;public class Main&#123; public static void main(String args[])&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; int num = Integer.parseInt(scanner.nextLine()); int flag = Integer.parseInt(scanner.nextLine()); LinkedHashMap&lt;String,Integer&gt; map = new LinkedHashMap&lt;String,Integer&gt;(); for(int i=0;i&lt;num;i++)&#123; String[] lineArr = scanner.nextLine().split("\\s+"); map.put(lineArr[0]+lineArr[1], Integer.parseInt(lineArr[1])); &#125; List&lt;Map.Entry&lt;String, Integer&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;String,Integer&gt;&gt;(map.entrySet()); if(flag==0)&#123; Collections.sort(list,new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;()&#123; @Override public int compare(Entry&lt;String,Integer&gt; o1,Entry&lt;String,Integer&gt; o2)&#123; return o2.getValue().compareTo(o1.getValue()); &#125; &#125;); &#125;else if(flag==1)&#123; Collections.sort(list,new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;()&#123; @Override public int compare(Entry&lt;String,Integer&gt; o1,Entry&lt;String,Integer&gt; o2)&#123; return o1.getValue().compareTo(o2.getValue()); &#125; &#125;); &#125; for(Map.Entry&lt;String, Integer&gt; entry : list)&#123; StringBuilder sb = new StringBuilder(); String key = entry.getKey(); for (int i = 0; i &lt; key.length(); i++) &#123; if(!Character.isDigit(key.charAt(i)))&#123; sb.append(key.charAt(i)); &#125; &#125; System.out.println(sb.toString()+" "+entry.getValue()); &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142再看一个例子：import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.util.List;import java.util.Map;import java.util.Map.Entry;import java.util.TreeMap;public class TreeMapTest &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new TreeMap&lt;String, String&gt;(); map.put("a", "ddddd"); map.put("c", "bbbbb"); map.put("d", "aaaaa"); map.put("b", "ccccc"); //这里将map.entrySet()转换成list List&lt;Map.Entry&lt;String,String&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;String,String&gt;&gt;(map.entrySet()); //然后通过比较器来实现排序 Collections.sort(list,new Comparator&lt;Map.Entry&lt;String,String&gt;&gt;() &#123; //升序排序 public int compare(Entry&lt;String, String&gt; o1, Entry&lt;String, String&gt; o2) &#123; return o1.getValue().compareTo(o2.getValue()); &#125; &#125;); for(Map.Entry&lt;String,String&gt; mapping:list)&#123; System.out.println(mapping.getKey()+":"+mapping.getValue()); &#125; &#125;&#125;/** d:aaaaa c:bbbbb b:ccccc a:ddddd*/ 查找所有子串123456789101112131415161718192021222324public static void getSubstring(String str,LinkedHashSet&lt;String&gt; set)&#123; for(int i=0;i&lt;str.length()-1;i++)&#123; for(int j=i+1;j&lt;str.length();j++)&#123; set.add(str.substring(i,j)); if(j==str.length()-1)&#123; set.add(String.valueOf(str.charAt(j))); set.add(str.substring(i)); &#125; &#125; &#125;&#125;public static void getSubstring(String oriString,TreeSet&lt;String&gt; set)&#123; int oriLength = oriString.length(); for(int i=0;i&lt;oriLength-1;i++)&#123; for(int j=i+1;j&lt;oriLength;j++)&#123; set.add(oriString.substring(i,j)); if(j==oriLength-1&amp;&amp;i!=0)&#123; set.add(String.valueOf(oriString.charAt(j))); set.add(oriString.substring(i)); &#125; &#125; &#125; &#125; 判断一个数是不是素数（素数）1234567891011//判断一个数是否是质数（素数） public boolean isPrimeNumber(int num)&#123; if(num == 2) return true;//2特殊处理 if(num &lt; 2 || num % 2 == 0) return false;//识别小于2的数和偶数 （1不是质数） for(int i=3; i&lt;=Math.sqrt(num); i+=2)&#123; if(num % i == 0)&#123;//识别被奇数整除 return false; &#125; &#125; return true; &#125; 关于Regex的匹配1. 匹配字母[a-zA-Z] 2. 匹配字母数字[a-zA-Z0-9] 3. 匹配中文[\u4e00-\u9fa5] 4. 匹配空格[\\s+] 5. 匹配点.[\\.] 6. 匹配\[\\\\] 7. 匹配/[\\/] 8. ^[A-Za-z0-9]+$匹配由数字和26个英文字母组成的字符串 关于四则运算利用栈（Stack、LIFO），逆波兰表示法。 中缀表示法–&gt;后缀表示法 后缀表示进行运算 两步都需要进行push和pop方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128发现这个只对个位数的运算有用，因为都是按照char走的，想要对别的都成立，就要想办法把算数式拆分！！！符号是符号，数字是数字！！！import java.util.*;public class Main&#123; //把中缀表达式变成后缀表达式，利用逆波兰法，但是这个算法只支持正整数的变化。 //遇到符号就压栈，遇到数字字符就保存进入我们的StringBuilder，最后清空栈，得到我们的后缀表达式 //System.out.println(infixToPostfix("3+(2-5)*6/3"));//325-6*3/+ //System.out.println(expToResult(infixToPostfix("3+(2-5)*6/3")));//-3 public static String infixToPostfix(String exp)&#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); StringBuilder postfix = new StringBuilder(); int length = exp.length(); for(int i=0;i&lt;length;i++)&#123; char temp; char ch = exp.charAt(i); switch(ch)&#123; case '('://左括号压栈 stack.push(ch); break; case '+'://因为switch...case...的语法可以这样写 case '-'://遇到+、-这就是优先级最低的符号，只要遇到的不是(，压入的除非是(，不然都要弹出，再压入。 while(stack.size()!=0)&#123;//栈中一直有值 temp = stack.pop(); if(temp=='(')&#123; stack.push('('); break;//跳出当前循环，把这个符号压入 &#125; postfix.append(temp); //break;//直接跳出while，进入for &#125; stack.push(ch);//能到这就说明压入-/+的时候栈中是空的，所以直接压入 break; case '*': case '/': while(stack.size()!=0)&#123; temp = stack.pop();//*和/的优先级比较高，直接压入，除非是）、*、/：也就是说压入的优先级小于等于栈顶的，都要把栈顶的全部弹出后再压入 if(temp=='+'||temp=='-'||temp=='(')&#123; stack.push(temp); break; &#125;else&#123; postfix.append(temp); //break; &#125; &#125; stack.push(ch); break; case ')': while(stack.size()!=0)&#123; temp = stack.pop(); if(temp=='(')&#123; break; &#125;else&#123; postfix.append(temp); &#125; &#125; break; default: postfix.append(ch); break; &#125; &#125; while(stack.size()!=0)&#123; postfix.append(stack.pop()); &#125; return postfix.toString(); &#125; public static int expToResult(String exp)&#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); for(int i=0;i&lt;exp.length();i++)&#123; if(Character.isDigit(exp.charAt(i)))&#123; stack.push(Integer.parseInt(String.valueOf(exp.charAt(i)))); &#125;else&#123; int first = stack.pop(); int second = stack.pop(); stack.push(calculateResult(first,second,exp.charAt(i))); &#125; &#125; return stack.pop(); &#125; public static int calculateResult(int first,int second,char symbol)&#123; if(symbol=='+')&#123; return first+second; &#125;else if(symbol=='-')&#123; return second-first; &#125;else if(symbol=='*')&#123; return first*second; &#125;else if(symbol=='/')&#123; return second/first; &#125;else&#123; return 0; &#125; &#125; public static String minusAddZero(String exp)&#123; exp = exp.replaceAll("[\\[\\&#123;]", "("); exp = exp.replaceAll("[\\]\\&#125;]", ")"); StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;exp.length();i++)&#123; if(exp.charAt(i)=='-')&#123; if(i==0||!Character.isDigit(exp.charAt(i-1)))&#123; sb.append('0'); &#125; &#125; sb.append(exp.charAt(i)); &#125; return sb.toString(); &#125; public static void main(String[] args)&#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String arthLine = scanner.nextLine();//3+2*&#123;1+2*[-4/(8-6)+7]&#125; String infixLine = minusAddZero(arthLine); String postfixLine = infixToPostfix(infixLine); int num = expToResult(postfixLine); System.out.println(num);//25 &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166完整的解决！！！import java.util.*;public class Main&#123; //把中缀表达式变成后缀表达式，利用逆波兰法。 //遇到符号就压栈，遇到数字字符就保存进入ArrayList，最后清空栈，得到我们的后缀表达式 public static ArrayList&lt;String&gt; infixToPostfix(ArrayList&lt;String&gt; exp)&#123; Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); ArrayList&lt;String&gt; alist = new ArrayList&lt;String&gt;(); int length = exp.size();//exp的长度 for(int i=0;i&lt;length;i++)&#123; String temp; String s = exp.get(i); switch(s)&#123; case "("://左括号压栈 stack.push(s); break; case "+"://因为switch...case...的语法可以这样写 case "-"://遇到+、-这就是优先级最低的符号，只要遇到的不是(，压入的除非是(，不然都要弹出，再压入。 while(stack.size()!=0)&#123;//栈中一直有值 temp = stack.pop(); if(temp.equals("("))&#123; stack.push("("); break;//跳出当前循环，把这个符号压入 &#125; alist.add(temp); &#125; stack.push(s);//能到这就说明压入-/+的时候栈中是空的，所以直接压入 break; case "*": case "/": while(stack.size()!=0)&#123; temp = stack.pop();//*和/的优先级比较高，直接压入，除非是）、*、/：也就是说压入的优先级小于等于栈顶的，都要把栈顶的全部弹出后再压入 if(temp.equals("(")||temp.equals("-")||temp.equals("+"))&#123; stack.push(temp); break; &#125;else&#123; alist.add(temp); &#125; &#125; stack.push(s); break; case ")": while(stack.size()!=0)&#123; temp = stack.pop(); if(temp.equals("("))&#123; break; &#125;else&#123; alist.add(temp); &#125; &#125; break; default: alist.add(s); break; &#125; &#125; while(stack.size()!=0)&#123; alist.add(stack.pop()); &#125; return alist; &#125; public static int expToResult(ArrayList&lt;String&gt; exp)&#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); ArrayList&lt;String&gt; expTemp = new ArrayList&lt;String&gt;(); for(int i=0;i&lt;exp.size();i++)&#123; if(exp.get(i).trim().length()!=0)&#123; expTemp.add(exp.get(i)); &#125; &#125; for(int i=0;i&lt;expTemp.size();i++)&#123; if(!expTemp.get(i).matches("[\\+\\-\\/\\*\\(\\)]")&amp;&amp;expTemp.get(i).trim().length()&gt;0)&#123;//不是数字 stack.push(Integer.parseInt(expTemp.get(i))); &#125;else&#123; int first = stack.pop(); int second = stack.pop(); stack.push(calculateResult(first,second,expTemp.get(i))); &#125; &#125; return stack.pop(); &#125; public static int calculateResult(int first,int second,String symbol)&#123; if(symbol.equals("+"))&#123; return first+second; &#125;else if(symbol.equals("-"))&#123; return second-first; &#125;else if(symbol.equals("*"))&#123; return first*second; &#125;else if(symbol.equals("/"))&#123; return second/first; &#125;else&#123; return 0; &#125; &#125; public static ArrayList&lt;String&gt; getStr(String str)&#123; StringBuilder sb = new StringBuilder(); Character ch[] = &#123;'0','1','2','3','4','5','6','7','8','9'&#125;; List&lt;Character&gt; list = new ArrayList&lt;Character&gt;(Arrays.asList(ch)); str = str.replaceAll("[\\[\\&#123;]", "("); str = str.replaceAll("[\\]\\&#125;]", ")"); for (int i = 0; i &lt; str.length(); i++) &#123; if(!(list.contains(str.charAt(i))))&#123; sb.append(","); sb.append(str.charAt(i)); sb.append(","); &#125;else&#123; sb.append(str.charAt(i)); &#125; &#125; String strArr[] = sb.toString().split("\\,+"); List&lt;String&gt; alist = new ArrayList&lt;String&gt;(Arrays.asList(strArr));//9+(3-1)*3+10/2 ArrayList&lt;Integer&gt; llist = new ArrayList&lt;Integer&gt;(); if(alist.get(0).equals("-"))&#123; alist.set(1, "-"+alist.get(1)); llist.add(0); &#125; for (int i=1;i&lt;alist.size();i++) &#123; if(alist.get(i).equals("-"))&#123; if(alist.get(i-1).matches("[\\+\\/\\-\\*\\(]"))&#123;//前一个是数字）后面可以有- alist.set(i+1, Integer.parseInt(alist.get(i+1))*(-1)+""); llist.add(i); &#125; &#125; &#125; ArrayList&lt;String&gt; tlist = new ArrayList&lt;String&gt;(); for(int i=0;i&lt;alist.size();i++)&#123; if(!llist.contains(i))&#123; tlist.add(alist.get(i)); &#125; &#125; return tlist; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String arthLine = scanner.nextLine(); if(arthLine.trim().length()!=0)&#123; //String infixLine = minusAddZero(arthLine); //ArrayList&lt;String&gt; list =getStr(infixLine); //ArrayList&lt;String&gt; alist = infixToPostfix(getStr(arthLine)); //int num = expToResult(infixToPostfix(getStr(arthLine))); System.out.println(expToResult(infixToPostfix(getStr(arthLine)))); &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163public class Main&#123; public static ArrayList&lt;String&gt; infixToPostfix(ArrayList&lt;String&gt; inExp)&#123; int length = inExp.size(); ArrayList&lt;String&gt; postExp = new ArrayList&lt;String&gt;(); Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); for(int i=0;i&lt;length;i++)&#123; String temp = inExp.get(i); switch(temp)&#123; case "(": stack.push(temp); break; case "+": case "-": while(stack.size()!=0)&#123; String tempPop = stack.pop(); if(tempPop.equals("("))&#123; stack.push(tempPop); break; &#125; postExp.add(tempPop); &#125; stack.push(temp); break; case "*": case "/": while(stack.size()!=0)&#123; String tempPop = stack.pop(); if(tempPop.equals("(")||tempPop.equals("+")||tempPop.equals("-"))&#123; stack.push(tempPop); break; &#125;else&#123; postExp.add(tempPop); &#125; &#125; stack.push(temp); break; case ")"://)不入栈 while(stack.size()!=0)&#123; String tempPop = stack.pop(); if(tempPop.equals("("))&#123;// stack.push(tempPop); break; &#125;else&#123; postExp.add(tempPop); &#125; &#125; break; default: postExp.add(temp); break; &#125; &#125; while(stack.size()!=0)&#123; postExp.add(stack.pop()); &#125; return postExp; &#125; public static int postfixToResult(ArrayList&lt;String&gt; postfixExp)&#123; Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int expLength = postfixExp.size(); ArrayList&lt;String&gt; expTemp = new ArrayList&lt;String&gt;(); //去掉空格的东西 for(int i=0;i&lt;expLength;i++)&#123; if(postfixExp.get(i).trim().length()!=0)&#123; expTemp.add(postfixExp.get(i)); &#125; &#125; int length = expTemp.size(); for(int i=0;i&lt;length;i++)&#123; if(!expTemp.get(i).matches("[\\(\\)\\+\\-\\*\\/]"))&#123; stack.push(Integer.parseInt(expTemp.get(i))); &#125;else&#123; int first = stack.pop(); int second = stack.pop(); stack.push(getResult(first,second,expTemp.get(i))); &#125; &#125; return stack.pop(); &#125; public static int getResult(int first,int second,String symbol)&#123; if(symbol.equals("+"))&#123; return first+second; &#125;else if(symbol.equals("-"))&#123; return second-first; &#125;else if(symbol.equals("*"))&#123; return first*second; &#125;else if(symbol.equals("/"))&#123; return second/first; &#125; return 0; &#125; public static ArrayList&lt;String&gt; getExpression(String exp)&#123; exp = exp.trim(); exp = exp.replaceAll("[\\[\\&#123;]", "("); exp = exp.replaceAll("[\\]\\&#125;]", ")"); int expLength = exp.length(); StringBuilder inSb = new StringBuilder(); for(int i=0;i&lt;expLength;i++)&#123; String tempStr = String.valueOf(exp.charAt(i)); if(tempStr.matches("[\\(\\)\\+\\-\\*\\/]"))&#123; inSb.append(","); inSb.append(tempStr); inSb.append(","); &#125;else&#123; inSb.append(tempStr); &#125; &#125; String[] inArr = inSb.toString().split("\\,+"); ArrayList&lt;String&gt; inStr = new ArrayList&lt;String&gt;(Arrays.asList(inArr)); ArrayList&lt;Integer&gt; numList = new ArrayList&lt;Integer&gt;(); if(inStr.get(0).equals("-"))&#123; inStr.set(1, "-"+inStr.get(1)); numList.add(0); &#125;else&#123; for (int i=1;i&lt;inStr.size();i++) &#123; if(inStr.get(i).equals("-"))&#123; if(inStr.get(i-1).matches("[\\+\\/\\-\\*\\(]"))&#123;//前一个是数字）后面可以有 inStr.set(i+1,"-"+inStr.get(i+1)); numList.add(i); &#125; &#125; &#125; &#125; ArrayList&lt;String&gt; endList = new ArrayList&lt;String&gt;(); for(int i=0;i&lt;inStr.size();i++)&#123; if(!numList.contains(i))&#123; endList.add(inStr.get(i)); &#125; &#125; return endList; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNextLine())&#123; String arthLine = scanner.nextLine(); if(arthLine.trim().length()!=0)&#123; System.out.println(postfixToResult(infixToPostfix(getExpression(arthLine)))); &#125; &#125; &#125;&#125; 兄弟单词其实如果只是有限次的变换后成为一个，那么只要判断这个两个字符串按照字典顺序排序后，是否完全一致！！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.*;public class Main&#123; public static boolean isBrother(String f,String s)&#123; if(f.equals(s)||f.length()!=s.length())&#123; return false; &#125;else&#123; ArrayList&lt;Character&gt; fList = new ArrayList&lt;Character&gt;(); ArrayList&lt;Character&gt; sList = new ArrayList&lt;Character&gt;(); for(int i=0;i&lt;f.length();i++)&#123; fList.add(f.charAt(i)); sList.add(s.charAt(i)); &#125; Collections.sort(fList); Collections.sort(sList); if(fList.equals(sList))&#123; return true; &#125;else&#123; return false; &#125; &#125; &#125; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; int num = scanner.nextInt(); ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); for(int i=0;i&lt;num;i++)&#123; list.add(scanner.next()); &#125; Collections.sort(list); String target = scanner.next(); int n = scanner.nextInt(); ArrayList&lt;String&gt; endList = new ArrayList&lt;String&gt;(); for(int i=0;i&lt;num;i++)&#123; if(isBrother(list.get(i),target))&#123; endList.add(list.get(i)); &#125; &#125; if(endList.size()==0)&#123; System.out.println(0);//没有兄弟单词的时候输出0 &#125;else if(endList.size()&lt;n)&#123; System.out.println(endList.size());//查找大于兄弟单词的时候就输出兄弟单词的个数 &#125;else&#123; System.out.println(endList.size()); System.out.println(endList.get(n-1)); &#125; &#125; &#125;&#125; Collections和Arrays的sort感觉这种排序考的很多，都是要自己去写一个比较器 1234567891011121314151617181920212223242526比如数串：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组&#123;3，32，321&#125;，则打印出这三个数字能排成的最小数字为321323。public class Solution &#123; public String PrintMinNumber(int [] numbers) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for(int i : numbers)&#123; list.add(i); &#125; Collections.sort(list,new Comparator&lt;Integer&gt;()&#123; @Override public int compare(Integer o1,Integer o2)&#123; String str1 = ""+o1+o2; String str2 = ""+o2+o1; return str1.compareTo(str2); &#125; &#125;); StringBuilder sb = new StringBuilder(); for(Integer i : list)&#123; sb.append(i); &#125; return sb.toString(); &#125;&#125; 包装类和String因为Collections.sort&lt;List&lt;T&gt;&gt;，这个方法泛型必须实现Comparable接口，也就是需要重写compareTo方法！！！ 每一个实现了Comparable的类都有自己默认的排序，所以我们在进行处理的时候，对Map进行值排序或者字符串字典降序排序的时候也就是只是在重写这个方法！！ 而对于自定义的类而言。如果我们不实现这个接口，就必须在用的时候指定比较器！！！也就是Comparator 而我们的排序集合中TreeSet，TreeMap都是可以在构造中直接写比较器的！！！这一点很重要 先看一个List(ArrayList/LinkedList)的排序 123456789101112131415161718192021222324252627282930313233343536373839public class Main&#123; public static void main(String[] args) &#123; Integer arr[] = &#123;2,5,1,3,5,2,8,5,67,7,4,9&#125;; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(arr));// Collections.sort(list);// System.out.println(list);// [1, 2, 2, 3, 4, 5, 5, 5, 7, 8, 9, 67] Collections.sort(list,new Comparator&lt;Integer&gt;()&#123; @Override public int compare(Integer o1, Integer o2) &#123; // TODO Auto-generated method stub return o2.compareTo(o1); &#125; &#125;); System.out.println(list);// [67, 9, 8, 7, 5, 5, 5, 4, 3, 2, 2, 1] &#125;&#125;public class Main&#123; public static void main(String[] args) &#123; String arr[] = &#123;"90","ndjsa","hbgdsa","jdud"&#125;; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(arr));// Collections.sort(list);// System.out.println(list);// [90, hbgdsa, jdud, ndjsa] Collections.sort(list,new Comparator&lt;String&gt;()&#123; @Override public int compare(String o1, String o2) &#123; // TODO Auto-generated method stub return o2.compareTo(o1); &#125; &#125;); System.out.println(list);// [ndjsa, jdud, hbgdsa, 90] &#125;&#125; 再看Map 我们说过，对于Map的排序，就是先排K，再排V K的顺序按照要求分为输入顺序和字典顺序（升&amp;降），这个直接使用LinkedHashMap，或者TreeMap（构造器中可以指定排序规则）V的顺序基本上就是使用Map转成List&lt;Map.Entry&gt;后，再使用Collection.sort来指定比较器 注意：这个map构造器指定比较器好像只有TreeMap有，LinkedHashMap没有 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class Main&#123; public static void main(String[] args) &#123; LinkedHashMap&lt;String,Integer&gt; map = new LinkedHashMap&lt;String, Integer&gt;(); for (int i = 10; i &lt;=18; i++) &#123; map.put(Integer.toHexString(i), i); &#125; List&lt;Map.Entry&lt;String, Integer&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;String,Integer&gt;&gt;(map.entrySet()); System.out.println(list); Collections.sort(list,new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123; @Override public int compare(Entry&lt;String, Integer&gt; o1, Entry&lt;String, Integer&gt; o2) &#123;// return o2.getValue().compareTo(o1.getValue());//按照值进行降序排// return o1.getValue().compareTo(o2.getValue());//按照值升序// return o2.getKey().compareTo(o1.getKey());//按照k降序，也就是我们字典降序 return o1.getKey().compareTo(o2.getKey());//按照k升序，也就是我们字典顺讯 &#125; &#125;); System.out.println(list); &#125;&#125;注意：TreeMap默认按照K的字典顺序排序同时构造器直接设置比较器的话有缺陷的，不能直接写成我们要的TreeMap&lt;String,Integer&gt; map = new TreeMap&lt;String, Integer&gt;(new Comparator&lt;Map.Entry&lt;String,Integer&gt;&gt;() &#123; &#125;)像上面这种直接就会报错的！！！而且只能这个构造器中的比较器只能指定Map&lt;K,V&gt;中的K作为比较器的泛型，进行升序或者降序（但是默认就是升序，所以只有用作降序的时候才这么用！！！）public class Main&#123; public static void main(String[] args) &#123; TreeMap&lt;String,Integer&gt; map = new TreeMap&lt;String, Integer&gt;(new Comparator&lt;String&gt;() &#123; @Override public int compare(String o1, String o2) &#123; return o2.compareTo(o1); &#125; &#125;); for (int i = 10; i &lt;=18; i++) &#123; map.put(Integer.toHexString(i), i); &#125;// System.out.println(map);//按照K的降序// &#123;f=15, e=14, d=13, c=12, b=11, a=10, 12=18, 11=17, 10=16&#125; &#125;&#125; 自定义的类型自己写一个类 123456789101112131415161718192021222324252627public class Emp&#123; private int empno; private String ename; public int getEmpno() &#123; return empno; &#125; public void setEmpno(int empno) &#123; this.empno = empno; &#125; public String getEname() &#123; return ename; &#125; public void setEname(String ename) &#123; this.ename = ename; &#125; public Emp(int empno, String ename) &#123; super(); this.empno = empno; this.ename = ename; &#125; @Override public String toString() &#123; return "empno:\t"+empno+"\tename:\t"+ename; &#125;&#125; 直接使用Collections.sort()排序 12345678static List&lt;Emp&gt; empList; static &#123; Emp emp1 = new Emp(2,"Guan YunChang"); Emp emp2 = new Emp(3,"Zhang Fei"); Emp emp3 = new Emp(1,"Liu Bei"); empList = Arrays.asList(emp1,emp2,emp3); &#125; 此时会报错： The method sort(List&lt;T&gt;) in the type Collections is not applicable for the arguments (List&lt;Emp&gt;) 意思是参数类型为List&lt;Emp&gt;时，sort方法无法执行，原因是泛型没有继承Comparable接口，这种方式稍后再说，我们先使用sort方法的第二种形式： 12345678910111213141516171819202122private static void sortEmpByIDefineMode() &#123; System.out.println("before sort:"); PrintUtil.showList(empList); System.out.println("========================="); Collections.sort(empList,new Comparator&lt;Emp&gt;() &#123; @Override public int compare(Emp o1, Emp o2) &#123; /*按员工编号正序排序*/ return o1.getEmpno()-o2.getEmpno(); /*按员工编号逆序排序*/ //return o2.getEmpno()-o1.getEmpno(); /*按员工姓名正序排序*/ //return o1.getEname().compareTo(o2.getEname()); /*按员工姓名逆序排序*/ //return o2.getEname().compareTo(o1.getEname()); &#125; &#125;); System.out.println("after sort:"); PrintUtil.showList(empList); &#125; 根据不同的排序方式即可呈现不同的结果。 接下来看看第一种形式的实现，首先让Emp类继承Comparable接口并重写compareTo方法（为了和上面的排序方式区别开，此次按照员工姓名逆序排列）： 12345678910111213141516171819202122232425public class Emp implements Comparable&lt;Emp&gt;&#123; /*属性、getter/setter方法、toString方法及构造方法略*/ @Override public int compareTo(Emp emp) &#123; /*按员工编号正序排序*/ //return this.getEmpno()-emp.getEmpno(); /*按员工编号逆序排序*/ //return emp.getEmpno()-this.getEmpno(); /*按员工姓名正序排序*/ //return this.getEname().compareTo(emp.getEname()); /*按员工姓名逆序排序*/ return emp.getEname().compareTo(this.getEname()); &#125;&#125;使用Collections.sor方法的第一种形式实现：private static void sortEmpByDefaultMode() &#123; System.out.println("before sort:"); PrintUtil.showList(empList); System.out.println("========================="); Collections.sort(empList); System.out.println("after sort:"); PrintUtil.showList(empList); &#125; 1.对于String或Integer这些已经实现Comparable接口的类来说，可以直接使用Collections.sort方法传入list参数来实现默认方式（正序）排序； 2.如果不想使用默认方式（正序）排序，可以通过Collections.sort传入第二个参数类型为Comparator来自定义排序规则； 3.对于自定义类型(如本例子中的Emp)，如果想使用Collections.sort的方式一进行排序，可以通过实现Comparable接口的compareTo方法来进行，如果不实现，则参考第2点； 4.jdk1.8的Comparator接口有很多新增方法，其中有个reversed()方法比较实用，是用来切换正序和逆序的，代码如下： 12345678910111213141516171819202122232425private static void sortEmpByIDefineMode()&#123; System.out.println("before sort:"); PrintUtil.showList(empList); System.out.println("========================="); Comparator&lt;Emp&gt; comparator = new Comparator&lt;Emp&gt;() &#123; @Override public int compare(Emp o1, Emp o2) &#123; /*按员工编号正序排序*/ return o1.getEmpno()-o2.getEmpno(); /*按员工编号逆序排序*/ //return o2.getEmpno()-o1.getEmpno(); /*按员工姓名正序排序*/ //return o1.getEname().compareTo(o2.getEname()); /*按员工姓名逆序排序*/ //return o2.getEname().compareTo(o1.getEname()); &#125; &#125;; /*新的逆序实现方式*/ Collections.sort(empList,comparator.reversed()); System.out.println("after sort:"); PrintUtil.showList(empList);&#125; 数串问题设有n个正整数，将他们连接成一排，组成一个最大的多位整数。 如:n=3时，3个整数13,312,343,连成的最大整数为34331213。 如:n=4时,4个整数7,13,4,246连接成的最大整数为7424613。 1234567891011121314151617181920212223242526272829import java.util.*;public class Main&#123; public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); while(scanner.hasNext())&#123; int num = scanner.nextInt(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for(int i=0;i&lt;num;i++)&#123; list.add(scanner.nextInt()); &#125; Collections.sort(list,new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; //按照两个数字字符串合并的反字典顺序排序 String first = ""+o1+o2; String second = ""+o2+o1; // return first.compareTo(second);//字典顺序 return second.compareTo(first); &#125; &#125;); StringBuilder sb = new StringBuilder(); for(Integer i : list)&#123; sb.append(i); &#125; System.out.println(sb.toString()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试（200 Questions）]]></title>
    <url>%2F2017%2F12%2F14%2FJava%E9%9D%A2%E8%AF%95%EF%BC%88200-Questions%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. Java的基本数据类型有哪些？String是不是基本数据类型？ Java的基本数据有八种四类，byte--&gt;short/char--&gt;int--&gt;long--&gt;float--&gt;double还有boolean，其中byte、short、int、long是整数类型，char是字符型，boolean布尔型，float和double是浮点型。 整数类型的默认是int(0,0l)，小数是double(0.0f,0.0d)，boolean是false，char是&apos;\u0000&apos;； 基本数据类型转换时会出现自动向上转型。 String不是基本数据类型，是一个引用类，而且是final修饰的，不可继承。 2. 一个.java源文件中是否可以包含多个类，有什么限制？ 一个.java中可以包含多个类，但是和文件名一样的必须类必须用public修饰（public只能有一个），而内部类却分为四种：成员、静态、局部、匿名。 3. Java中有没有goto？ 有，goto本来是C++中的一个关键字，Java本来就是从C++来的，所以这里就保留了这个关键字。 4. 说说&amp;和&amp;&amp;，|和|| &amp;和&amp;&amp; 两者都是遇假则假，但是&amp;两边都会去运算，而&amp;&amp;一旦左边是假，右边就不会在执行了。 |和|| 两者都是遇真则真，但是|两边都会去运算，而||一旦左边是真，右边就不会在执行了。 5. 在Java中如何跳出多重嵌套循环？ 使用break； 在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如， ok: for(int i=0;i&lt;10;i++){ for(int j=0;j&lt;10;j++){ System.out.println(“i=” + i + “,j=” + j); if(j == 5) break ok; } } 6. switch语句的作用域？ short、byte、char、int、Enum、String（JDK1.7）、int以下的包装类。 7. short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错? s1+1会把数据类型自动转成int型，int型的值肯定就能直接赋值给byte；而s1+=1；直接就把s1变成了int型，所以没有错。 8. char可不可以存储汉子，为什么？ Java中用的是Unicode编码，都是两个字节。 9. 最有效的方法算出2乘以8等于几？ 乘法运算最快的就是左移了，2&lt;&lt;3;(只有右移才有&gt;&gt;&gt;) 10. 请设计一个一百亿的计算器？ 11. 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？ 引用不能变，但是引用的对象是可以变的。 12. “==”和equals方法有什么区别？ 对于基本数据类型而言参与的&quot;==&quot;比较，比较的都是数值，而对于引用类型而言，比较的是物理地址。 基本数据类型之所以可以和其对应的包装类可以进行比较，是因为包装类在和基本数据类型比较的时候拆箱了，比如Integer用的就是intValue方法进行拆箱。 而equals，基本数据类型没有这个方法，这个方法是Object类的，对于引用数据类型比较的时候，先比较的是对象的hashCode，一旦hashCode一致，利用equals方法比较值。 也就是说两个对象相等，hashCode一定一样，而hashCode一样，两个对象却不一定一样。 一般而言hashCode()方法和equals方法需要一起重写。 13. 静态变量和实例变量？ 静态变量就是类变量，被static修饰的成员变量，可以直接通过类名引用的，而实例变量就是我们的成员变量，实例变量也就是我们必须要通过对象调用的方法。 对于类变量的个数和我们对象的个数没有关系，所有的对象都只对这个变量进行操作，而成员变量却不是，每个对象都有自己的变量。 14. 是否可从一个static方法内发出对非static方法的调用？ 不可以，静态方法不可以调用非静态方法，静态方法中不能使用非静态的成员变量。 15. Integer和int的区别？ Integer是int的包装类，int是基本数据类型，Integer作为一个类，继承了Object，有自己的方法，但是int没有自己的方法，但是Integer和int可以利用Integer中的valueOf和intValue进行拆装箱转换。 Integer的默认值是null，而int是0。 16. Math.round(11.5)等於多少? Math.round(-11.5)等於多少? Math.round(11.5)--&gt;12; Math.round(-11.5)--&gt;-11（这里一定要注意，我们round方法是负数的时候入的时候是从6入的，入完加负号） round是给内部的数字+0.5再向下取整。 17. 下面的代码有什么不妥之处? 18. 访问修饰符的权限 public无限大 protected同包，子类 default通包 private本类 19. Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型? Overload是在编译的时候体现多态，可以发生在子父类或者本类中，只和方法名还有参数列表有关。 Overload是在运行的时候体现多态，只能发生在子父类中，需要满足两同，两小，一大 两同：方法名和参数列表一致。 两小：返回值和抛出的异常变小（是被重写方法的子类或者相同） 一大：访问修饰符大于或等于被重写的方法，static也要加 注意：对于子类重写父类的静态方法，那么在调用的时候：Parent p = new Son()，p调用的还是自己的静态方法。 20. 同学贡献的一些题？ 21. 线程如何同步和通讯？ 线程之间利用synchronized加锁进行同步 22. ClassLoader如何加载class？ 23. Servlet的生命周期？ init--&gt;service--&gt;destory init：加载Servlet类对象，ServletConfig对象，配置信息。 service：根据get/post创建HttpServlet对象 destory：销毁 24. 抽象类的作用？ 抽象类就是一种概念的提取，而接口是一种行为的提取。 25. ArrayList扩容 ArrayList使用的是一种动态数组的形式进行存储，默认数组长度为10，但是可以通过构造器进行设置，一旦存入的数据到了数组末尾，对数组长度进行*1.5 倍的扩容。 26. 分层设计的好处？ 27. 序列化接口的id有什么用？ 28. StringBuilder和StringBuffer的区别？ StringBuilder是线程不安全的所以效率高，而StringBuffer是线程安全了，方法加了synchronized关键字，所以效率低。 29. hashCode方法的作用？ hashCode()方法就是为了得到对象的hash值，在集合框架中进行存储和比较的很多。 30. webservice问得很多？ 31. 什么是Java虚拟机？为什么Java被称作是”平台无关的编程语言？” Java虚拟机（Java Virtual Machine，JVM）是一个可以执行Java字节码的虚拟机进程（软件）。Java源文件（.java）能够被编译成被Java虚拟机执行的字节码文件。（.class） 字节码文件（.class）可不是直接可以在硬件平台上执行的代码，不用的硬件平台安装不同的JVM，由JVM把字节码翻译成硬件平台可以用的机器码。 所以Java源码是有平台无关性，但是JVM却和硬件平台有关。 32. JDK和JRE的区别？ JDK（Java Development Kits）：Java开发包，里面就有JRE，编译器和其他工具（JavaDoc，JavaProf，Jbd） JRE（Java Runnning Environment）：Java运行时环境。包括了JVM，Java的核心类库，支持文件。 33. static关键字是什么意思？Java中是否可以重写一个被private和static修饰的方法？ static表明一个成员变量或者成员方法可以在没有所属的类的实例变量的情况下可以被访问。 第一，为某特定数据类型或对象分配单一的存储空间，而与创建对象的个数无关。 第二，实现某个方法或属性是与类本身联系在一起，而不是与对象关联在一起。 Java中被static修饰的方法，在子类中可以重写，但是重写后并是真正意义上的覆盖了，利用多态的时候，父类对象用的还是父类的方法。 private修饰的方法也是一个道理，你重写只是代表你去new了一个新的方法，和之前父类的那个没什么关系。 34. 可以在static环境中访问非static成员吗？ 不可以，因为static环境是在类加载的时候就被初始化了，但是这个时候非static的成员还设有被创建（因为成员变量是属于对象，也不是类，对象没创建）。 35. Overload和Override的区别？ Overload和Override都是多态的表现事项，Overload是编译时多态的体现，Override是运行时多态的体现。 Overload只要求方法名一致和形参列表不同。其他的例如方法访问权限，返回值类型和抛出的异常都没有影响。 Override要求两同，两小，一大。 两同：方法名、形参列表 两小：返回值和抛出异常是被重写方法的子类或者相同。（返回值是基本数据类型时，必须相同） 一大：访问修饰符大于等于被重写的方法。 36. Java中什么是Constructor？什么是构造方法重载？什么是复制构造方法？ 在Java中构造器是用来在对象实例化时初始化对象的成员变量。构造器有很多要求： 1. 构造器必须要和类名一致，并且没有返回值。（和void不是一个改变）。 2. 构造器可以重载。 3. 构造器只能被访问修饰符修饰。 4. 构造函数的调用总是伴随着new操作，必须由系统自动调用，程序的编写者不可直接调用。 5. 构造器就是为了完成对象初始化。 6. 一个父类中没有默认无参构造器，那么子类构造器中必须显示调用，并且一定要在第一行。 7. 构造器不能被继承，也就不存在重写。 C++中支持复制构造方法，但是在Java中不支持。 37. Java支持多继承？ 不支持，只有单继承，接口可以多继承，但是一个类可以实现多个接口。写的时候先继承再实现。 38. 接口和抽象类的区别？ 相同点：接口和抽象类都不能直接实例化，接口的实现类和抽象类的子类都只有在实现了所有的抽象方法后才可以被实例化。 不同点： 1. 接口中的所有方法都是public abstract的，而抽象类中可以没有抽象方法。 2. 接口中只有public static final修饰的静态常量，而抽象类中可以有自己的普通成员变量。 3. 抽象类中可以有main方法，接口中不可以。 39. 值传递和引用传递？ 值传递是对基本数据类型而言的，传递的是这个变量值的一个副本，（在栈中）改变副本不用影响我们原变量。 引用传递是对于对象性变量而言的，传递的是该对象在堆中物理地址的一个副本，也就是把栈中的变量又copy了一份在栈中给另一个引用变量，让这个引用变量也指向了堆地址。 注意：就算是引用传递传递的是也不是原对象本身。 所以，我们在引用传递的过程中一旦只是改变了形参的指向地址，那么对形参后面的操作，都不会再影响到原来的变量。 这个原理在异常处理中也是一样的，try中的变量在finally中修饰了，也是遵循上面这个原则。 40. 进程和线程的区别？为什么使用多线程？ 进程就是一个应用程序，而线程就是这个进程内部的一个执行序列。一个进程中有多个线程。 进程是程序的一种动态形式，是CPU、内存等资源占用的基本单位，而线程是程序执行的最小单位，进程之间相互独立，不好通信，而线程直接共享一块内存区域，通信比较方便。 1. 多线程可以减少程序的响应时间。 2. 与进程相比，线程的创建和切换开销更小 3. 多CPU本来就支持多线程，可以简化程序的结构。 41. 创建线程的几种方法？ 1. 继承Thread类，不重写run()方法，执行的就是Thread的run方法 2. 实现Runnable接口，重写run()方法 3. 应用程序可以使用Executor框架来创建线程池。 4. 实现Callable接口，重写call()方法。这个方法会有一个返回值，且可以抛出异常。 42. 概括一下线程的几种可用状态。 1. 新建（New）：新建了一个线程对象。 2. 可运行（Runnable）：线程对象创建后，其他线程（比如主线程）调用了该线程对象的start方法，该线程就将状态从 new--&gt;runnable，线程本身进入可运行线程池，等待被线程调度选中，获取CPU资源。 3. 运行（Running）：Runnable的线程被线程调度选中，线程得到CPU时间片（timeslice），执行程序代码。 4. 阻塞（Block）：阻塞态是Running的线程因为某种原因放弃了CPU的使用权（让出了CPU timeslice），暂时停止运行。 直到线程从Block--&gt;Runnable，才有机会再次被线程调度选中，得到CPU timeslice。阻塞态有三种： 一、等待阻塞：Running线程调用了Object中的wait方法 二、同步线程：Running线程获取对象锁时，该锁被别的线程占用，JVM就会把线程放入锁池（Lock Pool） 三、其他阻塞：Running线程执行了Thread.sleep(long ms)或join()方法或者发出了I/O请求。当sleep状态超时， join等待线程终止或超时，或者I/O处理完毕，线程有进入Runnable 5. 死亡（Dead）：线程run()、main()方法执行结束或出现了异常退出了run()方法，则该线程结束生命周期。 死亡的线程不可再生。 43. 同步代码块和同步方法有什么区别？ 同步方法默认用this或者当前类class对象作为锁。 同步代码块可以选择用什么来加锁，比同步方法要更细颗粒度，也就是可一选择只同步会有同步问题的部分代码，而不是整个方法。 同步方法使用synchronized，而同步代码块用的是synchronized(object){代码} 44. 在监视器内部，如何做到线程同步？ 监视器和锁在JVM中一块使用，监视器监视一块同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。 45. 什么是死锁？ 多个线程要获取同一个锁而陷入相互等待的情况。这种情况下，如果没有外力，线程就无法向前推进。 46. 如何确保N个线程可以访问N个资源同时又不导致死锁？ 指定获取锁的顺序，并强制线程按照指定的顺序获取锁。 47. Java集合类框架的基本接口有哪些？ 基接口Collection，下面两个小的List和Set。Map不是Collection的子接口，三个大的接口下面都有一个Abstract的类。 48. 为什么集合类没有实现Cloneable和Serializable接口？ 克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。 49. 什么是迭代器？ Iterator接口提供了很多对集合元素进行迭代的方法。容器中的iterator()就是得到一个Iterator对象，而hasNext就判断容器中是不是还有元素，如果有用next方法可以得到下一个元素，同步remove方法进行删除。 注意，利用Iterator遍历的时候，我们可以用iterator的remove，但是不能用集合的remove，add，因为由于集合框架里面的Iterator都是fast-fail的，所以会抛出异常，同时删除的时候从前往后删，直接利用角标的话，会报角标溢出。 50. Iterator和ListIterator的区别？ Iterator对集合只能正向遍历，但是ListIterator继承自Iterator，只针对与List，既可以前向又可以后向。Iterator适合删除元素，而ListIterator有别的功能，增加，替换，前后索引的获取。 51. fail-fast和fail-safe有什么区别？ 在集合框架中所有集合的Iterator都是fail-fast的，而JUC包下的集合都是fail-safe的。fail-fast的Iterator都会抛出一个ConcurrentModificationException异常（在迭代过程中改变了集合的个数就会抛出），而fail-safe就不会抛出这种异常。 52. Java中HashMap的工作原理 HashMap使用K-V键值对来存储元素的。默认容量是16，loadfactor是0.75。内部使用数据+链表+红黑二叉树的结构在存储，在进行put操作的时候，会先对对象的K进行一个计算，得到K的hashCode，但是它不像Hashtable那样，直接用K的hashCode作为hash值，而是使用K的hashCode高8位&amp;低8位后作为hash值。一旦hash值在hash表中不存在，直接插入，如果存在再计算K的equals方法，如果不相同，形成链表，当链表长度到达8的时候，链表变成红黑二叉树。如果相同，直接进行覆盖。 53. hashCode和equals方法的重要性体现在哪？ 这两个方法都是Object中的方法，在Object中分为功能是计算对象的hash值（int）和比较对象之间的物理地址。在使用hash算法的集合框架中，通过重写这两个方法可以有利于更好的存储和获取元素。 54. HashMap和Hashtable有什么区别？ 1. HashMap是直接父类是AbstractMap，实现接口是Map，而Hashtable的父类是Dictionary，也实现了Map接口。 2. HashMap中允许出现K-V同时或者单个为null的情况，Hashtable中不允许。 3. HashMap是线程不安全的，但是效率高，而Hashtable是线程安全的，因为很多方法都使用了synchronized修饰。 4. HashMap的初始容量是16，而Hashtable是11，但是两者的load Factor都是0.75，扩容时，HashMap每次扩大2倍，而Hashtable确是*2+1倍。 5. HashMap中计算hahs值，是把K的hashCode算出来，高8位和低8位进行&amp;运算，而Hashtable却不是，是直接把K的hashCode作为hash值。 6. HashMap使用Iterator迭代，而Hashtable使用Enum迭代。 7. HashMap中没有contains方法，但是添加了containsKey和containsValue方法。 55. ArrayList和Array有什么区别？ 1. ArrayList有序列表，底层使用动态数组（Object[]），默认长度是10，扩容是1.5倍。但是集合框架中只能放对象，不能放基本数据类型，但是Array可以放基本数据类型。 2. Array是定长的，但是ArrayList不是。 56. ArrayList和LinkedList的区别？ 1. ArrayList是动态数组，LinkedList是双向链表 2. ArrayList适合随机访问，LinkedList适合增删。 57. Enumeration和Iterator接口有什么区别？ 1. Enumeration的速度是Iterator的2倍。 2. Iterator比Enumeration安全，Iterator可以删除元素，Enumeration做不到。 58. HashSet和TreeSet有什么区别？ 1. HashSet的底层是HashMap，只是把Map中的所有V都变成一个对象，那么就肯定不可以重复了，因为就只有K。HashSet是无序的，add()、remove()、contains()方法的时间复杂度都是O(1)。 2. TreeSet的底层是TreeMap，会对K进行升序排序。所以add()、remove()、contains()方法的时间复杂度是O(logn)。 59. Java中的GC是什么？什么时候进行GC？ Java中不想C++需要程序员人工的去回收内存，而是提供了一个自动回收的机制，又JVM本身来进行内存回收，而这个内存回收的时间，是由JVM自身决定的，外部无法指定JVM去回收什么，什么时候回收。 而在JVM进行回收的对象，基本都是在堆和方法区上的，主要是在堆，因为对象都在这里。一个对象在经过可达性分析后，发现对象并没有和GC Roots链接的引用链，那么我们的对象会被第一次标记，这个标记后，对象会被放入一个F-QUeue的队列中，在GC前，系统会自动调用这个对象的finalize方法，这个方法是Object中的方法，要调用这个方法，对象本类中必须进行重写，同时这个方法JVM一个对象的一生只会调用一次，一旦JVM调用了对象的finalize方法，并在方法中和引用链相连接，那么就会不会被清除，一旦没有调用，或者调用后没有链接，那么对象被标记第二次，直接被GC清除。 60. System.gc()和Runtime.gc()的功能？ 这两个方法可以通知JVM进行GC，但是，到底是立即开始还是延迟进行这个是由JVM自身决定的。 61. finalize()方法什么时候被调用？析构函数(finalization)的目的是什么？ 垃圾回收器(garbage colector)决定回收某对象时，就会运行该对象的finalize()方法 但是在Java中很不幸，如果内存总是充足的，那么垃圾回收可能永远不会进行，也就是说filalize()可能永远不被执行，显然指望它做收尾工作是靠不住的。 那么finalize()究竟是做什么的呢？它最主要的用途是回收特殊渠道申请的内存。Java程序有垃圾回收器，所以一般情况下内存问题不用程序员操心。但有一种JNI(Java Native Interface)调用non-Java程序（C或C++），finalize()的工作就是回收这部分的内存。 Java中没有析构函数，只有构造函数，析构函数的功能和构造函数相反。 62. 如果对象的引用被置为null，垃圾收集器是否会立即释放对象占用的内存？ 不会，在下一个垃圾回收周期中，这个对象将是可被回收的。 63. Java堆的结构是什么样子的？什么是堆中的永久代(Perm Gen space)? 在HotSpot中，堆可以分为新生代和老年代，而新生代又可以细分为一个Eden和两个Survivor。对象被new出来基本都是在Eden中，除非这个时候Eden中没有足够的连续内存空间，才会被直接new到老年代。 而永久代其实就是方法区。方法区里面有运行时常量池，本来字符串常池也在里面，JDK1.7以后就被移除了。永久代里面放的都是静态文件。 64. 串行(serial)收集器和吞吐量(throughput)收集器的区别是什么？ 两个都是新生代的GCor，Serial是一个单线程的收集器，在它进行GC时，所有的线程必须停止（STW），直到收集结束。虽然GC停顿，一直都会发生。 Parallel Scavenge就和ParNew很像，ParNew就是Serial的多线程版本，而Parallel Scanvenge更偏向于达到一个可控制的吞吐量，而其他的GCor关注点在于尽可能缩短GC时GC停顿的时间。 吞吐量=运行用户代码时间/（运行用户代码时间+GC时间） 新生代的GCor都是用复制算法，而老年代的Gcor只有CMS是标记-清除，其他两个是标记-整理。G1就比较厉害了。新老通吃。 65. Java中的两种异常类型是什么？他们有什么区别？ 受检异常和非受检异常。 所有的异常都是Throwable子类，分为Error，Exception。如果只从Exception中分的话，RuntimeException和其子类都是非受检异常，其他的都是受检异常。 受检异常需要被throws在方法或者构造器上抛出，在语句中与throw抛出异常对象。而非受检异常不用。 64. throw和throws的区别？ throw在方法体中使用用于明确的抛出一个异常对象，而throws在方法声明上使用，用来表明这个异常本方法处理不了。 65. 异常处理完成以后，Exception对象会发生什么变化？ Exception对象会在下一个垃圾回收过程中被回收掉。 66. finally代码块和finalize()方法有什么区别？ finally代码块是异常中的语句，try不能单独使用，必须要有catch或者finally代码块，fianlly代码块一定会被执行，除非在进入try块前就出现了异常，或者try/catch执行中遇到了System.exit()方法，同时，finally中return会覆盖try/catch中的return。但是！！finally中的代码块对基本数据类型和对象的传递遵从值传递和引用传递的规则。 finalize()是Objcet类的一个protected方法，它会在对象被标记第一次被放入F-Queue后被JVM自己调用（第一执行和本类重写），这个方法是对象重生的最后一次机会。 67. 什么是Applet？ java applet是能够被包含在HTML页面中并且能被启用了java的客户端浏览器执行的程序。Applet主要用来创建动态交互的web应用程序。 68. 解释一下Applet的生命周期？ applet可以经历下面的状态： Init：每次被载入的时候都会被初始化。 Start：开始执行applet。 Paint：绘制。 Stop：结束执行applet。 Destroy：卸载applet之前，做最后的清理工作。 69. 当applet被载入的时候会发生什么？ 首先，创建applet控制类的实例，然后初始化applet，最后开始运行。 70. Applet和普通的Java应用程序有什么区别？ ava应用程序需要一个有特定方法签名的main函数来开始执行。Java applet不需要这样的函数来开始执行。 71. 什么是JDBC？ Java DataBase Connection，Java数据库连接池。 72. 解释下驱动(Driver)在JDBC中的角色？ JDBC驱动提供了特定厂商对JDBC API接口类的实现，驱动必须要提供java.sql包下面这些类的实现：Connection, Statement, PreparedStatement,CallableStatement, ResultSet和Driver。 73. Class.forName()方法有什么作用？ 初始化参数指定的类，并且返回此类对应的Class对象。返回一个与带有给定字符串名的类或接口相关的Class对象，其实就是把这个Class类加载到JVM中。 Test t = (Test)Class.forName(&quot;Test&quot;).newInstance(); Test t = new Test(); 74. PreparedStatement/Statement/CallableStatement？ Statement是PreparedStatement的父类，PreparedStatement是CallableStatement的父类。 Statement:执行不带参数的SQL语句，没执行，SQL都需要数据库自己编译。 PreparedStatement：预编译，同时执行带参数的SQL语句。 CallableStatement：提供了用来调用数据库中存储过程的接口，预编译，带参查询。用来执行存储过程。存储过程是由数据库存储和提供的。存储过程可以接受输入参数，也可以有返回结果。非常鼓励使用存储过程，因为它提供了安全性和模块化。准备一个CallableStatement的方法是： CallableStatement Connection.prepareCall(); 75. 什么是序列化？ 就是把一个对象变成一连串的字节，里面包含了对象的数据，类型信息，对象内部的数据类型信息等等。因此，序列化可以看成是为了把对象存储在磁盘上或者从磁盘上读取并创建对象而把对象扁平化的一种方式。 要实现序列化的类都必须实现Serialization接口，这个接口在java.lang.*下，没有任何方法。 使用一个输出流来构造ObjectOutputStream对象，接着，使用这个对象的writeObject方法将我们要写出的对象的写出，需要恢复的时候再使用对应的输入流。 序列化有两个特点： 1. 如果一个类可以被序列化，那么这个类的子类也可以。 2. 一个类中被static和transient修饰的成员不能被序列化。但是这个成员变量还在，只是值就是默认值了。 76. 多态的定义？ 多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。 77. 继承的定义？ 继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用行，也可以在不修改类的情况下给现存的类添加新特性。 78. 抽象的定义？抽象和封装的不同点？ 抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。Java支持创建只暴漏接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。 抽象和封装是互补的概念。一方面，抽象关注对象的行为。另一方面，封装关注对象行为的细节。一般是通过隐藏对象内部状态信息做到封装，因此，封装可以看成是用来提供抽象的一种策略。 79. Math中的round、floor、ceil有什么区别？ round:加0.5向下取整，注意，这个返回的是int/long。0 floor:向下取整，小于原来的数。返回double。-0.0 ceil:向上取整，大于原来的数。返回double。 80. synchronized和volatile？ synchronized：实现了可见性和原子性。 volatile：只实现了可见性。就是每次得到值的时候，让从内存中取，而不是在缓存区获取。 81. 标识符命名规则？ 1. 字母，数字，符号（_和$，没有*，没有空格，没有&amp;，只有两个） 2. 数字不能开头。 3. 不能用关键字，false，null，true都不是关键字，是常量，但是也不能用！！！ 82. 面向对象开发的六个基本原则 单一职责：一个类只做它该做的事情（高内聚）。 开放封闭：软件实体应当对扩展开放，对修改关闭。 里氏替换：任何时候都可以使用子类把父类替换掉。 依赖倒置：面向接口编程。 合成聚和复用：优先使用聚合或合成关系复用代码。 接口隔离：接口要小而专，决不能大而全。 83. Java序列化，如何实现序列化和反序列化，常见的序列化协议有哪些？ 实现了Serializable接口的对象转换成一个字节序列，并能够在以后将这个字节序列完全恢复为原来的对象，序列化可以弥补不同操作系统之间的差异。 序列化时，对象的类名、属性都会被序列化（除了static和transient修饰的属性），方法不会被序列化 84. HashMap&amp;Hashtable&amp;ConcurrentHashMap的区别？ 在HashMap的基础上，ConcurrentHashMap将数据分为了多个segment，默认是16个，每次操作对一个segment加锁，避免多线程锁 的概率，提高并发效率。 在多线程环境下，使用HashMap进行put操作会造成死循环，而Hashtable中几乎所有方法都使用了synchronized来保证线程安全，但 是这样做效率很低。因为当一个线程需要访问Hashtable的时候，可能会进入阻塞，比如，线程一使用put时，线程二不但不能 使用put方法，而且不能使用get方法。 Hashtable这么慢就是因为所有的访问都必须要竞争同一把锁，那么如果我们的容器中有多把锁，每把锁只用于锁其中的一部分数据， 那么当多线程访问容器里不同数据段的数据时，线程之间就不会存在锁的竞争，这也就是ConcurrentHashMap中使用的锁分段技术， 首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他 线程访问。但是有的方法是需要跨段的，比如size和containsValue（），它们的话可能就需要锁定整个表而不是某一个段， 这需要按顺序锁定所有段，操作完之后，又按顺序释放所有段的锁。在ConcurrentHashMap中，段数组是final的。 ConcurrentHashMap中是有Segment数组结构和HashEntry数组结构组成的。Segment是一种可重入锁ReentrantLock， 在ConcurrentHashMap中扮演着锁的角色，HashEntry则使用数据+链表的形式进行存储键值对（1.8之后也是Node&lt;K,V&gt;,红黑二叉树）。 Hashtable的任何操作都会把整个表锁住，是阻塞的。好处是总能获取最实时的更新，比如说线程A调用putAll写入大量数据， 期间线程B调用get，线程B就会被阻塞，直到线程A完成putAll，因此线程B肯定能获取到线程A写入的完整数据。坏处是所有调 用都要排队，效率较低。 ConcurrentHashMap 是设计为非阻塞的。在更新时会局部锁住某部分数据，但不会把整个表都锁住。同步读取操作则是完全非阻塞的。 好处是在保证合理的同步前提下，效率很高。坏处 是严格来说读取操作不能保证反映最近的更新。例如线程A调用putAll写入大量数据， 期间线程B调用get，则只能get到目前为止已经顺利插入的部分 数据。此外，使用默认构造器创建的ConcurrentHashMap 比较占内存，如果程序需要创建巨量ConcurrentHashMap，应该在构造 时指定concurrencyLevel。 concurrencyLevel的作用就是用来计算segments数组的容量大小。 85. ThreadLocal的设计原理和作用 86. ThreadPool用法和优势 87. foreach和正常for的区别 88. Java IO和NIO 89. 反射的作用与原理 90. 泛型擦除机制，List是否可以转为List 91. Minor GC和Minor GC发生在什么时候？ 92. Collections和Arays中的排序有什么区别？]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试（杂-2）]]></title>
    <url>%2F2017%2F12%2F13%2FJava%E9%9D%A2%E8%AF%95%EF%BC%88%E6%9D%82-2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节复习了：1. JDK中的工具；2. JDK &amp; JRE；3. Struts1 &amp; Struts2； 4. Servlet生命周； 5. 跟踪会话技术的实现手段； 6. Object类的方法； 7. 字节流和字符流的基础； 8. 杂的知识点；9.Java修饰符； 10. 基本数据类型的默认值； 11. 内部类的区别； 12. Java中的关键字； 13. floor &amp; ceil &amp; round； 14. for &amp; switch； 15. 关于子父类中重写方法的区别，静态方法和非静态方法; 16. 事务的属性的种类； 17. 运算符优先级 18. 子父类静态块、Main方法、构造块、构造方法执行顺序； 19. 静态与非静态调用 java工具1. jar 将许多文件组合成一个jar文件 2. javac 编译器 3. javadoc 从程序源码中抽取类、方法、成员等注释形成一个和源代码配套的API帮助文档。 4. javah 把java代码声明的JNI(Java Native Interface)方法转换成C/C++头文件。 5. java.exe 执行编号好的.class文件 6. jdb.exe Java调试器 7. javaprof.exe 剖析工具 JDK &amp; JRE JRE（Java Runtime Environment），Java程序的运行环境 JDK（Java Development Kit），Java的开发工具包，包含了JRE，各种类库和工具 JDK是Java开发工具，不仅包含了Java程序运行的JRE，还提供了一系列编译，运行等工具，如javac,java,javaw等，JRE只是Java程序的运行环境，它最核心的就是JVM和Java的核心类库。 如果只是想运行Java程序，有JRE就可以了，但是要编写，就要有JDK Struts1 &amp; Struts2Action类 1. Struts1中Action类要求继承一个抽象基类。 2. Struts2中Action类可以实现一个Action接口，但是不是必须的。（ActionSupport） 线程模式 1. Struts1 Action是单例模式，要求线程安全。（Action资源必须是线程安全的或同步的） 2. Struts2 Action为每一个请求产生一个实例，因此没有线程安全问题。 Servlet依赖 1. Struts1 Action依赖Servlet API， 2. Struts2 Action不依赖容器 表达式语言 1. Struts1 整合了JSTL（JavaServer Pages Standard Tag Library - JSP标准标签库） 2. Struts2 不但有JSTL，还有OGNL（Object Graph Navigation Language - 对象图导航语言） synchronized &amp; volatilesynchronized支持可见性和原子性，volatile只支持可见性。 JDK1.8以上支持的锁1. 自旋锁 2. 自旋锁的其他种类 3. 阻塞锁 4. 可重入锁 一个线程可以多次进入同一个锁。ReentrantLock 5. 读写锁 多个读可以并行，但是写是互斥的，写优先于读 6. 互斥锁 一次只能有一个线程拥有锁 7. 悲观锁 修改数据时加锁，认为只要修改就有别的线程来打扰 8. 乐观锁 修改数据时不加锁，认为修改的时候不会有线程来打扰 9. 公平锁 哪个线程先运行，就先得到锁 10. 非公平锁 和线程运行顺序无关，都是随机获得锁 11. 对象锁 12. 线程锁 13. 偏向锁 14. 锁粗话 15. 锁消除 16. 锁膨胀 17. 信号量 18. 轻量级锁 Servlet生命周期 每一次请求来到容器时，会产生HttpServletRequest与HttpServlceResponse对象，并在调用service()方法时当做参数传入。 实现会话跟踪1. 隐藏表单域：&lt;input type=&quot;hidden&quot;&gt;，非常适合不需要大量数据存储的会话引用。 2. URL重写：URL可以在后面附加参数，和服务器的请求一起发送 3. Cookie 4. Session Object类中的方法1. clone：实现对象的浅复制，只有这个类实现了Cloneable接口才能用这个方法，否则会抛出CloneNotSupportedException。 2. getClass：final方法，获得运行时类型对象名。包名+类名 3. toString 4. hashCode：得到对象的hashCode 5. equals：比较，一般和hashCode一起用，都需要重写。 6. finalize：对象经过可达性分析后，和GC Roots没有引用链，被标记一次，放入F-Queue，对象执行这个方法（被本类重写且第一次执行），如果方法内让被标记对象得到引用，则对象被移除被GC清理的集合，否则，对象被标记第二次，直接就被GC。 7. wait：等待，抛出InterruptedException，释放锁。 8. notify：唤醒调用这个方法的对象上的等待某个线程。 9. notifyAll：唤醒调用这个方法的对象上等待的所有线程。 在Object方法中，hashCode()和equals()基本上就用来判断两个对象是否相等的。而wait、notify、notifyAll就是线程方法。 而在JDK1.5中，出现了Condition，这个类就是用来替代Object的这三个方法，await、signal、signalAll， for循环和switch的执行顺序forfor(语句一；语句二；语句三) 执行语句一，判断语句二的条件是不是满足，满足就执行for的循环体，不满足就不进入for，执行完循环体，语句三可以执行，执行完后又开始执行语句二判断条件。 语句三的执行次数和循环体执行次数一样，但是语句二要多一次 switch…case123456789101112131415161718192021222324252627public class Test&#123; public static void main(String[] args)&#123; int x=2; switch(x)&#123; case 1: System.out.println(1); case 5: System.out.println(5); case 2: System.out.println(2); default: System.out.println("00"); case 3: System.out.println(3); case 4: System.out.println(4); &#125; System.out.println("end"); &#125;&#125;/** 2 00 3 4 end*/ switch(x)，x会从第一个往下找，一旦找到了就顺序执行了，一旦没有找到，而且有default，那么就从default开始顺序执行。 一旦遇到了break，直接跳出。 switch中的x支持int往后的基本数据类型（byte、char/short、int），boolean，枚举，String(JDK1.7以后)，一些包装类（Character、Integer、Byte、Short） Java中的关键字关键字都是小写，false，true是boolean常量，null是null常量也不是关键字 基本数据类型的默认值只有long和double是64位，8个字节；int和float都是4个字节，32位，一个字节8个bits位 八种基本数据类型被分为四类： 1. 整数类型：byte、short、int、long 2. 浮点类型：float、double 3. 逻辑类型：boolean 4. 字符类型：char 线程状态转换 round() &amp; ceil() &amp; floor()**floor()返回不大于的最大整数（double），取小的** **ceil()返回不小于的最小整数（double），取大的** **round()四舍五入，入的时候是到大于它的整数！！！（int、long）** 12345678910111213141516171819202122232425262728293031323334353637public class Test extends Parent&#123; public static void main(String arg[]) &#123; System.out.println(Math.round(-0.4)); System.out.println(Math.round(-1.4)); System.out.println(Math.round(-1.6)); System.out.println(Math.ceil(-0.4)); System.out.println(Math.ceil(-1.4)); System.out.println(Math.floor(-0.4)); System.out.println(Math.floor(-1.4)); System.out.println("--------------"); System.out.println(Math.round(0.4)); System.out.println(Math.round(1.4)); System.out.println(Math.round(-1.4)); System.out.println(Math.ceil(0.4)); System.out.println(Math.floor(0.4)); &#125;&#125;/** Math.round(-1.4)：-1 Math.round(-1.6)：-2 Math.ceil(-0.4)：-0.0 Math.ceil(-1.4)：-1.0 Math.floor(-0.4)：-1.0 Math.floor(-1.4)：-2.0 -------------- Math.round(0.4)：0 Math.round(1.4)：1 Math.round(-1.4)：-1 Math.ceil(0.4)：1.0 Math.floor(0.4)：0.0 Math.floor(2.5)：2.0*/ 运算符优先级 Java修饰符变量类中的成员变量或者类变量（成员变量加了static） public static final int N = 0;//abstract不能修饰变量 成员变量都是默认值的，引用为null，基本数据类型为0，0.0f，0.0d，fasle，&apos;\u0000&apos; 类中的局部变量 局部变量不能被访问修饰符、static修饰，只能被final修饰。 局部变量没有默认值，必须在第一次运算前初始化。 接口中的变量 接口中没有普通成员变量，只有静态常量，可以写成int n=0;但是默认会加上public static final 方法方法可以被任何修饰符限定，唯一要注意的就是abstract和final or static or private不能一起修饰一个方法 构造方法也可以被访问修饰符修饰，但是不能被除了这四种之外的修饰符修饰 类外部类：只能被public修饰或者不写，被public修饰的类必须和.java的文件名一致 内部类：静态、成员内部类可以被访问修饰符修饰，局部的不能被访问修饰符修饰，匿名的连名字都不会有 代码块代码块不能被任何修饰符修饰（除了静态代码块被static修饰和同步块synchronized） 内部类成员内部类（一般意义上的内部类）直接写在一个类中，可以访问它的外部类的所有成员变量和方法 OutClass.InnerClass inner = new OutClass().new InnerClass() 静态内部类（加了static的成员内部类）只能访问外部类中的静态成员变量和静态方法（）也就是类变量和类方法 OutClass.InnerClass inner = new OutClass.InnerClass() 局部内部类局部内部类不能被修饰符修饰，除了final，被定义在方法内，但是可以访问外部类的所有成员变量和方法内部被final修饰的局部变量 匿名内部类不能使用class、extends、implement，没有构造器，匿名内部类隐式的继承了一个父类或者实现了一个接口。 重写的特殊性多态的表现形式在编译期是重载（本类或者子父类），运行期是重写（子父类） 但是在重写的时候，我们调用的话就会有一个重写的区别 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package test;class Parent&#123; public static int num = 0; public int tt = 0; public static void function()&#123; System.out.println("父类"); &#125; public void fun()&#123; System.out.println("----"); &#125; &#125;public class Test extends Parent&#123; public static void main(String arg[]) &#123; Parent p = new Test(); p.function(); p.fun(); System.out.println(num); &#125; public static void function()&#123; System.out.println("子类"); &#125; public void fun()&#123; System.out.println(tt); System.out.println(super.tt); System.out.println("++++"); &#125;&#125;/** 父类 99.0 99.0 ++++ 0.0说明：我们子类对父类方法的重写，如果重写的是一个静态方法，那么调用的时候啊还是调用了父类中的方法，但是如果不是静态方法，调用的就是子类中的方法。也就是说其实对静态方法而言，重写并不说把这个方法直接给不要了，而是隐藏，但是一旦是父类的引用调用，那么还是要执行父类的方法的。还要说明的是，子类对于父类的数据域就是全继承，不过对于private修饰的成员，只有继承权没有使用权，这里要注意，还有就是父类的静态到子类中直接用的时候还是静态，非静态还是非静态，不能在静态方法内用了父类非静态的成员，同时静态方法内也不能出现this.super.*/ 事务属性的种类事务的传播 事务的隔离级别 二进制码型的运算字节流 &amp; 字符流字节流都是用Stream结尾的。 子父类静态块、Main方法、构造块、构造器的执行顺序执行顺序：父类静态块–&gt;子类静态块–&gt;Main方法–&gt;父类构造块–&gt;父类指定构造器–&gt;子类构造块–&gt;子类指定构造器 注意：我们子类的构造器默认第一行就是一个super(),指定的就是父类的无参构造器，可是一旦父类中没有这个无参构造，那么在子类中必须显式的调用父类的指定构造器！！！ 注意：我们的构造块和构造方法，其实只有在创建对象的时候才会被调用，而静态块是在class加载进内存的时候就会被执行，所以肯定是先加载父类再加载子类！！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Parent&#123; static&#123; System.out.println("父类静态块--1"); &#125; &#123; System.out.println("父类构造块--1"); &#125; static&#123; System.out.println("父类静态块--2"); &#125; &#123; System.out.println("父类构造块--2"); &#125; public Parent()&#123; System.out.println("父类无参构造"); &#125; public Parent(String name)&#123; System.out.println("父类有参构造..."+name); &#125;&#125;public class Son extends Parent&#123; static&#123; System.out.println("子类静态块--1"); &#125; &#123; System.out.println("子类构造块--1"); &#125; public Son()&#123; System.out.println("子类无参构造"); &#125; public Son(String name)&#123;// super();// this(); System.out.println("子类有参构造..."+name); &#125; public static void main(String[] args) &#123; System.out.println("Main方法开始"); new Son("Jerry"); System.out.println("Main方法结束"); &#125; static&#123; System.out.println("子类静态块--2"); &#125; &#123; System.out.println("子类构造块--1"); &#125;&#125;/** 父类静态块--1 父类静态块--2 子类静态块--1 子类静态块--2 Main方法开始 父类构造块--1 父类构造块--2 父类无参构造 子类构造块--1 子类构造块--1 子类有参构造...Jerry Main方法结束*/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class Parent&#123; static&#123; System.out.println("父类静态块--1"); &#125; &#123; System.out.println("父类构造块--1"); &#125; static&#123; System.out.println("父类静态块--2"); &#125; &#123; System.out.println("父类构造块--2"); &#125; public Parent()&#123; System.out.println("父类无参构造"); &#125; public Parent(String name)&#123; System.out.println("父类有参构造..."+name); &#125;&#125;public class Son extends Parent&#123; static&#123; System.out.println("子类静态块--1"); &#125; &#123; System.out.println("子类构造块--1"); &#125; public Son()&#123; System.out.println("子类无参构造"); &#125; public Son(String name)&#123;// super();// this(); System.out.println("子类有参构造..."+name); &#125; public static void main(String[] args) &#123; System.out.println("Main方法开始");// new Son("Jerry"); new Parent(); System.out.println("Main方法结束"); &#125; static&#123; System.out.println("子类静态块--2"); &#125; &#123; System.out.println("子类构造块--1"); &#125;&#125;/** 父类静态块--1 父类静态块--2 子类静态块--1 子类静态块--2 Main方法开始 父类构造块--1 父类构造块--2 父类无参构造 Main方法结束*/ 静态和非静态的调用因为静态static修饰的东西属于类的东西，在class加载进JVM的时候就已经被初始化了，而其他的只有在用的时候才会初始化，所以静态修饰的东西可以在非静态中用，而非静态的东西却不能在静态方法里面用！！！ 注意：我们在静态方法重写的时候，一旦这个方法是一个类方法，那么子类并不能真正意义上的重写，虽然方法完全一样，但是在实例调用的时候，利用多态没有用，编译和运行看的都是左边的类名 123456789101112131415161718192021222324252627282930class Parent&#123; public Parent()&#123; System.out.println("父类无参构造"); &#125; public static void function()&#123; System.out.println("Parent--Function"); &#125;&#125;public class Son extends Parent&#123; public static void main(String[] args) &#123; Parent p = new Son(); Parent pp = new Parent(); Son s = new Son(); p.function(); pp.function(); s.function(); &#125; public static void function()&#123; System.out.println("Son--Function"); &#125;&#125;/** Parent--Function Parent--Function Son--Function*/ 杂1. 方法之间不能称之为继承，最多是显式、隐式调用。 2. 构造方法不需要同步。构造方法每次都是构造出新的对象，不存在多个线程同时读写同一个对象中的属性问题。 3. 只要父类中的方法不是final修饰，其他修饰符修饰，子类都可以覆盖。 4. ServletContext：Servlet容器在启动时会加载web应用，并为每一个web应用创建唯一的ServletContext对象，在 ServletContext中存放共享数据，因为和这个对象是一个真正的全局对象，整个web应用只有唯一的一个ServletContext对象。 5. ServletConfig：用于封装Servlet的配置信息。 6. 构造方法的主要作用是完成对类的对象的初始化工作。 7. 一般在创建（new）新的对象的时候，系统会自动调用构造方法。 8. 两个基本数据类型进行二元操作时，基本数据类型之间会自动向上转型，而byte、short在运算的时候会自动直接成为int进行计算。 9. 创建对象的时候只有在new和反射的过程才会调用构造方法。下面是四种创建对象的方式： 调用Java.io.ObjectInputStream的readObject方法（序列化对象，从文件中还原对象） 调用对象的clone()方法（克隆，拷贝对象） java反射机制使用java.lang.Class或java.lang.reflect.Constructor的newInstance()方法 new语句创建对象 10. 枚举类：所有的枚举值都是类静态常量，在初始化时会对所有的枚举值对象进行第一次初始化。 11. Java中的所有方法都必须定义在类中。 12. Servlet和CGI，调用一个CGI程序的时候，服务器就要启动一个进程。而Servlet时却不是；而CGI不具备平台无关性 （CGI的不可移植性），系统环境一旦变化，CGI就瘫痪了，而Servlet却不是这样的。 13. ServerSocket(int port)：服务器绑定port端口，调用accept()监听等待客户端调用，它返回的是一个连接队列中的一个 socket。 Socket(inetAddress address，int port)是创建客户端连接主机的socket流， 14. 在Java中，对于不再使用的内存资源是有GC进行自动回收，但是GC作用实在方法区和堆上的，像调用完一个方法这种只是在栈中， 利用栈帧进行出入栈的操作，不要GC释放。 15. 常用的Servlet包：javax.servlet、javx.servlet.http 16. 不考虑反射机制，一个子类显式调用父类的构造器必须用super(x)/super()/...，如果子类的构造器中没有显式的调用父类的 构造方法，那么默认是super()，但是一旦这个时候父类中没有无参的构造器，直接就报错了。 17. 客户端通过new Socket()方法创建通信的Secket对象 18. 服务端通过new ServerSocket()创建TCP链接对象 accept接受客户端请求。 19. 一个Java源文件(.java)中定义几个类和接口，则编译后就会产生几个以类名.class为后缀名的字节码文件。 如果是普通内部类：外部类名 + $ + 内部类名 [+ $ + 内部类名 + ...]+ .class，类名之间使用符号$隔开。 ClassD$ClassDd$ClassDdd.class 如果是匿名内部类： 外部类名 + $ + 数字 [+ $ + 数字 + ...]+ .class，ClassE$1$1.class 20. 常用的ASCII码值： 空格：32；0-9：48-57；大写字母65-90；小写字母=大写字母+32 21. Scoket中得到本地IP：getLocalAddress();连接IP：getInetAddress(); 22. Math.cos、sin的形参都是弧度值。 23. 对于float和long而言，基本数据类型的时候后面可以不见f和l，但是如果是包装类，就一定要加。 24. 基本数据类型中boolean不能和其他几种进行转换。 25. long test=012这种格式是对的。 26. 构造方法不能被static、final、synchronized、abstract、native修饰，但是可以被public、private protected修饰。 27. 构造方式不是类的成员方法。 28. 子类中调用父类构造函数不可以直接书写父类构造函数，而应该用super()。 29. valueOf是把String或者基本数据类型转成对应的包装类！！这个方法有三个重载，其中一个可以对String的转换进制进行设置！！！ 这是一个静态方法。（装箱方法） 30. intValue()这是拆箱的方法，intValue()可不是静态方法; 31. parseInt是把String变成了Integer 32. transient是反序列化 33. 注意，在我们的接口中我们的变量可以写成是int i=0；会直接默认被public static final 修饰， 但是不能改成private int i=0;这样就直接报错了。 34. 编码格式由浏览器决定。 35. 注意，不管是值传递还是引用传递，我们其实传的都是副本，对于值传递而言（基本数据类型），根本不会影响传之前的数据， 但是对于引用类型，如果我们在方法内并没有的引用的实体，也就是这个对象的内部属性进行修改，而只是给这个copy的引用给了一个 新的地址（也就是重新new或者直接把一个相同/相容的对象给它），那么对传之前的对象也不会有任何影响！！！ 36. java是强类型的语言，而JavaScript是弱类型的。 37. SQL语言又被称为结构化查询语言。 38. J2EE中，当把来自客户机的HTTP请求委托给servlet时，会调用HttpServlet的service方法。 39. 子类可以访问父类的public、protected成员。 40. java.lang.*中被final修饰的类 基本数据类型的包装类，Math，String，StringBuilder、StringBuffer，System Compile、Void、Class&lt;T&gt;、ProcessBuilder、StrictMath 41. System是java.lang中的类，out为System中的一个静态成员，out是java.io.PrintStream类的对象，而println()是 java.io.PrintStream类的方法，所有可以调用类.静态方法.println()方法。 42. 子类并不能访问父类中被private修饰了的变量和方法，不管是不是加了static的。 43. 线程局部存储（TLS Thread Local Storage）解决了多线程中对同一个变量的访问冲突的一种技术，TLS会为每一个线程维护 一个和该线程绑定的变量的副本，而ThreadLocal(lang包下)就是这个技术的实现。 44. 事物隔离级别由数据库系统实现，是数据库系统本身的一个功能。 45. 日志的级别之间的大小关系如右所示：ALL &lt; TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL &lt; OFF Log4j建议只使 用四个级别，优先级从高到低分别是 ERROR &gt; WARN &gt; INFO &gt; DEBUG。 log4j在运行期间是不可以重新设置的。 log4j支持设置时间间隔去打印 46. 进程对管道进行读写都可能被阻塞，管道并不能实现双向数据传输，管道在内存中，可以有多个进程对管道进行读写，只不过不能是同步的。 47. java是支持TCP/IP协议的。 48. Java程序使用赋值运算符进行对象赋值时，只是改变了其中一个引用方向，并不是说得到了两个完全相同的对象。 49. Java的屏幕坐标是以像素为单位，容器的左下角被确定为坐标的起点。 50. 局部内部类可以看成是一个局部变量，所以它不能加任何访问修饰符，static，abstract，最多也就加的final，但是内部 类可不是这样的，内部类（成员内部类）这可就是访问修饰符都可以加，但是外部类只能用public或者不写。 51. 通过反射可以看出来子类可以继承父类的所有成员（成员变量和成员方法，包括private），只不过子类只有继承权没有使用权。 52. static为成员变量或函数，在类初始化是加载完成，可以被成员函数调用或访问。 53. 虚函数是C++中的，虚函数不可能是static的 54. const和goto是保留关键字。true和false看起来像关键字，但严格来说，它们是boolean常量；null看起来也像关键字，但 严格来说，它是null常量。 综上，true,false,null不是关键字。而是常量。同时关键字一定是小写的。 55. 事件处理模型是一种人机交互模型：事件源、事件、事件监听器。 56. 在函数代码小，频繁调用情况下适合采用内联函数。 57. 8进制的第一个符号是字母O不是数字0 58. 单例模式中，两个基本要点是构造函数私有化&amp;唯一实例和单子类自己提供单例。 59. 注意，在继承和实现都有的时候，先继承后实现！！！ public class A extends B implements C,D 60. 匿名内部类没有名字，而构造方法的方法名需要和类名一致，所以匿名内部类没有构造器。 61. 使用匿名内部类的时候，必须继承一个类或者实现一个接口，而匿名内部类中不能含有静态成员变量和静态方法。 62. 字节流都用Stream结尾，字符流都是reader或者writer。 63. 0的ASCII是48，A的ASCII是65 64. final和static一起用的时候不分前后 65. java语言中成员方法是对象的成员，类方法才术语类的成员。 66. Java中对于文本文件和二进制文件，都可以当做二进制文件进行操作。 67. 不能定义 float = 1.0；这样的东西，因为浮点型默认就是double的，必须强转！！！ 68. 构造方法相互调用的时候，要么是this(a,b)，要么就要用new Base(a,b); 69. 无法直接调用静态初始块，也就是说在程序中，用户并不能控制静态代码块的执行时间 70. 在创建第一个实例前或引用任何静态成员之前，将自动调用静态初始化块来初始化。 71. 静态初始化块既没有访问修饰符，也没有参数。 72. 成员变量存放在堆中，而方法的局部变量都在栈中 73. 对于final修饰的变量，必须初始化，不能有默认值的形式！！！ 74. LinkedBlockingQueue是一个可选有界队列（FIFO），不允许有null值，线程安全的！ 76. PriorityQueue是一个无界队列，不允许null值，入队和出队的时间复杂度都是O(log(n))，线程不安全。有blocking是线程安全。 77. JDK提供的用于并发编程的同步器有Semaphore、CyclicBarrier、CountDownLatch。 78. StringBuilder中sb.capacity()说的是内部动态数组的大小，而length说的是实际存储的字符串的长度。 79. Swing是在AWT的基础上构建的一套新的图形界面系统，它提供了AWT能提供的所有功能,并且用纯粹的Java代码对AWT 的功能进行了大幅度的扩充.但是AWT是基于本地方法的C/C++程序，其运行速度比较快。 同时SWT是基于Java的跨平台MVC框架。使用单线程模式，Swing是一个基于组件的框架，所有的组件都是从javax.swing.JComponent中来的。 80. true false null是boolean常量和null常量，但是goto是关键字 81.再说一个内部类，这个概念记错好几次，一般的内部类也就是成员内部类，这就是个成员变量；静态内部类，就是个类变量；这两个符合一切各自的性质；局部内部类，这就个局部变量，局部变量明白吗！！！局部变量不能用public、protected、private、static修饰！！！只能访问方法中final类型的局部变量！！！这个很重要；匿名内部类，这个类连个名字都没有，这个类基本撒都不能修饰，但是前面一定有个new，不然这个类咋来。 83. 注意，我们一个类不管是继承抽象类还是实现接口，对抽象类和接口中方法就是重写，方法符合重写的两同两小一大就可以 84. 构造方法不能被static、final、synchronized、abstract、native修饰，但可以被public、private、protected修饰 85. 存根和动态链接有关 86.]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试（垃圾回收与内存分配 基础）]]></title>
    <url>%2F2017%2F12%2F11%2FJava%E9%9D%A2%E8%AF%95%EF%BC%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E5%9F%BA%E7%A1%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节复习了JVM内存的内部结构，GC的原理，GC的基本配置 Java内存区域JVM运行时数据区域 程序计数器： 记录当前线程所执行的字节码的行号指示器。 在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 线程切换后能恢复到正确的执行位置，就是因为这个，每个线程都有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。 虚拟机栈：与程序计数器一样，虚拟机栈也是线程私有的，生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的时候都会创建一个栈帧，这个栈帧用来存储局部变量表、动态链接等信息。 每个方法从调用直到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 局部变量表存放了编译期就可知的八种基本数据类型、对象引用和returnAddress类型（指向一条字节码指令的地址）。局部变量表所需的内存空间在编译期间完成分配，long和double占两个变量空间，其他的都占一个，所以当进入一个方法的时候，这个方法需要在栈帧中分配多大的局部变量空间就确定了，在方法运行期间不会改变局部变量表的大小。 本地方法栈：与虚拟机栈发挥的作用很像，虚拟机栈视为虚拟机执行Java方法（字节码）服务，而本地方法栈则是为虚拟机栈使用到的Native方法服务。 堆：Java堆是所有线程共享的一块内存区域，在虚拟机启动时创建。这个内存区域的唯一目的就是存放对象实例，所有的对象实例以及数组都要在堆上分配。 堆分为新生代和老年代，而新生代又可以分为Eden、From Survivor和 To Survivor 方法区：线程共享，用于存储已经被虚拟机记载的类信息，常量，静态变量，JIT（即时编译器）编译后的代码数据等。 在HotSpot上开发的人来说，我们的方法区就是永久代，只是因为HotSpot的开发者把GC分代收集扩展到了方法区，这样HotSpot的GC就可以像管理堆一样管理我们的方法区。 JDK1.7的HotSpot中，原本在永久代的字符串常量池被移除，称为自己独立的一块内存。 方法区的运行时常量池&amp;Class文件的常量池&amp;字符串常量池运行时常量池存放在方法区中，而Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池，也就是class文件常量池，这个class文件常量池存放编译期就生成的各种字面量和符号引用，这些字面量和符号引用都是在类被加载进入JVM后，被存储在了运行时常量池。（我一直感觉是运行时常量池中包含了class文件常量池） 对于Class文件常量池，要求常量一定是在编译时才能放入，但是运行时常量池却不是，相对Class文件常量池，运行时常量池有动态性，也就是说运行期间也可能将新的常量放入池中。 而我们的字符串常量池在JDK1.7以前，在HotSpot中是存放在永久代中的，1.7开始把它独立了出来。 String s = new String(“abc”) 1. 在栈中开辟空间存放引用str； 2. 在堆中开辟空间new一个String实体&quot;abc&quot; 3. 栈中的引用str指向堆中的实体 4. 如果常量池中没有字面值&quot;abc&quot;，把堆中的字面值复制给字符串常量池一份。 String str = “a” + “b”; str == “ab” 1. 在栈中开辟空间存放引用str 2. 根据编译器合并已知量的优化功能，在字符串常量中只有一个空间存放&quot;ab&quot; 3. str指向字符串常量池中的&quot;ab&quot;； final String s=”a”;String str = s+”b”; str=”ab” 1. 因为s被final修饰了，成了常量，所以直接就已知了。 2. 后面的和上一个一样。 String a=”a”;String b=”b”;String str=a+b;str==”ab” 1. 在栈中开辟一个空间存放引用a； 2. 在字符串常量中开辟空间存放&quot;a&quot;; 3. a指向字符串常量池中的&quot;a&quot;; 4. 在栈中开辟一个空间存放引用b； 5. 在字符串常量中开辟空间存放&quot;b&quot;; 6. b指向字符串常量池中的&quot;b&quot;; 7. 两个变量相加最后的结果是通过StringBuilder的最后一步，toString后new出来的一个String对象&quot;ab&quot;，存放在堆中，str也指向堆。 GC基础（回收什么）什么内存需要回收程序计数器、虚拟机栈、本地方法栈都是和线程共存亡的，同时线程隔离，这三个区域的不需要考虑我们的回收的问题，因为方法结束或者进程结束时，内存自然就跟随着回收了。 而我们的方法区和堆中的内存分配和回收都是动态的，所以GC关注的就是这部分内容 在堆中，尤其是新生代，一次GC一般可以回收70%-95%，但是HotSpot中的永久代效率远低于这个。 永久代中的垃圾回收有两部分：废弃常量和无用的类 废弃的常量的GC过程和堆中的对象相似。无用的类比较麻烦：如何判定一个类是无用的类（判定是判定，回收是回收） 1. Java堆中不存在该类的任何实例。 2. 加载该类的ClassLoader被回收。 3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 什么样的对象被回收1. 引用计数法 给我们对象上加一个引用计数器，当有引用的时候+1，引用失效的时候-1，任何时刻计数器为0的对象就是不可能再被使用的对象。 问题： 无法解决对象之间相互循环引用的问题，比如： public class ReferneceGC{ public Object instance = null; public static void testGC(){ ReferenceGC objA = new ReferenceGC(); ReferenceGC objB = new ReferenceGC(); objA.instance = objB; objB.instacne = objA; objA = null; objB = null; system.gc(); } } 这种情况下我们的两个对象已经不能再被访问了，但是两个之间还存着引用，所以计数器不为0，也就没法被GC。 2. 可达性分析(JVM) 通过&quot;GC Roots&quot;对象作为起始点，从这些结点向下搜索，走过的路径称为引用链（Reference Chain），当一个对象到GC Roots 没有引用链，那么这个对象就不可用，也就是说GC Roots到不了这个对象，这个对象被判定是可回收的对象。注意！！！这里只是判 定可回收，并不是真的回收了，真正的回收是需要两次标记的这里只是一层标记，还有一层是在F-Queue中执行了finalize()后，被 标记第二次，才会真正的被回收。 GC Roots对象的范围： 1. 虚拟机栈中引用的对象。 2. 方法区中类静态属性引用的对象。 3. 方法区中的常量引用 4. 本地方法栈中JNI（Java Native Interface）引用的对象。 3. 判断对象是否死亡 上面也说到了，当一个对象经过可达性分析后，不能到达GC Roots，那么这个对象会被第一次标记，并同时进行一次筛选，这个筛选就是判断对象是否需要执行finalize()方法，如果没有必要执行，那么这个对象被第二次标记，同时就保留在了原来&quot;即将收回&quot;的集合中，如果有必要执行finalize()方法，那么这个对象会被放在一个F-Queue的队列中，并在稍后，JVM会自动创建一个Finalizer线程（优先级很低）去执行他。如果对象在finalize()方法中成功拯救了自己--只要重新与引用链上任何一个对象建立关联即可，比如：把自己赋值给某个类变量或者对象的成员变量，那么在第二次标记前它就会被移除&quot;即将回收&quot;的集合。 注意： 如果判断一个对象是否有必要执行finalize()方法： 1. 对象本类中，finalize()方法被重写； 2. finalize()方法还没有被执行（任何一个对象的finalize()方法只能被JVM自动调用一次，也就是说这个对象一旦面临第二次被回收，那么JVM不会再调用finalize()方法，对象也就别回收了） GC算法（回收算法）在了解GC算法前，我们需要先对GC的区域，也就是堆的内存进行一个细致的了解。 Heap我们之前也说了，堆上的内存进行了分代，至于为什么分代，唯一的理由就是优化GC性能。 一个堆可以分为新生代和老年代，新生代又可以分为Eden和两Survivor。 HotSpot JVM中新生代的Eden和两个Survivor（From、To）的默认比例是8：1：1，新创建的对象实例基本都会被直接分配到Eden或者From，当然一些比较大的对象实例，如果Eden中没有那么大的连续空间，就直接分配到老年代。这些对象经过第一次对新生代的GC（Minor GC）后，被移动到To。随后，对象每次在Survivor经过一次Minor GC ，年龄就会增加一岁，一旦到15（默认的），就会被移动到老年代。 在新生代中的对象基本都是朝生夕死（98%以上），所以年轻代的GC算法是复制算法。复制算法不会产生内存碎片。 Minor GC前，对象都是Eden和From中，To是空的，GC时，Eden存活的对象直接被移到To，而From存活的对象，如果年纪到达了阈值，被移动到老年代，否则，被移动到To。经过这次Minor GC,Eden和From清空。在下一次Minor GC前，我们之前的To，就是现在的From，之前的From就是To（From和To互换，因为一定要保证To是空的）。不断进行Minor GC，这个时候有可能会有一次，Eden和From移动的对象把To填满了，也就是下一次的From满了，这个时候把To中的对象都移动到老年代（Handle Propotion，分配担保）。 我是一个普通的Java对象，我出生在Eden区，在Eden区我还看到和我长的很像的小兄弟，我们在Eden区中玩了挺长时间。有一天Eden区中的人实在是太多了，我就被迫去了Survivor区的“From”区，自从去了Survivor区，我就开始漂了，有时候在Survivor的“From”区，有时候在Survivor的“To”区，居无定所。直到我18岁的时候，爸爸说我成人了，该去社会上闯闯了。于是我就去了年老代那边，年老代里，人很多，并且年龄都挺大的，我在这里也认识了很多人。在年老代里，我生活了20年(每次GC加一岁)，然后被回收。 标记-清除（Mark-Sweep）老年代使用，先标记出所有需要回收的对象，在标记完成后，统一回收。 标记过程就是之前说的两次标记。 缺点： 1. 效率低 2. 空间问题，这个样子标记清除会产生很多不连续的内存碎片，空间中碎片太多，会让程序在运行过程中需要分配比较大的对象时，无法找到足够大的连续空间，而提前触发下一次GC 标记-整理（Mark-Compact）老年代使用，先标记，然后把存活的对象都向一边移动，然后直接清除掉边界外的内存。 复制（Copying）新生代使用，算法本身是把可用内存划分为可用的两部分，一块用完了，把存活的复制到另一块上，然后把这块清空，但是50%太多了，后来就有了Eden和两个Survivor，只有10%不被使用。一旦需要移动的存活对象大于了10%，那么就把这些对象所有直接移动到老年代，也就是所谓的分配担保（Handle Promotion） 分代收集（Generational Collection）基本上JVM都用这个，新生代复制算法，老年代标记-整理（清除） JVM怎么发起回收JVM线程执行的过程中在GC前需要可达性分析，而可达性分析需要枚举根节点，枚举根节点的时候需要进行GC停顿，在GC停顿的时间上利用OopMap得到引用的位置，进而减少了扫描的范围。而在线程进行GC的时候，并不是任何时间点都可以随意的发生GC，线程GC必须是在安全点上，因为OopMap的数据就存放在安全点上，线程只有到这里才知道要引用在哪。 枚举根节点（GC停顿上）可以作为GC Roots的节点，基本都在方法区和栈中，也就是全局性引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，在可达性分析的时候，因为这项分析工作必须在一个能保证一致性的快照中进行，也就是GC停顿中执行，在GC停顿中我们的HotSpot使用一组称为OopMap的数据结构来完成准确式GC（虚拟机有办法直接得到哪些地方存放着对象引用），那么在枚举根节点的时候，就直接在这些地方进行扫描，很快就得到了根节点（GC Roots）。 我们枚举根节点是在GC停顿上，但是我们什么进行GC呢，GC停顿是为了得到我们引用位置，而引用位置在OopMap中，所以我们的GC停顿就在安全点上，也就是GC就在安全点上。 那么我们GC的时候我们的线程必须处于安全点上，那么怎么就能让GC的时候线程就在安全点上呢？ 抢先式中断 在GC发生时，把所有线程中断，没有在安全点的线程，恢复线程，让它跑到安全点后再中断 主动式中断 设置一个标志位，各个线程自己去轮询这个标志，发现标志为真时，线程中断，这个标志位和安全点的位置一致。 基本上都用这个主动式中断，但是主动式中断时，线程必须都是活的，一旦我们的线程是Sleep或是wait时，我们的线程就需要存放在一个Safe Region的区域，也就是线程一旦处于挂起，就让它进入安全域，同时标识这个线程已经进入了Safe Region，这个时候就是发生了GC，也无所谓。但是在线程恢复的时候，也就是离开安全域时，线程要检查是不是已经完成了枚举根节点或者是整个GC过程，如果完成了线程恢复，没有完成的话，线程还是要等待，等待一个可以离开的信号。 GC器 两个重要的概念并行：两个回收线程一起进行垃圾回收，但是用户线程是等待的。并发：垃圾回收线程和用户线程一起执行（但是垃圾回收线程不一定是并行的，可能变替执行），用户线程在运行，垃圾收集线程在另一个CPU上运行 Serial（串行GC）Serial收集器是一个新生代收集器，单线程执行，使用复制算法。 在进行收集垃圾时，必须stop the world，它是虚拟机运行在Client模式下的默认新生代收集器。 ParNew（并行GC）ParNew收集器是Serial收集器的多线程版本，许多运行在Server模式下的虚拟机中首选的新生代收集器，除Serial外，只有它能与CMS收集器配合工作。 ParNew收集器其实就是serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为与Serial收集器一样。 Parallel Scavenge（并行回收GC）Parallel Scavenge收集器也是一个新生代收集器，它也是使用复制算法的收集器，又是并行多线程收集器。 CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。吞吐量= 程序运行时间/(程序运行时间 + 垃圾收集时间)， 虚拟机总共运行了100分钟。其中垃圾收集花掉1分钟，那吞吐量就是99%。 自适应调节策略是Parallel Scavenge与ParNew的一个重要区别 Serial Old（串行GC）Serial Old是Serial收集器的老年代版本，同样是单线程收集器，使用标记整理算法。 Parallel Old（并行GC）Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和标记整理算法。 CMS（Concurrent Mark Sweep 并发GC）Concurrent Mark Sweep 收集器是一种以获得最短回收停顿时间为目标的收集器，基于标记清除算法。 过程如下：初始标记，并发标记，重新标记，并发清除，优点是并发收集，低停顿，缺点是对CPU资源非常敏感，无法处理浮动垃圾，收集结束会产生大量空间碎片。 G1（Garbage First）G1(Garbage First)收集器是JDK1.7提供的一个新收集器，G1收集器基于“标记-整理”算法实现，也就是说不会产生内存碎片。还有一个特点之前的收集器进行收集的范围都是整个新生代或老年代，而G1将整个Java堆(包括新生代，老年代)。 内存分配与回收策略之前也讲了，一个对象new出来，主要分配在Eden和From上，但是如果启动了本地线程分配缓冲，就按照线程优先在TLAB（Thread-Local Allocation Buffer）上分配。少数情况下，也就是对象太大时，直接就分派到了老年代。 经过一次Minor GC后，Eden和From中没有过阈值的存活对象移动到To（大多数情况是小于10%的，不出现分配担保），同时对象年龄+1，而From中经过这次Minor GC到达阈值的对象，直接进入老年代。 同时一旦在Survior中一个年龄点的对象超过了Survior空间的一半，那么这年龄等于或者大于这个点的对象直接进入老年代。 每次进行Minor GC前，JVM都会检查一下老年代中最大可用的连续空间是不是大于新生代中所有存活对象的总空间，一旦大于，Minor GC确保安全，一旦不小于或着等于，JVM会查看HandlePromotionFailure设置值是否允许担保失败，一旦允许，那么就继续查看老年代中的最大可用连续空间是不是大于历次老年代对象的平均大小，如果大于，就进行Minor GC，虽然有风险，但是也会执行，但是一旦HandlePromotionFailure不允许担保失败，或者小于，直接进行一个Full GC。 Minor GC &amp; Major GC &amp; Full GCMinor GC年轻代内存的垃圾收集事件称为小型GC。 1. 当JVM无法为新对象分配内存空间时总会触发 Minor GC,比如 Eden 区占满时。Survivor满不会引发GC。所以(新对象)分配频率越高, Minor GC 的频率就越高。 2. Minor GC 事件实际上忽略了老年代。从老年代指向年轻代的引用都被认为是GC Root。而从年轻代指向老年代的引用在标记阶段全部被忽略。 3. Minor GC 每次都会引起全线停顿(stop-the-world ), 暂停所有的应用线程。 Major GCMajor GC(大型GC) 清理的是老年代空间(Old space)。 Full GCFull GC(完全GC)清理的是整个堆, 包括年轻代和老年代空间。 触发Full GC 1. 方法区空间不足 2. 老年代空间不足 3. 调用System.gc()，系统会建议执行Full GC，但是不必然执行 4. 通过Minor GC后，进入老年代的平均大小大于老年代的可用空间 5. 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小 6. CMS GC时出现promotion failed和concurrent mode failure GC调优堆设置-Xms：初始堆大小-Xmx：最大堆大小-Xmn：年轻代大小-Xss：每个线程的堆栈大小-XX：NewSize=n；设置年轻代大小-XX：NewRatio=n；设置年轻代和老年代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5-XX:MaxPermSize=n:设置持久代大小 收集器设置-XX:+UseSerialGC:设置串行收集器-XX:+UseParallelGC:设置并行收集器-XX:+UseParalledlOldGC:设置并行年老代收集器-XX:+UseConcMarkSweepGC:设置并发收集器 并行收集器设置-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n) 并发收集器设置-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。 垃圾回收统计信息-XX:+PrintGC-XX:+PrintGCDetails-XX:+PrintGCTimeStamps-Xloggc:filename 实例java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -Xmx3550m：设置JVM最大可用内存为3550M。 -Xms3550m：设置JVM初始内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。 -Xmn2g：设置年轻代大小为2G。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。 -Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。 java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0 -XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5 -XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6 -XX:MaxPermSize=16m:设置持久代大小为16m。 -XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试（杂）]]></title>
    <url>%2F2017%2F12%2F06%2FJava%E9%9D%A2%E8%AF%95%EF%BC%88%E6%9D%82%EF%BC%89%2F</url>
    <content type="text"><![CDATA[做选择题的时候发现的一些个问题 Java中的三种变量局部变量在方法、构造器或是块中使用，在方法、构造器或块进入时被创建，一旦退出该变量就会被销毁。 局部变量没有默认时，因此变量必须在声明和在第一次使用的前初始化，也就是赋值。 实例变量（成员变量）也就是一定意义上的全局变量，在类中声明，但是它不在块、构造器或是方法内声明，也就是一旦new的时候，堆中的对象就被分配了一个空间，每个实例变量的位置也就改变了。 实例变量有默认值，数字默认为0，boolean默认为false，对象引用默认为NULL。 类变量（静态变量）类变量也是就被static修饰的成员变量。 HttpServletResponse &amp; HttpServletRequestHttpServletResponse1. 设置Http头标：response.setHeader(&quot;Refresh&quot;,&quot;3&quot;); 2. 设置cookie Cookie c1 = new Cookie(&quot;username&quot;，&quot;only&quot;); response.addCookie(c1); 3. 输出返回数据 HttpServletResponse.getOutputStream().write(); 4. 设置返回数据类型 HttpServletRequest1. 读取cookie 2. 读取Http头 3. 读取路径信息 4. 标识Http会话 堆、栈、静态域、常量池、非RAM存储栈：存放基本数据类型的数据和对象的引用，旦对象本身是在堆中的。 堆：存在new出来的东西和数组。 静态域：存放在对象中用static定义的静态成员，也就是类变量 常量池：存放常量 非RAM存储：硬盘等永久存储空间 forward &amp; redirect1. forward是转发，不会改变地址栏，redirect是重定向，会改变地址栏 2. 转发的页面之前可以共享request内的数据，但是redirect不可以。 3. forward效率高、redirect效率低 4. redirct默认是302码，包含两次请求和两次响应。 java类的加载过程jvm加载类机制，前提是java源文件被javac编译成class字节码文件。javac编译时不进行内存分配的工作，而是在jvm运行时才动态加载和动态链接。 Loading--&gt;Verification--&gt;Preparation--&gt;Resolution--&gt;Initialization--&gt;Using--&gt;Unloading 加载--&gt;验证--&gt;准备--&gt;初始化--&gt;卸载。而解析不一定就是在初始化之前。 1. Loading： 这个阶段jvm通过类的全路径读取到类的二进制字节流，然后将字节流代表的类结构转化到运行时数据区的方法区中，最后jvm堆中生成这个类的java.lang.Class实例。 2. Verification： Loading和验证是交叉进行的，验证二进制字节流代表的字节码是否合格。 3. Preparation： 在方法区中给类的类变量分配内存，然后初始化值，如果这个类变量是public static final修饰的，也就是常量，直接就给这个内存区域赋值这个常量。 4. Resolution： 将常量池内的符号引用替换成直接引用过程。 5. Initialzation： 执行java代码。 ThreadLocal类这个类就是一个线程本地变量，为变量在每个线程都中创建了一个副本，那么这个线程可以访问自己内部的副本变量。 正则表达式i++和++i对于Java而言，因为有一个中间缓存机制，也就是说我们i++或者是++i之后，是把i的值先放到了一个temp变量中，最后返回的其实是这个temp的值！！！ volatile和synchronized的区别：1. volatile本质是在jvm当前变量在寄存器中的值是不确定的，需要从主存中读取，而synchronized则是锁定当前变量，只有在当前线程可以访问该变量，其他线程被阻塞。 2. volatile仅能使用在变量级别，但是synchronized则可以使用在变量和方法中。 3. volatile仅能实现变量的修改可见性，不具备原子性，但是synchronized则保证了变量的修改可见性和原子性。 4. volatile不会造成线程的阻塞，而synchronized可能会造成线程的阻塞。 5. volatile标记的变量不会被编译器优化，而synchronized标记的变量可以被编译器优化。 杂1. 导包的时候，要导入到最底层，比如说：导入java/awt/event下面所有的类，import java awt.event.* 2. this、super都不能在static的方法和块内使用，注意，Main方法是静态的。 3. ArrayList的空间浪费主要体现在list列表的结尾预留一定的容量空间，而LinkedList的空间浪费体现在它的每一个元素都需要消耗相当的空间。 4. 重写的两同、两小、一大。 两同：方法名、参数列表 两小：子类中方法的返回值小于等于父类中方法的返回值，抛出的异常。 一大：修饰符大于等于父类中被重写的方法。 5. abstract修饰的方法不能有{}. 6. 类中不能有变量运算。 7. abstract和static、final都不能一起用 8. switch()括号内的只能是基本数据类型中short、char、int、long、枚举、JDK1.7后支持String 9. this和super只能放在第一行，并且不能同时出现在一个构造方法中。 10. 声明数组：String a[]、String[] a、Object a[]，声明的时候不能指定数组长度。 11. 父类静态块--&gt;子类静态块--&gt;父类构造块--&gt;父类构造方法--&gt;子类构造块--&gt;子类构造方法 12. Java中判断一个类一样： 类的全称相同 &amp; 使用的类加载器一致 Java中三个类加载器： Bootstrap ClassLoader：主要加载JVM自身工作需要的类 Extension ClassLoader：主要加载%JAVA_HOME%\lib\ext目录下的库类。 Application ClassLoader：主要加载Classpath指定的库类，一般情况下这是程序中的默认类加载器，也是ClassLoader.getSystemClassLoader() 的返回值。 13. List&lt;? extends A&gt;小于等于A的范围，List&lt;? super A&gt;表示大于等于A的范围，&lt;?&gt;表示所有范围。 14. List&lt;A&gt;表示一个点，而不是一个范围，所以B extends A，但是List&lt;A&gt;和List&lt;B&gt;不能相互赋值（=）。 15. servlet在多线程下其本身并不是线程安全的。 16. getParameter()是获取POST/GET传递的参数值； getInitParameter获取Tomcat的server.xml中设置Context的初始化参数 getAttribute()是获取对象容器中的数据值； getRequestDispatcher是请求转发。 17. 一个类中，可以有多个main方法，这是重载，但是public static void main(String[] args)的方法只能有一个。 18. 所有类的实例和数组都是在堆上分配内存的。 19. 对象所占的堆内存是由自动内存管理系统回收的。 20. throws用来声明一个方法可能抛出的异常，throw才会真正抛出了异常对象。 21. 对于Integer而言，如果赋予的int数值在-128 - 127之间，直接从cache数组中取值，这些cache引用对Integer对象地址是不变的，但是一旦赋予的int值数据，不再这个范围呢，就会new Integer(i)，这个地址就是新的了。 也就是说让我们Integer i = 200；这个时候就会执行Integer内部的一个静态方法，Integer i = Integer.ValueOf(200);下面是这个方法的源码： public static Integer valueOf(int i) { if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 22. 析构函数(destructor) 与 构造函数 相反，当对象结束其 生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。 23. 对于Integer如果装箱，会调用valueOf方法，如果拆箱，会调用intValue方法。 24. 对于引用传递而言，只有在对引用对象的内部做出了修改，才会影响到原对象，如果直接把引用修改的，则原对象不受影响：这个被修改的引用，现在不是原来对象的引用，而是新对象的引用。 25. 字符常量使用&apos;&apos;包起来的东西。 26. javac一次可同时编译数个Java源文件 27. 环境变量可在编译source code时指定。 28. javac.exe能指定编译结果置于哪个目录。 29. 非RuntimeException一般是外部错误（不考虑Error），其必须被try{}catch语句所捕获。 30. Error类体系描述了Java运行系统中的内部错误以及资源消耗的情形，Error不需要捕获。 31. RuntimeException体系包括错误的类型转换、数组越界、空指针等，但这是在运行时才会被发现的异常，所以不要被try{}catch显示捕获。 32. volatile并不能保证线程安全。 33. 二维数组的定义中第一个长度一定要指定： float f[][] = new float[7][7] float []f[] = new float[7][7] float [][]f = new float[7][7] float [][]f = new float[7][] 34. java.exe负责运行，javac.exe负责编译，能被java.exe成功运行的java class文件必须有main()方法。 35. J2SDK是一个编译工具，不是API。 36. 子类的构造方法总是先调用父类的构造方法，如果子类的构造方法没有明显地指明使用父类的哪个构造方法， 子类就调用父类不带参数的构造方法。 而父类没有无参的构造函数，所以子类需要在自己的构造函数中显示的调用父类的构造函数。 37. if()，()内必须是一个boolean的值，如果是x=y这种赋值操作，编译就通不过。 38. 一个类中，一个构造方法调用另一个构造方法时，直接用this(x)这种形式。 39. 能够对对象进行传输的貌似只有ObjectOutputStream和ObjectInputStream这些以Object开头的流对象。 40. public Method[] getDeclaredMethods()返回类或接口声明的所有方法，但是不包括继承的方法，但是包括实现接口的方法。 public Method[] getMethods()返回类的所有public方法，包括继承类的公有方法，当然也包括实现类的方法。 41. 内部类：InsideOne ei=eo.new InsideOne(); EnclosingOne.InsideOne ei=eo.new InsideOne(); 42. 方法区，又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。同时，方法区包含的都是整个程序中永远唯一的元素。 43. 方法区和堆内存是线程共享的，程序计数器和虚拟机栈都是线程隔离的。 44. JDK1.8以前，抽象类的方法默认是protected，1.8默认是default。 JDK1.8以前，接口中的方法都是public abstract的，JDK1.8，接口中的方法可以是public和default，JDK1.9时，接口中的方法可以是private的了。 45. Statement、PreparedStatement和CallableStatement都是接口，Statement继承自Wrapper、PreparedStatement继承自Statement、CallableStatment继承自PreparedStatement。 46. Statement普通不带参数的查询SQL，支持批量更新，删除 PreparedStatement可变参数的SQL，编译一次，执行多次，效率高，安全性高，有效防止SQL注入等问题。 CallableStatement继承自PreparedStatement，支持调用存储过程，提供了对输出和输入参数的支持。 47. ？在Statement类和子类中代表占位符，但是一个占位符只能对应一个值。 48. json对象要求属性必须加双引号，使用{}就是json对象了，而json对象必须由一组有序的键值对组成。 {&quot;company&quot;:{&quot;name&quot;:[4399,4399,4399]}} 49. ./表示当前项目的路径，../表示当前路径的父路径， 盘符：\\name\\file 或者 盘符：/name/file表示物理地址。 50. 方法调用时，会创建栈帧在栈中，调用完是程序自动出栈，而不是gc来释放。 51. 面向对象的五大基本原则： 单一职责原则（SSP，Single-Responsibility Principle）：一个类应该仅有一个引起它变化的原因。 开放封闭原则（OCP，Open-Closed Principle）：对扩展开放，对修改封闭。 里式替换原则（LSP，Liskov-Substituion Principle）：子类可以替换父类并且出现在父类能够出现的任何地方。 接口隔离原则（ISP，Interface-Segregation Principle）：使用多个专门的接口比使用单个接口会好得多。 依赖倒置原则（DIP，Dependency-Inversion Principle）：高层模块不再依赖底层模块，二者都依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 52. 接口中不能有构造器，但是抽象类中需要有构造器。同时接口这东西就和static无缘。]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试（异常框架）]]></title>
    <url>%2F2017%2F12%2F04%2FJava%E9%9D%A2%E8%AF%95%EF%BC%88%E5%BC%82%E5%B8%B8%E6%A1%86%E6%9E%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节复习了异常框架的结构，理清楚受检异常和非受检异常的分类。 异常框架 执行顺序try-catch-finally规则 try块：用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。 catch块：用于处理try捕获到的异常。 finally块：无论是否捕获或处理了异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。在以下4中情况下，finally不会被执行： finally语句块中发生了异常 在前面的代码中使用了System.exit()退出程序。 程序所在的线程死亡。 关闭CPU。 1. 没有异常 2. 有异常 演示代码123456789101112131415161718192021222324public class ExceTest &#123; private static int getInt() &#123; try &#123; int x = 10/0;// return 0; &#125; catch (Exception e) &#123; // e.printStackTrace(); return 0; &#125;finally&#123; return 1; &#125; &#125; public static void main(String[] args) &#123; int i=getInt(); System.out.println(i); &#125; &#125;/**Output: 1*/ throws和throw throws是说如果这个方法本身没有处理这个异常的能力，可以在方法声明处用throws子句来声明抛出异常。 throw总是出现在函数体内，用来抛出一个Throwable类型的异常。程序会在throw语句立即终止，它后面的语句执行不到，然后在包含它的所有tru块，从里往外找含有与其匹配的catch子句的try块。 123456789101112131415161718192021222324252627282930313233public class ExceTest &#123; static int question(int x,int y) throws MyException&#123; if(y&lt;0)&#123; throw new MyException("y不能为负数"); &#125; return x/y; &#125; public static void main(String[] args) &#123; int a =3; int b =-1; try &#123; // try语句包含可能发生异常的语句 int result = question(a, b); // 调用方法quotient() &#125; catch (MyException e) &#123; // 处理自定义异常 System.out.println(e.getMessage()); // 输出异常信息 &#125; catch (ArithmeticException e) &#123; // 处理ArithmeticException异常 System.out.println("除数不能为0"); // 输出提示信息 &#125; catch (Exception e) &#123; // 处理其他异常 System.out.println("程序发生了其他的异常"); // 输出提示信息 &#125; &#125;&#125;class MyException extends Exception&#123; String message; public MyException(String errorMessage) &#123; message = errorMessage; &#125; public String getMessage()&#123; return message; &#125;&#125; 面试中常见问题1. 什么是Java异常？ 异常时发生在程序执行过程中阻碍程序正常执行的错误事件。在Java中所有的异常都是由Throwable这个接口衍生而来的。在所有的异常中，分为java.lang.error和java.lang.exception,而这里两个包中，error类和其子类，还有Exception中的RuntimeException类和其子类都是非受检异常，其他的异常都是受检异常。 2. Java异常处理中有哪些关键字？ throws、throw、try-catch-finally 3. Java异常类有哪些的重要方法？ String getMessage():返回Throwable的String信息，当异常通过构造器创建后可用。 String toString():返回String格式的Throwable信息。 void printStackTrace()：打印栈轨迹信息到标准错误流。 4. 受检异常和非受检异常的区别？ 检查型异常需要使用try, catch和finally关键字在编译期进行处理，否则会出现编译器会报错。对于非检查型异常则不需要这样做。 5. Java中的NullPointerException和ArrayIndexOutOfBoundException之间有什么相同之处？ 两个都是RuntimeException的子类，都是非受检异常。但是在C中，数组是没有长度的，所以不能有ArrayIndexOutOfBoundException。 6. Java异常处理过程中，你遵循的实践是什么？ * 调用方法的时候返回Boolean来代替返回null。 * catch块内一定写代码。 * 尽量抛受检异常 * 数据库连接，查询，流处理后，在finally块中关系流。 7. 什么是“异常链”? 异常链是说在进行一个异常处理的时候，又抛出了另一个新的异常，由此生成一个链。]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试（几个比较）]]></title>
    <url>%2F2017%2F12%2F04%2FJava%E9%9D%A2%E8%AF%95%EF%BC%88%E5%87%A0%E4%B8%AA%E6%AF%94%E8%BE%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节复习了基本概念的比较：接口和抽象类、多态的两种方式（重载和重写）、值传递和引用传递、基本数据类型和包装类的转换、修饰符问题 接口 &amp; 抽象类抽象类是对某一个事务特性的描述，主要用来抽象类别。 接口是某一个行为的描述，主要用来抽象功能。 区别和联系抽象类和接口的区别： 1. 抽象类和接口都不能被实例化。 2. 抽象类要被子类继承，接口要被类实现。抽象类的子类如果没有重写所有父类中方法，那么这个子类也是一个抽象类。 3. 接口中只能有方法的声明，不能有方法的实现。abstract修饰的方法都是只用；结尾，没有{}. 4. 接口中定义的变量只能是公共的静态常量，但是抽象类中的变量可以是普通变量。 5. 接口中的方法默认是public abstract，变量默认的public final static，并且，接口中的方法只能用public，但是抽象类中的抽象方法可以用public，protected、default修饰。（抽象类的成员函数可以用private、protected、public修饰） 6. 抽象类里可以没有抽象方法。 7. 抽象方法要被实现，不能被private和static修饰。 8. 接口内的方法必须用public修饰。同时不能有static的东西。 9. 抽象类可以实现接口，同时不用实现完所有的接口方法，因为它本身就是Abstract的。 抽象类中是可以有Main方法的，同时可以运行起来，而接口中不可能。 面试常见问题1. Java抽象类可以有构造函数？ 可以有，抽象类和普通类的一个区别就是不能实例化，其他区别并不大，所有抽象类中可以声明并定义构造函数，如果不写，那么也会默认有一个无参的。 2. Java抽象类可以实现接口吗？需要实现此接口的所有的方法吗？ 可以实现接口，同时不需要实现所有接口中的方法，甚至一个都不实现，比如说，AbstractList抽象类和List接口，AbstractList实现了List中所有通用方法。 3. Java抽象类可以final的吗？ 不可以，抽象类作为一个基类，需要被子类继承后实现其内部所有的抽象方法，既然需要继承，那么抽象类肯定不是final的，因为被final修饰的类不能被继承，修饰的变量成了常量，修饰的方法不能被重写。 也就是说被abstract修饰的类的方法，都不能再被final修饰。而abstract和static也不能共用,因为被static修饰的方法可以不用进行类的实例化，直接调用，但是抽象类和接口都不能被实例化。但是接口的静态常量是public final static。 4. Java抽象类可以有static方法吗？ 可以，抽象类中可以有抽象和非抽象方法，非抽象方法当然可以用static修饰，但是这么写了因为抽象类不能实例化，所有也就只能在本类中用。 5. 可以创建抽象类的实例吗？ 不可以 6. 抽象类必须要有抽象方法吗？ 不需要 7. Java抽象类中可以包含main方法吗？ 可以，抽象类可以包含main方法，它只是一个静态方法，你可以会用main方法执行抽象类，但是不能创建任何实例。 8. Java中抽象类和接口有什么区别？ 首先，抽象类强调的是事务特性的描述，而接口强调的是行为的描述。抽象类和接口主要的区别就在于： 1. 首先，抽象类中可以有普通方法和方法实现，但是在接口中只有抽象方法的声明，public abstract， 2. 其次，抽象类中可以存在普通的变量，但是在接口中只能有静态常量 public static final。 3. 同时，抽象类和接口都不能被实例化，但是抽象类中可以有Main方法，但是接口中不能有，同时抽象类一旦继承接口，我们的抽象类不需要实现这个接口中的方法，也是成立的。 重载、重写、多态面向对象编程的三大特性：封装，继承，多态。 重载（Overloading）和重写(Overriding)是多态的不同表现。 重载是多态在一个类中的表现。重写是多态在子父类中的表现。 重载重载是OverLoading，一般用于一个类中实现若干同名函数。 1. 重载只能通过，相同的函数名和不同的形参列表进行确定。 2. 重载不能通过返回值类型，访问权限，抛出异常进行确定。 3. 方法的异常类型和数目不会对重载造成影响。 重写重写是Overriding，一般用于子类重写父类的方法。 1. 重写方法的参数列表、方法返回值需要和被重写的方法完全相同。 2. 重写方法的访问修饰符一定要大于等于被重写的方法。 3. 重写方法抛出的异常必须和被重写的方法抛出的异常必须一致或是其子类。 4. 被重写方法不能被修饰为Private 5. 静态方法不能被重写成非静态。 值传递&amp;引用传递Java中数据类型分为基本数类型和引用数据类型。 基本数据类型： 整型：byte、short、int、long（默认int） 浮点型：float、double（默认double） 字符型：char 布尔型：boolean 引用数据类型： 数组、接口、类 值传递进行值传递的是基本数据类型和基本数据类型的包装类！！！还有String！！！因为他们都是（immutable）。 参数经过函数后，并不会改变原始的数据！！包括在类中的静态数据，只要是基本数据类型和包装类，还有String。 12345678910111213141516171819202122232425262728293031323334353637package javasee;public class AbsTest &#123; public static String n = "0"; public static int m=0; public static String fun2(String c)&#123; c="000"; return c; &#125; public static Integer fun1(Integer a)&#123; a=100; return a; &#125; public static void main(String[] args) &#123; fun2(AbsTest.n); System.out.println(AbsTest.n); fun1(AbsTest.m); System.out.println(AbsTest.m); AbsTest.m++; System.out.println(AbsTest.m); //System.out.println("Main:"+c+",fun1:"+fun2(c)); &#125;&#125;/**Output: 0 0 1*/ 引用传递引用传递，尤其针对数组和对象（不包含基本数据类型的包装类和String），经过函数后，会改变数据。 123456789101112131415161718192021222324public class AbsTest &#123; private void test(A a)&#123; a.age = 100; System.out.println("test中数据"+a.age); &#125; public static void main(String[] args) &#123; AbsTest at = new AbsTest(); A a = new A(); a.age = 10; at.test(a); System.out.println("main中数据"+a.age); &#125; static class A&#123; public int age = 0; &#125;&#125;/**Output: test中数据100 main中数据100*/ 基本数据类型的转换（自转&amp;强转）byte–&gt;short(char)–&gt;int–&gt;long–&gt;float–&gt;double * byte：-128 ~ 127（-2^7 ~ 2^7-1） 一个字节 * short(char)：-32768 ~ 32767（-2^15 ~ 2^15-1） 两个字节 （ java采用Unicode编码,不论汉字、字母、数字,每个字符都占用2字节。 ） * int：-2^31 ~ 2^31-1（默认类型） 四个字节 * long： -2^63 ~ 2^63-1（末尾要用L来表示） 八个字节 * float：单精度，四个字节，必须以f作为结尾 * double：双精度，八个字节（默认类型） * char：两个字节，0 ~ 65535 * boolean：true、false boolean不是数字型，所以boolean不能和其他的六种进行相互转换。 在说数据类型的转换之前，我们先简单看一个Java中的编码 Java编码计算机中存储信息的最小单元是一个字节即 8 个 bit，所以能表示的字符范围是 0~255 个。人们要表示的符号太多，无法用一个字节来完全表示，要解决这个矛盾必须需要一个新的数据结构 char，从 char 到 byte 必须编码。 只有 字符到字节 或者 字节到字符 的转换才存在编码转码; Java的字符串（String）是Unicode码，class文件是UFT-8编码，JVM运行时采用UTF-16。 注意了Unicode和ASCII一样都是一种编码！！，而GBK，UTF这种都是编码的方式。UFT-8考虑了很多种不同国家的字符，涵盖了整个Unicode码表，所有在存储一个字符的编码的时候，使用的字节长度也从1个字节到4个字节不等。 ASCII码规定了128个字符的编码，0-31位是控制字符（如回车，删除）32-126是打印字符，可以用过键盘输如并且能够显示出来。 对于字符串的编码： 1. 重新对字符串进行编码：Byte[] bytes=str.getBytes(&quot;UFT-8&quot;) 2. 重新对bytes进行解码，创建新的字符串对象：String str=new String(&quot;Demo&quot;.getBytes(&quot;ISO-8859-1&quot;),&quot;GBK&quot;); java采用Unicode编码,不论汉字、字母、数字,每个字符都占用2字节。但是在UTD-8的编码条件下，汉字占3个字节 基本数据类型的自转和强转自动转型就是向上转型！！！ 12345678910111213141516171819202122232425 Byte b = 100; byte b2 = 100; Character c = 'r'; char c2 = 'c'; Short s = 77; short s2 = 20; Long l = 1L; long l2 = 1L;//long l2 = 1; Float f = 2.0F; float f2 = 3f;//float f = 2.0f Double d = 3.0;//Double d = 3d,3.0d,3.0D double d2 = 3; System.out.println(s+","+s2+","+b+","+b2+","+c+","+c2+","+s+","+s2 +","+l+","+l2+","+f+","+f2+","+d+","+d2);/**Output: 77,20,100,100,r,c,77,20,1,1,2.0,3.0,3.0,3.0*/ 下面开始看转换：（强制转换只能写基本数据类型，装箱不是我们做的） 1. 如果左、右边是基本数据类型： 左边大：直接右边的数据向上转型。 左边小：右边的数据需要强制转换。 char和short不能转换，char可以强转成byte，但是byte无法向上转成char 2. 如果左、右两边都是包装类： 左边和右边只要类型不一样，都需要强转，这可是类啊！！！ 3. 左边是包装类，右边是基本数据类型： 基本数据类型必须强转，然后JVM自动完成装箱！！！ 4. 左边是基本数据类型，右边是包装类： 包装类可以先由JVM自动拆箱，向上转，但是不能向下转，强转也不行。 int x = 1; Integer x2 = 0; double d = 7; Double d2 = 7.0; d = x2;但是x=d2是错的。 基本数据类型的运算1. 整数（int、long）除以0，编译通过，运行报错(0/0也是这一类) 2. 小数除以0，结果是Infinity 3. 0/0.0、0.0/0结果是NaN，非数字 4. byte和short运算的时候，会自动转成int 5. 取余运算，不管是整数还是负数，都按照正数计算，计算完之后，%左边的数字时正数，余数就是正数，反之也成立。 6. 2+4+&quot;s&quot; --&gt; &quot;6s&quot; &quot;s&quot;+2+4 --&gt; &quot;s24&quot; 7. 一旦超过了长度限制，从就得到负数。 byte b = 127; b+1--&gt;128; (byte)(b+1)--&gt;-1; byte b = -128; b-1--&gt;-129 (byte)(b-1)--&gt;127 8. instance of 只能用于引用数据类型。d instanceof Double这么写是错的！！！ 9. 只要有基本数据类型参与的==号比较，比较的都是值，基本数据类型包装类的equals比较的都是值。 Integer x = 0; int y = 0; Integer m = new Integer(0); Integer n = new Integer(0); Integer ss = Integer.valueOf(0); System.out.println(ss==y); --&gt;true System.out.println(ss==x); --&gt;true（重要） System.out.println(x==y); --&gt;true System.out.println(m==y); --&gt;true System.out.println(x==m); --&gt;false System.out.println(m==n); --&gt;false System.out.println(m.equals(n)); --&gt;true String和基本数据类型的转换基本数据类型到String 1. String str = String.valueOf(int i) 2. String str = Integer.toString(int i) String到基本数据类型 1. int i = Integer.parseInt(String str) byte b = Byte.parseByte( s ); short t = Short.parseShort( s ); int i = Integer.parseInt( s ); long l = Long.parseLong( s ); float f = Float.parseFloat( s ); double d = Double.parseDouble( s ); 2. int i = Integer.valueOf(String str).intValue(); Java中几个修饰符的比较类修饰符1. public（访问控制符），将一个类声明为公共类，他可以被任何对象访问，一个程序的主类必须是公共类。 2. abstract，将一个类声明为抽象类，没有实现的方法，需要子类提供方法实现。 3. final，将一个类生命为最终（即非继承类），表示他不能被其他类继承。 4. friendly，默认的修饰符，只有在相同包中的对象才能使用这样的类。 成员修饰符1. public（公共访问控制符），指定该变量为公共的，他可以被任何对象的方法访问。 2. private（私有访问控制符）指定该变量只允许自己的类的方法访问，其他任何类（包括子类）中的方法均不能访问。 3. protected（保护访问控制符）指定该变量可以别被自己的类和子类访问。在子类中可以覆盖此变量。 4. friendly ，在同一个包中的类可以访问，其他包中的类不能访问。 5. final，最终修饰符，指定此变量的值不能变。 6. static（静态修饰符）指定变量被所有对象共享，即所有实例都可以使用该变量。变量属于这个类。 7. transient（过度修饰符）指定该变量是系统保留，暂无特别作用的临时性变量。 8. volatile（易失修饰符）指定该变量可以同时被几个线程控制和修改。 方法修饰符：1. public（公共控制符） 2. private（私有控制符）指定此方法只能有自己类等方法访问，其他的类不能访问（包括子类） 3. protected（保护访问控制符）指定该方法可以被它的类和子类进行访问。 4. final，指定该方法不能被重写。 5. static，指定不需要实例化就可以激活的一个方法。 6. synchronize，同步修饰符，在多个线程中，该修饰符用于在运行前，对他所属的方法加锁，以防止其他线程的访问，运行结束后解锁。 7. native，本地修饰符。指定此方法的方法体是用其他语言在程序外部编写的。]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面试（集合框架）]]></title>
    <url>%2F2017%2F12%2F01%2FJava%E9%9D%A2%E8%AF%95%EF%BC%88%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[总结集合框架的面试点 1. 集合比较2. 接口&amp;抽象类比较3. 重写&amp;重载&amp;多态4. 执行顺序5. 基本数据类型（自转&amp;强转）6. 值传递&amp;引用传递7. 修饰符8. 异常的执行顺序9. 线程10. Statement 集合(java.util.*)继承&amp;实现关系 常考的继承关系： 1. Collection接口下的直接继承接口有List、Set、Queue 2. Map并没有继承Collcetion接口，但是List、Set、Map都在Java.util.* 包下。 3. List的直接实现类AbstractList（抽象类），而ArrayList、LinkedList、Vector都继承自AbstractList，Stack(FILO)继承自Vector。 4. Set的直接实现类AbstractSet（抽象类），直接接口是SortedSet。而HashSet、TreeSet都继承了AbstractSet类，同时TreeSet还是实现了SortedSet。 5. Map是个类，只实现了Serializable接口，但是Map&lt;K,V&gt;是个接口。 6. Map的直接实现类只有AbstractMap，直接继承接口只有SortedMap。 7. AbstractMap的主要直接继承类有HashMap，TreeMap（实现了SoredMap接口），Hashtable直接继承Dictionary（抽象类），但是也实现了Map接口。 8. Collections和Arrays是两个包装类，里面都是静态方法，都是工具类，不能被实例化。 线程安全集合框架中线程安全的类 1. Vector和它的子类Stack 2. Hashtable 3. Enumeration 4. 在Java.util.*下的集合都有那个fast-fail机制（当Iterator迭代遍历集合时，一旦改变了集合的结构，立刻抛出一个异常），但是在Java.util.concurrent这个包中，并发的集合都不会出现这个情况，因为它们是fast-unsafe机制。 集合框架比较（List接口）List接口及其实现类是容量可变的列表，可按索引访问集合中的元素（有序）。 * ArrayList实现一个动态数组，适合快速查找元素。 * LinkedList实现了一个双向链表，适合插入和移除元素。 * Vector是给ArrayList都加了syn（互斥锁），所以是线程安全版的ArrayList。 * Stack继承自Vector。 集合框架比较（Set接口）Set接口中的实现类中不能有重复的对象。集合中的元素不按特定方式排序，只是简单的把对象加入集合中。 * HashSet，存入HashSet中的对象必须实现HashCode()方法，同时HashSet底层使用HashMap实现的，也就是存入的都是HashMap中的K，所以才不让重复，也就是会覆盖。所有的V都是一个内部的对象。 * TreeSet，底层使用红黑二叉树实现，将让放入其中的元素按序存放（升序），内部是SortedSet。 * LinkedHashSet，采用hash表存储，并用双向链表插入顺序。内部是LinkedHashMap。 集合框架比较（QUeue）在两端出入List，所以也可以用数组或链表也实现。 集合框架比较(Map接口&amp;Dictionary)Map是一个独立的接口，不继承Collection，而Dictionary是一个抽象类，Map现在用来代替这个类。 Map中的Key不能重复。 Map是一种把K和V对象进行关联的容器。映射和列表或者集有明显的区别，映射中每一项都是成对的，Map把键对象和值对象进行关联。映射中存储的每个对象都有一个相关的关键字K对象，关键字(K)决定了对象在映射中的存储位置，索引对象时，必须提供相应的关键字。所以K对象一定不能重复，一旦重复就会对之前的对象进行覆盖。 K本身不能决定对象的存储位置，它需要利用散列技术实现，也就是得到我们的散列码(int)，这个散列码就会给V分配一个内存起始区。一旦散列码一样，就会产生不一样的处理方式。比如HashMap中形成链表和红黑树。 * HashMap，允许键为null（只能有一个，因为键必须唯一） * Hashtable，不允许键为null（这个现在不用） * TreeMap * Properties 集合框架面试题1. Java集合框架的基础接口有那些？ Collection是集合层级的根接口。Java不提供这个接口的任何直接实现。 List是一个有序集合，可以包含重复元素。可以通过索引来访问任何元素。 Set是一个无序集合，但是TreeSet提供升序存放。 Queue队列。 Map是一个独立的接口。 2. 为何Collection不从Cloneable和Serializable接口继承? Collection&lt;E&gt;继承自Iterable&lt;E&gt;,Iterable提供迭代器。Collection就是一个接口，重要的是实现，只有与实现打交道的时候，克隆和序列化才有意思。 3. Map接口为何不继承Collection？ Map接口中存放的K-V，而Collection存放的一组对象。但是Map接口和它的实现也属于集合框架的一部分。 4. 什么是Iterator？ Iterator接口提供遍历任何Collection的接口。允许在迭代的过程中移除元素，而Enumeration不可以移除。同时取代了Java集合框架中的Enumeration。 5. Iterator和Eunmeration两个接口的区别？ Eunmeration的速度是Iterator的两倍，但是Iterator是fast-fail的，更加安全。同时Iterator可以移除元素。 6. 为何没有像Iterator.add()这样的方法，向集合中添加元素？ 语义不明，已知的是，Iterator的协议不能确保迭代的次序。然而要注意，ListIterator没有提供一个add操作，它要确保迭代的顺序。 7. Iterater和ListIterator之间有什么区别？ 1. Iterator可以用来遍历Set、List、Map，但是ListIterator只能遍历List。 2. Iterator只能向前遍历，但是ListIterator可以双向遍历。 3. ListIterator继承自Iterator，添加了一些额外的功能，比如添加、替换一个元素，获取前、后元素的索引位置。 8. 遍历一个List有哪些不同的方式？ 123456789101112131415List&lt;String&gt; strList = new ArrayList&lt;&gt;();//使用for-each循环for(String obj : strList)&#123; System.out.println(obj);&#125;//using iteratorIterator&lt;String&gt; it = strList.iterator();while(it.hasNext())&#123; String obj = it.next(); System.out.println(obj);&#125;/** 使用迭代器会使线程更加安全，因为它可以确保在当前遍历的集合元素被更改的时候，它会抛出ConcurrentModificationException。*/ 9. 通过迭代器fail-fast属性，你明白了什么? 每次我们尝试获取下一个元素的时候，Iterator的fail-fast属性检查当前集合结构里的任何改动，它抛出 ConcurrentModificationException。Collection中的所有Iterator都是按照fail-fast来设计的。 （JUC中的并发集合除外，例如ConcurrentHashMap，CopyOnWriteArrayList，但是这些集合可不是简单的加了互斥锁， JUC中的集合都是fail-safe机制，从来不抛出ConcurrentModificationException） 10. 为何Iterator接口没有直接的实现类？ Iterator的实现是集合实现类的责任。每个能够用Iterator迭代的集合类都有它自己的Iterator实现内部类。 11. UnsupportedOperationException是什么？ UnsupportedOperationException用于表明操作不支持异常。在集合框架java.util.Conllections.UnmodifiableCollection将会在所有add和remove操作中抛出这个异常。 12. HashMap工作原理是什么？ HashMap内部是使用内部类Map.Entry&lt;K,V&gt;来存储K-V对的,在进行get和put时，会先根据K对象来通过计算K对象的hashCode（K的hash值高低8位相与）得到K在桶中的索引，如果不存在直接创建一个K-V键值对，如果存在，使用Object中的equals()方法比较插入或者查找当前K-V键值对和K后面的之前就链的每个K，如果不一致就插入，如果一致就直接覆盖原来K对应的V。 HashMap的初始容量是16，加载因子是0.75，阈值是16*0.75，扩容是2的n次方（前一次的两倍），每次扩容就是hash表的重新散列。 13. hashCode()和equals()方法？ * 如果o1.equals(02)为true，那么o1.hashCode()==o2.hashCode()总是true。 * 如果o1.hashCode()==o2.hashCode()为true，并不意味着o1.equals(02)为true。 14. 我们是否可以任何类作为Map的key? 我们可以使用任何类作为Map的key，然而使用它们之前，需要考虑以下几点： 1. 如果类重写了equals()方法，它也应该重写hahsCode()方法。 2. 类的所有实例都需要遵循equals()和hashCode()相关的规则。 3. 如果一个类没有使用equals(),就不能在hashCode中使用。 15. Map接口提供了哪些不同的集合视图？ 1. Set keySet()，返回Map中包含的所有Key的一个Set视图。 2. Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()，返回Map中包含的所有映射的一个集合视图。 16. HashMap和Hashtable有何不同? 1. HashMap直接父类是AbstractMap，Hashtable直接父类是Dictionary，这两个类都是抽象类。但是HashMap和Hashtable都实现了Map接口。 2. HashMap和Hashtable的初始容量都是16，但是扩容机制不同，HashMap是2的n次方，Hashtable是2的n次方+1倍。 3. HashMap和Hashtable中计算K的hahs值不同，HashMap是计算hash值是利用K的hashCode和其hashCode的高16位进行与运算（(key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);），Hashtable计算hash值直接用的就是K的hashCode()。 4. HashMap中可以存在一个K-V都是null的键值对，但是Hashtable中K不能为null 5. HashMap是线程不安全的，Hashtable是线程安全的。因为使用了互斥锁的关键字。但是Hashtable毕竟是个遗留的类，我们用线程安全的时候，其实使用的是JUC中的ConcurrentHashMap。 6. HashMap支持Iterator（fail-fast）而Hashtable用Enumeration，不支持fail-fast。 17. ArrayList和Vector有什么区别？ 1. ArrayList都是基于索引，内部是动态数组。同时有序，内部的Iterator也都实现了fail-fast，内部可以存储多个null 2. 但是ArrayList是线程不安全的，Vector是线程安全的，但是我们使用的同步时，也就是在遍历的时候需要对列表进行改变时，我们用的也不是Vector，而是JUC中的CopyOnWriteArrayList。 3. ArrayList比Vector块，因为没有锁。 18. Array和ArrayList有什么区别? 1. Array可以容纳基本数据类型和对象，但是ArrayList只能容纳对象。 2. Array可以指定大小，而ArrayList大小是规定的，只能扩容，或者在构造的时候设定。 19. ArrayList和LinkedList的区别？ 1. ArrayList和LinkedList都是有序列表。线程都不安全。 2. ArrayList是动态数组，LinkedList是双向链表。 3. ArrayList查找快，复杂度是O(1),而LinkedList是O(n)。 4. ArrayList增删慢。 5. LinkedList比ArrayList消耗更多的内存，因为LinkedList中的每个结点存储了前后节点的引用。 6. ArrayList提供随机查找。 20. 哪些集合提供元素的随机查找？ ArrayList、HashMap、TreeMap、Hashtable。 21. 哪些集合是线程安全的? Vector、Stack、Hashtable、Properties 22. 队列和栈是什么，列出它们的区别？ Stack是一个类，继承自Vector(FILO) Queue是一个接口，FIFO 23. Collections和Collection的区别？ 1. Collection是集合框架的顶层接口，Java不允许有它的直接实现类。 2. Collections是Java.util.*下的一个工具类，里面都是静态方法。 24. Comparaable和Comparator接口是什么，有什么区别？ 1. Comparable和Comparator接口被用来对对象集合或者数组进行排序。Comparable接口被用来提供对象的自然排序，我们可以使用它来提供基于单个逻辑的排序。 2. Comparator接口被用来提供不同的排序算法，我们可以选择需要使用的Comparator来对给定的对象集合进行排序。 25. 当一个集合被作为参数传递给一个函数时，如何才可以确保函数不能修改它？ 在作为参数传递之前，我们可以使用Collections.unmodifiableCollection(Collection c)方法创建一个只读集合，这将确保改变集合的任何操作都会抛出UnsupportedOperationException。 26. 在Hashtable上下文中同步是什么意思？ 同步意味着在一个时间点只能有一个线程可以修改哈希表，任何线程在执行hashtable的更新操作前需要获取对象锁，其他线程等待锁的释放。]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Concurrent（六）]]></title>
    <url>%2F2017%2F11%2F29%2FConcurrent%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节讲的是ReentrantLock ReentrantLock概述ReentrantLock是一个可重入的互斥锁。 ReentrantLock锁在同一个时间点只能被一个线程锁持有；而可重入的意思是，ReentrantLock锁，可以被单个线程多次获取。 ReentrantLock分为“公平锁”和“非公平锁”。它们的区别体现在获取锁的机制上是否公平。“锁”是为了保护竞争资源，防止多个线程同时操作线程而出错，ReentrantLock在同一个时间点只能被一个线程获取(当某线程获取到“锁”时，其它线程就必须等待)；ReentraantLock是通过一个FIFO的等待队列来管理获取该锁所有线程的。在“公平锁”的机制下，线程依次排队获取锁；而“非公平锁”在锁是可获取状态时，不管自己是不是在队列的开头都会获取锁。 ReentrantLock函数列表1234567891011121314151617181920212223242526272829303132333435363738394041// 创建一个 ReentrantLock ，默认是“非公平锁”。ReentrantLock()// 创建策略是fair的 ReentrantLock。fair为true表示是公平锁，fair为false表示是非公平锁。ReentrantLock(boolean fair)// 查询当前线程保持此锁的次数。int getHoldCount()// 返回目前拥有此锁的线程，如果此锁不被任何线程拥有，则返回 null。protected Thread getOwner()// 返回一个 collection，它包含可能正等待获取此锁的线程。protected Collection&lt;Thread&gt; getQueuedThreads()// 返回正等待获取此锁的线程估计数。int getQueueLength()// 返回一个 collection，它包含可能正在等待与此锁相关给定条件的那些线程。protected Collection&lt;Thread&gt; getWaitingThreads(Condition condition)// 返回等待与此锁相关的给定条件的线程估计数。int getWaitQueueLength(Condition condition)// 查询给定线程是否正在等待获取此锁。boolean hasQueuedThread(Thread thread)// 查询是否有些线程正在等待获取此锁。boolean hasQueuedThreads()// 查询是否有些线程正在等待与此锁有关的给定条件。boolean hasWaiters(Condition condition)// 如果是“公平锁”返回true，否则返回false。boolean isFair()// 查询当前线程是否保持此锁。boolean isHeldByCurrentThread()// 查询此锁是否由任意线程保持。boolean isLocked()// 获取锁。void lock()// 如果当前线程未被中断，则获取锁。void lockInterruptibly()// 返回用来与此 Lock 实例一起使用的 Condition 实例。Condition newCondition()// 仅在调用时锁未被另一个线程保持的情况下，才获取该锁。boolean tryLock()// 如果锁在给定等待时间内没有被另一个线程保持，且当前线程未被中断，则获取该锁。boolean tryLock(long timeout, TimeUnit unit)// 试图释放此锁。void unlock() ReentrantLock示例加锁123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899package juc;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class Depot&#123; private int size; private Lock lock; public Depot()&#123; this.size=0; this.lock=new ReentrantLock(); &#125; public void produce(int val)&#123; lock.lock(); size+=val; System.out.println("produce--&gt;"+Thread.currentThread().getName()+".."+val+".."+size); lock.unlock(); &#125; public void consume(int val)&#123; lock.lock(); size-=val; System.out.println("consume--&gt;"+Thread.currentThread().getName()+".."+val+".."+size); lock.unlock(); &#125;&#125;class Producer&#123; private Depot depot; public Producer(Depot depot) &#123; super(); this.depot = depot; &#125; public void produce(int val)&#123; new Thread()&#123; public void run()&#123; depot.produce(val); &#125; &#125;.start(); &#125;&#125;class Customer&#123; private Depot depot; public Customer(Depot depot) &#123; super(); this.depot = depot; &#125; public void consume(int val)&#123; new Thread()&#123; public void run()&#123; depot.consume(val); &#125; &#125;.start(); &#125;&#125;public class LockTest &#123; public static void main(String[] args) &#123; Depot myDepot = new Depot(); Producer myPro = new Producer(myDepot); Customer myCus = new Customer(myDepot); myPro.produce(60); myPro.produce(120); myCus.consume(90); myCus.consume(150); myPro.produce(110); &#125;&#125;/**Output: produce--&gt;Thread-0..60..60 produce--&gt;Thread-1..120..180 consume--&gt;Thread-2..90..90 consume--&gt;Thread-3..150..-60 produce--&gt;Thread-4..110..50分析： 1. Depot是一个仓库，通过produce()能往仓库中生产货物，通过consume()能消费仓库中的货物。通过独占锁lock实现对仓库的互斥访问：在操作（生活/消费）仓库中货品前，会先lock(),操作完再unlock()解锁。 2. Produce是生产者类。调用Producer中的produce()函数可以新建一个线程往仓库中生产产品。 3. Customer是消费者类。调用Customer中的consume()函数可以新建一个线程消费仓库中的产品。 4. 在主线程main中，我们会新建1个生产者myPro，同时新建1个消费者myCus。它们分别向仓库中生产/消费产品。 根据main中的生产/消费数量，仓库最终剩余的产品应该是50。运行结果是符合我们预期的！*/ 不加锁1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package juc;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class Depot&#123; private int size; private Lock lock; public Depot()&#123; this.size=0; this.lock=new ReentrantLock(); &#125; public void produce(int val)&#123; //lock.lock(); size+=val; System.out.println("produce--&gt;"+Thread.currentThread().getName()+".."+val+".."+size); //lock.unlock(); &#125; public void consume(int val)&#123; //lock.lock(); size-=val; System.out.println("consume&lt;--"+Thread.currentThread().getName()+".."+val+".."+size); //lock.unlock(); &#125;&#125;class Producer&#123; private Depot depot; public Producer(Depot depot) &#123; super(); this.depot = depot; &#125; public void produce(int val)&#123; new Thread()&#123; public void run()&#123; depot.produce(val); &#125; &#125;.start(); &#125;&#125;class Customer&#123; private Depot depot; public Customer(Depot depot) &#123; super(); this.depot = depot; &#125; public void consume(int val)&#123; new Thread()&#123; public void run()&#123; depot.consume(val); &#125; &#125;.start(); &#125;&#125;public class LockTest &#123; public static void main(String[] args) &#123; Depot myDepot = new Depot(); Producer myPro = new Producer(myDepot); Customer myCus = new Customer(myDepot); myPro.produce(60); myPro.produce(120); myCus.consume(90); myCus.consume(150); myPro.produce(110); &#125;&#125;/**Output: produce--&gt;Thread-0..60..60 produce--&gt;Thread-1..120..180 consume&lt;--Thread-3..150..90 consume&lt;--Thread-2..90..90 produce--&gt;Thread-4..110..200*/ 线程等待123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139package juc;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;class Depot&#123; private int capacity;//仓库的容量 private int size;//仓库的实际数量 private Lock lock;//独占锁 private Condition fullCondition; private Condition emptyCondition; public Depot(int capacity)&#123; this.capacity = capacity; this.size=0; this.lock=new ReentrantLock(); this.fullCondition = lock.newCondition(); this.emptyCondition = lock.newCondition(); &#125; public void produce(int val)&#123; lock.lock();//加锁 try &#123; int left = val; while(left&gt;0)&#123; while(size&gt;=capacity)&#123; fullCondition.await(); &#125; int increment = (size+left)&gt;capacity?(capacity-size):left; size+=increment; left-=increment; System.out.println("produce--&gt;"+Thread.currentThread().getName()+",一共要生产："+val+",这次生产完还需要再生产："+left+",这次生产多少："+increment+",实际现在有多少："+size); emptyCondition.signal(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally&#123; lock.unlock(); &#125; &#125; public void consume(int val)&#123; lock.lock(); try &#123; int left = val; while(left&gt;0)&#123; while(size&lt;=0)&#123; emptyCondition.await(); &#125; int decrement = (size&lt;left)?size:left; size-=decrement; left-=decrement; System.out.println("consume&lt;--"+Thread.currentThread().getName()+",一共需要多少："+val+"，这次完了还需要多少："+left+",这次需要多少："+decrement+",实际现在有多少"+size); fullCondition.signal(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally&#123; lock.unlock(); &#125; &#125; @Override public String toString() &#123; return "Depot [capacity=" + capacity + ", size=" + size + ", lock=" + lock + ", fullCondition=" + fullCondition + ", emptyCondition=" + emptyCondition + "]"; &#125;&#125;class Producer&#123; private Depot depot; public Producer(Depot depot) &#123; super(); this.depot = depot; &#125; public void produce(int val)&#123; new Thread()&#123; public void run()&#123; depot.produce(val); &#125; &#125;.start(); &#125;&#125;class Customer&#123; private Depot depot; public Customer(Depot depot) &#123; super(); this.depot = depot; &#125; public void consume(int val)&#123; new Thread()&#123; public void run()&#123; depot.consume(val); &#125; &#125;.start(); &#125;&#125;public class LockTest &#123; public static void main(String[] args) &#123; Depot myDepot = new Depot(100); Producer myPro = new Producer(myDepot); Customer myCus = new Customer(myDepot); myPro.produce(60); myPro.produce(120); myCus.consume(90); myCus.consume(150); myPro.produce(110); &#125;&#125;/**Output: produce--&gt;Thread-0,一共要生产：60,这次生产完还需要再生产：0,这次生产多少：60,实际现在有多少：60 produce--&gt;Thread-4,一共要生产：110,这次生产完还需要再生产：70,这次生产多少：40,实际现在有多少：100 consume&lt;--Thread-3,一共需要多少：150，这次完了还需要多少：50,这次需要多少：100,实际现在有多少0 produce--&gt;Thread-4,一共要生产：110,这次生产完还需要再生产：0,这次生产多少：70,实际现在有多少：70 consume&lt;--Thread-3,一共需要多少：150，这次完了还需要多少：0,这次需要多少：50,实际现在有多少20 produce--&gt;Thread-1,一共要生产：120,这次生产完还需要再生产：40,这次生产多少：80,实际现在有多少：100 consume&lt;--Thread-2,一共需要多少：90，这次完了还需要多少：0,这次需要多少：90,实际现在有多少10 produce--&gt;Thread-1,一共要生产：120,这次生产完还需要再生产：0,这次生产多少：40,实际现在有多少：50*/]]></content>
      <categories>
        <category>Concurrent</category>
      </categories>
      <tags>
        <tag>Concurrent JUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Concurrent（五）]]></title>
    <url>%2F2017%2F11%2F29%2FConcurrent%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节学习了同步锁和JUC包中的锁，了解了JUC包中锁的组成和AQS的概念。同时了解了独占锁、共享锁、可重入的概念 Java中的锁根据锁添加到Java中的时间，Java中的锁，可以分为”同步锁”和”JUC包中的锁”。 同步锁所谓的同步锁，也就是之前加了synchronized关键字来进行同步，实现对竞争资源的互斥访问的锁。 同步锁的原理是，对于每一个对象，有且仅有一个同步锁；不同的线程能共同访问该同步锁。但是，在同一个时间点，该同步锁能且只能被一个线程获取到。这个得到锁的线程才能被CPU调度，从而在CPU上执行。而没有获取到同步锁的线程，必须进行等待，直到获取到同步锁之后才能继续运行。 这个原理也就是多线程通过同步锁进行同步的原理！！！ JUC包中的锁相比同步锁，JUC包中的锁的功能更加强大，它为锁提供了一个框架，该框架允许更灵活地使用锁，只是它的用法更难罢了。 JUC包中锁，包括：Lock接口，ReadWriteLock接口，LockSupport阻塞原语，Condition条件，AbstractOwnableSynchronizer/AbstractQueuedSynchronizer/AbstractQueuedLongSynchronizer三个抽象类，ReentrantLock独占锁，ReentrantReadWriteLock读写锁。由于CountDownLatch，CyclicBarrier和Semaphore也是通过AQS来实现的；因此，我也将它们归纳到锁的框架中进行介绍。 锁的框架 LockJUC包中的Lock接口支持那些语义不同（重入、公平等）的锁规则。所谓语义不同，是指锁可是有”公平机制的锁”、”非公平机制的锁”、”可重入的锁”等等。 公平/非公平机制指的是不同线程获取锁的机制是否公平，而可重入指的是同一个锁能够被一个线程多次获取。 ReadWriteLockReadWriteLock 接口以和Lock类似的方式定义了一些读取者可以共享而写入者独占的锁。JUC包只有一个类实现了该接口，即 ReentrantReadWriteLock，因为它适用于大部分的标准用法上下文。但程序员可以创建自己的、适用于非标准要求的实现。 AbstractOwnableSynchronizer/AbstractQueuedSynchronizer/AbstractQueuedLongSynchronizerAbstractQueuedSynchronizer就是被称之为AQS的类，它是一个非常有用的超类，可用来定义锁以及依赖于排队阻塞线程的其他同步器；ReentrantLock，ReentrantReadWriteLock，CountDownLatch，CyclicBarrier和Semaphore等这些类都是基于AQS类实现的。AbstractQueuedLongSynchronizer 类提供相同的功能但扩展了对同步状态的 64 位的支持。两者都扩展了类 AbstractOwnableSynchronizer（一个帮助记录当前保持独占同步的线程的简单类）。 LockSupportLockSupport提供“创建锁”和“其他同步类的基本线程阻塞原语”。 LockSupport的功能和”Thread中的Thread.suspend()和Thread.resume()有点类似”，LockSupport中的park() 和 unpark() 的作用分别是阻塞线程和解除阻塞线程。但是park()和unpark()不会遇到“Thread.suspend 和 Thread.resume所可能引发的死锁”问题。 ConditionCondition需要和Lock联合使用，它的作用是代替Object监视器方法，可以通过await(),signal()来休眠/唤醒线程。Condition 接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版本中的不同。 ReentrantLock（独占锁）ReentrantLock是独占锁。所谓独占锁，是指只能被独自占领，即同一个时间点只能被一个线程锁获取到的锁。ReentrantLock锁包括”公平的ReentrantLock”和”非公平的ReentrantLock”。”公平的ReentrantLock”是指”不同线程获取锁的机制是公平的”，而”非公平的 ReentrantLock”则是指”不同线程获取锁的机制是非公平的”，ReentrantLock是”可重入的锁”。 1. ReentrantLock实现了Lock接口。 2. ReentrantLock内部有一个成员变量sync，syn是Sync类；Sync是一个抽象类，且这个抽象类继承自AQS。 3. ReentrantLock中&quot;公平锁类&quot;FairSync和&quot;非公平锁类&quot;NonFairSync，它们都是Sync的子类。 4. ReentrantReadWriteLock中sync对象，是FairSync与NonfairSync中的一种，这也意味着ReentrantLock是&quot;公平锁&quot;或&quot;非公平锁&quot;中的一种，ReentrantLock默认是非公平锁。 ReentrantReadWriteLockReentrantReadWriteLock是读写锁接口ReadWriteLock的实现类，它包括ReadLock和WriteLock。ReadLock是共享锁，而Write是独占所。（独占和共享是根据是否锁在同一时刻能否被不同的线程占有）。 1. ReentrantReadWriteLock实现了ReadWriteLock接口。 2. ReentrantReadWriteLock中包含sync对象，读锁readerLock和写锁writerLock。同时读/写锁也都实现了Lock接口。 3. 和&quot;ReentrantLock&quot;一样，sync也是Sync类，继承自AQS的抽象类，也包括FairLock和NonFairLock CountDownLatchCountDownLatch是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。 CyclicBarrierCyclicBarrier是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。 CyclicBarrier是包含了”ReentrantLock对象lock”和”Condition对象trip”，它是通过独占锁实现的。 CyclicBarrier和CountDownLatch的区别是： 1. CountDownLatch的作用是允许1或N个线程等待其他线程完成执行；而CyclicBarrier则是允许N个线程相互等待。 2. CountDownLatch的计数器无法被重置；CyclicBarrier的计数器可以被重置后使用，因此它被称为是循环的barrier。 SemaphoreSemaphore是一个计数信号量，它的本质是一个”共享锁”。 信号量维护了一个信号量许可集。线程可以通过调用acquire()来获取信号量的许可；当信号量中有可用的许可时，线程能获取该许可；否则线程必须等待，直到有可用的许可为止。 线程可以通过release()来释放它所持有的信号量许可。]]></content>
      <categories>
        <category>Concurrent</category>
      </categories>
      <tags>
        <tag>Concurrent JUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Concurrent（四）]]></title>
    <url>%2F2017%2F11%2F29%2FConcurrent%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[从这一节开始了解Java中的Java Utils Concurrent，本节学习了JUC的整体框架和JUC类：基本数据类型(AtomicInteger,AtomicLong,AtomicBoolean)、数组(AtomicIntegerArray,AtomicLongArray,AtomicReferenceArray)、引用类型(AtomicReference)。 了解了一下什么是CAS（CompareAndSwap） JUC概括Java JUC包结构 Atomic : AtomicIntegerLocks : Lock, Condition, ReadWriteLockCollections : Queue, ConcurrentMapExecuter : Future, Callable, ExecutorTools : CountDownLatch, CyclicBarrier, Semaphore 原子操作多线程执行一个操作时，其中任何一个线程要么完全执行完此操作，要么没有执行此操作的任何步骤，那么这个操作就是原子的。 原子操作之所以会出现就是因为synchronized的代价比较高。 下面以AtomicInteger为例子。 int addAndGet(int delta)：以原子方式将给定值与当前值相加。 实际上就是等于线程安全版本的i =i+delta操作。 boolean compareAndSet(int expect, int update)：如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。 如果成功就返回true，否则返回false，并且不修改原值。 int decrementAndGet()：以原子方式将当前值减 1。 相当于线程安全版本的–i操作。 int getAndAdd(int delta)：以原子方式将给定值与当前值相加。 相当于线程安全版本的t=i;i+=delta;return t;操作。 int getAndDecrement()：以原子方式将当前值减 1。 相当于线程安全版本的i–操作。 int getAndIncrement()：以原子方式将当前值加 1。 相当于线程安全版本的i++操作。 int getAndSet(int newValue)：以原子方式设置为给定值，并返回旧值。 相当于线程安全版本的t=i;i=newValue;return t;操作。 int incrementAndGet()：以原子方式将当前值加 1。 相当于线程安全版本的++i操作。 JUC原子类原子类框架根据修改的数据类型，可以将JUC包中的原子操作类分为4类。 基本类型: AtomicInteger, AtomicLong, AtomicBoolean ; 数组类型: AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray ; 引用类型: AtomicReference, AtomicStampedRerence, AtomicMarkableReference ; 对象的属性修改类型: AtomicIntegerFieldUpdater, AtomicLongFieldUpdater, AtomicReferenceFieldUpdater 。 这些类存在的目的是对相应的数据进行原子操作。所谓原子操作，是指操作过程不会被中断，保证数据操作是以原子方式进行的。 AtomicLongAtomicInteger, AtomicLong和AtomicBoolean这3个基本类型的原子类的原理和用法相似。 AtomicLong作用是对长整形进行原子操作。 在32位操作系统中，64位的long和double变量由于会被JVM当做两个分离的32位来进行操作，所有不具有原子性。而使用AtomicLong能让Long的操作保持原子性。 123456789101112131415161718192021222324252627282930313233343536373839函数列表：// 构造函数AtomicLong()// 创建值为initialValue的AtomicLong对象AtomicLong(long initialValue)// 以原子方式设置当前值为newValue。final void set(long newValue) // 获取当前值final long get() // 以原子方式将当前值减 1，并返回减1后的值。等价于“--num”final long decrementAndGet() // 以原子方式将当前值减 1，并返回减1前的值。等价于“num--”final long getAndDecrement() // 以原子方式将当前值加 1，并返回加1后的值。等价于“++num”final long incrementAndGet() // 以原子方式将当前值加 1，并返回加1前的值。等价于“num++”final long getAndIncrement() // 以原子方式将delta与当前值相加，并返回相加后的值。final long addAndGet(long delta) // 以原子方式将delta添加到当前值，并返回相加前的值。final long getAndAdd(long delta) // 如果当前值 == expect，则以原子方式将该值设置为update。成功返回true，否则返回false，并且不修改原值。final boolean compareAndSet(long expect, long update)// 以原子方式设置当前值为newValue，并返回旧值。final long getAndSet(long newValue)// 返回当前值对应的int值int intValue() // 获取当前值对应的long值long longValue() // 以 float 形式返回当前值float floatValue() // 以 double 形式返回当前值double doubleValue() // 最后设置为给定值。延时设置变量值，这个等价于set()方法，但是由于字段是volatile类型的，因此次字段的修改会比普通字段（非volatile字段）有稍微的性能延时（尽管可以忽略），所以如果不是想立即读取设置的新值，允许在“后台”修改值，那么此方法就很有用。如果还是难以理解，这里就类似于启动一个后台线程如执行修改新值的任务，原线程就不等待修改结果立即返回（这种解释其实是不正确的，但是可以这么理解）。final void lazySet(long newValue)// 如果当前值 == 预期值，则以原子方式将该设置为给定的更新值。JSR规范中说：以原子方式读取和有条件地写入变量但不 创建任何 happen-before 排序，因此不提供与除 weakCompareAndSet 目标外任何变量以前或后续读取或写入操作有关的任何保证。大意就是说调用weakCompareAndSet时并不能保证不存在happen-before的发生（也就是可能存在指令重排序导致此操作失败）。但是从Java源码来看，其实此方法并没有实现JSR规范的要求，最后效果和compareAndSet是等效的，都调用了unsafe.compareAndSwapInt()完成操作。final boolean weakCompareAndSet(long expect, long update) AtomicLongArrayAtomicIntegerArray, AtomicLongArray, AtomicReferenceArray这3个数组类型的原子类的原理和用法相似。本章以AtomicLongArray对数组类型的原子类进行介绍。 AtomicLong是作用是对长整形进行原子操作。而AtomicLongArray的作用则是对”长整形数组”进行原子操作。 123456789101112131415161718192021222324252627282930313233343536函数列表：// 创建给定长度的新 AtomicLongArray。AtomicLongArray(int length)// 创建与给定数组具有相同长度的新 AtomicLongArray，并从给定数组复制其所有元素。AtomicLongArray(long[] array)// 以原子方式将给定值添加到索引 i 的元素。long addAndGet(int i, long delta)// 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。boolean compareAndSet(int i, long expect, long update)// 以原子方式将索引 i 的元素减1。long decrementAndGet(int i)// 获取位置 i 的当前值。long get(int i)// 以原子方式将给定值与索引 i 的元素相加。long getAndAdd(int i, long delta)// 以原子方式将索引 i 的元素减 1。long getAndDecrement(int i)// 以原子方式将索引 i 的元素加 1。long getAndIncrement(int i)// 以原子方式将位置 i 的元素设置为给定值，并返回旧值。long getAndSet(int i, long newValue)// 以原子方式将索引 i 的元素加1。long incrementAndGet(int i)// 最终将位置 i 的元素设置为给定值。void lazySet(int i, long newValue)// 返回该数组的长度。int length()// 将位置 i 的元素设置为给定值。void set(int i, long newValue)// 返回数组当前值的字符串表示形式。String toString()// 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。boolean weakCompareAndSet(int i, long expect, long update) AtomicLongArray示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package juc;import java.util.Arrays;import java.util.concurrent.atomic.AtomicLongArray;public class LongArrayTest &#123; public static void main(String[] args) &#123; long[] arrLong = new long[]&#123;10,20,30,40,50&#125;; AtomicLongArray ala = new AtomicLongArray(arrLong); ala.set(0, 100); StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; ala.length(); i++) &#123; sb.append(ala.get(i)+","); &#125; String str = sb.toString(); str = str.substring(0, str.length()-1); System.out.println("["+str+"]"); System.out.println("getAndDecrement(0)--&gt;"+ala.getAndDecrement(0)); System.out.println(ala.get(0)); System.out.println("decrementAndGet(1)--&gt;"+ala.decrementAndGet(1)); System.out.println(ala.get(1)); System.out.println("getAndIncrement(2)--&gt;"+ala.getAndIncrement(2)); System.out.println(ala.get(2)); System.out.println("incrementAndGet(3)--&gt;"+ala.incrementAndGet(3)); System.out.println(ala.get(3)); System.out.println("addAndGet(0,777)--&gt;"+ala.addAndGet(0, 777)); System.out.println(ala.get(0)); System.out.println("getAndAdd(0,777)--&gt;"+ala.getAndAdd(1, 777)); System.out.println(ala.get(1)); System.out.println("compareAndSet(0,1,777)--&gt;"+ala.compareAndSet(0, 100, 777)); System.out.println(ala.get(0)); &#125;&#125;/**Output: [100,20,30,40,50] getAndDecrement(0)--&gt;100 99 decrementAndGet(1)--&gt;19 19 getAndIncrement(2)--&gt;30 31 incrementAndGet(3)--&gt;41 41 addAndGet(0,777)--&gt;876 876 getAndAdd(0,777)--&gt;19 796 compareAndSet(0,1,777)--&gt;false 876*/ AtomicReferenceAtomicReference是作用是对”对象”进行原子操作。 123456789101112131415161718192021函数列表// 使用 null 初始值创建新的 AtomicReference。AtomicReference()// 使用给定的初始值创建新的 AtomicReference。AtomicReference(V initialValue)// 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。boolean compareAndSet(V expect, V update)// 获取当前值。V get()// 以原子方式设置为给定值，并返回旧值。V getAndSet(V newValue)// 最终设置为给定值。void lazySet(V newValue)// 设置为给定值。void set(V newValue)// 返回当前值的字符串表示形式。String toString()// 如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。boolean weakCompareAndSet(V expect, V update) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758源码：public class AtomicReference&lt;V&gt; implements java.io.Serializable &#123; private static final long serialVersionUID = -1848883965231344442L; // 获取Unsafe对象，Unsafe的作用是提供CAS操作 private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicReference.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; // volatile类型 private volatile V value; public AtomicReference(V initialValue) &#123; value = initialValue; &#125; public AtomicReference() &#123; &#125; public final V get() &#123; return value; &#125; public final void set(V newValue) &#123; value = newValue; &#125; public final void lazySet(V newValue) &#123; unsafe.putOrderedObject(this, valueOffset, newValue); &#125; public final boolean compareAndSet(V expect, V update) &#123; return unsafe.compareAndSwapObject(this, valueOffset, expect, update); &#125; public final boolean weakCompareAndSet(V expect, V update) &#123; return unsafe.compareAndSwapObject(this, valueOffset, expect, update); &#125; public final V getAndSet(V newValue) &#123; while (true) &#123; V x = get(); if (compareAndSet(x, newValue)) return x; &#125; &#125; public String toString() &#123; return String.valueOf(get()); &#125;&#125; AtomicReference的源码比较简单。它是通过”volatile”和”Unsafe提供的CAS函数实现”原子操作。 (01) value是volatile类型。这保证了：当某线程修改value的值时，其他线程看到的value值都是最新的value值，即修改之后的volatile的值。 (02) 通过CAS设置value。这保证了：当某线程池通过CAS函数(如compareAndSet函数)设置value时，它的操作是原子的，即线程在操作value时不会被中断。 AutomicReference示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package juc;import java.util.concurrent.atomic.AtomicReference;public class LongReferenceTest &#123; public static void main(String[] args)&#123; Person p1 = new Person(101); Person p2 = new Person(102); AtomicReference&lt;Person&gt; ar = new AtomicReference&lt;Person&gt;(p1); System.out.println(ar.compareAndSet(p1, p2)); System.out.println(ar.get()); Person p3 = ar.get(); System.out.print("p2==p3--&gt;"); System.out.println(p2==p3); System.out.print("p2.equals(p3)--&gt;"); System.out.println(p2.equals(p3)); int a = 1; int b = 1; System.out.print("a==b--&gt;"); System.out.println(a==b); Integer c = new Integer(1); Integer d = new Integer(1); System.out.print("c.equals(d)--&gt;"); System.out.println(c.equals(d)); System.out.print("c==d--&gt;"); System.out.println(c==d); //对于引用数据类型而言，我们的==和Object中的equals都是比较是否两个对象是同一个， //就是物理地址是否一致。 //但我们用的一些包装类之所以==和equals不一样是因为这些包装类重写了Object中的equals方法 //对于基本数据类型而言==比较的是具体的值 &#125;&#125;class Person&#123; volatile long id; public Person(long id)&#123; this.id = id; &#125; @Override public String toString() &#123; return "Person [id=" + id + "]"; &#125;&#125;/**Output: true Person [id=102] p2==p3--&gt;true p2.equals(p3)--&gt;true a==b--&gt;true c.equals(d)--&gt;true c==d--&gt;false*/]]></content>
      <categories>
        <category>Concurrent</category>
      </categories>
      <tags>
        <tag>Concurrent JUC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Concurrent（二）]]></title>
    <url>%2F2017%2F11%2F29%2FConcurrent%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节复习了线程中的生产和消费者关系。 生产消费者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135package thread_3;class Depot&#123; int capacity; int size; public Depot(int capacity) &#123; super(); this.capacity = capacity; this.size = 0; &#125; public synchronized void produce(int num)&#123; int want = num; while(want&gt;0)&#123; while(size&gt;=capacity)&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; int inc = (size+want)&gt;capacity ? (capacity-size) :want; size+=inc; want-=inc; System.out.printf("%s produce(%3d) --&gt; want=%3d, inc=%3d, size=%3d\n", Thread.currentThread().getName(), num, want, inc, size); notifyAll(); &#125; &#125; public synchronized void consume(int num)&#123; int want = num; while(want&gt;0)&#123; while(size&lt;=0)&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; int dec = (size&lt;want)?size:want; size-=dec; want-=dec; System.out.printf("%s consume(%3d) &lt;-- want=%3d, dec=%3d, size=%3d\n", Thread.currentThread().getName(), num, want, dec, size); notifyAll(); &#125; &#125; @Override public String toString() &#123; return "Depot [capacity=" + capacity + ", size=" + size + "]"; &#125;&#125;class Producer&#123; private Depot depot; public Producer(Depot depot) &#123; super(); this.depot = depot; &#125; public void produce(int val)&#123; new Thread()&#123; public void run()&#123; depot.produce(val); &#125; &#125;.start(); &#125;&#125;class Customer&#123; private Depot depot; public Customer(Depot depot) &#123; super(); this.depot = depot; &#125; public void consume(int val)&#123; new Thread()&#123; public void run()&#123; depot.consume(val); &#125; &#125;.start(); &#125;&#125;public class Shop &#123; public static void main(String[] args) &#123; Depot myDepot = new Depot(100); Producer myPro = new Producer(myDepot); Customer myCus = new Customer(myDepot); myPro.produce(60); myPro.produce(120); myCus.consume(90); myCus.consume(150); myPro.produce(110); &#125;&#125;/**Output: Thread-0 produce( 60) --&gt; want= 0, inc= 60, size= 60 Thread-4 produce(110) --&gt; want= 70, inc= 40, size=100 Thread-3 consume(150) &lt;-- want= 50, dec=100, size= 0 Thread-1 produce(120) --&gt; want= 20, inc=100, size=100 Thread-2 consume( 90) &lt;-- want= 0, dec= 90, size= 10 Thread-3 consume(150) &lt;-- want= 40, dec= 10, size= 0 Thread-4 produce(110) --&gt; want= 0, inc= 70, size= 70 Thread-3 consume(150) &lt;-- want= 0, dec= 40, size= 30 Thread-1 produce(120) --&gt; want= 0, inc= 20, size= 50分析： 1. Producer是"生产者"类，它与"仓库(depot)"关联。当调用"生产者"的produce()方法时，它会新建一个线程并向"仓库"中生产产品。 2. Customer是"消费者"类，它与"仓库(depot)"关联。当调用consume()方法时，它会新建一个线程并消费"仓库"中的产品。 3. Depot是"仓库"类，仓库记录"仓库的容量(capacity)"以及"仓库中当前产品数目(size)"。 4. "仓库"类中的两个方法都是synchronized方法，进入synchronized方法体，意味着这个线程获取了该"仓库"对象的同步锁。这就是说，同一时间，生产者和消费者线程只能有一个运行。通过同步锁，实现了对"残酷"的互斥访问。对于生产方法produce()而言：当仓库满时，生产者线程等待，需要等待消费者消费产品之后，生产线程才能生产；生产者线程生产完产品之后，会通过notifyAll()唤醒同步锁上的所有线程，包括“消费者线程”，即我们所说的“通知消费者进行消费”。对于消费方法consume()而言：当仓库为空时，消费者线程等待，需要等待生产者生产产品之后，消费者线程才能消费；消费者线程消费完产品之后，会通过notifyAll()唤醒同步锁上的所有线程，包括“生产者线程”，即我们所说的“通知生产者进行生产”。*/]]></content>
      <categories>
        <category>Concurrent</category>
      </categories>
      <tags>
        <tag>Concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Concurrent（二）]]></title>
    <url>%2F2017%2F11%2F27%2FConcurrent%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节复习了线程中的几个状态和演示：sleep、wait &amp; notify、yield、join、interrupt 线程处理 线程调用和执行（线程栈模型）栈是先进后出。 线程栈是指某时刻时内存中线程调度的栈信息，当前调用的方法总是位于栈顶。线程栈的内容随着程序的运行动态变化，因此，研究线程栈必须选择一个运行的时刻（实际上指代码运行到什么地方）。 这幅图描述在代码执行到两个不同时刻1、2时，虚拟机线程调用栈示意图。 当程序执行到t.start()时，程序多出了一个分支（增加了一个调用栈B），这样，栈A，栈B并行执行。 进程状态转换 新建状态（New）：新建一个线程对象 就绪 / 可运行 状态（Runnable）：线程对象创建后，其他线程调用了改对象的start()方法。该状态的线程位于可运行线程池中，变的可运行，等待CPU的使用权。 也就是说，start()方法调用时，线程首先进行可运行状态，但是这个时候调度程序还没有把它选定为运行线程。在线程运行之后或者从阻塞、等待或睡眠状态回来后，也可以返回到可运行状态。 运行状态（Running）：线程开始获取了CPU，执行程序代码。 线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进行运行状态的唯一一种方式。 阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态（Runnable），才有机会转到运行状态。阻塞的情况有三种： 等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。（wait会释放持有的锁） 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入Runnable状态。（Sleep和wait不同，Sleep不会释放锁）。 其实这三种状态组合为一种，其共同点就是：线程依旧是活的，但是当前没有条件运行。换句话说，它是可运行的，但是只有某件事件出现，它才可能回到Runnable 死亡状态（Dead）：线程执行玩了或者因异常退出了run()，该线程结束声明周期。 如果在一个死去的线程上调用start()方法，会抛出 java.lang.IllegalThreadStateException。 线程调度调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。 Java线程的优先级用整数表示，取值范围是1-10，Thread类中有三个静态常量： 123456static int MAX_PRIORITY 线程可以具有的最高优先级，取值为10。 static int MIN_PRIORITY 线程可以具有的最低优先级，取值为1。 static int NORM_PRIORITY 分配给线程的默认优先级，取值为5。 Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。 每个线程都有默认的优先级，比如A线程中创建了B线程，那么B将和A具有相同的优先级。JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。 线程睡眠Thread.sleep(long millis)，线程转到阻塞状态。millis参数设定睡眠的时间，当睡眠结束后，就转为Runnable状态。sleep()平台移植性好。 线程睡眠的原因：线程执行太快，或者需要强制进行下一轮，因为Java规范不会保证合理的轮换。 睡眠的实现：调用静态方法。 12345try &#123; Thread.sleep(123); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; 睡眠的位置：为了让其他线程有机会执行，可以将Thread.sleep()的调用放线程run()之内。这样才能保证线程执行的过程中会睡眠。 1234567891011121314151617181920212223242526272829303132333435363738394041package thread;public class ThreadDemo implements Runnable&#123; private String name; public ThreadDemo(String name)&#123; this.name = name; &#125; public void run()&#123; for(int i=0;i&lt;3;i++)&#123; System.out.println(name+" 运行 ："+i); &#125; try&#123; Thread.sleep((int)Math.random()*1000); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; ThreadDemo Th_1 = new ThreadDemo("线程一"); ThreadDemo Th_2 = new ThreadDemo("线程二"); ThreadDemo Th_3 = new ThreadDemo("线程三"); new Thread(Th_1).start(); new Thread(Th_2).start(); new Thread(Th_3).start(); &#125;&#125;/**Output: 线程二 运行 ：0 线程二 运行 ：1 线程二 运行 ：2 线程三 运行 ：0 线程一 运行 ：0 线程一 运行 ：1 线程一 运行 ：2 线程三 运行 ：1 线程三 运行 ：2*/ 注意： 1. 线程睡眠是帮助所有线程获得运行机会的最好方法。 2. 线程睡眠到期自动苏醒，并返回可运行状态（Runnable），不是运行态（Running）。sleep()中指定的时间只有线程不会运行的最短时间。因为，sleep()方法不能保证改线程睡眠到期后就开始执行。 3. sleep()是静态方法，只能控制当前正在运行的线程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class ThreadDemo_2 implements Runnable&#123; @Override public void run() &#123; for(int i=0;i&lt;50;i++)&#123; if(i%10==0)&#123; System.out.println("------"+i); &#125; System.out.print(i); try &#123; Thread.sleep(1); System.out.println(" 线程睡眠1毫秒"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; ThreadDemo_2 Th_1 = new ThreadDemo_2(); new Thread(Th_1).start(); &#125;&#125;/**Output: ------0 0 线程睡眠1毫秒 1 线程睡眠1毫秒 2 线程睡眠1毫秒 3 线程睡眠1毫秒 4 线程睡眠1毫秒 5 线程睡眠1毫秒 6 线程睡眠1毫秒 7 线程睡眠1毫秒 8 线程睡眠1毫秒 9 线程睡眠1毫秒 ------10 10 线程睡眠1毫秒 11 线程睡眠1毫秒 12 线程睡眠1毫秒 13 线程睡眠1毫秒 14 线程睡眠1毫秒 15 线程睡眠1毫秒 16 线程睡眠1毫秒 17 线程睡眠1毫秒 18 线程睡眠1毫秒 19 线程睡眠1毫秒 ------20 20 线程睡眠1毫秒 21 线程睡眠1毫秒 22 线程睡眠1毫秒 23 线程睡眠1毫秒 24 线程睡眠1毫秒 25 线程睡眠1毫秒 26 线程睡眠1毫秒 27 线程睡眠1毫秒 28 线程睡眠1毫秒 29 线程睡眠1毫秒 ------30 30 线程睡眠1毫秒 31 线程睡眠1毫秒 32 线程睡眠1毫秒 33 线程睡眠1毫秒 34 线程睡眠1毫秒 35 线程睡眠1毫秒 36 线程睡眠1毫秒 37 线程睡眠1毫秒 38 线程睡眠1毫秒 39 线程睡眠1毫秒 ------40 40 线程睡眠1毫秒 41 线程睡眠1毫秒 42 线程睡眠1毫秒 43 线程睡眠1毫秒 44 线程睡眠1毫秒 45 线程睡眠1毫秒 46 线程睡眠1毫秒 47 线程睡眠1毫秒 48 线程睡眠1毫秒 49 线程睡眠1毫秒*/ sleep（）和 wait()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package thread_2;public class SleepTest &#123; public static void main(String[] args) &#123; // 创建共享对象 Service service = new Service(); // 创建线程 SleepThread t1 = new SleepThread("t1", service); SleepThread t2 = new SleepThread("t2", service); // 启动线程 t1.start(); t2.start(); &#125; &#125; class SleepThread extends Thread &#123; private Service service; public SleepThread(String name, Service service) &#123; super(name); this.service = service; &#125; public void run() &#123; service.calc(); &#125; &#125; class Service &#123; public synchronized void calc() &#123; System.out.println(Thread.currentThread().getName() + "准备计算"); System.out.println(Thread.currentThread().getName() + "感觉累了，开始睡觉"); try &#123; Thread.sleep(5000);// 睡5秒 &#125; catch (InterruptedException e) &#123; return; &#125; System.out.println(Thread.currentThread().getName() + "睡醒了，开始计算"); System.out.println(Thread.currentThread().getName() + "计算完成"); &#125; &#125; /**Output: t1准备计算 t1感觉累了，开始睡觉 t1睡醒了，开始计算 t1计算完成 t2准备计算 t2感觉累了，开始睡觉 t2睡醒了，开始计算 t2计算完成*/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package thread_2;class Demo &#123; public synchronized void calc() &#123; System.out.println(Thread.currentThread().getName() + "准备计算"); System.out.println(Thread.currentThread().getName() + "感觉累了，开始睡觉"); try &#123; Thread.sleep(3000);// 睡5秒 &#125; catch (InterruptedException e) &#123; return; &#125; System.out.println(Thread.currentThread().getName() + "睡醒了，开始计算"); System.out.println(Thread.currentThread().getName() + "计算完成"); &#125; &#125; class SleepThread_1 extends Thread&#123; private Demo demo; public SleepThread_1(String name, Demo demo) &#123; super(name); this.demo = demo; &#125; @Override public void run() &#123; demo.calc(); &#125;&#125;public class ThreadDemo_5 &#123; public static void main(String[] args) throws InterruptedException &#123; Demo demo = new Demo(); Demo demo_2 = new Demo(); SleepThread_1 sTh = new SleepThread_1("t1",demo); SleepThread_1 sTh_2 = new SleepThread_1("t2",demo); sTh.start(); sTh_2.start();//sTh和sTh_2处于Runnable状态 synchronized (demo_2) &#123;//主线程拿到了demo_2这个对象的锁 for (int i = 0; i &lt; 3; i++) &#123; System.out.println(Thread.currentThread().getName()); Thread.sleep(20000); &#125; &#125; &#125;&#125;/**Output: main t1准备计算 t1感觉累了，开始睡觉 t1睡醒了，开始计算 t1计算完成 t2准备计算 t2感觉累了，开始睡觉 t2睡醒了，开始计算 t2计算完成 main main*/ 线程等待与唤醒1. wait() &amp; notify() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package thread_2;class Thread_1 extends Thread&#123; public Thread_1(String name)&#123; super(name); &#125; public void run()&#123; synchronized (this) &#123; System.out.println(Thread.currentThread().getName()+" call notify()"); notify(); &#125; &#125;&#125;public class ThreadDemo_2&#123; public static void main(String[] args) &#123; Thread_1 t1 = new Thread_1("t1");//线程t1处于新建状态 synchronized (t1) &#123;//主线程拿到了t1的锁 System.out.println(Thread.currentThread().getName()+" start t1"); t1.start();//只是Runnable状态，不一定就是直接被CPU调用 System.out.println(Thread.currentThread().getName()+" wait()"); try &#123; t1.wait(); //当前线程等待，当前线程是main，等待后，主线程进入阻塞状态，释放了t1对象的锁，t1线程拿到锁， //从runnable--&gt;running，执行了run()，走了notify(),唤醒了当前对象的阻塞线程(主线程)，主线程处于Runnable状态 //run()执行完之后，t1的锁被释放，被主线程拿到，主线程从runnable--&gt;running。 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+" continue"); &#125; &#125;&#125;/**Output: main start t1 main wait() t1 call notify() main continue*/ 注意： t1.wait()应该是让“线程t1”等待；但是，为什么却是让“主线程main”等待了呢？ 引起“当前线程”等待，直到另外一个线程调用notify()或notifyAll()唤醒该线程。换句话说，这个方法和wait(0)的效果一样！(补充，对于wait(long millis)方法，当millis为0时，表示无限等待，直到被notify()或notifyAll()唤醒)。 这里“当前线程”在调用wait()时，必须拥有该对象的同步锁。该线程调用wait()之后，会释放该锁；然后一直等待直到“其它线程”调用对象的同步锁的notify()或notifyAll()方法。然后，该线程继续等待直到它重新获取“该对象的同步锁”，然后就可以接着运行。 注意：jdk的解释中，说wait()的作用是让“当前线程”等待，而“当前线程”是指正在cpu上运行的线程！ 这也意味着，虽然t1.wait()是通过“线程t1”调用的wait()方法，但是调用t1.wait()的地方是在“主线程main”中。而主线程必须是“当前线程”，也就是运行状态，才可以执行t1.wait()。所以，此时的“当前线程”是“主线程main”！因此，t1.wait()是让“主线程”等待，而不是“线程t1”！ 2. wait(long time) &amp; notify() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package thread_2;class Thread_3 extends Thread&#123; public Thread_3(String name)&#123; super(name); &#125; public void run()&#123; synchronized (this) &#123; System.out.println(Thread.currentThread().getName()+" run "); while(true)&#123; System.out.print(1); &#125; &#125; &#125;&#125;public class ThreadDemo_3 &#123; public static void main(String[] args) &#123; Thread_3 t3 = new Thread_3("t3"); synchronized (t3) &#123; try &#123; System.out.println(Thread.currentThread().getName() + " start "); t3.start(); System.out.println(Thread.currentThread().getName()+" wait "); t3.wait(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+" continue "); &#125; &#125;&#125;/**Output: main start t3 main call wait t3 run分析： 1. 首先主线程加载，主线程上创建了t3对象（t3线程，处于new的状态) 2. synchroized(t3)主线程得到了t3对象的锁， 3. t3.start()，在主线程上开启t3线程，t3：new---&gt;runnable 4. t3.wait(3000)，主线程上wait(3000)，主线程进入阻塞状态，释放t3锁，t3线程拿到锁，开始执行run() 5. 执行3秒后，主线程回到runnable，但是这个时候t3线程一直是死循环，并没有释放锁！！！所以main线程不会接着代码执行！！！（只有主线程拿到了锁，才会再执行！！！） */ 3. wait() &amp; notifyAll() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package thread_2;public class ThreadDemo_3 &#123; private static Object obj = new Object(); public static void main(String[] args) &#123; Thread_3 t3 = new Thread_3("t3"); Thread_3 t4 = new Thread_3("t4"); Thread_3 t5 = new Thread_3("t5"); t3.start(); t4.start(); t5.start(); try &#123; System.out.println(Thread.currentThread().getName() + " sleep(3000) "); Thread.sleep(3000); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized (obj) &#123; System.out.println(Thread.currentThread().getName()+" notifyAll()"); obj.notifyAll(); &#125; &#125; static class Thread_3 extends Thread&#123; public Thread_3(String name)&#123; super(name); &#125; public void run()&#123; synchronized (obj) &#123; try &#123; System.out.println(Thread.currentThread().getName()+" wait "); obj.wait(); System.out.println(Thread.currentThread().getName()+" continue "); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;/**Output: t3 wait t4 wait main sleep(3000) t5 wait main notifyAll() t5 continue t4 continue t3 continue 分析： 1. 因为没有得到锁的关系，开始的时候我们的主线程和三个线程一个level，所以在start后，四个线程都可能被CPU调用。 2. 但是Thread.sleep(3000)，是在主线程上执行的，这个时候三个线程还是runnable，其中一个是running了，一旦进入running，那么就会在该线程了执行obj.wait 3. 在进入等待的时候，我们的主线程也在sleep，3秒后，主线程唤醒，得到obj的锁，开始唤醒obj对象上所有的线程，让所有的线程都又处于runnable。*/ 为什么notify(),wait()等函数定义在Object中，而不是Thread中 Object中的wait()，notify()等函数，和synchronized一样，会对“对象的同步锁”进行操作。 wait()会让“当前线程”等待，因为线程进入等待状态，所以线程才会释放持有的“同步锁”，否则其他线程获取不到该“同步锁”而无法运行！ 而一旦释放了锁，线程进入等待，那么notify依靠什么唤醒等待线程呢，就是“对象的同步锁” 唤醒线程只有在获取“该对象的同步锁”（这里的同步锁必须和等待线程的同步锁是一个），并且该对象在唤醒线程上调用notify后，才能唤醒等待线程。虽然，等待线程被唤醒；但是它并不会立刻执行，只是处于Runnable，因为唤醒线程还持有“该对象的同步锁”。必须等到唤醒线程释放了“对象的同步锁”之后，等待线程才能获取到“对象的同步锁”进而继续运行。 总之，notify(),wait()依赖于“同步锁”，而“同步锁”是对象锁持有，并且每个对象有且仅有一个！这就是为什么notify(),wait()等函数定义在Object类中，而不是Thread类中的原因。 线程让步线程让步：Thread.yield()方法，暂停当时正在执行的线程对象，把执行机会让给优先级一致或者更高的线程。 但是执行Thread.yield()的线程只是从Running–&gt;Runnable,和其他线程一起竞争，所以最后也是有可能又执行的 线程让步和线程等待的区别 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package thread_2;class ThreadA extends Thread&#123; public ThreadA(String name)&#123; super(name); &#125; int i=0; @Override public void run() &#123; synchronized (this) &#123; for(int i=0;i&lt;5;i++)&#123; System.out.println(Thread.currentThread().getName()+" -- Priority: "+Thread.currentThread().getPriority()+" , "+i); if(i%2==0)&#123; Thread.yield(); &#125; &#125; &#125; &#125;&#125;public class ThreadDemo_4 &#123; public static void main(String[] args) throws InterruptedException &#123; // 创建线程对象 ThreadA t1 = new ThreadA("t1"); t1.setPriority(Thread.MAX_PRIORITY); synchronized (t1) &#123; t1.start(); //Thread.sleep(1000); //t1.wait(); Thread.yield(); for(int i=0;i&lt;5;i++)&#123; System.out.println(Thread.currentThread().getName()+" -- Priority: "+Thread.currentThread().getPriority()+" , "+i); &#125; &#125; &#125;&#125;/**Output: main -- Priority: 5 , 0 main -- Priority: 5 , 1 main -- Priority: 5 , 2 main -- Priority: 5 , 3 main -- Priority: 5 , 4 t1 -- Priority: 10 , 0 t1 -- Priority: 10 , 1 t1 -- Priority: 10 , 2 t1 -- Priority: 10 , 3 t1 -- Priority: 10 , 4如果是t1.wait，则主线程进入阻塞态，并且会释放线程Output： t1 -- Priority: 10 , 0 t1 -- Priority: 10 , 1 t1 -- Priority: 10 , 2 t1 -- Priority: 10 , 3 t1 -- Priority: 10 , 4 main -- Priority: 5 , 0 main -- Priority: 5 , 1 main -- Priority: 5 , 2 main -- Priority: 5 , 3 main -- Priority: 5 , 4*/ (01) wait()是让线程由“运行状态”进入到“等待(阻塞)状态”，而不yield()是让线程由“运行状态”进入到“就绪状态”。(02) wait()是会线程释放它所持有对象的同步锁，而yield()和sleep()方法不会释放锁。 主线程等待 join()12345678910111213141516171819202122232425262728293031323334353637383940414243444546package thread_2;class Son extends Thread&#123; public void run()&#123; for(int i=0;i&lt;3;i++)&#123; System.out.println(Thread.currentThread().getName()+".."+i); &#125; &#125;&#125;class Father extends Thread&#123; public void run()&#123; Son s = new Son(); s.setName("Son"); s.start(); try &#123; s.join(); for(int i=0;i&lt;3;i++)&#123; System.out.println(Thread.currentThread().getName()+".."+i); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;public class ThreadJoin &#123; public static void main(String[] args) &#123; Thread f_Thread = new Father(); f_Thread.setName("Father"); f_Thread.start(); &#125;&#125;/**Output: Son..0 Son..1 Son..2 Father..0 Father..1 Father..2分析： 两个线程Father、Son，在Father启动后，创建Son，Son--&gt;Runnable,所以Father是主线程，Son是子线程。s.join后，会使对应这个子线程的父线程等待，直到子线程执行完毕，才继续执行。*/ 即只要子线程是活的，主线程就不停的等待。 123456789101112131415161718192021222324252627282930313233343536373839404142Join示例：package thread_2;public class ThreadJoin_2 &#123; public static void main(String[] args) throws InterruptedException &#123; Thread thA = new ThreadA("ThA"); thA.start(); thA.join(); System.out.println(Thread.currentThread().getName()+" end"); &#125; static class ThreadA extends Thread&#123; public ThreadA(String name)&#123; super(name); &#125; public void run()&#123; System.out.println(Thread.currentThread().getName()+" start"); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+" end"); &#125; &#125;&#125;/**Output: ThA start ThA end main end*/ Interrupt() &amp; 线程终止方式Interrupt()的作用是中断本线程。 本线程中断自己是被允许的；其他线程调用本线程的interrupt()方法时，会通过checkAccess()检查权限。这有可能抛出SecurityException异常。 如果本线程本身已经处于阻塞状态，这个时候调用它的interrupt()方法，那么它的“中断状态”会被清楚，并抛出一个InterruptedException。 例如，线程通过wait()进入阻塞状态，此时通过interrupt()中断该线程；调用interrupt()会立即将线程的中断标记设为“true”，但是由于线程处于阻塞状态，所以该“中断标记”会立即被清除为“false”，同时，会产生一个InterruptedException的异常。 如果线程被阻塞在一个Selector选择器中，那么通过interrupt()中断它时；线程的中断标记会被设置为true，并且它会立即从选择操作中返回。 如果不属于前面所说的情况，那么通过interrupt()中断线程时，它的中断标记会被设置为“true”。 中断一个“已终止的线程”不会产生任何操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899示例一：package thread_2;class MyThread extends Thread&#123; public MyThread(String name)&#123; super(name); &#125; @Override public void run() &#123; int i=0; while(!isInterrupted())&#123; try &#123; Thread.sleep(1000); i++; System.out.println(Thread.currentThread().getName()+"（"+this.getState()+"） loop "+i); &#125; catch (InterruptedException e) &#123; System.out.println(Thread.currentThread().getName() +" ("+this.getState()+") catch InterruptedException."); &#125; &#125; &#125;&#125;public class ThreadInterrupt &#123; public static void main(String[] args) &#123; Thread myTh = new MyThread("myTh"); System.out.println(myTh.getName()+"（"+myTh.getState()+"） is new."); myTh.start(); System.out.println(myTh.getName()+"（"+myTh.getState()+"） is runnable."); try &#123; Thread.sleep(3000); myTh.interrupt(); System.out.println(myTh.getName()+"（"+myTh.getState()+"） is interrupt."); Thread.sleep(3000); System.out.println(myTh.getName()+"（"+myTh.getState()+"） is interrupted."); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;/**Output1: myTh（NEW） is new. myTh（RUNNABLE） is runnable. myTh（RUNNABLE） loop 1 myTh（RUNNABLE） loop 2 myTh（TIMED_WAITING） is interrupt. myTh（RUNNABLE） loop 3 myTh（TERMINATED） is interrupted.Output2: myTh（NEW） is new. myTh（RUNNABLE） is runnable. myTh（RUNNABLE） loop 1 myTh（RUNNABLE） loop 2 myTh（RUNNABLE） loop 3 myTh (RUNNABLE) catch InterruptedException. myTh（TIMED_WAITING） is interrupt. myTh（RUNNABLE） loop 4 myTh（RUNNABLE） loop 5 myTh（TIMED_WAITING） is interrupted. myTh（RUNNABLE） loop 6 myTh（RUNNABLE） loop 7 ...... ......Output3: myTh（NEW） is new. myTh（RUNNABLE） is runnable. myTh（RUNNABLE） loop 1 myTh（RUNNABLE） loop 2 myTh（RUNNABLE） loop 3 myTh（RUNNABLE） is interrupt. myTh（TERMINATED） is interrupted.Output4: myTh（NEW） is new. myTh（RUNNABLE） is runnable. myTh（RUNNABLE） loop 1 myTh（RUNNABLE） loop 2 myTh（TIMED_WAITING） is interrupt. myTh (RUNNABLE) catch InterruptedException. myTh（RUNNABLE） loop 3 myTh（RUNNABLE） loop 4 myTh（RUNNABLE） loop 5 myTh（TIMED_WAITING） is interrupted. myTh（RUNNABLE） loop 6分析： 出现这种情况的原因就是因为在主线程Sleep（3000）后，我们的myTh线程和主线程开始出现一个竞争的关系，同时 在myTh拿到运行权后，又存在一个Sleep(1000)，这个时候main线程又会执行，同时sleep时，我们的myTh处于TIME_WAITTING，这个时候，因为myTh处于阻塞态，所以执行了中断后，也不会有影响，sleep醒来后还是继续竞争！！ 但是一旦是在myTh运行时，就被抢占了，这个时候再在主线程中执行中断，那么myTh就会被中断了！！！*/ 守护线程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// Demo.javaclass MyThread extends Thread&#123; public MyThread(String name) &#123; super(name); &#125; public void run()&#123; try &#123; for (int i=0; i&lt;5; i++) &#123; Thread.sleep(3); System.out.println(this.getName() +"(isDaemon="+this.isDaemon()+ ")" +", loop "+i); &#125; &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;; class MyDaemon extends Thread&#123; public MyDaemon(String name) &#123; super(name); &#125; public void run()&#123; try &#123; for (int i=0; i&lt;10000; i++) &#123; Thread.sleep(1); System.out.println(this.getName() +"(isDaemon="+this.isDaemon()+ ")" +", loop "+i); &#125; &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;public class Demo &#123; public static void main(String[] args) &#123; System.out.println(Thread.currentThread().getName() +"(isDaemon="+Thread.currentThread().isDaemon()+ ")"); Thread t1=new MyThread("t1"); // 新建t1 Thread t2=new MyDaemon("t2"); // 新建t2 t2.setDaemon(true); // 设置t2为守护线程 t1.start(); // 启动t1 t2.start(); // 启动t2 &#125; &#125;/**Output: main(isDaemon=false) t2(isDaemon=true), loop 0 t2(isDaemon=true), loop 1 t1(isDaemon=false), loop 0 t2(isDaemon=true), loop 2 t2(isDaemon=true), loop 3 t1(isDaemon=false), loop 1 t2(isDaemon=true), loop 4 t2(isDaemon=true), loop 5 t2(isDaemon=true), loop 6 t1(isDaemon=false), loop 2 t2(isDaemon=true), loop 7 t2(isDaemon=true), loop 8 t2(isDaemon=true), loop 9 t1(isDaemon=false), loop 3 t2(isDaemon=true), loop 10 t2(isDaemon=true), loop 11 t1(isDaemon=false), loop 4 t2(isDaemon=true), loop 12分析： (01) 主线程main是用户线程，它创建的子线程t1也是用户线程。 (02) t2是守护线程。在“主线程main”和“子线程t1”(它们都是用户线程)执行完毕，只剩t2这个守护线程的时候，JVM自动退出。*/]]></content>
      <categories>
        <category>Concurrent</category>
      </categories>
      <tags>
        <tag>Concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Concurrent（一）]]></title>
    <url>%2F2017%2F11%2F07%2FConcurrent%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节复习了多线程的概念，线程和进程的关系，Java中线程的创建方式，run()和start()的区别，synchronized 的使用。 Java多线程概念和原理操作系统中线程和进程的概念进程和线程都是一个时间段的描述，是CPU工作时间段的描述。 进程是指一个内存中运行的应用程序，每个进程都有自己独立的一块内存空间，一个进程中可以启动多个线程。比如在Windows系统中，一个运行的exe就是一个进程。 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位. 线程是指进程中的一个执行流程，一个进程中可以运行多个线程。比如java.exe进程中可以运行很多线程。线程总是属于某个进程，进程中的多个线程共享进程的内存。 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位. 线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮， 但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。 1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程. 2) 线程的划分尺度小于进程，使得多线程程序的并发性高。 3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独 立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立 的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 6) 进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其 他线程一起共享分配给该进程的所有资源。 线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。 多进程是指操作系统能同时运行多个任务（程序）。 多线程是指在同一程序中有多个顺序流在执行。 进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1–n个线程。（进程是资源分配的最小单位） 线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位） Java中线程的创建和启动在java中要想实现多线程，有两种手段，一种是继承Thread类，另外一种是实现Runable接口。 继承Thread类 1234567891011121314151617181920212223242526272829303132333435363738public class ThreadDemo extends Thread&#123; private String name; public ThreadDemo(String name)&#123; this.name = name; &#125; public void run()&#123; for(int i=0;i&lt;5;i++)&#123; System.out.println(name+" 运行 ："+i); &#125; try&#123; sleep((int)Math.random()*10); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; ThreadDemo Th_1 = new ThreadDemo("线程一"); ThreadDemo Th_2 = new ThreadDemo("线程二"); Th_1.start(); Th_2.start(); &#125;&#125;/**Output: 线程一 运行 ：0 线程二 运行 ：0 线程二 运行 ：1 线程二 运行 ：2 线程二 运行 ：3 线程二 运行 ：4 线程一 运行 ：1 线程一 运行 ：2 线程一 运行 ：3 线程一 运行 ：4*/ 程序启动运行main时候，java虚拟机启动一个进程，主线程main在main()调用时候被创建。随着调用MitiSay的两个对象的start方法，另外两个线程也启动了，这样，整个应用就在多线程下运行。 注意：start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。 从程序运行的结果可以发现，多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程。 Thread.sleep()方法调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留出一定时间给其他线程执行的机会。 实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。 但是start方法重复调用的话，会出现java.lang.IllegalThreadStateException异常。 1234567891011121314151617181920public static void main(String[] args) &#123; ThreadDemo Th_1 = new ThreadDemo("线程一"); ThreadDemo Th_2 = new ThreadDemo("线程二"); Th_1.start(); Th_1.start(); //Th_2.start();&#125;/**Output:Exception in thread "main" 线程一 运行 ：0线程一 运行 ：1线程一 运行 ：2线程一 运行 ：3线程一 运行 ：4java.lang.IllegalThreadStateException at java.lang.Thread.start(Thread.java:708) at thread.ThreadDemo.main(ThreadDemo.java:24)*/ 实现Runnable接口 123456789101112131415161718192021222324public class ThreadDemo implements Runnable&#123; private String name; public ThreadDemo(String name)&#123; this.name = name; &#125; public void run()&#123; for(int i=0;i&lt;5;i++)&#123; System.out.println(name+" 运行 ："+i); &#125; try&#123; Thread.sleep((int)Math.random()*10); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; ThreadDemo Th_1 = new ThreadDemo("线程一"); ThreadDemo Th_2 = new ThreadDemo("线程二"); new Thread(Th_1).start(); new Thread(Th_2).start(); &#125;&#125; 说明：Thread2类通过实现Runnable接口，使得该类有了多线程类的特征。run（）方法是多线程程序的一个约定。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。 在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。 实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是扩展Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。 Thread和Runnable的区别如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。 总结：实现Runnable接口比继承Thread类所具有的优势： 1）适合多个相同的程序代码的线程去处理同一个资源 2）可以避免java中的单继承的限制 3）增加程序的健壮性，代码可以被多个线程共享，代码和数据独立 4）线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类 提醒一下大家：main方法其实也是一个线程。在java中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到CPU的资源。 在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个JVM，每一个JVM实际上就是在操作系统中启动了一个进程。 常见的问题 线程的名字，一个运行中的线程总是有名字的，名字有两个来源，一个是虚拟机自己给的名字，一个是自己定的名字。在没有指定线程名字的情况下，虚拟机总会为线程指定名字，并且主线程的名字总是main，其他线程的名字不确定。 线程都可以设置和获取名字，主线程也不例外。 获取当前线程的对象的方法是Thread.currentThread() 上面的代码中，只能保证：每个线程都将启动，每个线程都将运行直到完成。一系列线程以某种顺序启动并不意味着将按改顺序执行。对于任何一组启动的线程来说，调度程序不能保证其执行次序，持续时间也无法保证。 一旦线程启动，它就永远不能再重新启动。只有一个新的线程可以被启动，并且只能一次。一个可运行的线程或死线程可以被重新启动。 线程的调度是JVM的一部分，在一个CPU的机器上，实际上一次只能运行一个线程。一个只有一个线程栈执行。JVM线程调度程序决定实际运行哪个处于可运行状态的线程。 众多可运行线程中的某一个会被选中作为当前线程。可运行线程被选择运行的顺序是没有保障的。 Thread中start()和run()的区别start()：它的作用是启动一个新线程，新线程会执行相应的run()方法。start()不能被重复调用。 run()：run()就和普通的成员方法一样，可以被重复调用。单独调用run()的话，会在当前线程中执行run(),并不会启动新的线程！！！ 1234567891011121314151617181920212223242526272829303132333435package thread;public class ThreadDemo_2 implements Runnable&#123; @Override public void run() &#123; System.out.println(" "+Thread.currentThread().getName()+" is Running"); &#125; public static void main(String[] args)&#123; ThreadDemo_2 Th_2 = new ThreadDemo_2(); Thread Th = new Thread(Th_2); Th.setName("MyThread"); System.out.println("Concurrent run():"); Th.run(); System.out.println("Concurrent start():"); Th.start(); &#125;&#125;/**Output: Concurrent run(): main is Running Concurrent start(): MyThread is Running分析： Thread.currentThread().getName()是用于获取"当前线程"的名字。当前线程指的是正在CPU中调度执行的线程。 Th.run()时，run()方法其实是在main线程上调用。 Th.start()时，run()方法就是在自己创建的线程上调用了*/ synchroized（同步锁）&amp; asynchroized（异步锁）同步和异步同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。 要想实现同步操作，必须要获得线程的对象锁。获得它可以保证在同一时刻只有一个线程能进入临界区，并且在这个锁被释放前，其他的线程都不能再进入这个临界区，如果其他线程想要获得这个对象的锁，只能进入等待队列等待。只有当拥有该对象锁的线程退出临界区时，锁才会被释放，等待队列中优先级最高的线程才能获得该锁。 实现同步的方式：同步方法，同步代码块 异步，当一个异步过程的调用发出后，调用者不会立刻得到结果。实际处理这个调用的部件实在调用发出后，通过状态，通知来通知调用者，或通过回调函数处理这个调用。 由于每个线程都包含了运行时自身所需要的数据或方法，因此，在进行输入输出时，不必关系其他线程的状态或行为，也不必等到输入输出处理完毕才返回。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，异步能够提高程序的效率。 同步的目的就是为了线程安全，其实对于线程安全来说，需要满足两个特性： * 原子性(同步) * 可见性 Java里同步和异步的概念，如果一个class类里有两个方法，一个叫做p1,一个叫做p2,如果p1加上synchronized修饰了，那么p1这个方法就叫做同步方法， p2没有加synchronized修饰，也没有采用任何锁的机制，那么p2就是一个异步方法。 synchroized原理在Java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。 当我们调用某对象的synchronized方法时，就获取了该对象的同步锁。例如，synchronized(obj)就获取了“obj这个对象”的同步锁。 不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到！通过同步锁，我们就能在多线程中，实现对“对象/方法”的互斥访问。 例如，现在有两个线程A和线程B，它们都会访问“对象obj的同步锁”。假设，在某一时刻，线程A获取到“obj的同步锁”并在执行一些操作；而此时，线程B也企图获取“obj的同步锁” —— 线程B会获取失败，它必须等待，直到线程A释放了“该对象的同步锁”之后线程B才能获取到“obj的同步锁”从而才可以运行。 synchroized基本规则我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。 第一条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 第二条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。 第三条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 1.当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 123456789101112131415161718192021222324252627282930313233343536373839404142434445package thread;class Thread_1 implements Runnable&#123; @Override public void run() &#123; synchronized (this) &#123; try &#123; for(int i=0;i&lt;3;i++)&#123; Thread.sleep(100); System.out.println(Thread.currentThread().getName()+" loop "+i); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class ThreadTest_4&#123; public static void main(String[] args) &#123; Runnable demo = new Thread_1(); Thread t1 = new Thread(demo,"t1"); Thread t2 = new Thread(demo,"t2"); t1.start(); t2.start();//执行的都是run的方法，但是run里面都是同步的，同时sleep并不会释放锁，所以只有t1线程结束后才会走t2 &#125;&#125;/**Output: t1 loop 0 t1 loop 1 t1 loop 2 t2 loop 0 t2 loop 1 t2 loop 2分析：run()方法中存在“synchronized(this)代码块”，而且t1和t2都是基于"demo这个Runnable对象"创建的线程。这就意味着，我们可以将synchronized(this)中的this看作是“demo这个Runnable对象”；因此，线程t1和t2共享“demo对象的同步锁”。所以，当一个线程运行的时候，另外一个线程必须等待“运行线程”释放“demo的同步锁”之后才能运行。*/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Thread_2 extends Thread&#123; public Thread_2() &#123; super(); &#125; public Thread_2(String name) &#123; super(name); &#125; @Override public void run() &#123; synchronized (this) &#123; try &#123; for(int i=0;i&lt;3;i++)&#123; Thread.sleep(100); System.out.println(Thread.currentThread().getName()+" loop "+i); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;public class ThreadTest_4&#123; public static void main(String[] args) &#123; Thread_2 t1 = new Thread_2("t1"); Thread_2 t2 = new Thread_2("t2"); t1.start(); t2.start(); &#125;&#125;/**Output: t1 loop 0 t2 loop 0 t1 loop 1 t2 loop 1 t2 loop 2 t1 loop 2分析：注意，这里为什么不是一个线程走完再走另一个呢，就是因为我们的锁加是this，也就是当前对象，这个main中t1，t2其实是两个对象了，并没有公用一个runnable子类对象，所以不会出现代码1中的情况。*/ 第二条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Demo&#123; public synchronized void synMethod()&#123; try &#123; for(int i=0;i&lt;3;i++)&#123; Thread.sleep(100); System.out.println(Thread.currentThread().getName()+" synMethod loop "+i); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public void asynMethod()&#123; try &#123; for(int i=0;i&lt;3;i++)&#123; Thread.sleep(100); System.out.println(Thread.currentThread().getName()+" asynMethod loop "+i); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;public class ThreadTest_4&#123; public static void main(String[] args) &#123; final Demo demo = new Demo(); Thread t1 = new Thread(new Runnable()&#123; @Override public void run() &#123; demo.synMethod(); &#125; &#125;,"t1"); Thread t2 = new Thread(new Runnable()&#123; @Override public void run() &#123; demo.asynMethod(); &#125; &#125;,"t2"); t1.start(); t2.start(); &#125;&#125;/**Output: t2 asynMethod loop 0 t1 synMethod loop 0 t1 synMethod loop 1 t2 asynMethod loop 1 t1 synMethod loop 2 t2 asynMethod loop 2分析： 主线程虽然新建了两个子线程t1和t2。t1会调用Demo对象的synMethod，t2调用Demo对象的asynMethod，并没有造成阻塞。*/ 第三条: 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Count &#123; // 含有synchronized同步块的方法 public void synMethod() &#123; synchronized(this) &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName() + " synMethod loop " + i); &#125; &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125; // 也包含synchronized同步块的方法 public void nonSynMethod() &#123; synchronized(this) &#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); System.out.println(Thread.currentThread().getName() + " nonSynMethod loop " + i); &#125; &#125; catch (InterruptedException ie) &#123; &#125; &#125; &#125;&#125;public class Demo3 &#123; public static void main(String[] args) &#123; final Count count = new Count(); // 新建t1, t1会调用“count对象”的synMethod()方法 Thread t1 = new Thread( new Runnable() &#123; @Override public void run() &#123; count.synMethod(); &#125; &#125;, "t1"); // 新建t2, t2会调用“count对象”的nonSynMethod()方法 Thread t2 = new Thread( new Runnable() &#123; @Override public void run() &#123; count.nonSynMethod(); &#125; &#125;, "t2"); t1.start(); // 启动t1 t2.start(); // 启动t2 &#125; &#125;/**Output: t1 synMethod loop 0 t1 synMethod loop 1 t1 synMethod loop 2 t1 synMethod loop 3 t1 synMethod loop 4 t2 nonSynMethod loop 0 t2 nonSynMethod loop 1 t2 nonSynMethod loop 2 t2 nonSynMethod loop 3 t2 nonSynMethod loop 4*/ synchronized方法 和 synchronized代码块“synchronized方法”是用synchronized修饰方法，而 “synchronized代码块”则是用synchronized修饰代码块。 123456789101112131415161718192021222324252627282930313233343536// Demo4.java的源码public class Demo4 &#123; public synchronized void synMethod() &#123; for(int i=0; i&lt;1000000; i++) ; &#125; public void synBlock() &#123; synchronized( this ) &#123; for(int i=0; i&lt;1000000; i++) ; &#125; &#125; public static void main(String[] args) &#123; Demo4 demo = new Demo4(); long start, diff; start = System.currentTimeMillis(); // 获取当前时间(millis) demo.synMethod(); // 调用“synchronized方法” diff = System.currentTimeMillis() - start; // 获取“时间差值” System.out.println("synMethod() : "+ diff); start = System.currentTimeMillis(); // 获取当前时间(millis) demo.synBlock(); // 调用“synchronized方法块” diff = System.currentTimeMillis() - start; // 获取“时间差值” System.out.println("synBlock() : "+ diff); &#125;&#125;/**Output: synMethod() : 11 synBlock() : 3*/ 实例锁 &amp; 全局锁实例锁 – 锁在某一个实例对象上。如果该类是单例，那么该锁也具有全局锁的概念。 实例锁对应的就是synchronized关键字。全局锁 – 该锁针对的是类，无论实例多少个对象，那么线程都共享该锁。 全局锁对应的就是static synchronized（或者是锁在该类的class或者classloader对象上）。 123456pulbic class Something &#123; public synchronized void isSyncA()&#123;&#125; public synchronized void isSyncB()&#123;&#125; public static synchronized void cSyncA()&#123;&#125; public static synchronized void cSyncB()&#123;&#125;&#125; x.isSyncA()与x.isSyncB():不能同时被访问123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package thread_2;class Something&#123; public synchronized void isSyncA()&#123; try &#123; for (int i = 0; i &lt; 3; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : isSyncA"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public synchronized void isSyncB()&#123; try &#123; for (int i = 0; i &lt; 3; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : isSyncB"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125;&#125;class Thread_1&#123; Something x = new Something(); Something y = new Something(); // 比较(01) x.isSyncA()与x.isSyncB() public void test_1() &#123; // 新建t11, t11会调用 x.isSyncA() Thread t11 = new Thread( new Runnable() &#123; @Override public void run() &#123; x.isSyncA(); &#125; &#125;, "t11"); // 新建t12, t12会调用 x.isSyncB() Thread t12 = new Thread( new Runnable() &#123; @Override public void run() &#123; x.isSyncB(); &#125; &#125;, "t12"); t11.start(); // 启动t11 t12.start(); // 启动t12 &#125;&#125;public class ThreadDemo &#123; public static void main(String[] args) &#123; Thread_1 Th_1 = new Thread_1(); Th_1.test_1(); &#125;&#125;/**Output: t11 : isSyncA t11 : isSyncA t11 : isSyncA t12 : isSyncB t12 : isSyncB t12 : isSyncB*/ x.isSyncA()与y.isSyncA()：可以同时被访问 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package thread_2;class Something&#123; public synchronized void isSyncA()&#123; try &#123; for (int i = 0; i &lt; 3; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : isSyncA"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public synchronized void isSyncB()&#123; try &#123; for (int i = 0; i &lt; 3; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : isSyncB"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125;&#125;class Thread_1&#123; Something x = new Something(); Something y = new Something(); // 比较(01) x.isSyncA()与x.isSyncB() public void test_1() &#123; // 新建t11, t11会调用 x.isSyncA() Thread t11 = new Thread( new Runnable() &#123; @Override public void run() &#123; x.isSyncA(); &#125; &#125;, "t11"); // 新建t12, t12会调用 x.isSyncB() Thread t12 = new Thread( new Runnable() &#123; @Override public void run() &#123; y.isSyncA(); &#125; &#125;, "t12"); t11.start(); // 启动t11 t12.start(); // 启动t12 &#125;&#125;public class ThreadDemo &#123; public static void main(String[] args) &#123; Thread_1 Th_1 = new Thread_1(); Th_1.test_1(); &#125;&#125;/**Output: t12 : isSyncA t11 : isSyncA t12 : isSyncA t11 : isSyncA t11 : isSyncA t12 : isSyncA*/ cSyncA()和cSyncB():不能被同时访问 因为cSyncA()和cSyncB()都是static类型，x.cSyncA()相当于Something.isSyncA()，y.cSyncB()相当于Something.isSyncB()，因此它们共用一个同步锁，不能被同时反问。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package thread_2;class Something&#123; public synchronized void isSyncA()&#123; try &#123; for (int i = 0; i &lt; 3; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : isSyncA"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public synchronized void isSyncB()&#123; try &#123; for (int i = 0; i &lt; 3; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : isSyncB"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public static synchronized void cSyncA()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : cSyncA"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public static synchronized void cSyncB()&#123; try &#123; for (int i = 0; i &lt; 5; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : cSyncB"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125;&#125;class Thread_1&#123; Something x = new Something(); Something y = new Something(); // 比较(01) x.isSyncA()与x.isSyncB() public void test_1() &#123; // 新建t11, t11会调用 x.isSyncA() Thread t11 = new Thread( new Runnable() &#123; @Override public void run() &#123; x.cSyncA(); &#125; &#125;, "t11"); // 新建t12, t12会调用 x.isSyncB() Thread t12 = new Thread( new Runnable() &#123; @Override public void run() &#123; y.cSyncB(); &#125; &#125;, "t12"); t11.start(); // 启动t11 t12.start(); // 启动t12 &#125;&#125;public class ThreadDemo &#123; public static void main(String[] args) &#123; Thread_1 Th_1 = new Thread_1(); Th_1.test_1(); &#125;&#125;/**Output: t11 : cSyncA t11 : cSyncA t11 : cSyncA t12 : cSyncB t12 : cSyncB t12 : cSyncB*/ isSyncA()和cSyncA()：可以被同时访问。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package thread_2;class Something&#123; public synchronized void isSyncA()&#123; try &#123; for (int i = 0; i &lt; 3; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : isSyncA"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public synchronized void isSyncB()&#123; try &#123; for (int i = 0; i &lt; 3; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : isSyncB"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public static synchronized void cSyncA()&#123; try &#123; for (int i = 0; i &lt; 3; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : cSyncA"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125; public static synchronized void cSyncB()&#123; try &#123; for (int i = 0; i &lt; 3; i++) &#123; Thread.sleep(100); // 休眠100ms System.out.println(Thread.currentThread().getName()+" : cSyncB"); &#125; &#125;catch (InterruptedException ie) &#123; &#125; &#125;&#125;class Thread_1&#123; Something x = new Something(); Something y = new Something(); // 比较(01) x.isSyncA()与x.isSyncB() public void test_1() &#123; // 新建t11, t11会调用 x.isSyncA() Thread t11 = new Thread( new Runnable() &#123; @Override public void run() &#123; x.cSyncA(); &#125; &#125;, "t11"); // 新建t12, t12会调用 x.isSyncB() Thread t12 = new Thread( new Runnable() &#123; @Override public void run() &#123; y.isSyncA(); &#125; &#125;, "t12"); t11.start(); // 启动t11 t12.start(); // 启动t12 &#125;&#125;public class ThreadDemo &#123; public static void main(String[] args) &#123; Thread_1 Th_1 = new Thread_1(); Th_1.test_1(); &#125;&#125;/**Output: t11 : cSyncA t12 : isSyncA t11 : cSyncA t12 : isSyncA t12 : isSyncA t11 : cSyncA*/]]></content>
      <categories>
        <category>Concurrent</category>
      </categories>
      <tags>
        <tag>Concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structure（Sort）]]></title>
    <url>%2F2017%2F11%2F06%2FData-Structure%EF%BC%88Sort%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节复习了七种排序 排序 三种简单的排序选择排序原理：第一个数和它后面的所有的数进行比较，如果后面的数有比第一个数小的，就交换。没有就接着下一个比较。第一次遍历完之后，确定了所有数中最小的那一个。接着就是从第二个数开始依次再比较所有后面的数，直到最后。 123456789101112131415161718/** * 第一个和后面的所有的数据进行一个比较，第一遍比较完确定了最一个最后的数据， * 其实也就是比较多少次，就确定了多少个最小值 * @param array */public static void selectSort(Integer[] array)&#123; Integer temp;//用来存放交换数据时候的 for(int i=0;i&lt;array.length;i++)&#123; for(int j=i+1;j&lt;array.length;j++)&#123; if(array[i]&gt;array[j])&#123; temp = array[j]; array[j] = array[i]; array[i] = temp; &#125; &#125; &#125;&#125; 冒泡排序原理：冒泡排序跟选择排序一样的简单，好理解，整个过程就想气泡一样往上升，假设从小到大排序，对于给定的n个记录，从第一个记录开始依次对相邻的两个记录进行比较，当前面的记录大于后面的记录时，交换位置，进行一轮比较后，第n位上就是整个记录中最大的数，然后在对前n-1个记录进行第二轮比较，重复该过程直到进行比较的记录只剩下一个为止。 12345678910111213141516171819/** * 冒泡排序 * * 第一层循环是长度为length的数组，需要比较length-1次。 * 第二层循环是相邻的两个数据之间进行比较 * @param array */public static void bubbleSort(Integer[] array)&#123; Integer temp; for(int i=0;i&lt;array.length-1;i++)&#123; for(int j=array.length-1;i&lt;j;j--)&#123; if(array[j]&lt;array[j-1])&#123; temp = array[j]; array[j] = array[j-1]; array[j-1] = temp; &#125; &#125; &#125;&#125; 直接插入排序原理: 简单，给定的一组记录，将其分为两个序列组，一个为有序序列(按照顺序从小到大或者从大到小)，一个为无序序列，初始时，将记录中的第一个数当成有序序列组中的一个数据，剩下其他所有数都当做是无序序列组中的数据。然后从无序序列组中的数据中(也就是从记录中的第二个数据开始)依次与有序序列中的记录进行比较，然后插入到有序序列组中合适的位置，直到无序序列组中的最后一个数据插入到有序序列组中为止。 算法说明：就用上面的那个图片 1. 一开始有序数组只有38，而无序数组中的第一个元素是65，65&gt;38,那么temp等于65，但是65&gt;38,所以不能进行内层循环，不过 还是执行了j=i-1，这个时候j变成了0，所以在后面才会有array[j+1] = arr[1] = 65. 第一层循环完之后，我们的有序数组变成了[38 65] 2. 外层循环的i++了，i=2，那么就是97，但是97还是比它前面的j=i-1=2-1=1，arr[1]大，所以arr[2] = 97 这层循环完以后，有序数组成了[38 65 97] 3. 有开始外层循环，i++，i=3，发现这个时候前面的数据arr[3-1] = 97,大于了76，所以arr[2+1] = arr[2]=97,这个时候我 们的arr[2]=arr[3]都是97，因为arr[2]&gt;temp，所以再往前走，arr[1]&lt;temp=76,这个时候j=1了，但是跳出了循环，所以我们 arr[j+1] = temp ---&gt; arr[2] = 76 这层循环完之后，有序数组成了[38 65 76 97] 4.依次往下走，直到我们无序数据中只有一个数据。 123456789101112131415161718/** * 把整个大的数组分成两个小的数组，左侧有序，右侧无序。默认右侧的第一个元素是无序的第一个元素，如果第一个元素均大于之前有序的元素，直接插入 * 否则，在有序数组中从后往前比较，进行插入，这样就会涉及到我们的数组的移位。 * @param array */public static void insertSort(Integer[] array)&#123; int j,temp;//temp临时存放无序数组中的第一个元素 for(int i=1;i&lt;array.length;i++)&#123;//一开始的时候第一个元素，也就是下标为0的数组元素单独是一个有序数组，后面的所有元素是一个无序数组 temp = array[i];//无序数组中的第一个元素 for(j=i-1;j&gt;=0&amp;&amp;temp&lt;array[j];j--)&#123; //拿到无序数组前的那个数据，一旦前面的数据比我们的无序数组的第一个元素大，就开始插入这个无序数组中的第一个元素， //既然是插入，就要涉及到插入位置后面所有角标的移位。 //这个循环是比较了把所有第一个无序元素和前面的有序元素的所有数据都进行了一次比较.一旦发现比它大的数据，直接就在前面插入。 array[j+1] = array[j]; &#125; array[j+1] = temp;//因为for循环最后一次--后比较了和temp的大小，但是小于temp，跳出了循环，但是--还是执行了，所以需要往后走一位，赋值。 &#125;&#125; 三种简单排序的升级希尔排序原理： 希尔排序其实是插入排序的升级版本，本质上进行的也是插入排序的操作，但是希尔排序并不是把一组记录看成一个整体，而将整个记录分为了若干组记录，然后在对每组记录进行插入排序， 分组规则为如下图所示：假设有 1 2 3 4 5 6 7 8 9 10 十个位置(每个位置上都会放数，这里忽略数，只讨论位置)。(省略了插入排序操作，只对如何分组进行讲解，而完整的希尔排序就是在每次分组完之后进行插入排序操作即可) 步长为：5、3、1 第一次分为5组记录(组数跟步长是一样的)：1,6 、2,7、3,8、 4,9、 5,10 这五组记录，分别对这五组记录进行插入排序。 第二次分为3组记录：1,4,7,10、2,5,8、3,6,9 这三组记录，分别对这三组记录进行插入排序 第三次分为1组记录：1 2 3 4 5 6 7 8 9 10， 为这组记录进行插入排序 而步长只要满足最后一次为1，并且是从大到小即可。一般使用(数组长度/2) 或者 (数组长度/3 +1) 来代表步长。 这样做的好处是： 将待排序的数组元素分成多组，每组中记录数相对较少 经过前几次的排序后，整个序列变为了“基本有序序列”，最后在对所有元素进行一次直接插入排序。 直接插入排序对基本有序和记录数少的序列的效率是非常高的，而希尔排序就是利用了这两点。 解释：第一次分组，49,13、38,27、65,49、97,55、76,04 五组，对这五组分别进行插入排序，在49找到13时，就会进行插入排序，位置会进行互换，而并非先全部分组，后排序。 按照步长一直重复执行，直到步长为1后，执行完最后一次直接插入排序，整个希尔排序就完成了。 12345678910111213141516171819202122/** * 希尔排序其实就是直接插值排序的升级版，在插值中我们每次都是一位一位的前进比较，但是在希尔排序中我们利用gap直接把数组分段， * 也就是说先小范围的比较，最后直接进行一次整合 * @param array */public static void shellSort(Integer[] array)&#123; int i,j,temp; int gap = array.length; do&#123; gap = gap/2; for(i=gap;i&lt;array.length;i++)&#123; if(array[i]&lt;array[i-gap])&#123; temp = array[i]; for(j=i-gap;j&gt;=0 &amp;&amp; array[j]&gt;temp;j-=gap)&#123; array[j+gap] = array[j]; &#125; array[j+gap] = temp; &#125; &#125; &#125;while(gap&gt;0);&#125; 快速排序原理： 快速排序是对冒泡排序的增强，增强得点在于：冒泡排序中，记录的比较和移动是在相邻两个位置进行的，记录每次交换只能后移一个位置，因而总的比较次数和移动次数较多，而快排记录的比较和移动是从两端向中间进行的，较大的记录一次就能从前面移动到后面，较小的记录一次就能从后面移动到前面，这样就减少了比较次数和移动次数。 选取一个轴值(比较的基准)，将待排序记录分为独立的两个部分，左侧记录都是小于或等于轴值，右侧记录都是大于或等于轴值，然后分别对左侧部分和右侧部分重复前面的过程，也就是左侧部分又选择一个轴值，又分为两个独立的部分，这就使用了递归了。到最后，整个序列就变得有序了。 问题：如何选择轴值？如何将序列变成左右两部分？ 轴值的选择有三种： 1、选取序列的第一个位置上的记录 2、选择序列的中间位置上的记录 3、将序列第一个位置 和 中间位置 和 末尾位置上的记录进行比较，选择大小居中的记录， 如何将序列划分成左右两部分？ 看图的执行流程，当一趟比较下来，轴值的左侧和右侧就被排好了，其中利用了first和end两个参数，一个从起点开始，一个从末尾开始，当两个相等时，就将序列中所有记录都遍历了一遍，第一次的比较次数是和选择排序第一次比较次数是一样的，但是之后就开始不一样了，因为在轴值的左侧的元素就不用跟轴值右侧的元素进行比较了，而选择排序还是跟所有的比。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 快速排序中计算每次轴值的位置 * 以第一次为例子，数组中的第一个元素为first也就是默认的轴值，在i&lt;j的情况下，从右往左走，右侧找小的，一旦找到了比轴值小的数据，轴值和 * 其位置交换，同时一开始指向轴值的指针加一，也就是左移，但是这个时候j是不变的，还是指向了轴值。左侧找大的，一旦找打了比轴值大的数据， * 进行位置交换，j又开始左移，不断循环，一直到i==j，跳出循环，返回轴值的位置 * @param array * @param first * @param end * @return */private static int Partition(Integer[] array,int first,int end)&#123; int i=first; int j=end; while(i&lt;j)&#123; while(i&lt;j &amp;&amp; array[i]&lt;array[j])&#123; j--; &#125; if(i&lt;j)&#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; i++; &#125; while(i&lt;j &amp;&amp; array[i]&lt;array[j])&#123; i++; &#125; if(i&lt;j &amp;&amp; array[i]&gt;array[j])&#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; j--; &#125; &#125; return j;&#125; /** * 快速排序中利用递归对数据进行循环。一旦找到了轴值，又以轴值为中心，两侧分为两个新的数组，开始其对应的新的轴值。 * @param array * @param first * @param end */private static void quickSortByScope(Integer[] array,int first,int end)&#123; if(first&lt;end)&#123; int pivot = Partition(array, first, end); quickSortByScope(array,first,pivot-1); quickSortByScope(array, pivot+1, end); &#125;&#125;/** * 快速排序 * @param array */public static void quickSort(Integer[] array)&#123; quickSortByScope(array, 0, array.length-1);&#125; 堆排序作为选择排序的改进版，堆排序可以把每一趟元素的比较结果保存下来，以便我们在选择最小/大元素时对已经比较过的元素做出相应的调整。 堆排序是一种树形选择排序，在排序过程中可以把元素看成是一颗完全二叉树，每个节点都大（小）于它的两个子节点，当每个节点都大于等于它的两个子节点时，就称为大顶堆，也叫堆有序； 当每个节点都小于等于它的两个子节点时，就称为小顶堆。 原理(以大顶堆为例)： 1.将长度为n的待排序的数组进行堆有序化构造成一个大顶堆 2.将根节点与尾节点交换并输出此时的尾节点 3.将剩余的n -1个节点重新进行堆有序化 4.重复步骤2，步骤3直至构造成一个有序序列 在构造有序堆时，我们开始只需要扫描一半的元素（n/2-1 ~ 0）即可，为什么?因为(n/2-1)~0的节点才有子节点，如n=8,(n/2-1) = 3 即3 2 1 0这个四个节点才有子节点 第一次构建 构建后输出调整 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 堆排序 * @param array */public static void heapSort(Integer[] array)&#123; int length = array.length; //第一步构建，将数组构建成一个大堆顶 for(int i=length/2-1;i&gt;=0;i--)&#123; //从完全二叉树的最后一个父节点的位置length/2处开始构建，二叉树上是length/2，在数组中就是length/2-1 //这里的i就是父节点的元素角标 //构建，这个函数的作用就是从下往上，把子结点中大于父节点的数据和父节点的数据交换。同时把父节点指向这个较大的子节点。 adjustMaxHeap(array,i,length); &#125; //第一遍构建完成后，开始调整，把堆顶的第一个数和最后一个数交换，并重新构建 for(int i = length-1;i&gt;0;i--)&#123; int temp = array[0]; array[0] = array[i]; array[i] = temp; adjustMaxHeap(array,0,i); &#125;&#125;/** * 大堆顶的构建 * @param array * @param i * @param length */public static void adjustMaxHeap(Integer[] array,int i,int length)&#123; int temp = array[i];//获取父节点 int child;//父节点的子节点中较大的那个元素在数组中的角标 for(child = 2*i+1;child&lt;=length-1;child = child*2+1)&#123; if(child&lt;length-1 &amp;&amp; array[child]&lt;array[child+1])&#123; //当前父节点是i，对应的左子结点是2(i+1),但是是数组就成了2(i+1)-1=2i+1 //child&lt;length-1,说明肯定i有右子结点，如果是child=length-1，说明只有左结点。 //左子结点小于右子结点，把子结点的指针指向右子结点 child++; &#125; if(array[child]&gt;temp)&#123; //如果当前父结点的右子结点大于父节点，交换位置 array[i] = array[child]; &#125;else&#123; break; &#125; array[child] = temp; i = child;//交换位置后，把父节点变成当前的这个大的子节点 &#125;&#125; 其他排序归并排序 拆分：其实就是不断的递归的过程 合并 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 归并排序 * 这个方法完成了合并的功能，把一个数组变成两个。第一个指针指向第一个元素，第二个元素指向中间元素的第一个元素。 * 循环比较大小，那个小就往临时数组中存那个。 * 一旦跳出了循环，就证明这个时候比较完成了，但是左数组或者是有数组中还存在一部分没有存入的元素，所以先存左数组，后存右数组。 * 存完之后把数组进行一个复制 * @param array * @param first * @param mid * @param end * @param temp */private static void merge(Integer[] array,int first,int mid,int end,Integer[] temp)&#123; int i = first; int j = mid+1; int t = 0; while(i&lt;=mid &amp;&amp; j&lt;=end)&#123; if(array[i]&lt;array[j])&#123; temp[t++] = array[i++]; &#125;else&#123; temp[t++] = array[j++]; &#125; &#125; while(i&lt;=mid)&#123; temp[t++] = array[i++]; &#125; while(j&lt;=end)&#123; temp[t++] = array[j++]; &#125; t=0; while(first&lt;=end)&#123; array[first++] = temp[t++]; &#125;&#125;/** * 这个方法完成了分的功能，利用了递归 * @param array * @param first * @param end * @param temp */private static void mergeSortBySort(Integer[] array,int first,int end,Integer[] temp)&#123; if(first&lt;end)&#123; int mid = (first+end)/2; mergeSortBySort(array,first,mid,temp); mergeSortBySort(array,mid+1,end,temp); merge(array,first,mid,end,temp); &#125;&#125;/** * 归并排序 * @param array */public static void mergeSort(Integer[] array)&#123; Integer[] temp = new Integer[array.length]; mergeSortBySort(array, 0, array.length-1, temp);&#125; 比较 整合123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213package algorithm;import java.util.Arrays;/** * Sort类 * @author whbai_xd@163.com * @date 2017年11月7日 下午8:36:47 */public class SortDemo &#123; //顺序排序 public static void selectSort(Integer[] array)&#123; int temp; for(int i=0;i&lt;array.length;i++)&#123; for(int j=i+1;j&lt;array.length;j++)&#123; if(array[i]&gt;array[j])&#123; temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; &#125; &#125; &#125; //冒泡排序 public static void bubbleSort(Integer[] array)&#123; int temp; for(int i=0;i&lt;array.length-1;i++)&#123; for(int j = array.length-1; j&gt;i;j--)&#123; if(array[j]&lt;array[j-1])&#123; temp = array[j-1]; array[j-1] = array[j]; array[j] = temp; &#125; &#125; &#125; &#125; //直接插入排序 public static void insertSort(Integer[] array)&#123; int j,temp; for(int i=1;i&lt;array.length;i++)&#123; if(array[i]&lt;array[i-1])&#123; temp = array[i]; for(j = i-1;j&gt;=0 &amp;&amp; array[j]&gt;temp;j--)&#123; array[j+1] = array[j]; &#125; array[j+1] = temp; &#125; &#125; &#125; //希尔排序 public static void shellSort(Integer[] array)&#123; int i,j,temp; int gap = array.length; do&#123; gap = gap/2; for(i = gap;i&lt;array.length;i++)&#123; if(array[i]&lt;array[i-gap])&#123; temp = array[i]; for(j = i-gap;j&gt;=0 &amp;&amp; array[j]&gt;temp;j-=gap)&#123; array[j+gap] = array[j]; &#125; array[j+gap] = temp; &#125; &#125; &#125;while(gap&gt;0); &#125; //快速排序 //1. 查找轴值 private static int Partition(Integer[] array,int first,int end)&#123; int i = first; int j = end; while(i&lt;j)&#123; while(i&lt;j &amp;&amp; array[i]&lt;array[j])&#123; j--; &#125; if(i&lt;j)&#123; swap(array,i,j); i++; &#125; while(i&lt;j &amp;&amp; array[i]&lt;array[j])&#123; i++; &#125; if(i&lt;j)&#123; swap(array,i,j); j--; &#125; &#125; return j; &#125; //2.递归 private static void quickSortByAxis(Integer[] array,int first,int end)&#123; if(first&lt;end)&#123; int axis = Partition(array, first, end); quickSortByAxis(array, first, axis-1); quickSortByAxis(array, axis+1, end); &#125; &#125; //进入 public static void quickSort(Integer[] array)&#123; quickSortByAxis(array, 0, array.length-1); &#125; //归并排序 //1.归并 private static void merge(Integer[] array,int first,int mid,int end,Integer[] temp)&#123; int i = first; int j = mid+1; int t = 0; while(i&lt;=mid &amp;&amp; j&lt;=end)&#123; if(array[i]&lt;array[j])&#123; temp[t++] = array[i++]; &#125;else&#123; temp[t++] = array[j++]; &#125; &#125; while(i&lt;=mid)&#123; temp[t++] = array[i++]; &#125; while(j&lt;=end)&#123; temp[t++] = array[j++]; &#125; t = 0; while(first&lt;=end)&#123; array[first++] = temp[t++]; &#125; &#125; //2.拆分---&gt;递归 private static void mergeSortByBin(Integer[] array,int first,int end,Integer[] temp)&#123; if(first&lt;end)&#123; int mid = (first+end)/2; mergeSortByBin(array,first,mid,temp); mergeSortByBin(array, mid+1, end, temp); merge(array, first, mid, end, temp); &#125; &#125; //归并 private static void mergeSort(Integer[] array)&#123; Integer[] temp = new Integer[array.length]; mergeSortByBin(array, 0, array.length-1, temp); &#125; //堆排序 //1.构建 private static void adjustMaxHeap(Integer[] array,int i,int length)&#123; int temp = array[i]; int child; for(child = 2*i+1;child&lt;=length-1;child = 2*child+1)&#123; if(child&lt;length-1 &amp;&amp; array[child]&lt;array[child+1])&#123; child++; &#125; if(array[child]&gt;temp)&#123; array[i] = array[child]; &#125;else&#123; break; &#125; array[child] = temp; i = child; &#125; &#125; //2.堆排序 public static void heapSort(Integer[] array)&#123; int length = array.length; for(int i=length/2-1;i&gt;=0;i--)&#123; adjustMaxHeap(array, i, length); &#125; for(int j=length-1;j&gt;0;j--)&#123; swap(array, 0, j); adjustMaxHeap(array, 0, j); &#125; &#125; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;93,10,4,2,76,1,3,6,61,29,5,6,5,123,87&#125;; //selectSort(array); //bubbleSort(array); //insertSort(array); //shellSort(array); //quickSort(array); //mergeSort(array); heapSort(array); System.out.println(Arrays.toString(array)); &#125; public static void swap(Integer[] array,int i,int j)&#123; int temp = array[j]; array[j] = array[i]; array[i] = temp; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm Sort</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structure（又说Hash表）]]></title>
    <url>%2F2017%2F11%2F05%2FData-Structure%EF%BC%88%E5%8F%88%E8%AF%B4Hash%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这节又再看了一下散列表的东西 Hash表（散列表）散列(Hash)表概述散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使得每个关键字key对应一个存储位置f(key)。 我们把这种对应关系f称为散列函数，又称为（Hash）函数。按这个思想，采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hashtable）。那么关键字对应的记录的存储位置我们称为散列地址。 整个散列的过程其实就是两步： 1. 存储时，通过hash函数计算记录的散列地址，并按此散列地址存储该记录。 2. 查找记录时，同样的利用hash函数计算记录的散列地址，并按此地址访问该记录。 hash冲突，说的是两个key不相同的记录，通过hash函数后得到了相同的散列地址(key1 != key2 f(key1) == f(key2))。 同时，我们把key1和key2称为这个散列函数的同义词。 散列函数的构造构造要求： 1. 计算简单 2. 散列地址分布均匀 1. 直接定址法 我们取关键字的某个线性函数值为散列地址。 f(key) = a*key+b （a，b为常数） 2. 除留余数法 f(key) = key%p (p&lt;=m) 若散列表表长是m，通常p为小于或等于表长的最小质数或不包含小于20质因子的合数。 3. 数字分析法 4. 平方取中法 5. 折叠法 6. 随机数法 取关键字的随机函数值为它的散列地址。也就是f(key)=random(key) 解决散列冲突(拉链法)拉链法是指把所有的同义词存储在一个线性链表中，这个链表由散列地址唯一标识。 关键字码为：{06,12,15,26,36,38,41,44,51,68}，散列函数为H(key)=key%13。用拉链法处理冲突建立的表如下： 解决散列冲突(开放定址法)所谓的开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。 f(key) = (f(key)+di)%m (m是散列表长) 线性探测 di = 1，2，3，… ，m-1 特点：冲突发生时，顺序查看表中下一个单元，直到直到空单元为止。 我们把本来不是同义词却需要争夺一个地址的情况称为堆积。 平方探测 di=1^2，-1^2，2^2，-2^2···，k^2，-k^2。K&lt;s=m/2 随机探测法 位移量di采用随机函数计算得到 解决散列冲突(再散列、公共溢出)一、 再散列函数法 f(key) = RHi(key) 这里RHi就是不同的散列函数，每当发生散列地址冲突的时候，就换一个散列函数计算。 二、 公共溢出区法 就相当于把冲突的记录放入了一个新的表中，在查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行查找，如果相等，则查找成功；如果不相等，则到溢出表去进行顺序查找。如果相对于基本表而言，有冲突的数据数据很少的情况下，公共溢出区的结构对查找性能还是很高的。 关于Hash的常用类（HashMap）HashMap数据结构JDK1.8以前，都是这种数组+链表的实现。 JDK1.8使用了这种数组+链表+红黑树的实现。 HashMap成员变量1234567891011121314151617181920212223242526272829public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; // 序列号 private static final long serialVersionUID = 362498820763181265L; // 默认的初始容量是16 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 最大容量 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认的填充因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 当桶(bucket)上的结点数大于这个值时会转成红黑树 static final int TREEIFY_THRESHOLD = 8; // 当桶(bucket)上的结点数小于这个值时树转链表 static final int UNTREEIFY_THRESHOLD = 6; // 桶中结构转化为红黑树对应的table的最小大小 static final int MIN_TREEIFY_CAPACITY = 64; // 存储元素的数组，总是2的幂次倍 // table就是存储Node类的数组，就是对应上图中左边那一栏， transient Node&lt;k,v&gt;[] table; // 存放具体元素的集 transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet; // 存放元素的个数，注意这个不等于数组的长度。 transient int size; // 每次扩容和更改map结构的计数器，fail-fast机制 transient int modCount; // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容,也就是size&gt;threshold的时候就会扩容 int threshold; // 填充因子 final float loadFactor;&#125; HashMap构造方法HashMap(int initialCapacity, float loadFactor) 1234567891011121314151617181920212223242526272829public HashMap(int initialCapacity, float loadFactor) &#123; // 初始容量不能小于0，否则报错 if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); // 初始容量不能大于最大值，否则为最大值 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; // 填充因子不能小于或等于0，不能为非数字 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); // 初始化填充因子 this.loadFactor = loadFactor; // 初始化threshold大小 this.threshold = tableSizeFor(initialCapacity); &#125;//说明：tableSizeFor(initialCapacity)返回大于initialCapacity的最小的二次幂数值。static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; HashMap(int initialCapacity) 1234public HashMap(int initialCapacity) &#123; // 调用HashMap(int initialCapacity, float loadFactor)型构造函数 this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125; HashMap() 123public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125; HashMap(Map&lt;? extends K, ? extends V&gt; m)123456789101112131415161718192021222324252627282930313233public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; // 初始化填充因子 this.loadFactor = DEFAULT_LOAD_FACTOR; // 将m中的所有元素添加至HashMap中 putMapEntries(m, false);&#125;//说明：putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict)函数将m的所有元素存入本HashMap实例中。 final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; // 判断table是否已经初始化 if (table == null) &#123; // pre-size // 未初始化，s为m的实际元素个数 float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); // 计算得到的t大于阈值，则初始化阈值 if (t &gt; threshold) threshold = tableSizeFor(t); &#125; // 已初始化，并且m元素个数大于阈值，进行扩容处理 else if (s &gt; threshold) resize(); // 将m中的所有元素添加至HashMap中 for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125;&#125; HashMap中重要的方法Node内部类TreeNode内部类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// Node&lt;K,V&gt; 类用来实现数组及链表的数据结构 static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; //保存节点的 hash 值 final K key; //保存节点的 key 值 V value; //保存节点的 value 值 Node&lt;K,V&gt; next; //指向链表结构下的当前节点的 next 节点，红黑树 TreeNode 节点中也有用到 Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; &#125; public final V getValue() &#123; &#125; public final String toString() &#123; &#125; public final int hashCode() &#123; &#125; public final V setValue(V newValue) &#123; &#125; public final boolean equals(Object o) &#123; &#125; &#125; public class LinkedHashMap&lt;K,V&gt; &#123; static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125; &#125; &#125; // TreeNode&lt;K,V&gt; 继承 LinkedHashMap.Entry&lt;K,V&gt;，用来实现红黑树相关的存储结构 static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // 存储当前节点的父节点 TreeNode&lt;K,V&gt; left; //存储当前节点的左孩子 TreeNode&lt;K,V&gt; right; //存储当前节点的右孩子 TreeNode&lt;K,V&gt; prev; // 存储当前节点的前一个节点 boolean red; // 存储当前节点的颜色（红、黑） TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; final TreeNode&lt;K,V&gt; root() &#123; &#125; static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) &#123; &#125; final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123; &#125; final void treeify(Node&lt;K,V&gt;[] tab) &#123; &#125; final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) &#123; &#125; final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int h, K k, V v) &#123; &#125; final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, boolean movable) &#123; &#125; final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123; &#125; /* ------------------------------------------------------------ */ // Red-black tree methods, all adapted from CLR // 红黑树相关操作 static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) &#123; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; p) &#123; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123; &#125; static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123; &#125; static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) &#123; &#125; &#125; put方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//指定节点 key,value，向 hashMap 中插入节点public V put(K key, V value) &#123; //注意待插入节点 hash 值的计算，调用了 hash(key) 函数 //实际调用 putVal（）进行节点的插入 return putVal(hash(key), key, value, false, true);&#125;static final int hash(Object key) &#123; int h; /*key 的 hash 值的计算是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销*/ return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 先将table赋给tab，判断table是否为null或大小为0，若为真，就调用resize（）初始化 ,n的值在条件上已经进行了判断 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; /*根据 hash 值确定节点在数组中的插入位置，若此位置没有元素则进行插入，注意确定插入位置所用的计算方法为 (n - 1) &amp; hash,由于 n 一定是２的幂次，这个操作相当于 hash % n */ //通过i = (n - 1) &amp; hash得到table中的index值，若为null，则直接添加一个newNode if ((p = tab[i = (n - 1) &amp; hash]) == null)//这个时候p已经是原来tab中tab[i]处的对象 tab[i] = newNode(hash, key, value, null); else &#123;//说明待插入位置存在元素.执行到这里，说明发生碰撞，即tab[i]不为空，需要组成单链表或红黑树 Node&lt;K,V&gt; e; K k; //比较原来元素与待插入元素的 hash 值和 key 值 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) //此时p指的是table[i]中存储的那个Node，如果待插入的节点中hash值和key值在p中已经存在，则将p赋给e e = p; //如果table数组中node类的hash、key的值与将要插入的Node的hash、key不吻合，就需要在这个node节点链表或者树节点中查找。 else if (p instanceof TreeNode)//若原来元素是红黑树节点，调用红黑树的插入方法:putTreeVal e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123;//证明原来的元素是链表的头结点，从此节点开始向后寻找合适插入位置 //到这里说明碰撞的节点以单链表形式存储，for循环用来使单链表依次向后查找 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; //找到插入位置后，新建节点插入.将p的下一个节点赋给e，如果为null，创建一个新节点赋给p的下一个节点 p.next = newNode(hash, key, value, null); //若链表上节点超过TREEIFY_THRESHOLD - 1，将链表变为红黑树 //如果冲突节点达到8个，调用treeifyBin(tab, hash)，这个treeifyBin首先回去判断当前hash表的长度，如果不足64的话，实际上就只进行resize，扩容table，如果已经达到64，那么才会将冲突项存储结构改为红黑树。 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //如果有相同的hash和key，则退出循环 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e;//将p调整为下一个节点 &#125; &#125;//end else//若e不为null，表示已经存在与待插入节点hash、key相同的节点，hashmap后插入的key值对应的value会覆盖以前相同key值对应的value值，就是下面这块代码实现的 if (e != null) &#123; // 待插入元素在 hashMap 中已存在 V oldValue = e.value; if (!onlyIfAbsent || oldValue == null)//判断是否修改已插入节点的value e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125;//end else ++modCount;//插入新节点后，hashmap的结构调整次数+1 if (++size &gt; threshold) resize();//HashMap中节点数+1，如果大于threshold，那么要进行一次扩容 afterNodeInsertion(evict); return null;&#125;//end putval/**1. 判断键值对数组tab[]是否为空或为null，是则resize()； 2. 根据键值key的hashCode()计算hash值得到当前Node的索引i，如果tab[i]==null[没碰撞]，直接新建节点添加，否则[碰撞]转入3 3. 判断当前数组中处理hash冲突的方式为红黑树还是链表(check第一个节点类型即可),分别处理。 [① 是红黑树则按红黑树逻辑插入； ② 是链表，则遍历链表，看是否有key相同的节点； ③ 有则更新value值，没有则新建节点，此时若链表数量大于阀值8【9个】，则调用treeifyBin方法. （此方法先判断table是否为null或tab.length小于64，是则执行resize操作，否则才将链表改为红黑树）]4. 如果size+1&gt; threshold则resize*/ public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; putMapEntries(m, true);&#125; /*把Map&lt;? extends K, ? extends V&gt; m 中的元素插入到 hashMap 中,若 evict 为 false,代表是在创建 hashMap 时调用了这个函数，例如利用上述构造函数３创建 hashMap;若 evict 为true,代表是在创建 hashMap 后才调用这个函数，例如上述的 putAll 函数。*/ final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; /*如果是在创建 hashMap 时调用的这个函数则 table 一定为空*/ if (table == null) &#123; //根据待插入的map 的 size 计算要创建的 hashMap 的容量。 float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); //把要创建的 hashMap 的容量存在 threshold 中 if (t &gt; threshold) threshold = tableSizeFor(t); &#125; //判断待插入的 map 的 size,若 size 大于 threshold，则先进行 resize() else if (s &gt; threshold) resize(); for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); //实际也是调用 putVal 函数进行元素的插入 putVal(hash(key), key, value, false, evict); &#125; &#125;&#125; resize()//两倍扩容并初始化table 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111final Node&lt;K,V&gt;[] resize() &#123; // 保存resize前的table Node&lt;K,V&gt;[] oldTab = table;//定义临时Node数组型变量，作为hash table // 保存resize前的table大小 int oldCap = (oldTab == null) ? 0 : oldTab.length; // 保存当前阈值 int oldThr = threshold; int newCap, newThr = 0;//初始化新的table长度和门限值 // 之前table大小大于0 if (oldCap &gt; 0) &#123; //执行到这里，说明table已经初始化 // 之前table大于最大容量 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; // 阈值为最大整形 threshold = Integer.MAX_VALUE; return oldTab; &#125; // 容量翻倍，使用左移，效率更高。//二倍扩容，容量和门限值都加倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) // 阈值翻倍 newThr = oldThr &lt;&lt; 1; // double threshold &#125; // 之前阈值大于0 else if (oldThr &gt; 0) newCap = oldThr;//用构造器初始化了门限值，将门限值直接赋给新table容量 // oldCap = 0并且oldThr = 0，使用缺省值（如使用HashMap()构造函数，之后再插入一个元素会调用resize函数，会进入这一步） else &#123;//老的table容量和门限值都为0，初始化新容量，新门限值，在调用hashmap（）方式构造容器时，就采用这种方式初始化 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 新阈值为0 if (newThr == 0) &#123;//如果门限值为0，重新设置门限 float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr;//更新新门限值为threshold @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) //初始化新的table数组 Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // //当原来的table不为null时，需要将table[i]中的节点迁移 if (oldTab != null) &#123; // 复制元素，重新进行hash for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123;//取出链表中第一个节点保存，若不为null，继续下面操作 oldTab[j] = null; if (e.next == null)//链表中只有一个节点，没有后续节点，则直接重新计算在新table中的index，并将此节点存储到新table对应的index位置处 newTab[e.hash &amp; (newCap - 1)] = e;//主动释放 else if (e instanceof TreeNode)//若e是红黑树节点，则按红黑树移动 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; //迁移单链表中的每个节点 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; // 将同一桶中的元素根据(e.hash &amp; oldCap)是否为0进行分割，分成两个不同的链表，完成rehash do &#123; /** * 把链表上的键值对按hash值分成lo和hi两串，lo串的新索引位置与原先相同[原先位 * j]，hi串的新索引位置为[原先位置j+oldCap]； * 链表的键值对加入lo还是hi串取决于 判断条件if ((e.hash &amp; oldCap) == 0)，因为* capacity是2的幂，所以oldCap为10...0的二进制形式，若判断条件为真，意味着 * oldCap为1的那位对应的hash位为0，对新索引的计算没有影响（新索引 * =hash&amp;(newCap-*1)，newCap=oldCap&lt;&lt;2）；若判断条件为假，则 oldCap为1的那位* 对应的hash位为1， * 即新索引=hash&amp;( newCap-1 )= hash&amp;( (oldCap&lt;&lt;2) - 1)，相当于多了10...0， * 即 oldCap * 例子： * 旧容量=16，二进制10000；新容量=32，二进制100000 * 旧索引的计算： * hash = xxxx xxxx xxxy xxxx * 旧容量-1 1111 * &amp;运算 xxxx * 新索引的计算： * hash = xxxx xxxx xxxy xxxx * 新容量-1 1 1111 * &amp;运算 y xxxx * 新索引 = 旧索引 + y0000，若判断条件为真，则y=0(lo串索引不变)，否则y=1(hi串 * 索引=旧索引+旧容量10000) */ next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; get() 1234567891011121314151617181920212223242526272829public V get(Object key) &#123; Node&lt;K,V&gt; e; //实际上是根据输入节点的 hash 值和 key 值利用getNode 方法进行查找 return (e = getNode(hash(key), key)) == null ? null : e.value; &#125; final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; // table已经初始化，长度大于0，根据hash寻找table中的项也不为空 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 桶中第一项(数组元素)相等 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 桶中不止一个结点 if ((e = first.next) != null) &#123; if (first instanceof TreeNode)// 为红黑树结点 //若定位到的节点是 TreeNode 节点，则在树中进行查找 return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123;//否则在链表中进行查找 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null; &#125; hashtable这里主要说一下hashMap和hashtable的区别就可以了 HashMap可以接受null(键值(key)和值(value)都可以为null），而Hashtable则不行，会抛出NullPointerException异常。 HashMap是非synchronized，而Hashtable是synchronized（每一个方法都使用synchronized进行了同步），这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有使用其他手段进行正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。 HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。 由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。 HashMap不能保证随着时间的推移Map中的元素次序是不变的。 HashMap中hash数组的默认大小是16，而且一定是2的指数。HashTable中hash数组默认大小是11，增加的方式是oldCapacity*2+1。 哈希值的使用不同，计算索引index的时候。HashMap重新计算hash值（扩容的时候不重新计算），而且用与运算代替求模。Hashtable直接使用key的hashCode值。 术语： 1. sychronized意味着在一次仅有一个线程能够更改Hashtable。就是说任何线程要更新Hashtable时要首先获得同步锁，其它线 程要等到同步锁被释放之后才能再次获得同步锁更新Hashtable。 2. Fail-safe和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更 改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这 并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。 3. 结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。 其他（1）HashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，HashCode是用来在散列存储结构中确定对象的存储地址的；（2）如果两个对象相同， equals方法一定返回true，并且这两个对象的HashCode一定相同；（3）如果对象的equals方法被重写，那么对象的HashCode也尽量重写，并且产生HashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；（4）两个对象的HashCode相同，并不一定表示两个对象就相同，也就是equals方法不一定返回true，只能够说明这两个对象在散列存储结构中，如Hashtable，他们存放在同一个篮子里。]]></content>
      <categories>
        <category>Algorithm Sort</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithm（排序）]]></title>
    <url>%2F2017%2F10%2F27%2FAlgorithm%EF%BC%88%E6%8E%92%E5%BA%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节复习了查找，从顺序表的顺序查找，到有序表的二分、插值、斐波那契查找，最后到我们的二叉排序树、AVL树的建立和查找。对于B树、B+树基本了解一点。 测试数组翻转利用队列的特性，先进后出。123456789101112131415161718192021public class SortDemo &#123; public static &lt;T&gt; void reverse(T[] arr)&#123; int start = 0; int end = arr.length-1; while(start&lt;end)&#123; T temp = arr[start]; arr[start] = arr[end]; arr[end] = temp; start++; end--; &#125; &#125; public static void main(String args[])&#123; Integer[] arr = &#123;2,43,1,1,4,1,31,1,54,9,0&#125;; reverse(arr); System.out.println(Arrays.toString(arr)); &#125;&#125; 顺序表查找顺序查找，又叫做线性查找，是最基本的查找技术，它的查找过程是:从表的第一个记录开始，逐个进行记录的说关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果查找到最后一个记录，其关键字和给定值比较都不相等，则表中没有所查的记录，查找不成功。 有重复的元素之后，返回的是第一次出现的下标 123456789101112131415public class FindDemo &#123; public static &lt;T&gt; int orderFind(T arr[], T key)&#123; for (int i = 0; i &lt; arr.length; i++) &#123; if(key == arr[i])&#123; return i; &#125; &#125; return -1; &#125; public static void main(String[] args)&#123; Integer[] arr = &#123;61,34,1,4,5,32,4,1&#125;; System.out.println(orderFind(arr,0)); &#125;&#125; 有序表查找二分查找(折半查找)折半查找。它的前提是线性表中的记录必须要是关键码有序，线性表必须采用顺序存储。 注意：折半查找的数组中最好不要有重复的元素 1234567891011121314151617181920public static int binarySearch(int[] arr, int key)&#123; Arrays.sort(arr); int min = 0; int max = arr.length-1; int mid; while(min&lt;=max)&#123; mid = (min+max)/2; if(key&lt;arr[mid])&#123; max = mid-1; &#125;else if(key&gt;arr[mid])&#123; min = mid+1; &#125;else&#123; return mid; &#125; &#125; return -1;&#125; 插值查找（二分查找增强)现在我们的新问题是，为什么一定要折半，而不是折四分之一或者折更多呢?打个比方，在英文词典里查”apple”，你下意识里翻开词典是翻前面的书页还是后面的书页呢?如果再让你查”zoo”，你又怎么查?很显然，这里你绝对不会是从中间开始查起，而是有一定目的的往前或往后翻。同样的，比如要在取值范围0 - 10000之间100个元素从小到大均匀分布的数组中查找5，我们自然会考虑从数组下标较小的开始查找。看来，我们的折半查找，还是有改进空间的。折半计算mid的公式，我们略微等式变换后得到:mid = (min+max)/2 = min + (max-min)/2也就是mid等于最低下标low加上最高下标high与low的差的一半。算法科学家们考虑的就是将这个 1/2 进行改进，通过类比，改进为下面的计算方案:mid = min + (max - min) * (key - arr[min]) / (arr[max] - arr[min]);这样就可以大大提高查找的效率。插值查找(Interpolation Search)是根据要查找的关键字 key 与查找表中最大最小记录的关键字比较后的查找方法，其核心就在于插值的计算公式(key - arr[min]) / (arr[max] - arr[min])。 应该说，从时间复杂度来看，它也是O(logn)， 但对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好得多 。反之， 数组中如果分布类似{0，1，2，2000，2001，…….,999998, 999999}这种极端不均匀的数据，用插值查找未必是很合适的选择。 1234567891011121314151617181920212223相比较二分查找，只是改变了循环中mid的查找方式，不再是简单的折半public static int binarySearch(int[] arr, int key)&#123; Arrays.sort(arr); int min = 0; int max = arr.length-1; int mid; while(min&lt;=max)&#123; mid = min + (max - min) * (key - arr[min]) / (arr[max] - arr[min]); if(key&lt;arr[mid])&#123; max = mid-1; &#125;else if(key&gt;arr[mid])&#123; min = mid+1; &#125;else&#123; return mid; &#125; &#125; return -1;&#125; 斐波那契查找(有点难)前半部分就是利用斐波那契额数列中的数值，重新做了个数组，而直接利用新的数组中的数据进行查找，这样就会出现新数组比我们原数组多元素的情况，所以将多余的都用最大角标（因为是顺序排序，角标最大就是最大）的元素值补全，补全后再进行查找 对这个算法的理解： 从上面这个图我们可以直接看到我们复制原数组后形成的新数组arrFbi[]的长度是F[k]，但是角标却是0~F[k]-1，根据斐波那契数列的公式我们可以得到的是F[k]=F[k-1]+F[k-2]，所以我们的数组中前半段是F[K-1]-1,后半段是F[k-2]-1，和中间的mid元素，这样，就是说当我们keyarrFbi[mid],low=mid+1,然后k=k-2。 1 ) 当 key=a[mid]时，查找就成功。 2 ) 当 key&lt;a[mid]时，新范围是第low个到第mid-l个，此时范围个数为f[k-1]-1个; 3 ) 当 key&gt;a[mid]时，新范围是第mid+l个到第high个，此时范围个数为f[k-2]-1个。 也就是说，如果要查找的记录在右侧，则左侧的数据都不用再判断了，不断反复进行下去，对处于当中的大部分数据，其工作效率要高一些。所以尽管斐波那契查找的时间复杂也为O(logn)，但就平均性能来说，斐波那契查找要优于折半查找。可惜如果是最坏情况，比如这里key=l，那么始终都处于左侧长半区在查找，则查找效率要低于折半查找。 还有比较关键的一点，折半查找是进行加法与除法运算mid=(low+ high)/2,插值查找进行复杂的四则运算mid = low + ((key - a[low])/(a[high] - a[low]))(high - low),而斐波那契查找只是最简单加减法运算mid=low+f[k-l]-1,在海量数据的查找过程中，这种细微的差别可能会影响最终的查找效率。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public static int Fbi(int fbiNum)&#123; if(fbiNum&lt;0)&#123; throw new RuntimeException("fbiNum must more zero !"); &#125;else if(fbiNum == 0 || fbiNum == 1)&#123; return 1; &#125;else&#123; return Fbi(fbiNum-1)+Fbi(fbiNum-2); &#125;&#125;/** * @param arr * @param key * @return */public static int FbiSearch(int[] arr, int key)&#123; //保证是顺序查找 Arrays.sort(arr); //构造斐波那契数列 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for(int i=0; i&lt;20;i++)&#123; list.add(Fbi(i)); &#125; Integer[] arrFbi = list.toArray(new Integer[0]); System.out.println(Arrays.toString(arrFbi)); int low, mid, high, k; low = 0; high = arr.length-1; k = 0; /** * //先重新构造新的数组 * 1. 确定原数组长度在arrFbi数列中的位置 * 2. 复制原数组 * 3. 补偿新数组 */ while(high&gt;arrFbi[k]-1)&#123; k++; &#125; System.out.println(k); arr = Arrays.copyOf(arr, arrFbi[k]); for(int i=high+1;i&lt;arr.length;i++)&#123; arr[i] = arr[high]; &#125; /** * 开始比较 */ while(low&lt;=high)&#123; mid = low+arrFbi[k-1]-1; if(key&lt;arr[mid])&#123; high = mid-1; // (全部元素) = (前半部分)+(后半部分) // f[k] = f[k-1] + f[k-2] // 因为前半部分有f[k-1]个元素， 则继续拆分f[k-1] = f[k-2] + f[k-3]成立 // 即在f[k-1]个元素的前半部分f[k-2]中继续查找，所以k = k - 1, // 则下次循环mid = low + f[k - 1 - 1] - 1; k = k-1; &#125;else if(key&gt;arr[mid])&#123; low = mid+1; // (全部元素) = (前半部分)+(后半部分) // f[k] = f[k-1] + f[k-2] // 因为后半部分有f[k-2]个元素， 则继续拆分f[k-2] = f[k-3] + f[k-4]成立 // 即在f[k-2]个元素的前半部分f[k-3]继续查找，所以k = k - 2, // 则下次循环mid = low + f[k - 2 - 1] - 1; k = k-2; &#125;else&#123; if(mid&gt;high)&#123; return high; &#125;else&#123; return mid; &#125; &#125; &#125; return -1;//没有找到&#125;public static void main(String[] args)&#123; //Integer[] arr = &#123;61,34,1,4,5,32,4,1&#125;; int[] arrInt = &#123;61,34,1,4,5,32,1,1,4,1,1,4,34&#125;; int index = FbiSearch(arrInt,4); Arrays.sort(arrInt); System.out.println(Arrays.toString(arrInt)); System.out.println("fbiSearch: "+index);&#125; 线性索引查找我们前面讲的几种比较高效的查找方法都是基于有序的基础之上的，但事实上，很多数据集可能增长非常快，如果要保证记录全部是按照当中的某个关键字有序，其时间代价是非常高昂的，所以这种数据通常都是按先后顺序存储。 那么对于这样的查找表，我们如何能够快速查找到需要的数据呢?办法就是–索引。 数据结构的最终目的是提高数据的处理速度，索引是为了加快查找速度而设计的一种数据结构。索引就是把一个关键字与它对应的记录相关联的过程，一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息。 索引技术是组织大型数据库以及磁盘文件的一种重要技术。 索引按照结构可以分为线性索引、树形索引和多级索引。 我们这里就只介绍线性索引技术。所谓线性索引就是将索引项集合组织为线性结构，也称为索引表。我们重点介绍三种线性索引：稠密索引、分块索引和倒排索引。 稠密索引稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项，如图下图所示。 对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列。 索引项有序也就意味着，我们要查找关键字时，可以用到折半、插值、斐被那契等有序查找算法，大大提高了效率 ，比如上图中，我要查找关键字是18的记录，如果直接从右侧的数据表中查找，那只能顺序查找，需要查找6次才可以查到结果。而如果是从左侧的索引表中查找，只需两次折半查找就可以得到18对应的指针，最终查找到结果。 这显然是稠密索引优点，但是如果数据集非常大，比如上亿，那也就意味着索引也得同样的数据集长度规模，对于内存有限的计算机来说，可能就需要反复去访问磁盘，查找性能反而大大下降了。 分块索引稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大。为了减少索引项的个数，我们可以对数据集进行分块，使其分块有序，然后再对每一块建立一个索引项，从而减少索引项的个数。 分块有序，是把数据集的记录分成了若干块，并且这些块需要满足两个条件: • 块内无序，即每一块内的记录不要求有序。当然 ，你如果能够让块内有序对查找来说更理想，不过这就要付出大量时间和空间的代价，因此通常我们不要求块内有序 。 • 块间有序，例如，要求第二块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字……因为只有块间有序，才有可能在查找时带来放率。 对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引。 如下图所示，我们定义的分块索引的索引项结构分三个数据项 : • 最大关键码，它存储每一块中的最大关键字，这样的好处就是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字要大; • 存储了块中的记录个数，以便于循环时使用; • 用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。 倒排索引搜索引擎通常检索的场景是：给定几个关键词，找出包含关键词的记录。 我们来看样例，现在有两篇极短的英文”文章”–其实只能算是句子，我们暂认为它是文章，编号分别是1和2。1.Books and friends should be few but good.(读书如交友，应求少而精。)2.A good book is a good friend.(好书如挚友。) 假设我们忽略掉如”books” 、”friends” 中的复数”s”以及如”A”这样的大小写差异。我们可以整理出这样一张单词表，如下表所示，并将单词做了排序，也就是表格显示了每个不同的单词分别出现在哪篇文章中，比如”good”在两篇文章中都有出现，而”is”只是在文章2中才有。 在这里这张单词表就是索引表，索引项的通用结构是: • 次关键码，例如上面的&quot;英文单词&quot;; • 记录号表，例如上面的&quot;文章编号&quot;。 其中记录号表存储具有相同次关键字的所有记录的记录号(可以是指向记录的指针或者是该记录的主关键字)。这样的索引方法就是倒排索引(inverted index)。 倒排索引源于实际应用中需要根据属性(或字段、次关键码)的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。 由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引。 又说二叉排序树(二叉查找树)二叉排序树(Binary Sort Tree)，又称二叉查找树，它或者是一颗空树，或者是具有下列性质的二叉树 * 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值。 * 若它的右结点不空，则右子树上所有结点的值均大于它的根节点的值。 * 它的左、右子树也分别为二叉排序树。 从二叉树的定义也可以知道，它前提是二叉树，然后它采用了递归的定义方法，再者，它的结点间满足一定的次序关系，左子树结点一定比其双亲结点小，右子树结点一定比其双亲结点大。 Tree1234567891011121314151617181920212223242526272829303132333435/** * @author whbai_xd@163.com * @date 2017年10月30日 下午9:02:53 * @param &lt;T&gt; */public interface Tree&lt;T extends Comparable&lt;T&gt;&gt; &#123; public boolean isEmpty(); public int size(); public int height(); public String preTraverse(); public String midTraverse(); public String endTraverse(); public String levelTraverse(); public void insert(T data); public void remove(T data); public T findMin(); public T findMax(); public BinaryNode&lt;T&gt; findNode(T data); public boolean contains(T data); public void clear();&#125; BinaryNode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * * @author whbai_xd@163.com * @date 2017年10月30日 下午9:02:48 * @param &lt;T&gt; */public class BinaryNode &lt;T extends Comparable&lt;T&gt;&gt; implements Serializable &#123; private static final long serialVersionUID = -6477238039299912313L; public BinaryNode&lt;T&gt; left; public BinaryNode&lt;T&gt; right; public T data; public BinaryNode() &#123; this(null,null,null); &#125; public BinaryNode(T data) &#123; this(null,null,data); &#125; public BinaryNode(BinaryNode&lt;T&gt; left, BinaryNode&lt;T&gt; right, T data) &#123; super(); this.left = left; this.right = right; this.data = data; &#125; public BinaryNode&lt;T&gt; getLeft() &#123; return left; &#125; public void setLeft(BinaryNode&lt;T&gt; left) &#123; this.left = left; &#125; public BinaryNode&lt;T&gt; getRight() &#123; return right; &#125; public void setRight(BinaryNode&lt;T&gt; right) &#123; this.right = right; &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125; @Override public String toString() &#123; return "BinaryNode [left=" + left + ", right=" + right + ", data=" + data + "]"; &#125; public boolean isLeaf()&#123; return this.left==null &amp;&amp; this.right==null; &#125;&#125; BST（Binary Sort Tree）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407package treeDemo;/** * * @author whbai_xd@163.com * @date 2017年10月30日 下午9:01:11 * @param &lt;T&gt; */public class BinSearchTree&lt;T extends Comparable&lt;T&gt;&gt; implements Tree&lt;T&gt;&#123; protected BinaryNode&lt;T&gt; rootNode;//相对根节点 /** * 创建一个空的二叉排序树 */ public BinSearchTree()&#123; rootNode = null; &#125; /** * 判断二叉排序树是否为空树，只需要判断根结点是不是为null就可以 */ @Override public boolean isEmpty() &#123; return rootNode==null ? true : false; &#125; /** * 计算二叉排序树的结点数 * 有点类似于汉诺塔的结构：H(n) = H(n-1) + 1 + H(n-1) * 递归size(BinaryNode&lt;T&gt; node)，左子树+1+右子树 */ @Override public int size() &#123; return size(rootNode); &#125; private int size(BinaryNode&lt;T&gt; node)&#123; if(node==null)&#123; return 0; &#125;else&#123; return size(node.left)+1+size(node.right); &#125; &#125; /** * 计算二叉树深度 * 分别计算左子树和右子树的高度(遍历high(BinaryNode&lt;T&gt; node)) * 返回层数多的子树并加上当前层(也就是+1) */ @Override public int height() &#123; return high(rootNode); &#125; private int high(BinaryNode&lt;T&gt; node)&#123; if(node == null)&#123; return 0; &#125;else&#123; int leftHigh = high(node.left); int rightHigh = high(node.right); return leftHigh&gt;rightHigh ? leftHigh+1 : rightHigh+1; &#125; &#125; /** * 前序遍历 * 1. 利用StringBuilder存储数据 * 2. node只要不为null，根--&gt;左子树--&gt;右子树，将node的data存入StringBuilder * 3. StringBuilder转成字符串返回 */ @Override public String preTraverse() &#123; String sb = preTraverse(rootNode); if(sb.length()&gt;0)&#123; sb = sb.substring(0, sb.length()-1); &#125; return sb; &#125; private String preTraverse(BinaryNode&lt;T&gt; node)&#123; StringBuilder sb = new StringBuilder(); if(node!=null)&#123; sb.append(node.data+","); sb.append(preTraverse(node.left)); sb.append(preTraverse(node.right)); &#125; return sb.toString(); &#125; /** * 中序遍历 * 1. 利用StringBuilder存储数据 * 2. node只要不为null，左子树--&gt;根--&gt;右子树，将node的data存入StringBuilder * 3. StringBuilder转成字符串返回 */ @Override public String midTraverse() &#123; String sb = midTraverse(rootNode); if(sb.length()&gt;0)&#123; sb = sb.substring(0,sb.length()-1); &#125; return sb; &#125; private String midTraverse(BinaryNode&lt;T&gt; node)&#123; StringBuilder sb = new StringBuilder(); if(node!=null)&#123; sb.append(midTraverse(node.left)); sb.append(node.data+","); sb.append(midTraverse(node.right)); &#125; return sb.toString(); &#125; /** * 后序遍历 * 1. 利用StringBuilder存储数据 * 2. node只要不为null，左子树--&gt;右子树--&gt;根，将node的data存入StringBuilder * 3. StringBuilder转成字符串返回 */ @Override public String endTraverse() &#123; String sb = endTraverse(rootNode); if(sb.length()&gt;0)&#123; sb = sb.substring(0,sb.length()-1); &#125; return sb; &#125; private String endTraverse(BinaryNode&lt;T&gt; node)&#123; StringBuilder sb = new StringBuilder(); if(node!=null)&#123; sb.append(endTraverse(node.left)); sb.append(endTraverse(node.right)); sb.append(node.data+","); &#125; return sb.toString(); &#125; /** * 层序遍历，这里先不写 */ @Override public String levelTraverse() &#123; return null; &#125; /** * 插入操作 * 只要数据为空，就抛出异常 * insert(T data,BinaryNode&lt;T&gt; node)中，如果根结点是null，就创建一个树，左右子树都是null * * 之后插入数据： * 1. 建立比较数 * 2. 插入的数据比当前结点的data大，查找右子树，右子树为null，直接插入，不为null就开始递归比较，一直到某一个结点是null，然后插入 * 3. 插入的数据比当前结点的data小，查找左子树，左子树为null，直接插入，不为null就开始递归比较，一直到某一个结点是null，然后插入 * 4. 插入后返回该结点（其实返回的直接就是插入后改变了的根结点） */ @Override public void insert(T data) &#123; if(data == null)&#123; throw new RuntimeException("data that is inserted is not null !!"); &#125; rootNode = insert(data,rootNode); &#125; private BinaryNode&lt;T&gt; insert(T data,BinaryNode&lt;T&gt; node)&#123; if(node==null)&#123; node = new BinaryNode&lt;T&gt;(null,null,data); &#125; int compareNum = data.compareTo(node.data); if(compareNum&gt;0)&#123; if(node.right!=null)&#123; node.right = insert(data,node.right); &#125;else&#123; node.right = new BinaryNode&lt;T&gt;(null,null,data); &#125; //node.right = insert(data,node.right); &#125;else if(compareNum&lt;0)&#123; if(node.left!=null)&#123; node.left = insert(data,node.left); &#125;else&#123; node.left = new BinaryNode&lt;T&gt;(null,null,data); &#125; //node.left = insert(data,node.left); &#125;else&#123; System.out.println("this Node is existed!!");; &#125; return node; &#125; /** * 删除操作 * 1. 如果删除的数据不存在或者为null，那么就抛出异常 * 2. remove(T data,BinaryNode&lt;T&gt; node)就有点类似于遍历 * 3. 一旦比较数一致，就说明我们的需要删除的结点找到了，剩下的就是一个置空和链接的操作 * * 这个有几句话不能很能理解！！！ */ @Override public void remove(T data) &#123; if(data==null || findNode(data)==null)&#123; throw new RuntimeException("data is null or unexisted"); &#125; rootNode = remove(data,rootNode); &#125; private BinaryNode&lt;T&gt; remove(T data,BinaryNode&lt;T&gt; node)&#123; if(node==null)&#123; return node; &#125; int compareNum = data.compareTo(node.data); if(compareNum&gt;0)&#123; node.right = remove(data,node.right); &#125;else if(compareNum&lt;0)&#123; node.left = remove(data,node.left); &#125;else&#123; if(node.left!=null &amp;&amp; node.right!=null)&#123; node.data = findMin(node.right).data; node.right = remove(node.data,node.right);//这句话实在想不来！！！ &#125;else&#123; node = node.left!=null ? node.left : node.right; &#125; &#125; return node; &#125; public boolean delete(T data)&#123; return delete(data,rootNode); &#125; private boolean delete(T data,BinaryNode&lt;T&gt; node)&#123; if(data==null || findNode(data)==null)&#123; return false; &#125;else&#123; int compareNum = data.compareTo(node.data); if(compareNum==0)&#123; return delete(node); &#125;else if(compareNum&lt;0)&#123; return delete(data,node.left); &#125;else&#123; return delete(data,node.right); &#125; &#125; &#125; private boolean delete(BinaryNode&lt;T&gt; node)&#123; BinaryNode&lt;T&gt; q,s; if(node.left == null)&#123; node = node.right; &#125;else if(node.right == null)&#123; node = node.left; &#125;else&#123; q = node; s = node.left; while(s.right!=null)&#123; q = s;//q指向被删除的结点的左子树 s = s.right;//s指向这个左子树中的最大值 &#125; node.data = s.data;//切换了被删除结点的值 if(q!=node)&#123; q.right = s.left; &#125;else&#123; q.left = s.right; &#125; &#125; return true; &#125; /** * 最小值： * 只要传入结点的左结点不为null，就不停的去找左结点并返回给当前结点。最后返回结点。 * * 最大值： * 只要传入结点的右结点不为null，就不停的去找右结点并返回给当前结点。最后返回结点。 */ @Override public T findMin() &#123; return findMin(rootNode).data; &#125; private BinaryNode&lt;T&gt; findMin(BinaryNode&lt;T&gt; node)&#123; while(node.left!=null)&#123; node = node.left; &#125; return node; &#125; @Override public T findMax() &#123; return findMax(rootNode).data; &#125; private BinaryNode&lt;T&gt; findMax(BinaryNode&lt;T&gt; node)&#123; while(node.right!=null)&#123; node = node.right; &#125; return node; &#125; /** * 先查找数据，数据是null就直接抛异常 * 查找结点是否存在 * 如果结点是null，直接返回一个null。 * 不为null则按照比较数的大小开始递归左、右子树，直到比较数为0 */ public String searchNode(T data)&#123; BinaryNode&lt;T&gt; node = findNode(data); return "[nodeData:"+node.data+",leftSubNode:"+node.left.data+",rightSubNode:"+node.right.data+"]"; &#125; @Override public BinaryNode&lt;T&gt; findNode(T data) &#123; if(data==null)&#123; throw new RuntimeException("data can't null!!!"); &#125;else&#123; return findNode(data,rootNode); &#125; &#125; private BinaryNode&lt;T&gt; findNode(T data,BinaryNode&lt;T&gt; node)&#123; if(node == null)&#123; return null; &#125; int compareNum = data.compareTo(node.data); if(compareNum&gt;0)&#123; if(node.right!=null)&#123; return node = findNode(data,node.right); &#125;else&#123; return null; &#125;// node = findNode(data,node.right); &#125;else if(compareNum&lt;0)&#123; if(node.left!=null)&#123; return node = findNode(data,node.left); &#125;else&#123; return null; &#125; //node = findNode(data,node.left); &#125;else&#123; return node; &#125; &#125; /** * 判断数据是否存在于结点中。 */ @Override public boolean contains(T data) &#123; return contains(data,rootNode); &#125; private boolean contains(T data, BinaryNode&lt;T&gt; node)&#123; if(node== null)&#123; return false; &#125; int compareNum = data.compareTo(node.data); if(compareNum&gt;0)&#123; if(node.right!=null)&#123; return contains(data,node.right); &#125;else&#123; return false; &#125; //contains(data,node.right); &#125;else if(compareNum&lt;0)&#123; if(node.left!=null)&#123; return contains(data,node.left); &#125;else&#123; return false; &#125;// contains(data,node.left); &#125;else&#123; return true; &#125; &#125; @Override public void clear() &#123; &#125;&#125; Test1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package treeDemo;/** * @author whbai_xd@163.com * @date 2017年10月30日 下午9:02:41 */public class TestTree &#123; public static void main(String[] args) &#123; BinSearchTree&lt;Integer&gt; binSearchTree = new BinSearchTree&lt;Integer&gt;(); System.out.println(binSearchTree.isEmpty()); System.out.println(binSearchTree.size()); System.out.println(binSearchTree.height()); binSearchTree.insert(0); binSearchTree.insert(7); binSearchTree.insert(-7); binSearchTree.insert(1); binSearchTree.insert(10); binSearchTree.insert(-10); binSearchTree.insert(-1); binSearchTree.insert(8); binSearchTree.insert(17); System.out.println(binSearchTree.preTraverse()); System.out.println(binSearchTree.midTraverse()); System.out.println(binSearchTree.endTraverse()); System.out.println(binSearchTree.isEmpty()); System.out.println(binSearchTree.size()); System.out.println(binSearchTree.height()); System.out.println(binSearchTree.findNode(7).toString()); System.out.println(binSearchTree.searchNode(10)); System.out.println(binSearchTree.contains(0)); System.out.println(binSearchTree.findMin()); System.out.println(binSearchTree.findMax()); binSearchTree.remove(7); //binSearchTree.delete(1); System.out.println(binSearchTree.preTraverse()); &#125;&#125;/**Output: true 0 0 this Node is existed!! 0,-7,-10,-1,7,1,10,8,17 -10,-7,-1,0,1,7,8,10,17 -10,-1,-7,1,8,17,10,7,0 false 9 4 BinaryNode [left=BinaryNode [left=null, right=null, data=1], right=BinaryNode [left=BinaryNode [left=null, right=null, data=8], right=BinaryNode [left=null, right=null, data=17], data=10], data=7] [nodeData:10,leftSubNode:8,rightSubNode:17] true -10 17 0,-7,-10,-1,8,1,10,17*/ 总之， 二叉排序树是以链接的方式存储，保持了链接存储结构在执行插入或删除操作时不用移动元素的优点，只要找到合造的插入和删除位置后，仅需修改链接指针即可。 插入删除的时间性能比较好。而对于二叉排序树的查找，走的就是从根结点到要查找的结点的路径，其比较次数等于给定值的结点在二叉排序树的层数。 极端情况，最少为1次，即根结点就是要找的结点，最多也不会超过树的深度。也就是说，二叉排序树的查找性能取决于二叉排序树的形状。 可问题就在于，二叉排序树的形状是不确定的。 例如{62，88，58，47，35，73，51，99，37，93}这样的数组，我们可以构建如下左图的二叉排序树。但如果数组元素的次序是从小到大有序，如 {35，37，47，51，58，62，73，88，93，99}，则二叉排序树就成了极端的右斜树，注意它依然是一棵二叉排序树，如下右图。此时，同样是查找结点99，左图只需要两次比较，而右图就需要10次比较才可以得到结果，二者差异很大。 也就是说，我们希望二叉排序树是比较平衡的，即其深度与完全二叉树相同，均为[log2n]+1，那么查找的时间复杂也就为O(logn)，近似于折半查找，事实上，上左图也不够平衡，明显的左重右轻。不平衡的最坏情况就是像上右图的斜树，查找时间复杂度为O(n)，这等同于顺序查找。因此，如果我们希望对一个集合按二叉排序树查找，最好是把它构建成一棵平衡的二叉排序树。这样我们就引申出另一个问题，如何让二叉排序树平衡的问题。 平衡二叉树(AVL)平衡二叉树（Self-Balancing Binary Search Tree），其实本身就是一个二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1. 二叉树上结点的左子树深度减去右子树深度的值称为平衡因子BF(Balance Factor). 距离插入结点最近的，且平衡因子的绝对值大于1的结点为根的子树，我们称为最小不平衡树 这里我们还需要明确一个概念，AVL树只是实现平衡二叉树的一种方法，它还有很多的其他实现方法如红黑树、替罪羊树、Treap、伸展树等，后面我们还会分析其他树的实现。 图(1)显然就是一棵平衡二叉树，它每个结点的左子树和右子树的高度最多相差1，同时也是一棵二叉查找树，而图二虽然也是一棵二叉查找树，但是它每个结点的左子树和右子树的高度相差却到达了2，因此不是平衡二叉树。理解了平衡二叉树的概念后，我们在思考一下，那些操作可能引起平衡发生变化呢？显然只有那些引起结点数量变化的操作才可能导致平衡被改变，也就是删除和插入操作了，如下图，我们把6插入到图a后，结构变成了图b，这时原本的平衡二叉树就失去平衡了。 显然图b已失去平衡，如果发生这样的情况，我们就必须考虑插入元素后恢复二叉树的平衡性质，实际上也总是可以通过对树进行简单的修复来让其重新恢复到平衡，而这样的简单操作我们就称之为旋转，当然旋转也有单旋转和双旋转之分，下面我们将会一一分析，这里有点需要明白的是，无论是插入还是删除，只有那些从插入或者删除点到根结点的路径上的结点的平衡才有可能被改变，因为只有这些结点的子树才可能发生变化，所以最终也只需针对这些点进行平衡修复操作即可。 右旋 1234567891011121314151617181920//形参是失衡点,右旋 public AVLNode&lt;T&gt; rightR(AVLNode&lt;T&gt; loseNode)&#123; AVLNode&lt;T&gt; tempNode; tempNode = loseNode.left; loseNode.left = tempNode.right; tempNode.right = loseNode; loseNode = tempNode; return loseNode; &#125;&#125;/**原理： 首先建立一个临时结点，让这个结点指向失衡结点的左子树，然后让失衡结点的左子树等于临时结点的右子树，也就是一开始失衡结点的左子树的右子树。最后将临时结点的右子树等于失衡结点。 最后把这个新的临时结点直接赋值给一开始的失衡结点。也就是改变了我们最初的失衡结点的构造。完成了右旋*/ 左旋 123456789101112131415161718 //左旋 public AVLNode&lt;T&gt; leftR(AVLNode&lt;T&gt; loseNode)&#123; AVLNode&lt;T&gt; tempNode; tempNode = loseNode.right; loseNode.right = tempNode.left; tempNode.left = loseNode; loseNode = tempNode; return loseNode; &#125;/**原理： loseNode是失衡结点，建立临时结点，使临时结点指向失衡结点的右子树，也就是打算左旋的子树的根结点。接着让失衡结点的右子树等于临时结点的左子树，最后让失衡结点称为临时结点的左子树。 最后返回临时结点给我们的失衡结点，完成平衡。*/ 左平衡旋转(左–&gt;右旋转)其实就是失衡点的左子树先左旋，然后失衡点右旋 1234567//左平衡循环（先是失衡点的左子树开始右旋，然后是失衡点卡开始左旋）public AVLNode&lt;T&gt; leftBalance(AVLNode&lt;T&gt; loseNode)&#123; loseNode.left = leftR(loseNode.left); return rightR(loseNode); &#125; 右平衡旋转 12345//右平衡旋转public AVLNode&lt;T&gt; rightBalance(AVLNode&lt;T&gt; loseNode)&#123; loseNode.right = rightR(loseNode.right); return leftR(loseNode);&#125; 平衡二叉树插入操作的实现123456789101112131415161718192021222324252627282930313233343536373839404142/** * 重写插入，因为有一个保持平衡的东西 */@Overridepublic void insert(T data)&#123; if(data==null)&#123; throw new RuntimeException("data that is inserted is not null !!"); &#125; this.rootNode = insert(data,rootNode);&#125;private AVLNode&lt;T&gt; insert(T data,AVLNode&lt;T&gt; node)&#123; ///说明已没有孩子结点,可以创建新结点插入了. if(node==null)&#123; node = new AVLNode&lt;T&gt;(data); &#125;else if(data.compareTo(node.data)&lt;0)&#123; node.left = insert(data,node.left); if(high(node.left)-high(node.right)==2)&#123; if(data.compareTo(node.left.data)&lt;0)&#123; node = rightR(node); &#125;else&#123; node = leftBalance(node); &#125; &#125; &#125;else if(data.compareTo(node.data)&gt;0)&#123; node.right = insert(data,node.right); if(high(node.right)-high(node.left)==2)&#123; if(data.compareTo(node.right.data)&gt;0)&#123; node = leftR(node); &#125;else&#123; node = rightBalance(node); &#125; &#125; &#125;else&#123; node.height = Math.max(high(node.left), high(node.right))+1; &#125; return node;&#125; 删除操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 重写删除操作 */@Overridepublic void remove(T data)&#123; if(data==null)&#123; throw new RuntimeException("data can\'t not be null "); &#125; this.rootNode = remove(data,rootNode);&#125;private AVLNode&lt;T&gt; remove(T data,AVLNode&lt;T&gt; node)&#123; if(node == null)&#123; return null; &#125; int compareNum = data.compareTo(node.data); if(compareNum&lt;0)&#123; node.left = remove(data,node.left); if(high(node.right)-high(node.left)==2)&#123; AVLNode&lt;T&gt; currentNode = node.right; if(high(currentNode.left)&gt;high(currentNode.right))&#123; node = rightR(node); &#125;else&#123; node = leftBalance(node); &#125; &#125; &#125;else if(compareNum&gt;0)&#123; node.right = remove(data,node.right); if(high(node.left)-high(node.right)==2)&#123; AVLNode&lt;T&gt; currentNode = node.left; if(high(currentNode.right)&gt;high(currentNode.left))&#123; node = leftR(node); &#125;else&#123; node = rightBalance(node); &#125; &#125; &#125;else if(node.right!=null &amp;&amp; node.left!=null)&#123; node.data = findMin(node.right).data; node.right = remove(node.data,node.right); &#125;else&#123; node = (node.left!=null)?node.left:node.right; &#125; if(node!=null)&#123; node.height = Math.max(high(node.left), high(node.right))+1; &#125; return node;&#125; B树多路查找树(muitl-way search tree)，其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素 2-3树2-3树是这样一颗多路查找树：其中的每一个结点都具有两个孩子（我们称它为2结点）或三个孩子（我们称它为3结点 一个2结点包含一个元素和两个孩子（或者没有孩子），且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。不过，与二叉排序树不同的是，这个2结点要么没有孩子，要有就有两个孩子，不能只有一个孩子。 一个3结点包含一小一大两个元素和三个孩子（或没有孩子），一个3结点要么没有孩子，要么具有3个孩子。如果某个3结点有孩子的话，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。 2-3树插入 对于2-3树的插入来说，与二叉排序树相同，插入操作一定是发生在叶子结点上。可与二叉排序树不同的是，2-3树插入一个元素的过程有可能会对该树的其余结构产生连锁反应。2-3树插入可分为三种情况。1) 对于空树，插入一个2结点即可，这很容易理解。 2) 插入结点到一个2结点的叶子上。应该说，由于其本身就只有一个元素，所以只需要将其升级为3结点即可。如图 所示，我们希望从左图的2-3树中插入元素3，根据遍历可知，3比8小、比4小，于是就只能考虑插入到叶子结点1所在的位置，因此很自然的想法就是将此结点变成一个3结点，即右图这样完成插入操作。当然，要视插入的元素与当前叶子结点的元素比较大小后，决定谁在左谁在右。例如，若插入的是0，则此结点就是”0”在左”1”在右了。 3)要往3结点中插入一个新元素。 因为3结点本身已经是2-3树的结点最大容量(已经有两个元素)，因此就需要将其拆分，且将树中两元素或插入元素的三者中选择其一向上移动一层。复杂的情况也正在于此。 第一种情况，见下图，需要向左图中插入元素5。经过遍历可得到元素5比8小比4大，因此它应该是需要插入在拥有6、7元素的3结点位置。问题就在于，6和7结点已经是3结点，不能再加。此时发现它的双亲结点4是个2结点，因此考虑让它升级为3结点，这样它就得有三个孩子，于是就想到，将6、7结点拆分，让6与4结成3结点，将5成为它的中间孩子，将7成为它的右孩子，如下右图所示。 另一种情况，如下图所示，需要向左图中插入元素11。经过遍历可得到元素11比12、14比9、10大，因此它应该是需要插入在拥有9、10元素的3结点位置。同样道理，9和10结点不能再增加结点。 此时发现它的双亲结点12、14 也是一个3结点，也不能再插入元素了。再往上看，12、14结点的双亲，结点8是个2结点。于是就想到，将9、10拆分， 12、14也拆分，让根结点8升级为3结点，最终形成如下右图样子。 再来看个例子， 如下图所示，需要在左图中插入元素2。经过遍历可得到元素2比4小、6比1大，因此它应该是需要插入在拥有1、3元素的3结点位置。与上例一样，你会发现，1、3结点，4、6结点都是3结点，都不能再插入元素了，再往上看，8、12结点还是一个3结点，那就意味着，当前我们的树结构是三层已经不能满足当前结点增加的需要了。 于是将1、3拆分，4、6拆分，连根结点8、12 也拆分，最终形成如下右图样子。 2-3树删除 对于2-3树的删除来说，如果对前面插入的理解足够到位的话，应该不是难事了。2-3树的删除也分为三种情况。与插入相反，我们从3结点开始说起。 1)所删除元素位于一个 3 结点的叶子结点上，这非常简单，只需要在该结点处删除该元素即可，不会影响到整棵树的其他结点结构。如下图所示，删除元素9，只需要将此结点改成只有元素10的2结点即可。 2)所删除的元素位于一个2结点上，即要删除的是一个只有一个元素的结点。如果按照以前树的理解，删除即可， 可现在的2- 树的定义告诉我们这样做是不可以的 . 比如下图所示，如果我们删除了结点1，那么结点4本来是一个2结点(它拥有两个孩子 )，此时它就不满足定义了。 因此，对于删除叶子是2结点的情况，我们需要分四种情形来处理。情形一，此结点的双亲也是2结点，且拥有一个3结点的右孩子。 如下图所示，删除结点1，那么只需要左旋，即6成为双亲，4成为6的左孩子，7是6的右孩子。 情形二，此结点的双亲是2结点，它的右孩子也是2结点。如下图，此时删除结点1，如果直接左旋会造成没有右孩子，因此需要对整棵树变形，办法就是，我们目标是让结点7变成3结点，那就得让比7稍大的元素8下来，随即就得让比元素8稍大的元素9补充结点8的位置，于是就有了下面中间图，于是再用左旋的方式，变成右图结果。 情形三，此结点的双亲是一个3结点。如下图所示，此时删除结点10，意味着双亲12、14这个结点不能成为3结点了 ，于是将此结点拆分，并将12与13合并成为左孩子。 情形四，如果当前树是一个满二叉树的情况，此时删除任何一个叶子都会使得整棵树不能满足2-3树的定义。如下图所示，删除叶子结点8时(其实删除任何一个结点都一样)，就不得不考虑要将2-3的层数减少，办法是将8的双亲7和其在子树6合并为3结点，再将14与9合并为3结点 ，最后成为右图的样子。 3)所删除的元素位于非叶子的分支结点。此时我们通常是将树按中序遍历后得到此元素的前驱或后继元素，考虑让它们来补位即可。如果我们要删除的分支结点是2结点。如下图所示我们要删除4结点，分析后得到它的前驱是1后继是6，显然，由于 6、7是3结点，只需要用6来补位即可，如下右图所示。 如果我们要删除的分支结点是3结点的某一元素，如下图所示我们要删除12、14 结点的12，此时，经过分析，显然应该是将是3结点的左孩子的10上升到删除位置合适。 2-3-4树有了2-3树的讲解，2-3-4树就很好理解了，它其实就是2-3树的概念扩展，包括了4结点的使用。一个4结点包含小中大三个元素和四个孩子(或没有孩子)，一个4结点要么没有孩子，要么具有4个孩子。如果某个4结点有孩子的话，左子树包含小于最小元素的元素;第二子树包含大于最小元素，小于第二元素的元素;第三子树包含大于第二元素，小于最大元素的元素;右子树包含大于最大元素的元素。 B树B树是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。结点最大的孩子数目称为B树的阶，因此，2-3树是3阶B树，2-3-4树是4阶B树。 一个m阶的B树具有如下属性: • 如果根结点不是叶结点，则其至少有两棵子树。 • 每一个非根的分支结点都有k-l个元素和k个孩子，其中[m/2]&lt;=k&lt;=m。 每一个叶子结点n都有k-l个元素，其中[m/2]&lt;=k&lt;=m。 • 所有叶子结点都位于同一层次。 •所有分支结点包含下列信息数据(n，A0，K1，A1，K2，......KN，AN)，其中:Ki(i=1，2…,n)为关键字，且Ki(i =1，2…，n); 为关键字，且Ki&lt;K(i+1)(i=0，2，…，n)为指向子树根结点的指针，且指针Ai所指子树中所有结点的关键字均小于Ki(i=1，2，…，n)， An所指子树中所有结点的关键字均大于Kn，n( [m/2]-1&lt;=n&lt;=m-l)为关键字的个数(或n+1为子树的个数)。 例如，2-3-4树中插入9个数后的图转成 B 树示意就如下图的右图所示。左侧灰色方块表示当前结点的元素个数。 在 B 树上查找的过程是一个指针查找结点和在结点中查找关键字的交叉过程。比方说，我们要查找数字7，首先从外存(比如硬盘中)读取得到根结点3、5 、8三个元素，发现7不在当中，但在5和 8之间，因此就通过A2再读取外存的6、7结点，查找到所要的元素.至于 B 树的插入和删除，方式是与2-3树和2-3-4树相类似的，只不过阶数会很大而已 。我们在本节的开头提到，如果内存与外存交换数据次数频繁，会造成了时间效率上的瓶颈，那么B树结构怎么就可以做到减少次数呢?我们的外存，比如硬盘，是将所有的信息分割成相等大小的页面，每次硬盘读写的都是一个或多个完整的页面，对于一个硬盘来说， 一页的长度可能是211到214个字节。在一个典型的B树应用中，要处理的硬盘数据量很大，因此无法一次全部装入内存。因此我们会对B树进行调整，使得 B树的阶数(或结点的元素)与硬盘存储的页面大小相匹配。比如说一棵B树的阶为1001(即1个结点包含1000个关键字) ，高度为2，它可以储存超过10亿个关键字，我们只要让根结点持久地保留在内存中，那么在这棵树上，寻找某一个关键字至多需要两次硬盘的读取即可。这就好比我们普通人数钱都是一张一张的数，而银行职员数钱则是五张、十张 ，甚至几十张一数，速度当然是比常人快了不少。通过这种方式，在有限内存的情况下，每一次磁盘的访问我们都可以获得最大数量的数据。由于B树每结点可以具有比二叉树多得多的元素，所以与二叉树的操作不同，它们减少了必须访问结点和数据块的数量，从而提高了性能。可以说，B树的数据结构就是为内外存的数据交互准备的。 B+树尽管前面我们已经讲了 B 树的诸多好处，但其实它还是有缺陷的。对于树结构来说，我们都可以通过中序遍历来顺序查找树中的元素，这一切都是在内存中进行。可是在B树结构中，我们往返于每个结点之间也就意味着，我们必须得在硬盘的页面之间进行多次访问，如下图所示，我们希望遍历这棵B树，假设每个结点都属于硬盘的不同页面，我们为了中序遍历所有的元素，页面2→页面1→页面 3→页面1→页面4→页面1→页面5。而且我们每次经过结点遍历时，都会对结点中的元素进行一次遍历，这就非常糟糕。有没有可能让遍历时每个元素只访问一次呢? 为了能够解决所有元素遍历等基本问题，我们在原有的B树结构基础上，加上了新的元素组织方式，这就是B+树。B+树是应文件系统所需而出的一种B树的变形树，注意严格意义上讲，它其实已经不是第之前所定义的树了。在B树中 ，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上。而在B+树中，出现在分支结点中的元素会被当作它们在该分支结点位置的中序后继者(叶子结点)中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针。例如下图所示，就是一棵B+树的示意，灰色关键字即是根结点中的关键字在叶子结点再次列出，并且所有叶子结点都链接在一起。 一棵m阶的B+树和m阶的B树的差异在于: • 有n棵子树的结点中包含有n个关键字; • 所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接; • 所有分支结点可以看成是索引，结点中仅含有其子树中的最大(或最)关键字。 这样的数据结构最大的好处就在子 ，如果是要随机查找，我们就从根结点出发，与B树的查找方式相同，只不过即使在分支结点找到了待查找的关键字，它也只是用来索引的，不能提供实际记录的访问，还是需要到达包含此关键字的终端结点。如果我们是需要从最小关键字进行从小到大的顺序查找，我们就可以从最左侧的叶子结点出发，不经过分支结点，而是延着指向下一叶子的指针就可遍历所有的关键字。]]></content>
      <categories>
        <category>Algorithm Sort</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structure（递归）]]></title>
    <url>%2F2017%2F10%2F26%2FData-Structure%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节我们再去复习一下递归的东西：汉诺塔、斐波那契数列 汉诺塔的问题(recursion)现在我们先不需要知道递归是什么，也没必要，我们先来看一个非常经典的游戏—汉诺塔，该游戏是数学家爱德华卢卡斯于1883年发明的，游戏的规则如下，有三根细柱（A、B、C），A柱上套着6个圆盘，圆盘的大小都不一样，它们按照从大到小的顺序自下而上地摆放，现在我们需要把A柱上的圆盘全部移动到B柱上去，并且在移动时有如下约定： 一次只能移动柱子最上端的一个圆盘。小圆盘上不能放大圆盘此时约定将一个圆盘从一根柱子移动另一根柱子算移动“1”次，那么将6个圆盘全部从A移动到B至少需要移动多少次呢？模型如下图： 图虽然很清晰，但我们依然无法立即找到特别清晰的解法，既然如此，我们就尝试先把问题的规模缩小点，把6个圆盘改为3个圆盘，先找出3层汉诺塔的解法，模型变为下图: 3层汉诺塔的解法就相对来说简单多了，我们要把3个圆盘全部从A移动到B，只需要先将最小的圆盘从A移动到B，然后将次小的圆盘从A移动到C，接着再把最小的圆盘从B移动到C，然后把最大的圆盘从A移动到B，接着把最小盘从C移动到A，在把次小盘从C移动到B，最后把最小盘从A移动到B即可，这样我们就完成了3此汉诺塔的解法了。这里我们把3个圆盘从小到大分别设为a,b,c，那么其移动过程如下： 1234567891011/** 元素 过程 a A-&gt;B b A-&gt;C a B-&gt;C c A-&gt;B a C-&gt;A b C-&gt;B a A-&gt;B 移动7次完结.. **/ 从上图中，我们很容易理解3层汉诺塔的解法，但是细想一下会发现这7次动中我们好像在做重复的事情：移动圆盘，只不过方向时而不同罢了。重新回顾一下①②③④⑤⑥⑦的移动过程，然后把它们分为如下3种情况： 在①②③中，移动了3次将2个圆盘从A柱移动到了C柱 在④中，将最大的圆盘从A柱移动到了B柱 在⑤⑥⑦中，移动了3次将2个圆盘从C柱移动到了B柱 我们发现这个过程移动的操作是几乎一样的，只不过是移动的方向不同了，A-&gt;C和C-&gt;B两种，其过程如下图： 从图确实可以看出虽然两次移动的目的地不相同，但是两次移动的操作却是非常相似的，而且我们发现如果把3次移动看成是“移动2个圆盘”的操作就是“2层汉诺塔的解法”，也就是说在解决3层汉诺塔的过程中，我们使用了“2层汉诺塔的解法“。既然如此，那是不是意味着解决”4层汉诺塔“的过程中可以使用解决”3层汉诺塔的解法“呢？嗯，确实是如此的，这就是汉诺塔的解法规律，没错，我们已经发现这种规律！这样的话，我们解决前面的6层汉诺塔的问题时，只需要先解决5层汉诺塔的问题，然后利用5层汉诺塔的解法来解决6层汉诺塔的问题即可！我们来看看利用5层汉诺塔解出6层汉诺塔的过程，如下： 从图中我们可以看出（a）和（c）就是5层汉诺塔的解法，为了解出6层汉诺塔需要使用到5层汉诺塔的解法，因此只要5层汉诺塔被解出，6层汉诺塔也就迎刃而解了。而5层汉诺塔的解法呢？没错利用我们前面发现的规律，用4层汉诺塔的解法去解出5层汉诺塔，如下过程： ①.先将4个圆盘从A柱移动到C柱，即解出4层汉诺塔 ②.然后再将最大的圆盘(5个中最大的圆盘)从A柱移动到B柱 ③.最后将4个圆盘从C柱移动到B柱，即再次利用解出的4层汉诺塔 这样5层汉诺塔就被解出了，而4层汉诺塔则可以利用同样的解法即使用3层汉诺塔的解法，3层汉诺塔再利用2层汉诺塔的解法……..依次类推即可，到此便已解出6层汉诺塔，实际上我们知道有了6层汉诺塔的解法自然就可以很轻松地解出7层汉诺塔，8层汉诺塔…….N层汉诺塔，也很容易发现这种利用已知的N-1层的解法来解决N层的问题的解题方式，它们每一层的解法结构都是相同即利用前一个已解决的问题结果来解决后一个问题。通过这种思考的方式，我们来总结一下N层汉诺塔的解法，不再使用具体的ABC三根柱子，而是将它们设为x、y、z。这样的话，x、y、z在不同的情况下会不固定对应ABC中的某一根。这里以x为起点柱，y为目标柱，z为中转柱，然后给出解出N层汉诺塔的过程。利用z柱将n个圆盘从x柱转移到y柱的解法如下： 1234567/**当 n=0时，无需任何移动当 n&gt;0时， ①将n-1个圆盘从x柱，经y柱中转，移动到z柱(即解出n-1层汉诺塔) ②然后将1个圆盘从x柱移动到y柱(最大的圆盘) ③最后将n-1个圆盘从z柱，经x中转移动到y柱(即解出n-1层汉诺塔) **/ 从上述过程可知为了解出n层汉诺塔，我们同样需要先解出n-1层汉诺塔，为更通用地表示解出n层汉诺塔的移动次数，将其设为H(n)。利用上述步骤，则有如下关系： 在数学上我们将这种H(n)和H(n-1)的关系式取了个名称，叫做递推公式，即已知H(0),由H(n-1)构成H(n)的方法也必然是已知的，只要依次计算便可以得出，如6层汉诺塔的递推过程如下： 1234567891011/** H(0)=0 = 1-1 H(1)=H(0)+1+H(0) = 1 = 2-1 H(2)=H(1)+1+H(1) = 3 = 4-1 H(3)=H(2)+1+H(2) = 7 = 8-1 H(4)=H(3)+1+H(3) = 15 = 16-1 H(5)=H(4)+1+H(4) = 31 = 32-1 H(6)=H(5)+1+H(5) = 63 = 64-1 ....... = ......... H(n)=H(n-1)+1+H(n-1) = 2^n -1**/ 这样我们也就知道了6层次汉诺塔的最少移动次数为63次（关于2^n-1的公式只是总结出更为简单的计算方式摆了）。到此我们来重新梳理一下汉诺塔的整个解题过程，在解出6层汉诺塔前，我们由于一时找不到解决的方法，因此先尝试解出更为简单3层汉诺塔的，而在这个过程中，我们慢慢发现了解决汉诺塔问题的通用规律，即使用n-1层的解法来解决n层汉诺塔的思考方式,通过这种思考方式最终成功地解决了6层汉诺塔的问题。而实际上我们利用的这种思考方式的本质就是将复杂的问题转换为较为简单的同类问题(回忆一下汉诺塔的问题解法)然后再找出解决方法最终利用简单同类问题解出复杂问题的过程，而这种思维的方式就是递归！！是的，没错！递归不是算法而是一种思考的思维方式，只不过我们将这种递归思维方式采用程序来解决时，该程序被称为递归算法罢了，而递归本身是一种思考问题的思维方式！到此我们对递归是否有些焕然大悟的感觉呢？或对递归有些许的理解了吧？ 递归的思维方式有了上述的分析，我们就可以这样去理解和使用递归，假设现在碰到了一个很复杂的难题，我们也明白‘简单问题易解’的道理，那么此时就可以利用类似于汉诺塔的解题的思考方式，即判断能否将目前复杂的问题转换为较为简单的同类问题呢？可以的话，就先转换为简单同类的问题来解决，然后再利用简单的同类问题解法来解决复杂的同类问题，这就恰恰就是递归思维方式的精髓所在，嗯，这就是递归！大家现在是不是已开始理解递归了呢？我们在回顾一下汉诺塔问题的解法，以便加深对递归的理解，如下图： 上图很清晰表现出n层汉诺塔的解法过程，通过复杂问题化为同类简单问题来求解，上述的图形还有一个名称叫做递归结构，根据该结构我们就可以建立起之前H(n)递推公式了，很显然发现递归结构并建立递推公式的过程十分重要，这样有助于我们把握本质问题即通过n-1层汉诺塔的解法来解决n层汉诺塔的问题，这样的发现能力需要我们有比较敏锐的洞察力和思维能力，这就需要我们再遇到复杂问题时，多采用递归的思维（复杂问题简单化）方式去思考，去挖掘规律。ok~，到此相信我们对递归已有比较清晰的了解了吧。接下来我们看看如何使用程序来实现递归算法并解决汉诺塔的问题。 汉诺塔的递归算法通过前面的分析，我们明白所谓的递归不过就是把复杂问题简单化的思维方式，而这种思维方式从程序语言的角度出发则称为递归算法，它通过程序的函数方法直接或者间接调用函数自身的过程，回忆一下前面分析汉诺塔的递推公式：H(n)=H(n-1)+1+H(n+1) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.zejian.structures.recursion;/*** Created by zejian on 2016/12/11.* Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创]* 汉诺塔的递归算法实现*/public class HanoiRecursion &#123; /** * @param n 汉诺塔的层数 * @param x x柱 起点柱(A) * @param y y柱 目标柱(B) * @param z z柱 中转柱(C) * 其中 A B C 只是作为辅助思考 */ public void hanoi(int n, char x ,char y ,char z)&#123; //H(0)=0 if (n==0)&#123; //什么也不做 &#125;else &#123; //递推公式：H(n)=H(n-1) + 1 + H(n-1) //将n-1个圆盘从x移动到z,y为中转柱 hanoi(n-1,x,z,y); //-----------------------&gt;解出n-1层汉诺塔:H(n-1) //移动最大圆盘到目的柱 System.out.println(x+"-&gt;"+y);//------------&gt; 1 //将n-1个圆盘从z移动到y,x为中转柱 hanoi(n-1,z,y,x);//------------------------&gt;解出n-1层汉诺塔:H(n-1) &#125; &#125; /** * @param n 汉诺塔的层数 * @param x x柱 起点柱(A) * @param y y柱 目标柱(B) * @param z z柱 中转柱(C) * 其中 A B C 只是作为辅助思考 */ public int hanoiCount(int n, char x ,char y ,char z)&#123; int moveCount=0; //H(0)=0 if (n==0)&#123; //什么也不做 return 0; &#125;else &#123; //递推公式：H(n)=H(n-1) + 1 + H(n-1) //将n-1个圆盘从x移动到z,y为中转柱 moveCount += hanoiCount(n-1,x,z,y); //-------------&gt;解出n-1层汉诺塔:H(n-1) //移动最大圆盘到目的柱 moveCount += 1; //---------------------------------&gt; 1 //将n-1个圆盘从z移动到y,x为中转柱 moveCount +=hanoiCount(n-1,z,y,x);//---------------&gt;解出n-1层汉诺塔:H(n-1) &#125; return moveCount; &#125; //测试 public static void main(String[] args)&#123; HanoiRecursion hanoi=new HanoiRecursion(); System.out.println("moveCount="+hanoi.hanoiCount(6,'A','B','C')); hanoi.hanoi(3,'A','B','C'); &#125;&#125; 因此到此我们也就明白了，递归思维在程序中的体现即为递归算法，而递归算法本身在程序内部的实现就是函数调用自身函数，这样大家总该理解递归算法了吧。这里有点要提醒大家的是，不要陷入程序递归的内部去思考递归算法，记住要从递归思维的本质(复杂问题简单化)出发去理解递归算法，千万不要去通过试图解析程序执行的每一个步骤来理解递归（解析程序的执行是指给函数一个真实值，然后自己一步步去推出结果，这样的思考方式是错误的！），那样只会让自己得到伪理解(没有真正理解)的结果。记住！递归并不是算法，是一种复杂问题简单化的思维方式，而这种思维方式在程序中的体现就递归算法！递归算法在实现上就是函数不断调用自身的过程！ 斐波那契数列斐波那契数列公式 代码实现12345678910111213141516171819public class Recursion &#123; public static int FbiRecursion(int num)&#123; if(num == 0 || num == 1)&#123; return num; &#125;else&#123; return FbiRecursion(num-1)+FbiRecursion(num-2); &#125; &#125; public static void main(String[] args) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; 10; i++) &#123; sb.append(FbiRecursion(i)+","); &#125; System.out.println("["+sb.substring(0,sb.length()-1)+"]"); &#125;&#125;]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structure（树）]]></title>
    <url>%2F2017%2F10%2F23%2FData-Structure%EF%BC%88%E6%A0%91%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这节基本上复习了一下我们的树的知识 树的概述定义树(Tree)是n(n&gt;=0)个结点的有限集T，并且当n&gt;0时满足下列条件： (1) 有且仅有一个特定的称为根(Root)的结点； (2) 当n&gt;1时，其余结点可以划分为m(m&gt;0)个互不相交的有限集T1、T2、...、Tm，每个集Ti(1&lt;= i &lt;=m)均为树，且称为树T的子树(SubTree) 特别地，不含任何结点(即n=0)的树，称为空树。 树的结构和术语 1. 根结点： 根结点是没有双亲的结点，一棵树中最多有一个根结点（如上图的A结点）。 2. 孩子结点：一棵树中，一个结点的子树的根结点称为其孩子结点，如上图的A的孩子结点就是B、C、D(同时B、C、D又是三个子树的根节点)。 3. 父母结点：相对于孩子结点而已其前驱结点即为父母结点，如上图的B、C、D 三个结点的父母结点都为A，当然E、F结点的父母结点则是B。 4. 兄弟结点：拥有相同的父母结点的所有孩子结点叫作兄弟结点，如上图B、C、D 三个结点共同父结点为A，因此它们是兄弟结点，E、F也是兄弟结点，但是F、G就肯定不是兄弟结点了。 5. 祖先结点：如果存在一条从根结点到结点Q的路径，而且结点P出现在这条路径上，那么P就是Q的祖先结点，而结点Q也称为P的子孙结点或者后代。如上图的E的祖先结点有A和B，而E则是A和B的子孙结点。 6. 叶子结点：没有孩子结点的结点叫作叶子结点，如E、F、G、H等。 (度为0) 7. 结点的度：指的是结点所拥有子树的棵数。如A的度为3，F的度为0，即叶子结点的度为0，而树的度则是树中各个结点度的最大值，如图（d）树的度为3（A结点） 8. 树的层：又称结点的层，该属性反映结点处于树中的层次位置，我们约定根结点的层为1，如上图所示，A层为1，B层为2，E的层为3。 9. 树的高度(深度)：是指树中结点的最大层数，图（d）的高度为3。 10. 边：边表示从父母结点到孩子结点的链接线，如上图（d）中A到B间的连线则称为边。 11. 有序树和无序树：树中任意一个结点的各子树按从左到右是有序的，称为有序树，否则称为无序树。 树的实现树是一种递归结构，表示方式一般有孩子表示法和孩子兄弟表示法两种。树实现方式有很多种、有可以由广义表的递归实现，也可以有二叉树实现，其中最常见的是将树用孩子兄弟表示法转化成二叉树来实现。 孩子表示法 方案一： 这种方案，用的是每个结点指针域的个数都等于树的度，但是这种方法对于树中各结点的度相差很大的时候，明显是很浪费空间的，因为有很多的结点，它的指针域都是空的。 方案二： 第二种方案是说，每个结点指针域的个数都等于该结点的度，我们专门取一个位置来存储结点指针域的个数。 这种方案虽然克服了空间的缺点，但是由于各个结点的链表是不相同的结构，加上要维护结点的度的数值，在运算上会带来时间上的损耗。 方案三： 把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，放进一个一维数组中。 孩子兄弟表示法(树—&gt;二叉树) 二叉树二叉树概述二叉树（Binary Tree）是n(n≥0)个结点组成的有限集合，n=0时称为空二叉树；n&gt;0的二叉树由一个根结点和两棵互不相交、分别称为左子树和右子树的子二叉树构成，二叉树也是递归定义的，在树种定义的度、层次等术语，同样适用于二叉树。 二叉树主要有以下5种基本形态： 特殊的二叉树 斜树 所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。 斜树有很一个很明显的特点，就是每一层都只有一个结点，结点的个数和二叉树的深度一致。 满二叉树 在一颗二叉树中，如果所有分支结点都存在左子树和右子树，并且所有的叶子结点都在同一层，这样的二叉树叫做满二叉树。 1. 叶子结点只能出现在最下面的一层 2. 非叶子结点的度一定是2。 3. 同样深度的树，满二叉树的结点数和叶子结点数最多。 完全二叉树 对于一颗具有n个结点的二叉树按层序，从左往右编号，如果该树中每个结点都和同样深度的满二叉树的相同编号的结点的位置完全一 致，那么这颗二叉树又称为完全二叉树。 1. 一个满二叉树一定是完全二叉树，反之不成立。 2. 叶子结点只能出现在最下两层 3. 最下层的叶子一定集中在左部连续位置 4. 倒数二层，若有叶子结点，一定都在右部连续位置 5. 如果结点度为1，则该结点只能有左结点 6. 同样结点数的二叉树，完全二叉树的深度最小 二叉树的性质性质一：若根结点的层次为1，则二叉树第i层最多有2^(i−1)(i≥1)个结点。 性质二：深度为k的二叉树最多有2^(k-1)(k≥1)个结点。 性质三：对于任何一颗二叉树T，如果其终端结点数是n，度为2结点数为m，则n=m+1（叶子节点数 = 度为2的结点数 + 1） 性质四：具有n个结点的完全二叉树的深度为Log2n+1 性质五：一棵具有n个结点的完全二叉树，对于序号为i(0&lt;=i&lt;=n)的结点，则有如下规则:(根节点序列是0) 1. 若i=0，则i为根结点，无父母结点；若i&gt;0，则i的父母结点序号是(i-1)/2. 2. 若2i+1&lt;n，则i的左孩子结点序号为2i+1，否则i无左孩子。 3. 若2i+2&gt;n，则i的右孩子结点序号为2i+2，否则i无右孩子。 二叉树的存储结构关于二叉树的存储结构主要采用的是链式存储结构，至于顺序存储结构仅适用于完全二叉树或满二叉树，就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系。 这里我们主要还是分析二叉树的链式存储结构。二叉树的链式存储结构主要有二叉链表和三叉链表两种，下面分别说明。 二叉树的二叉链表存储结构 二叉链表结构主要由一个数据域和两个分别指向左、右孩子的指针域组成，其结构如下： 从图中可以看出，采用二叉链表存储结构，每个结点只存储了到其孩子结点的单向关系，而没有存储到父结点的关系，这样的话，每次要获取父结点时将消耗较多的时间，因为需要从root根结点开始查找，花费的时间是遍历部分二叉树的时间，而且与该结点的位置有关。为了更高效的获取父结点，三叉链表存储结构孕育而生了。 二叉树的三叉链表存储结构 三叉链表主要是在二叉链表的基础上多添加了一个指向父结点的域，这样我们就存储了父结点与孩子结点的双向关系，当然这样也增加了一定的空开销其结点结构如下： 二叉树的设计与实现 从图中我们可以看到，无论的那种情况下的树都具备递归的结构，它们都拥有着一致的原子结构，这也就是为什么树可以使用递归定义的原因，递归结构与递归思维都体现得淋漓尽致，即使是一个十分复杂的树，我们也可以简化为原子的结构的求解过程，毕竟它们本质上是同类问题。 为了使二叉树的实现变得更有具体意义，我们将实现一种叫二叉查找树的数据结构，二叉查找树的特性是，对于树种的每个结点T（T可能是父结点）,它的左子树中所有项的值小T中的值，而它的右子树中所有项的值都大于T中的值。这意味着该树所有的元素可以用某种规则进行排序(取决于Comparable接口的实现)。二叉查找树使用二叉链表存储结构实现，其结点BinaryNode＜T＞声明如下： 12345678910111213141516171819202122232425262728293031323334package com.zejian.structures.Tree.BinaryTree;import java.io.Serializable;/** * 二叉树结点 */public class BinaryNode&lt;T extends Comparable&gt; implements Serializable&#123; private static final long serialVersionUID = -6477238039299912313L; public BinaryNode&lt;T&gt; left;//左结点 public BinaryNode&lt;T&gt; right;//右结点 public T data; public BinaryNode(T data,BinaryNode left,BinaryNode right)&#123; this.data=data; this.left=left; this.right=right; &#125; public BinaryNode(T data)&#123; this(data,null,null); &#125; /** * 判断是否为叶子结点 * @return */ public boolean isLeaf()&#123; return this.left==null&amp;&amp;this.right==null; &#125;&#125; 二叉查找树(二叉排序树) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.zejian.structures.Tree.BinaryTree;public class BinarySearchTree&lt;T extends Comparable&gt; implements Tree&lt;T&gt; &#123; //根结点 protected BinaryNode&lt;T&gt; root; public BinarySearchTree()&#123; root =null; &#125; @Override public boolean isEmpty() &#123; return false; &#125; @Override public int size() &#123; return 0; &#125; @Override public int height() &#123; return 0; &#125; @Override public String preOrder() &#123; return null; &#125; @Override public String inOrder() &#123; return null; &#125; @Override public String postOrder() &#123; return null; &#125; @Override public String levelOrder() &#123; return null; &#125; @Override public void insert(T data) &#123; &#125; @Override public void remove(T data) &#123; &#125; @Override public T findMin() &#123; return null; &#125; @Override public T findMax() &#123; return null; &#125; @Override public BinaryNode findNode(T data) &#123; return null; &#125; @Override public boolean contains(T data) throws Exception &#123; return false; &#125; @Override public void clear() &#123; &#125;&#125; 二叉查找树基本操作二叉查找树的插入事实上对于二叉查找树的插入操作的设计是比较简单，我们只要利用二叉查找树的特性（即对每个父结点，它的左子树中所有项的值小T中的值，而它的右子树中所有项的值都大于T中的值），找到只对应的插入位置即可，假如现在我们要插入data=4的结点，那么可以这样操作，沿着树查找(比较结点的数据与data的大小从而决定往左/右子树继续前行)，如果找到data(4),则什么也不做，否则将data插入到遍历的路径上的最后一个点，如下图所示： 12345678910111213141516171819202122232425262728293031@Overridepublic void insert(T data) &#123; if (data==null) throw new RuntimeException("data can\'Comparable be null !"); //插入操作 root=insert(data,root);&#125;/** * 插入操作,递归实现 * @param data * @param p * @return */private BinaryNode&lt;T&gt; insert(T data,BinaryNode&lt;T&gt; p)&#123; if(p==null)&#123; p=new BinaryNode&lt;&gt;(data,null,null); &#125; //比较插入结点的值，决定向左子树还是右子树搜索 int compareResult=data.compareTo(p.data); if (compareResult&lt;0)&#123;//左 p.left=insert(data,p.left); &#125;else if(compareResult&gt;0)&#123;//右 p.right=insert(data,p.right); &#125;else &#123; ;//已有元素就没必要重复插入了 &#125; return p;&#125; 二叉查找树的删除算法对于二叉树来说，删除是一种比较麻烦的操作，因为涉及到了多种情况（设要删除的结点为q，其父母结点为p）： ① 如果要删除的结点q恰好是叶子结点，那么它可以立即被删除 ② 如果要删除的结点q拥有一个孩子结点，则应该调整要被删除的父结点(p.left 或 p.right)指向被删除结点的孩子结点（q.left 或 q.right） ③ 如果要删除的结点q拥有两个孩子结点，则删除策略是用q的右子树的最小的数据替代要被删除结点的数据，并递归删除用于替换的结点(此时该结点已为空)，此时二叉查找树的结构并不会被打乱，其特性仍旧生效。采用这样策略的主要原因是右子树的最小结点的数据替换要被删除的结点后可以满足维持二叉查找树的结构和特性，又因为右子树最小结点不可能有左孩子，删除起来也相对简单些。 为了更新清晰描述这个过程，我们可以借助下图来理解： 下面是删除操作的程序实现，也是递归实现，其中的findMin方法是查找二叉查找树中的最小值，后面我们会分析这个方法，其代码注释也比较清晰： 123456789101112131415161718192021222324252627282930313233343536373839404142有点没看懂@Overridepublic void remove(T data) &#123; if(data==null) throw new RuntimeException("data can\'Comparable be null !"); //删除结点 root=remove(data,root);&#125;/*** 分3种情况* 1.删除叶子结点(也就是没有孩子结点)* 2.删除拥有一个孩子结点的结点(可能是左孩子也可能是右孩子)* 3.删除拥有两个孩子结点的结点* @param data* @param p* @return*/private BinaryNode&lt;T&gt; remove(T data,BinaryNode&lt;T&gt; p)&#123; //没有找到要删除的元素,递归结束 if (p==null)&#123; return p; &#125; int compareResult=data.compareTo(p.data); if (compareResult&lt;0)&#123;//如果需要被删除的数据比比较结点的小，则进入下一层，又开始比较 p.left=remove(data,p.left); &#125;else if (compareResult&gt;0) &#123; p.right=remove(data,p.right); &#125;else if (p.left!=null&amp;&amp;p.right!=null)&#123;//已找到结点并判断是否有两个子结点(情况3) //中继替换，找到右子树中最小的元素并替换需要删除的元素值 p.data = findMin( p.right ).data; //移除用于替换的结点 p.right = remove( p.data, p.right ); &#125;else if(p.left==null&amp;&amp;p.right==null)&#123; return p; &#125;else&#123; //拥有一个孩子结点的结点和叶子结点的情况 p=(p.left!=null)? p.left : p.right; &#125; return p;//返回该结点&#125; 二叉查找树的最大和最小值二叉查找树中的findMin和findMax方法分别返回的是树种的最小值和最大值，对于findMin()，则需要从根结点开始并且只要有左孩子就向左进行即可，其终止点即为最小值的元素；而对于findMax()，也需要从根结点开始并且只要有右孩子就向右进行即可，终止点即为值最大的元素。同样的我们使用递归实现它们，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142@Overridepublic T findMin() &#123; if(isEmpty()) throw new EmptyTreeException("BinarySearchTree is empty!"); return findMin(root).data;&#125;@Overridepublic T findMax() &#123; if(isEmpty()) throw new EmptyTreeException("BinarySearchTree is empty!"); return findMax(root).data;&#125;/*** 查找最小值结点* @param p* @return*/private BinaryNode&lt;T&gt; findMin(BinaryNode&lt;T&gt; p)&#123; if (p==null)//结束条件 return null; else if (p.left==null)//如果没有左结点,那么t就是最小的 return p; return findMin(p.left);&#125;/*** 查找最大值结点* @param p* @return*/private BinaryNode&lt;T&gt; findMax(BinaryNode&lt;T&gt; p)&#123; if (p==null)//结束条件 return null; else if (p.right==null) return p; return findMax(p.right);&#125; 二叉查找树的深度(height)和大小(size)计算根据前面的术语，可知树的深度即为最大层的结点所在层次，而大小就是树的结点数，关于深度，我们只需要从根结点开始寻找，然后计算出左子树的深度和右子树的深度，接着比较左子树与右子树的深度，最后返回深度大的即可。深度求解过程图示以及代码实现如下： 1234567891011121314151617181920212223/** * 计算深度 * @return */@Overridepublic int height() &#123; return height(root);&#125;/** * 递归实现 * @param subtree * @return */private int height(BinaryNode&lt;T&gt; subtree)&#123; if (subtree==null)&#123; return 0; &#125;else &#123; int l=height(subtree.left); int r=height(subtree.right); return (l&gt;r) ? (l+1):(r+1);//返回并加上当前层 &#125;&#125; 接着在看看求解二叉树大小(size)的算法该如何实现，实际上，size的求解跟上篇文章分析递归时，汉诺塔问题求解过程十分相似（其实不止是大小求解过程，二叉查找树的所有使用递归的操作都是这样的思想），我们先看看下图： 很显然树也是一个递归结构，而且我们发现，要从第一层开始计算，求出整棵树的结点数，只要先求出第2层的结点数（左子树和右子树），然后加上父结点1就是整棵树的结点数了，是不是跟汉诺塔求解很相似呢？只不过这里是反向求解罢了，因此我们的算法程序可以这样设计： 1234567891011121314151617181920212223/*** 计算大小* @return*/@Overridepublic int size() &#123; return size(root);&#125;/*** 递归实现：定义根节点root后，再用subtree实现递归* @param subtree* @return*/private int size(BinaryNode&lt;T&gt; subtree)&#123; if (subtree == null) return 0; else &#123; //对比汉诺塔:H(n)=H(n-1) + 1 + H(n-1) return size(subtree.left) + 1 + size(subtree.right); &#125;&#125; 二叉查找树的遍历算法先根次序遍历算法先根次序遍历算法，其访问规则是先遍历根结点，再遍历左子树，最后遍历右子树。如下图先根遍历的次序为ABEFC 从图可知，先根遍历每次总是先访问根结点，再访问左子树，最后访问右子树，而对于一个复杂的树，我们可以先将其简化为三个结点的树(两个结点或者一个结点则空白填补，最后去掉即可)，然后解出该子树的顺序，再求解其上层的子树，如上图的步骤(1)(2)的过程，我们可先求出以B为根的三个结点的子树,先根遍历次序为BEF，然后再求出以A为根结点的树，然后将已解出的(2)作为左子树整体插入到A(BEF)C的序列中即可，这样整棵树的遍历顺序求出来了，事实上这里我们又再次运用递归思维(复杂化简单求解问题)，因此在程序中也可以使用递归算法实现先根次序遍历算法如下： 12345678910111213141516171819202122232425262728@Overridepublic String preOrder() &#123; String sb=preOrder(root); if(sb.length()&gt;0)&#123; //去掉尾部","号 sb=sb.substring(0,sb.length()-1); &#125; return sb;&#125;/** * 先根遍历 * @param subtree * @return */private String preOrder(BinaryNode&lt;T&gt; subtree)&#123; StringBuffer sb=new StringBuffer(); if (subtree!=null) &#123;//递归结束条件 //先访问根结点 sb.append(subtree.data+","); //遍历左子树 sb.append(preOrder(subtree.left)); //遍历右子树 sb.append(preOrder(subtree.right)); &#125; return sb.toString();&#125; 中根次序遍历算法中根次序遍历的算法规则是，先遍历左子树，再遍历根结点，最后遍历右子树。过程如下图（同样利用的是递归思维） 注意：这个图上面最后的有问题，顺序应该是EBFACH 1234567891011121314151617181920212223242526@Overridepublic String inOrder() &#123; String sb=inOrder(root); if(sb.length()&gt;0)&#123; //去掉尾部","号 sb=sb.substring(0,sb.length()-1); &#125; return sb;&#125;/** * 中根遍历 * @return */public String inOrder(BinaryNode&lt;T&gt; subtree) &#123; StringBuffer sb=new StringBuffer(); if (subtree!=null) &#123;//递归结束条件 //先遍历左子树 sb.append(inOrder(subtree.left)); //再遍历根结点 sb.append(subtree.data+","); //最后遍历右子树 sb.append(inOrder(subtree.right)); &#125; return sb.toString();&#125; 后根次序遍历算法后根次序遍历的算法规则是，先访问左子树，再访问右子树，最后访问根结点，如下图(递归思维)： 123456789101112131415161718192021222324252627282930@Overridepublic String postOrder() &#123; String sb=postOrder(root); if(sb.length()&gt;0)&#123; //去掉尾部","号 sb=sb.substring(0,sb.length()-1); &#125; return sb;&#125;/*** 后根遍历* @param subtree* @return*/public String postOrder(BinaryNode&lt;T&gt; subtree) &#123; StringBuffer sb=new StringBuffer(); if (subtree!=null) &#123;//递归结束条件 //先遍历左子树 sb.append(postOrder(subtree.left)); //再遍历右子树 sb.append(postOrder(subtree.right)); //最后遍历根结点 sb.append(subtree.data+","); &#125; return sb.toString();&#125;]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structure（串）]]></title>
    <url>%2F2017%2F10%2F21%2FData-Structure%EF%BC%88%E4%B8%B2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节主要学习了 串 的知识，重点在于分析了BF、KMP算法的实现，但是KMP算法中Next数组的计算还是有点问题，以后需要再学习 同时，这一节我们去分析了部分String类的源码 串的概述串是若干个字符组成的有限序列。大部分的软件系统都会频繁使用串。串也是一种线性结构。和线性表不同的是，串的操作特点是一次操作若干个数据元素，即一次操作一个字符串。串通常采用顺序存储结构存储，模式匹配是串的一个非常重要的操作，但是模式匹配的时间效率很差。Brute-Force和Kmp算法是两种最经典的串模式匹配算法。 串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的，但是我们的字符串其实是不断变化的，不可能是定长的数组，所以我们用的就是动态数组，串值的存储空间可在程序执行过程中动态分配而得。 串的基本概念和抽象数据类型串(String)是由零个或多个字符组成的有限序列，又名叫字符串。 串（也称字符串）是由n(n&gt;=0)个字符串组成的有限序列。抽象含义的串一般记为s=”s1,s2…..sn”,其中s为串名，n 为串长度，双引号括起来的字符序列成为串值。每个字符si（0&lt;i&lt;n）可以是任意的Unicode码字符，一般是字母、数子、标点符号等屏幕可显示的字符。 一个串中任意个连续的字符组成的子序列称为该串的子串。包含子串的串称为该子串的主串。串也是一种特殊的线性表。和线性表相比，串的数据元素以及数据元素之间的逻辑关系和线性表完全相同，其差别是： （1）线性表的数据元素可以是任意数据类型，而字符串的数据类型只允许是字符类型。 （2）线性表一次操作一个数据元素，而串一次操作若干个数据元素，即一个字符串。如果每次操作的子串长度固定为1，那么串就是数据类型固定为字符型的线性表。 一个字符在一个串中的位置序号称为该字符在串中的位置。可以比较任意两个串的大小。我们称两个串相等，当且仅当这两个串的值完全相等。两个串的值完全相等意味着两个串不仅是长度相等，而且各个位置字符都想等。 模式匹配算法—Brute-Force基本原理这个Brute-Force就是朴素的模式匹配算法： 从目标串S=“ s0s1…sn-1 ”的第一个字符开始和模式串T=“ t0t1…tm-1 ”中的第一个字符比较，若相等，则继续逐个比较后续字符，否则，从目标串S的第2个字符开始重新与模式串T的第一个字符进行比较，依次类推，若从目标串S的第i个字符开始，每个字符依次和模式串t中的对应字符相等，则匹配成功，该算法返回i;否则匹配失败，返回-1。 举个例子，如果给定文本串S“BBC ABCDAB ABCDABCDABDE”，和模式串P“ABCDABD”，现在要拿模式串P去跟文本串S匹配，整个过程如下所示： 1. S[0]为B，P[0]为A，不匹配，执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”， S[1]跟P[0]匹配，相当于模式串要往右移动一位（i=1，j=0） 2. S[1]跟P[0]还是不匹配，继续执行第②条指令：“如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0”，S[2]跟P[0] 匹配（i=2，j=0），从而模式串不断的向右移动一位（不断的执行“令i = i - (j - 1)，j = 0”，i从2变到4，j一直为0） 3. 直到S[4]跟P[0]匹配成功（i=4，j=0），此时按照上面的暴力匹配算法的思路，转而执行第①条指令：“如果当前字符匹配成功 （即S[i] == P[j]），则i++，j++”，可得S[i]为S[5]，P[j]为P[1]，即接下来S[5]跟P[1]匹配（i=5，j=1） 4. S[5]跟P[1]匹配成功，继续执行第①条指令：“如果当前字符匹配成功（即S[i] == P[j]），则i++，j++”，得到S[6]跟P[2] 匹配（i=6，j=2），如此进行下去 5. 直到S[10]为空格字符，P[6]为字符D（i=10，j=6），因为不匹配，重新执行第②条指令：“如果失配（即S[i]! = P[j]）， 令i = i - (j - 1)，j = 0”，相当于S[5]跟P[0]匹配（i=5，j=0） 6. 至此，我们可以看到，如果按照暴力匹配算法的思路，尽管之前文本串和模式串已经分别匹配到了S[9]、P[5]，但因为S[10] 跟P[6]不匹配，所以文本串回溯到S[5]，模式串回溯到P[0]，从而让S[5]跟P[0]匹配。 而S[5]肯定跟P[0]失配。为什么呢？因为在之前第4步匹配中，我们已经得知S[5] = P[1] = B，而P[0] = A，即P[1] != P[0]，故S[5]必定不等于P[0]，所以回溯过去必然会导致失配。那有没有一种算法，让i 不往回退，只需要移动j 即可呢？ 答案是肯定的。这种算法就是本文的主旨KMP算法，它利用之前已经部分匹配这个有效信息，保持i 不回溯，通过修改j 的位置，让模式串尽量地移动到有效的位置。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 朴素字符串算法通过两层循环来寻找子串， * 好像是一个包含模式的“模板”沿待查文本滑动。 * 算法的思想是：从主串S的第pos个字符起与模式串进行比较， * 匹配不成功时，从主串S的第pos+1个字符重新与模式串进行比较。 * 如果主串S的长度是n，模式串长度是 m，那么Brute-Force的时间复杂度是o(m*n)。 * 最坏情况出现在模式串的子串频繁出现在主串S中。 * 虽然它的时间复杂度为o(m*n)，但在一般情况下匹配时间为o(m+n)， * 因此在实际中它被大量使用。 * 该方法的优点是：算法简单明朗，便于实现记忆。 * 该方法的缺点是：进行了回溯，效率不高，而这些回溯都是没有必要的。 * 下面是该算法的Java代码，找到子串的话，返回子串在父串中第一次出现的位置， * 找不到的话返回0. */ // 定义接口 interface StringMatcher &#123; /** * 从原字符串中查找模式字符串的位置,如果模式字符串存在,则返回模式字符串第一次出现的位置,否则返回-1 * * @param source * 原字符串 * @param pattern * 模式字符串 * @return if substring exists, return the first occurrence of pattern * substring, return -1 if not. */ int indexOf(String source, String pattern); &#125; /** * 暴力匹配 * &lt;p&gt; * 时间复杂度: O(m*n), m = pattern.length, n = source.length */ class ViolentStringMatcher implements StringMatcher &#123; @Override public int indexOf(String source, String pattern) &#123; int i = 0, j = 0; int sLen = source.length(), pLen = pattern.length(); char[] src = source.toCharArray(); char[] ptn = pattern.toCharArray(); while (i &lt; sLen &amp;&amp; j &lt; pLen) &#123; if (src[i] == ptn[j]) &#123; // 如果当前字符匹配成功,则将两者各自增1,继续比较后面的字符 i++; j++; &#125; else &#123; // 如果当前字符匹配不成功,则i回溯到此次匹配最开始的位置+1处,也就是i = i - j + 1 // (因为i,j是同步增长的), j = 0; i = i - j + 1; j = 0; &#125; &#125; // 匹配成功,则返回模式字符串在原字符串中首次出现的位置;否则返回-1 if (j == pLen) return i - j; else return -1; &#125; &#125; 模式匹配算法—KMP基本原理假设现在文本串S匹配到 i 位置，模式串P匹配到 j 位置 如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符；如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]。此举意味着失配时，模式串P相对于文本串S向右移动了j - next [j] 位。 换言之，当匹配失败时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值（next 数组的求解会在下文中详细阐述），即移动的实际位数为：j - next[j]，且此值大于等于1。 很快，你也会意识到next 数组各值的含义：代表当前字符之前的字符串中，有多大长度的相同前缀后缀。例如如果next [j] = k，代表j 之前的字符串中有最大长度为k 的相同前缀后缀。 此也意味着在某个字符失配时，该字符对应的next 值会告诉你下一步匹配中，模式串应该跳到哪个位置（跳到next [j] 的位置）。如果next [j] 等于0或-1，则跳到模式串的开头字符，若next [j] = k 且 k &gt; 0，代表下次匹配跳到j 之前的某个字符，而不是跳到开头，且具体跳过了k 个字符。 继续拿之前的例子来说，当S[10]跟P[6]匹配失败时，KMP不是跟暴力匹配那样简单的把模式串右移一位，而是执行第②条指令：“如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]”，即j 从6变到2（后面我们将求得P[6]，即字符D对应的next 值为2），所以相当于模式串向右移动的位数为j - next[j]（j - next[j] = 6-2 = 4）。 向右移动4位后，S[10]跟P[2]继续匹配。为什么要向右移动4位呢，因为移动4位后，模式串中又有个“AB”可以继续跟S[8]S[9]对应着，从而不用让i 回溯。 相当于在除去字符D的模式串子串中寻找相同的前缀和后缀，然后根据前缀后缀求出next 数组，最后基于next 数组进行匹配 步骤①寻找前缀后缀最长公共元素长度 其实就是寻找一个模式串中相同的字符个数，例如模式串：abab ②求next数组 next数组就和前后缀最长共有元素长度不一样就在，前者实在后者的基础上长度-1进行的统计，默认next[0]=-1 KMP的next 数组相当于告诉我们：当模式串中的某个字符跟文本串中的某个字符匹配失配时，模式串下一步应该跳到哪个位置。如模式串中在j 处的字符跟文本串在i 处的字符匹配失配时，下一步用next [j] 处的字符继续跟文本串i 处的字符匹配，相当于模式串向右移动 j - next[j] 位。 步骤详解1. 寻找最长前缀后缀 如果给定的模式串是：“ABCDABD”，从左至右遍历整个模式串，其各个子串的前缀后缀分别如下表格所示： 也就是说，原模式串子串对应的各个前缀后缀的公共元素的最大长度表为（下简称《最大长度表》）： 2. 利用最大长度表计算模式串移动位数 失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值（失配字符前的子串的最长前后缀个数） 下面，咱们就结合之前的《最大长度表》和上述结论，进行字符串的匹配。如果给定文本串“BBC ABCDAB ABCDABCDABDE”，和模式串“ABCDABD”，现在要拿模式串去跟文本串匹配，如下图所示： 1. 因为模式串中的字符A跟文本串中的字符B、B、C、空格一开始就不匹配，所以不必考虑结论，直接将模式串不断的右移一位即可， 直到模式串中的字符A跟文本串的第5个字符A匹配成功： 2. 继续往后匹配，当模式串最后一个字符D跟文本串匹配时失配，显而易见，模式串需要向右移动。但向右移动多少位呢？因为此时已 经匹配的字符数为6个（ABCDAB），然后根据《最大长度表》可得失配字符D的上一位字符B对应的长度值为2，所以根据之前的结论， 可知需要向右移动6 - 2 = 4 位。 3. 模式串向右移动4位后，发现C处再度失配，因为此时已经匹配了2个字符（AB），且上一位字符B对应的最大长度值为0，所以向右 移动：2 - 0 =2 位。 4. A与空格失配，向右移动1 位。 5. 继续比较，发现D与C 失配，故向右移动的位数为：已匹配的字符数6减去上一位字符B对应的最大长度2，即向右移动6-2=4位。 6. 经历第5步后，发现匹配成功，过程结束。 通过上述匹配过程可以看出，问题的关键就是寻找模式串中最大长度的相同前缀和后缀，找到了模式串中每个字符之前的前缀和后缀公共部分的最大长度后，便可基于此匹配。而这个最大长度便正是next 数组要表达的含义。 3. 根据《最大长度表》求next 数组 由上文，我们已经知道，字符串“ABCDABD”各个前缀后缀的最大公共元素长度分别为： 而且，根据这个表可以得出下述结论: 失配时，模式串向右移动的位数为：已匹配字符数 - 失配字符的上一位字符所对应的最大长度值 上文利用这个表和结论进行匹配时，我们发现，当匹配到一个字符失配时，其实没必要考虑当前失配的字符，更何况我们每次失配时，都是看的失配字符的上一位字符对应的最大长度值。如此，便引出了next 数组。 给定字符串“ABCDABD”，可求得它的next 数组如下： 把next数组跟之前求得的最大长度表对比后，不难发现，next 数组相当于“最大长度值” 整体向右移动一位，然后初始值赋为-1。 意识到了这一点，你会惊呼原来next 数组的求解竟然如此简单：就是找最大对称长度的前缀后缀，然后整体右移一位，初值赋为-1（当然，你也可以直接计算某个字符对应的next值，就是看这个字符之前的字符串中有多大长度的相同前缀后缀）。 换言之，对于给定的模式串：ABCDABD，它的最大长度表及next 数组分别如下： 根据最大长度表求出了next 数组后，从而有: 失配时，模式串向右移动的位数为：失配字符所在位置 - 失配字符对应的next 值 而后，你会发现，无论是基于《最大长度表》的匹配，还是基于next 数组的匹配，两者得出来的向右移动的位数是一样的。为什么呢？因为： 根据《最大长度表》，失配时，模式串向右移动的位数 = 已经匹配的字符数 - 失配字符的上一位字符的最大长度值而根据《next 数组》，失配时，模式串向右移动的位数 = 失配字符的位置 - 失配字符对应的next 值其中，从0开始计数时，失配字符的位置 = 已经匹配的字符数（失配字符不计数），而失配字符对应的next 值 = 失配字符的上一位字符的最大长度值，两相比较，结果必然完全一致。 所以，你可以把《最大长度表》看做是next 数组的雏形，甚至就把它当做next 数组也是可以的，区别不过是怎么用的问题。 4. 通过代码递推计算next 数组 这部分到底是怎么算的，我有一点不太懂，之后再过来看部分的东西吧。Next数组的计算 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * KMP模式匹配 * @author Tianma * */ class KMPStringMatcher implements StringMatcher &#123; /** * 获取KMP算法中pattern字符串对应的next数组 * * @param p * 模式字符串对应的字符数组 * @return */ protected int[] getNext(char[] p) &#123; // 已知next[j] = k,利用递归的思想求出next[j+1]的值 // 如果已知next[j] = k,如何求出next[j+1]呢?具体算法如下: // 1. 如果p[j] = p[k], 则next[j+1] = next[k] + 1; // 2. 如果p[j] != p[k], 则令k=next[k],如果此时p[j]==p[k],则next[j+1]=k+1, // 如果不相等,则继续递归前缀索引,令 k=next[k],继续判断,直至k=-1(即k=next[0])或者p[j]=p[k]为止 int pLen = p.length; int[] next = new int[pLen]; int k = -1; int j = 0; next[0] = -1; // next数组中next[0]为-1 while (j &lt; pLen - 1) &#123; if (k == -1 || p[j] == p[k]) &#123; k++; j++; next[j] = k; &#125; else &#123; k = next[k]; &#125; &#125; return next; &#125; @Override public int indexOf(String source, String pattern) &#123; int i = 0, j = 0; char[] src = source.toCharArray(); char[] ptn = pattern.toCharArray(); int sLen = src.length; int pLen = ptn.length; int[] next = getNext(ptn); while (i &lt; sLen &amp;&amp; j &lt; pLen) &#123; // 如果j = -1,或者当前字符匹配成功(src[i] = ptn[j]),都让i++,j++ if (j == -1 || src[i] == ptn[j]) &#123; i++; j++; &#125; else &#123; // 如果j!=-1且当前字符匹配失败,则令i不变,j=next[j],即让pattern模式串右移j-next[j]个单位 j = next[j]; &#125; &#125; if (j == pLen) return i - j; return -1; &#125; &#125; Next数组的优化同样的，这个Next数组的改进，也是看了好几遍，不能很能理解。Next数组的计算 这里以abab为例： 只要出现了p[next[j]] = p[j]的情况，则把next[j]的值再次递归。例如在求模式串“abab”的第2个a的next值时，如果是未优化的next值的话，第2个a对应的next值为0，相当于第2个a失配时，下一步匹配模式串会用p[0]处的a再次跟文本串匹配，必然失配。所以求第2个a的next值时，需要再次递归：next[2] = next[ next[2] ] = next[0] = -1（此后，根据优化后的新next值可知，第2个a失配时，执行“如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++，继续匹配下一个字符”），同理，第2个b对应的next值为0。对于优化后的next数组可以发现一点：如果模式串的后缀跟前缀相同，那么它们的next值也是相同的，例如模式串abcabc，它的前缀后缀都是abc，其优化后的next数组为：-1 0 0 -1 0 0，前缀后缀abc的next值都为-1 0 0。 12345678910111213141516171819202122232425262728293031323334353637383940/** * 优化的KMP算法(对next数组的获取进行优化) * * @author Tianma * */ class OptimizedKMPStringMatcher extends KMPStringMatcher &#123; @Override protected int[] getNext(char[] p) &#123; // 已知next[j] = k,利用递归的思想求出next[j+1]的值 // 如果已知next[j] = k,如何求出next[j+1]呢?具体算法如下: // 1. 如果p[j] = p[k], 则next[j+1] = next[k] + 1; // 2. 如果p[j] != p[k], 则令k=next[k],如果此时p[j]==p[k],则next[j+1]=k+1, // 如果不相等,则继续递归前缀索引,令 k=next[k],继续判断,直至k=-1(即k=next[0])或者p[j]=p[k]为止 int pLen = p.length; int[] next = new int[pLen]; int k = -1; int j = 0; next[0] = -1; // next数组中next[0]为-1 while (j &lt; pLen - 1) &#123; if (k == -1 || p[j] == p[k]) &#123; k++; j++; // 修改next数组求法 if (p[j] != p[k]) &#123; next[j] = k;// KMPStringMatcher中只有这一行 &#125; else &#123; // 不能出现p[j] = p[next[j]],所以如果出现这种情况则继续递归,如 k = next[k], // k = next[[next[k]] next[j] = next[k]; &#125; &#125; else &#123; k = next[k]; &#125; &#125; return next; &#125; &#125; String类构造1234567891011121314151617181920public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence&#123; /** The value is used for character storage. */ private final char value[]; /** The offset is the first index of the storage that is used. */ private final int offset; /** The count is the number of characters in the String. */ private final int count; /** Cache the hash code for the string */ private int hash; // Default to 0 /** use serialVersionUID from JDK 1.0.2 for interoperability */ private static final long serialVersionUID = -6849794470754667710L; ........&#125; 从上面可以看出两点（很重要） 1. String类是一个final类，也就是说我们的String类是不能被继承的，同时它的所有成员方法，都默认是final方法 2. 从上面可以看出，我们String其实使用char[] (Char数组)来保存我们的串的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public String substring(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; if (endIndex &gt; count) &#123; throw new StringIndexOutOfBoundsException(endIndex); &#125; if (beginIndex &gt; endIndex) &#123; throw new StringIndexOutOfBoundsException(endIndex - beginIndex); &#125; return ((beginIndex == 0) &amp;&amp; (endIndex == count)) ? this : new String(offset + beginIndex, endIndex - beginIndex, value);&#125;public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; char buf[] = new char[count + otherLen]; getChars(0, count, buf, 0); str.getChars(0, otherLen, buf, count); return new String(0, count + otherLen, buf);&#125;public String replace(char oldChar, char newChar) &#123; if (oldChar != newChar) &#123; int len = count; int i = -1; char[] val = value; /* avoid getfield opcode */ int off = offset; /* avoid getfield opcode */ while (++i &lt; len) &#123; if (val[off + i] == oldChar) &#123; break; &#125; &#125; if (i &lt; len) &#123; char buf[] = new char[len]; for (int j = 0 ; j &lt; i ; j++) &#123; buf[j] = val[off+j]; &#125; while (i &lt; len) &#123; char c = val[off + i]; buf[i] = (c == oldChar) ? newChar : c; i++; &#125; return new String(0, len, buf); &#125; &#125; return this;&#125; 很重要！！！ 从上面的三个方法可以看出，无论是subString、concat还是replace操作都不是在原有的字符串上进行的，而是重新生成了一个新的字符串对象。也就是说进行这些操作后，最原始的字符串并没有被改变。 在这里要永远记住一点：“String对象一旦被创建就是固定不变的了，对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象”。 字符串常量池我们知道字符串的分配和其他对象分配一样，是需要消耗高昂的时间和空间的，而且字符串我们使用的非常多。JVM为了提高性能和减少内存的开销，在实例化字符串的时候进行了一些优化：使用字符串常量池。每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。 由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串（这点对理解上面至关重要）。 Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。 所谓静态常量池，即#.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。而运行时常量池，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。 来看下面的程序： 12String a = "chenssy";String b = "chenssy"; a、b和字面上的chenssy都是指向JVM字符串常量池中的”chenssy”对象，他们指向同一个对象。 1String c = new String("chenssy"); new关键字一定会产生一个对象chenssy（注意这个chenssy和上面的chenssy不同），同时这个对象是存储在堆中。所以上面应该产生了两个对象：保存在栈中的c和保存堆中chenssy。 但是在Java中根本就不存在两个完全一模一样的字符串对象。故堆中的chenssy应该是引用字符串常量池中chenssy。所以c、chenssy、池chenssy的关系应该是：c—&gt;chenssy—&gt;池chenssy。整个关系如下： 通过上面的图我们可以非常清晰的认识他们之间的关系。所以我们修改内存中的值，他变化的是所有。 虽然a、b、c、chenssy是不同的对象，但是从String的内部结构我们是可以理解上面的。String c = new String(“chenssy”);虽然c的内容是创建在堆中，但是他的内部value还是指向JVM常量池的chenssy的value，它构造chenssy时所用的参数依然是chenssy字符串常量。 堆、栈、方法区堆区:（存放所有new出来的对象；）1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身 栈区:（存放基本类型的变量数据和对象的应用，对象（new出来的对象）本身并不存在栈中，而是存放在堆中或者常量池中（字符串常量对象存放在常量池中））1.每个线程包含一个栈区，栈中只保存基础数据类型的对象（比如int i=1中1就是基础类型的对象）和自定义对象的引用(不是对象)而真实对象都存放在堆区中 2.每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。 3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。 常量池：存放基本类型常量和字符串常量。 方法区:1.又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量。2.方法区中包含的都是在整个程序中永远唯一的元素，如class，static变量名，不是常量（它在堆栈中）。 实例12345678910例一：/** * 采用字面值的方式赋值 */public void test1()&#123; String str1="aaa"; String str2="aaa"; System.out.println("===========test1============"); System.out.println(str1==str2);//true 可以看出str1跟str2是指向同一个对象 &#125; 分析：第一句的时候，我们会现在栈中出现一个str1，同时JVM会在字符串常量池中查找是否存在”aaa”这个对象，发现不存在，那么就在字符串常量池（方法区内）中创建，然后把池中这个”aaa”对象的地址返回给字符串常量str1，这样str1会指向池中”aaa”这个字符串对象；而执行第二句话的时候，直接在池中找到了”aaa”这个对象，那么就直接把这个”aaa”的地址给str2，这样str1和str2就指向了同一个对象，因此str1==str2（==比较的就是地址值） 1234567891011例二：/** * 采用new关键字新建一个字符串对象 */public void test2()&#123; String str3=new String("aaa"); String str4=new String("aaa"); System.out.println("===========test2============"); System.out.println(str3==str4);//false 可以看出用new的方式是生成不同的对象 &#125; 分析：我们在执行第一句话的时候，new了一个新的字符串对象，但是也是先有的字面值”aaa”，所以我们的JVM先在我们的字符串常量池中进行查找，发现没有这个对象，那么就在池中创建，同时，因为是new的，所以我们的堆内存中，会出现一个”aaa”对象，而栈中的str3指向了堆内存中的这个地址，但是这个地址上的对象实际上还是指向的是字符串常量池中的那个，执行第二句的话的时候我们因为在池中已经有了那个字面值对象，所以直接是在堆中的另一个地址上创建了”aaa”对象，而str4指向了这个新地址，因为”==”比较的是对象的地址，所有new出来的肯定就不一样了 这里我们可以这么理解：就是说我们的字符串常量池中的对象是一个字面值对象，但是我们的堆中的对象，才是真正new出来的对象 123456789101112例三：/** * 编译期确定 */public void test3()&#123; String s0="helloworld"; String s1="helloworld"; String s2="hello"+"world"; System.out.println("===========test3============"); System.out.println(s0==s1); //true 可以看出s0跟s1是指向同一个对象 System.out.println(s0==s2); //true 可以看出s0跟s2是指向同一个对象 &#125; 分析：因为例子中的s0和s1中的”helloworld”都是字符串常量，它们在编译期就被确定了，所以s0==s1为true；而”hello”和”world”也都是字符串常量，当一个字符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，所以s2也同样在编译期就被解析为一个字符串常量，所以s2也是常量池中”helloworld”的一个引用。所以我们得出s0==s1==s2。 12345678910111213例四：/** * 编译期无法确定 */public void test4()&#123; String s0="helloworld"; String s1=new String("helloworld"); String s2="hello" + new String("world"); System.out.println("===========test4============"); System.out.println( s0==s1 ); //false System.out.println( s0==s2 ); //false System.out.println( s1==s2 ); //false&#125; 分析：用new String() 创建的字符串不是常量，不能在编译期就确定，所以new String() 创建的字符串不放入常量池中，它们有自己的地址空间。s0还是常量池中”helloworld”的引用，s1因为无法在编译期确定，所以是运行时创建的新对象”helloworld”的引用，s2因为有后半部分new String(”world”)所以也无法在编译期确定，所以也是一个新创建对象”helloworld”的引用。 1234567891011例五：/** * 继续-编译期无法确定 */public void test5()&#123; String str1="abc"; String str2="def"; String str3=str1+str2; System.out.println("===========test5============"); System.out.println(str3=="abcdef"); //false&#125; 分析：因为str3指向堆中的”abcdef”对象，而”abcdef”是字符串池中的对象，所以结果为false。JVM对String str=”abc”对象放在常量池中是在编译时做的，而String str3=str1+str2是在运行时刻才能知道的。new对象也是在运行时才做的。而这段代码总共创建了5个对象，字符串池中两个、堆中三个。+运算符会在堆中建立来两个String对象，这两个对象的值分别是”abc”和”def”，也就是说从字符串池中复制这两个值，然后在堆中创建两个对象，然后再建立对象str3,然后将”abcdef”的堆地址赋给str3。 步骤： 1)栈中开辟一块空间存放引用str1，str1指向池中String常量&quot;abc&quot;。 2)栈中开辟一块空间存放引用str2，str2指向池中String常量&quot;def&quot;。 3)栈中开辟一块空间存放引用str3。 4)str1 + str2通过StringBuilder的最后一步toString()方法还原一个新的String对象&quot;abcdef&quot;，因此堆中开辟一块空间存放此对象。 5)引用str3指向堆中(str1 + str2)所还原的新String对象。 6)str3指向的对象在堆中，而常量&quot;abcdef&quot;在池中，输出为false。 1234567891011121314151617例六：/** * 编译期优化 */public void test6()&#123; String s0 = "a1"; String s1 = "a" + 1; System.out.println("===========test6============"); System.out.println((s0 == s1)); //result = true String s2 = "atrue"; String s3= "a" + "true"; System.out.println((s2 == s3)); //result = true String s4 = "a3.4"; String s5 = "a" + 3.4; System.out.println((s4 == s5)); //result = true&#125; 分析：在程序编译期，JVM就将常量字符串的”+”连接优化为连接后的值，拿”a” + 1来说，经编译器优化后在class中就已经是a1。在编译期其字符串常量的值就确定下来，故上面程序最终的结果都为true。 123456789101112例七：/** * 编译期无法确定 */public void test7()&#123; String s0 = "ab"; String s1 = "b"; String s2 = "a" + s1; System.out.println("===========test7============"); System.out.println((s0 == s2)); //result = false&#125; 分析：JVM对于字符串引用，由于在字符串的”+”连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的，即”a” + s1无法被编译器优化，只有在程序运行期来动态分配并将连接后的新地址赋给s2。所以上面程序的结果也就为false。 1234567891011121314例八：/** * 比较字符串常量的“+”和字符串引用的“+”的区别 */public void test8()&#123; String test="javalanguagespecification"; String str="java"; String str1="language"; String str2="specification"; System.out.println("===========test8============"); System.out.println(test == "java" + "language" + "specification"); System.out.println(test == str + str1 + str2);&#125; 为什么出现上面的结果呢？这是因为，字符串字面量拼接操作是在Java编译器编译期间就执行了，也就是说编译器编译时，直接把”java”、”language”和”specification”这三个字面量进行”+”得到一个”javalanguagespecification” 常量，并且直接将这个常量放入字符串池中，这样做实际上是一种优化，将3个字面量合成一个，避免了创建多余的字符串对象。而字符串引用的”+”运算是在Java运行期间执行的，即str + str2 + str3在程序执行期间才会进行计算，它会在堆内存中重新创建一个拼接后的字符串对象。总结来说就是：字面量”+”拼接是在编译期间进行的，拼接后的字符串存放在字符串池中；而字符串引用的”+”拼接运算实在运行时进行的，新创建的字符串存放在堆中。 对于直接相加字符串，效率很高，因为在编译器便确定了它的值，也就是说形如”I”+”love”+”java”; 的字符串相加，在编译期间便被优化成了”Ilovejava”。对于间接相加（即包含字符串引用），形如s1+s2+s3; 效率要比直接相加低，因为在编译器不会对引用变量进行优化。 123456789101112例九：/** * 编译期确定 */public void test9()&#123; String s0 = "ab"; final String s1 = "b"; String s2 = "a" + s1; System.out.println("===========test9============"); System.out.println((s0 == s2)); //result = true&#125; 分析：和例子7中唯一不同的是s1字符串加了final修饰，对于final修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中。所以此时的”a” + s1和”a” + “b”效果是一样的。故上面程序的结果为true。 1234567891011121314151617例十：/** * 编译期无法确定 */public void test10()&#123; String s0 = "ab"; final String s1 = getS1(); String s2 = "a" + s1; System.out.println("===========test10============"); System.out.println((s0 == s2)); //result = false &#125;private static String getS1() &#123; return "b"; &#125; 分析：这里面虽然将s1用final修饰了，但是由于其赋值是通过方法调用返回的，那么它的值只能在运行期间确定，因此s0和s2指向的不是同一个对象，故上面程序的结果为false。 12345678910111213141516String s1 = "Hello";String s2 = "Hello";String s3 = "Hel" + "lo";String s4 = "Hel" + new String("lo");String s5 = new String("Hello");String s6 = s5.intern();String s7 = "H";String s8 = "ello";String s9 = s7 + s8; System.out.println(s1 == s2); // trueSystem.out.println(s1 == s3); // trueSystem.out.println(s1 == s4); // falseSystem.out.println(s1 == s9); // falseSystem.out.println(s4 == s5); // falseSystem.out.println(s1 == s6); // true 总结1.String类初始化后是不可变的(immutable) String使用private final char value[]来实现字符串的存储，也就是说String对象创建之后，就不能再修改此对象中存储的字符串内容，就是因为如此，才说String类型是不可变的(immutable)。 程序员不能对已有的不可变对象进行修改。我们自己也可以创建不可变对象，只要在接口中不提供修改数据的方法就可以。然而，String类对象确实有编辑字符串的功能，比如replace()。这些编辑功能是通过创建一个新的对象来实现的，而不是对原有对象进行修改。 比如: s = s.replace(&quot;World&quot;, &quot;Universe&quot;); 上面对s.replace()的调用将创建一个新的字符串”Hello Universe!”，并返回该对象的引用。通过赋值，引用s将指向该新的字符串。如果没有其他引用指向原有字符串”Hello World!”，原字符串对象将被垃圾回收。 2.引用变量与对象 A aa;这个语句声明一个类A的引用变量aa[我们常常称之为句柄]，而对象一般通过new创建。所以aa仅仅是一个引用变量，它不是对象。 3.创建字符串的方式 创建字符串的方式归纳起来有两类： （1）使用””引号创建字符串; （2）使用new关键字创建字符串。 结合上面例子，总结如下: （1）单独使用””引号创建的字符串都是常量,编译期就已经确定存储到String Pool中； （2）使用new String(“”)创建的对象会存储到heap中,是运行期新创建的； new创建字符串时首先查看池中是否有相同值的字符串，如果有，则拷贝一份到堆中，然后返回堆中的地址；如果池中没有，则在堆中创建一份，然后返回堆中的地址（注意，此时不需要从堆中复制到池中，否则，将使得堆中的字符串永远是池中的子集，导致浪费池的空间）！ （3）使用只包含常量的字符串连接符如”aa” + “aa”创建的也是常量,编译期就能确定,已经确定存储到String Pool中； （4）使用包含变量的字符串连接符如”aa” + s1创建的对象是运行期才创建的,存储在heap中； 4.使用String不一定创建对象 在执行到双引号包含字符串的语句时，如String a = “123”，JVM会先到常量池里查找，如果有的话返回常量池里的这个实例的引用，否则的话创建一个新实例并置入常量池里。所以，当我们在使用诸如String str = “abc”；的格式定义对象时，总是想当然地认为，创建了String类的对象str。担心陷阱！对象可能并没有被创建！而可能只是指向一个先前已经创建的对象。只有通过new()方法才能保证每次都创建一个新的对象。 5.使用new String，一定创建对象 在执行String a = new String(“123”)的时候，首先走常量池的路线取到一个实例的引用，然后在堆上创建一个新的String实例，走以下构造函数给value属性赋值，然后把实例引用赋值给a： 12345678910111213141516171819public String(String original) &#123; int size = original.count; char[] originalValue = original.value; char[] v; if (originalValue.length &gt; size) &#123; // The array representing the String is bigger than the new // String itself. Perhaps this constructor is being called // in order to trim the baggage, so make a copy of the array. int off = original.offset; v = Arrays.copyOfRange(originalValue, off, off+size); &#125; else &#123; // The array representing the String is the same // size as the String, so no point in making a copy. v = originalValue; &#125; this.offset = 0; this.count = size; this.value = v; &#125; 6.关于String.intern() intern方法使用：一个初始为空的字符串池，它由类String独自维护。当调用 intern方法时，如果池已经包含一个等于此String对象的字符串（用equals(oject)方法确定），则返回池中的字符串。否则，将此String对象添加到池中，并返回此String对象的引用。 它遵循以下规则：对于任意两个字符串 s 和 t，当且仅当 s.equals(t) 为 true 时，s.intern() == t.intern() 才为 true。 String.intern(); 再补充介绍一点：存在于.class文件中的常量池，在运行期间被jvm装载，并且可以扩充。String的intern()方法就是扩充常量池的一个方法；当一个String实例str调用intern()方法时，java查找常量池中是否有相同unicode的字符串常量，如果有，则返回其引用，如果没有，则在常量池中增加一个unicode等于str的字符串并返回它的引用。 12345678910111213141516/** * 关于String.intern() */public void test11()&#123; String s0 = "kvill"; String s1 = new String("kvill"); String s2 = new String("kvill"); System.out.println("===========test11============"); System.out.println( s0 == s1 ); //false System.out.println( "**********" ); s1.intern(); //虽然执行了s1.intern(),但它的返回值没有赋给s1 s2 = s2.intern(); //把常量池中"kvill"的引用赋给s2 System.out.println( s0 == s1); //flase System.out.println( s0 == s1.intern() ); //true//说明s1.intern()返回的是常量池中"kvill"的引用 System.out.println( s0 == s2 ); //true&#125; 7.关于equals和== （1）对于==，如果作用于基本数据类型的变量（byte,short,char,int,long,float,double,boolean ），则直接比较其存储的”值”是否相等；如果作用于引用类型的变量（String），则比较的是所指向的对象的地址（即是否指向同一个对象）。 （2）equals方法是基类Object中的方法，因此对于所有的继承于Object的类都会有该方法。在Object类中，equals方法是用来比较两个对象的引用是否相等，即是否指向同一个对象。(地址) （3）对于equals方法，注意：equals方法不能作用于基本数据类型的变量。如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；而String类对equals方法进行了重写，用来比较指向的字符串对象所存储的字符串是否相等。其他的一些类诸如Double，Date，Integer等，都对equals方法进行了重写用来比较指向的对象所存储的内容是否相等。 12345678910111213/** * 关于equals和== */public void test12()&#123; String s1="hello"; String s2="hello"; String s3=new String("hello"); System.out.println("===========test12============"); System.out.println( s1 == s2); //true,表示s1和s2指向同一对象，它们都指向常量池中的"hello"对象 //flase,表示s1和s3的地址不同，即它们分别指向的是不同的对象,s1指向常量池中的地址，s3指向堆中的地址 System.out.println( s1 == s3); System.out.println( s1.equals(s3)); //true,表示s1和s3所指向对象的内容相同&#125; 8.String相关的+： String中的 + 常用于字符串的连接。看下面一个简单的例子： 12345678910/** * String相关的+ */public void test13()&#123; String a = "aa"; String b = "bb"; String c = "xx" + "yy " + a + "zz" + "mm" + b; System.out.println("===========test13============"); System.out.println(c);&#125; String c = “xx” + “yy “ + a + “zz” + “mm” + b; 实质上的实现过程是： String c = new StringBuilder(“xxyy “).append(a).append(“zz”).append(“mm”).append(b).toString(); 由此得出结论：当使用+进行多个字符串连接时，实际上是产生了一个StringBuilder对象和一个String对象。 9.String的不可变性导致字符串变量使用+号的代价： 12345String s = "a" + "b" + "c"; String s1 = "a"; String s2 = "b"; String s3 = "c"; String s4 = s1 + s2 + s3; 分析：变量s的创建等价于 String s = “abc”; 由上面例子可知编译器进行了优化，这里只创建了一个对象。由上面的例子也可以知道s4不能在编译期进行优化，其对象创建相当于： 123StringBuilder temp = new StringBuilder(); temp.append(a).append(b).append(c); String s = temp.toString(); 由上面的分析结果，可就不难推断出String 采用连接运算符（+）效率低下原因分析，形如这样的代码： 12345678public class Test &#123; public static void main(String args[]) &#123; String s = null; for(int i = 0; i &lt; 100; i++) &#123; s += "a"; &#125; &#125;&#125; 每做一次 + 就产生个StringBuilder对象，然后append后就扔掉。下次循环再到达时重新产生个StringBuilder对象，然后 append 字符串，如此循环直至结束。 如果我们直接采用 StringBuilder 对象进行 append 的话，我们可以节省 N - 1 次创建和销毁对象的时间。所以对于在循环中要进行字符串连接的应用，一般都是用StringBuffer或StringBulider对象来进行append操作。 10.String、StringBuffer、StringBuilder的区别 （1）可变与不可变：String是不可变字符串对象，StringBuilder和StringBuffer是可变字符串对象（其内部的字符数组长度可变）。 （2）是否多线程安全：String中的对象是不可变的，也就可以理解为常量，显然线程安全。StringBuffer 与 StringBuilder 中的方法和功能完全是等价的，只是StringBuffer 中的方法大都采用了synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是非线程安全的。 （3）String、StringBuilder、StringBuffer三者的执行效率：StringBuilder &gt; StringBuffer &gt; String 当然这个是相对的，不一定在所有情况下都是这样。比如String str = “hello”+ “world”的效率就比 StringBuilder st = new StringBuilder().append(“hello”).append(“world”)要高。因此，这三个类是各有利弊，应当根据不同的情况来进行选择使用： 当字符串相加操作或者改动较少的情况下，建议使用 String str=”hello”这种形式；当字符串相加操作较多的情况下，建议使用StringBuilder，如果采用了多线程，则使用StringBuffer。 11.关于String str = new String(“abc”)创建了多少个对象？ 这个问题在很多书籍上都有说到比如《Java程序员面试宝典》，包括很多国内大公司笔试面试题都会遇到，大部分网上流传的以及一些面试书籍上都说是2个对象，这种说法是片面的。 首先必须弄清楚创建对象的含义，创建是什么时候创建的？这段代码在运行期间会创建2个对象么？毫无疑问不可能，用javap -c反编译即可得到JVM执行的字节码内容： 很显然，new只调用了一次，也就是说只创建了一个对象。而这道题目让人混淆的地方就是这里，这段代码在运行期间确实只创建了一个对象，即在堆上创建了”abc”对象。而为什么大家都在说是2个对象呢，这里面要澄清一个概念，该段代码执行过程和类的加载过程是有区别的。在类加载的过程中，确实在运行时常量池中创建了一个”abc”对象，而在代码执行过程中确实只创建了一个String对象。因此，这个问题如果换成 String str = new String(“abc”)涉及到几个String对象？合理的解释是2个。个人觉得在面试的时候如果遇到这个问题，可以向面试官询问清楚”是这段代码执行过程中创建了多少个对象还是涉及到多少个对象“再根据具体的来进行回答。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990综合测试：package com.spring.test;public class StringTest &#123; public static void main(String[] args) &#123; /** * 情景一：字符串池 * JAVA虚拟机(JVM)中存在着一个字符串池，其中保存着很多String对象; * 并且可以被共享使用，因此它提高了效率。 * 由于String类是final的，它的值一经创建就不可改变。 * 字符串池由String类维护，我们可以调用intern()方法来访问字符串池。 */ String s1 = "abc"; //↑ 在字符串池创建了一个对象 String s2 = "abc"; //↑ 字符串pool已经存在对象“abc”(共享),所以创建0个对象，累计创建一个对象 System.out.println("s1 == s2 : "+(s1==s2)); //↑ true 指向同一个对象， System.out.println("s1.equals(s2) : " + (s1.equals(s2))); //↑ true 值相等 //↑------------------------------------------------------over /** * 情景二：关于new String("") * */ String s3 = new String("abc"); //↑ 创建了两个对象，一个存放在字符串池中，一个存在与堆区中； //↑ 还有一个对象引用s3存放在栈中 String s4 = new String("abc"); //↑ 字符串池中已经存在“abc”对象，所以只在堆中创建了一个对象 System.out.println("s3 == s4 : "+(s3==s4)); //↑false s3和s4栈区的地址不同，指向堆区的不同地址； System.out.println("s3.equals(s4) : "+(s3.equals(s4))); //↑true s3和s4的值相同 System.out.println("s1 == s3 : "+(s1==s3)); //↑false 存放的地区多不同，一个栈区，一个堆区 System.out.println("s1.equals(s3) : "+(s1.equals(s3))); //↑true 值相同 //↑------------------------------------------------------over /** * 情景三： * 由于常量的值在编译的时候就被确定(优化)了。 * 在这里，"ab"和"cd"都是常量，因此变量str3的值在编译时就可以确定。 * 这行代码编译后的效果等同于： String str3 = "abcd"; */ String str1 = "ab" + "cd"; //1个对象 String str11 = "abcd"; System.out.println("str1 = str11 : "+ (str1 == str11)); //↑------------------------------------------------------over /** * 情景四： * 局部变量str2,str3存储的是存储两个拘留字符串对象(intern字符串对象)的地址。 * * 第三行代码原理(str2+str3)： * 运行期JVM首先会在堆中创建一个StringBuilder类， * 同时用str2指向的拘留字符串对象完成初始化， * 然后调用append方法完成对str3所指向的拘留字符串的合并， * 接着调用StringBuilder的toString()方法在堆中创建一个String对象， * 最后将刚生成的String对象的堆地址存放在局部变量str3中。 * * 而str5存储的是字符串池中"abcd"所对应的拘留字符串对象的地址。 * str4与str5地址当然不一样了。 * * 内存中实际上有五个字符串对象： * 三个拘留字符串对象、一个String对象和一个StringBuilder对象。 */ String str2 = "ab"; //1个对象 String str3 = "cd"; //1个对象 String str4 = str2+str3; String str5 = "abcd"; System.out.println("str4 = str5 : " + (str4==str5)); // false //↑------------------------------------------------------over /** * 情景五： * JAVA编译器对string + 基本类型/常量 是当成常量表达式直接求值来优化的。 * 运行期的两个string相加，会产生新的对象的，存储在堆(heap)中 */ String str6 = "b"; String str7 = "a" + str6; String str67 = "ab"; System.out.println("str7 = str67 : "+ (str7 == str67)); //↑str6为变量，在运行期才会被解析。 false final String str8 = "b"; String str9 = "a" + str8; String str89 = "ab"; System.out.println("str9 = str89 : "+ (str9 == str89)); //↑str8为常量变量，编译期会被优化 //↑------------------------------------------------------over &#125;&#125;]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structure（堆 & 栈 & 队列）]]></title>
    <url>%2F2017%2F10%2F20%2FDataStructure%EF%BC%88%E5%A0%86%26%E6%A0%88%26%E9%98%9F%E5%88%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节讲堆、栈、堆栈、队列 内存中的堆与栈(JVM)JAVA在程序运行时，在内存中划分5片空间进行数据的存储。分别是：1、寄存器。2、本地方法区。3、方法区。4、栈。5、堆。 1. 基本数据类型、局部变量都是存放在栈内存中的，用完就消失。 2. new创建的实例化对象及数组，是存放在堆内存中的，用完之后靠垃圾回收机制不定期自动消除。 在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对 象的引用变量。 引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。 具体的说： 栈与堆都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。Java的堆是一个运行时数据区,类的(对象从中分配空间。这些对象通过new、newarray、anewarray和multianewarray等 指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时 动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。 栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类 型的变量（,int, short, long, byte, float, double, boolean, char）和对象句柄。 栈有一个很重要的特殊性，就是存在栈中的数据可以共享 假设我们同时定义：int a = 3;int b = 3；编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3；在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。这时，如果再令a=4；那么编译器 会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。要注意这 种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。 String是一 个特殊的包装类数据。 可以用：String str = new String(“abc”);String str = “abc”;两种的形式来创建，第一种是用new()来新建对象的，它会在存放于堆中。每调用一次就会创建一个新的对象.而第二种是先在栈中创建一个对String类的对象引用变量str，然后查找栈 中有没有存放”abc”，如果没有，则将”abc”存放进栈，并令str指向”abc”，如果已经有”abc” 则直接令str指向“abc”。 比较类里面的数值是否相等时，用equals()方法；当 测试两个包装类的引用是否指向同一个对象时，用==， 下面用例子说明上面的理论。 12345678910111213141516String str1 = "abc"; String str2 = "abc"; System.out.println(str1==str2); //true System.out.println(str1.equals(str2));//true//可以看出str1和 str2是指向同一个对象的。 String str1 =new String ("abc"); String str2 =new String ("abc"); System.out.println(str1==str2); // false System.out.println(str1.equals(str2)); // false //第一个比较的是地址，第二个比较的内容（因为String类中复写了这Object中equals方法，先比较地址，再比较内容）String str1 ="abc"; String str2 =new String ("abc"); System.out.println(str1==str2); // false System.out.println(str1.equals(str2)); // true 因此用第二种方式创建多个”abc”字符串,在内存中其实只存在一个对象而已. 这种写法有利与节省内存空间. 同时它可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。而对于String str = new String(“abc”)；的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。 另一方面, 要注意: 我们在使用诸如String str = “abc”；的格式定义类时，总是想当然地认为，创建了String类的对象str。担心陷阱！对象可能并没有被创建！而可能只是指向一个先前已经创建的 对象。只有通过new()方法才能保证每次都创建一个新的对象。由于String类的immutable性质，当String变量需要经常变换其值时，应 该考虑使用StringBuffer类，以提高程序效率。 通过上面这个例子，我们又要再说一下我们的==和equals方法的区别了 从堆和栈的功能和作用来通俗的比较,堆主要用来存放对象的，栈主要是用来执行程序的.而这种不同又 主要是由于堆和栈的特点决定的: 在编程中，例如C/C++中，所有的方法调用都是通过栈来进行的,所有的局部变量,形式参数都是从栈中分配内存 空间的。实际上也不是什么分配,只是从栈顶向上用就行,就好像工厂中的传送带(conveyor belt)一样,Stack Pointer会自动指引你到放东西的位置,你所要做的只是把东西放下来就行.退出函数的时候，修改栈指针就可以把栈中的内容销毁.这样的模式速度最快, 当然要用来运行程序了.需要注意的是,在分配的时候,比如为一个即将要调用的程序模块分配数据区时,应事先知道这个数据区的大小,也就说是虽然分配是在程 序运行时进行的,但是分配的大小多少是确定的,不变的,而这个”大小多少”是在编译时确定的,不是在运行时. 堆是应用程序在运行的时候请求操作 系统分配给自己内存，由于从操作系统管理的内存分配,所以在分配和销毁时都要占用时间，因此用堆的效率非常低.但是堆的优点在于,编译器不必知道要从堆里 分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间,因此,用堆保存数据时会得到更大的灵活性。事实上,面向对象的多态性,堆内存分配是必不 可少的,因为多态变量所需的存储空间只有在运行时创建了对象之后才能确定.在C++中，要求创建一个对象时，只需用 new命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存.当然，为达到这种灵活性，必然会付出一定的代价:在堆里分配存储空间时会花 掉更长的时间！这也正是导致我们刚才所说的效率低的原因,看来列宁同志说的好,人的优点往往也是人的缺点,人的缺点往往也是人的优点(晕~). 又说”==” &amp; equals这里先说Java中的数据类型：基本数据类型（8种）&amp; 引用类型 基本类型的==比的是值,而不是对象，判断二者的内容是否相同。引用类型的==比较的是对象(内存地址)。基本类型没有equals方法，不是对象。但是String可不是除外（字符串缓冲池的东西） 注意，如果直接从Object来说，我们的==和equals方法而言，比较的都是对象的物理地址。 查看Object的API，这样说equals方法： 对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true，也就是说比较的是对象x和y在内存中的区域是否一致,如果不是同一块区域则返回false. JAVA当中所有的类都是继承于Object这个基类的，在Object中的基类中定义了一个equals的方法，这个方法的初始行为是比较对象的内存地 址，但在一些类库当中这个方法被覆盖掉了，如String,Integer,Date在这些类当中equals有其自身的实现，而不再是比较类在堆内存中的存放地址了。 而对于复合数据类型之间进行equals比较，在没有覆写equals方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为Object的equals方法也是用双等号（==）进行比较的，所以比较后的结果跟双等号（==）的结果相同。 可是，如果我们用的是自己写的类 1234Student student1 = new Student();Student student2 = new Student();System.out.println(student1.equals(student2));System.out.println(student1 == student2); 因为都是new出来的，肯定都是false，因为我们没有复写equals方法。那么问题来了 当我调用System.out.println(student1.toString().equals(student2.toString()));时，结果又是怎样的？结果却返回了false.为什么呢？这就牵扯到了hashcode的问题。那么为了保证两个对象比较值相等有什么办法么？想必大家都试过重写equals方法，而最终的结果都不如人意。为什么？因为单单重写equals方法并不能改变hashcode值，在java中 首先比较的就是hashcode，后来才是equals，这就是为什么我们自己写的类中经常需要复写hashcode和equals方法！！！ 堆堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质： 1. 堆中某个节点的值总是不大于或不小于其父节点的值； 2. 堆总是一棵完全二叉树。 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。 堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。 堆是应用程序在运行的时候请求操作系统分配给自己内存，一般是申请/给予的过程。 堆是指程序运行时申请的动态内存，而栈/队列只是指一种使用堆的方法(先进后出/先进先出)。 栈栈（stack）又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。 栈是限定仅在表尾进行插入和删除操作的线性表 栈就是一个桶，后放进去的先拿出来，它下面本来有的东西要等它出来之后才能出来（先进后出） 栈(Stack)是操作系统在建立某个进程时或者线程（在支持多线程的操作系统中是线程）为这个线程建立的存储区域，该区域具有FIFO的特性，在编译的时候可以指定需要的Stack的大小。 堆栈堆栈：什么是堆栈？又该怎么理解呢？注意：其实堆栈本身就是栈，只是换了个抽象的名字。堆栈的特性： 最后一个放入堆栈中的物体总是被最先拿出来， 这个特性通常称为后进先出(LIFO)队列。 堆栈中定义了一些操作。 两个最重要的是PUSH和POP。 PUSH操作在堆栈的顶部加入一 个元素。POP操作相反， 在堆栈顶部移去一个元素， 并将堆栈的大小减一。 堆、栈区别总结：堆栈空间分配 1. 栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 2. 堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。 堆栈缓存方式 1. 栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。 2. 堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。 堆栈数据结构区别 1. 堆（数据结构）：堆可以被看成是一棵树，如：堆排序。 2. 栈（数据结构）：一种先进后出的数据结构。 堆&amp;栈分析示例一 1234main() int x=1;show () int x=2 主函数main()中定义变量int x=1，show()函数中定义变量int x=1。最后show()函数执行完毕。 以上程序执行步骤： 第1步——main()函数是程序入口，JVM先执行，在栈内存中开辟一个空间，存放int类型变量x，同时附值1。 第2步——JVM执行show()函数，在栈内存中又开辟一个新的空间，存放int类型变量x，同时附值2。 此时main空间与show空间并存，同时运行，互不影响。 第3步——show()执行完毕，变量x立即释放，空间消失。但是main()函数空间仍存在，main中的变量x仍然存在，不受影响。 示例二123main() int[] x=new int[3]; x[0]=20 主函数main()中定义数组x，元素类型int，元素个数3。 以上程序执行步骤: 第1步——执行int[] x=new int[3]; 隐藏以下几分支 JVM执行main()函数，在栈内存中开辟一个空间，存放x变量（x变量是局部变量）。 同时，在堆内存中也开辟一个空间，存放new int[3]数组，堆内存会自动内存首地址值，如0x0045。 数组在堆内存中的地址值，会附给x，这样x也有地址值。所以，x就指向（引用）了这个数组。此时，所有元素均未附值，但都有默认初始化值0。 第2步——执行x[0]=20 即在堆内存中将20附给[0]这个数组元素。这样，数组的三个元素值分别为20,0,0 示例三 1234main() int[] x=new int[3]; x[0]=20 x=null; 以上步骤执行步骤第1、2步——与示例2完全一样，略。 第3步——执行x=null; null表示空值，即x的引用数组内存地址0x0045被删除了，则不再指向栈内存中的数组。此时，堆中的数组不再被x使用了，即被视为垃圾，JVM会启动垃圾回收机制，不定时自动删除。 示例四 12345main() int[] x=new int[3]; int[] y=x; y[1]=100 x=null; 以上步骤执行步骤 第1步——与示例2第1步一致，略。 第2步——执行int[] y=x， 在栈内存定义了新的数组变量内存y，同时将x的值0x0045附给了y。所以，y也指向了堆内存中的同一个数组。 第3步——执行y[1]=100 即在堆内存中将20附给[0]这个数组元素。这样，数组的三个元素值分别为0,100,0 第4步——执行x=null 则变量x不再指向栈内存中的数组了。但是，变量y仍然指向，所以数组不消失。 示例五1234Car c=new Car;c.color="blue";Car c1=new Car;c1.num=5; 虽然是个对象都引用new Car，但是是两个不同的对象。每一次new，都产生不同的实体. 示例六12345Car c=new Car;c.num=5;Car c1=c;c1.color="green";c.run(); Car c1=c，这句话相当于将对象复制一份出来，两个对象的内存地址值一样。所以指向同一个实体，对c1的属性修改，相当于c的属性也改了。 基本总结栈： 函数中定义的基本类型变量，对象的引用变量都在函数的栈内存中分配。 栈内存特点，数数据一执行完毕，变量会立即释放，节约内存空间。 栈内存中的数据，没有默认初始化值，需要手动设置。 堆： 堆内存用来存放new创建的对象和数组。 堆内存中所有的实体都有内存地址值。 堆内存中的实体是用来封装数据的，这些数据都有默认初始化值。 堆内存中的实体不再被指向时，JVM启动垃圾回收机制，自动清除，这也是JAVA优于C++的表现之一（C++中需要程序员手动清除）。 栈基本概述栈（Stack）是限定仅在表尾进行插入和删除操作的线性表 我们允许把插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈。栈又称为后进先出的线性表，简称LIFO（Last In First Out）结构。 顺序栈（数组实现）我们可以使用数组来存储栈中的元素Push的时候，直接添加一个元素S[N]到数组中，Pop的时候直接返回S[N-1]. 首先，我们定义一个数组，然后在构造函数中给定初始化大小，Push方法实现如下，就是集合里添加一个元素： 1234567T[] item;int number = 0;public StackImplementByArray(int capacity)&#123; item = new T[capacity];&#125; Push方法：12345public void Push(T _item)&#123; if (number == item.Length) Resize(2 * item.Length); item[number++] = _item;&#125; Pop方法：1234567public T Pop()&#123; T temp = item[--number]; item[number] = default(T); if (number &gt; 0 &amp;&amp; number == item.Length / 4) Resize(item.Length / 2); return temp;&#125; 在Push和Pop方法中，为了节省内存空间，我们会对数组进行整理。Push的时候，当元素的个数达到数组的Capacity的时候，我们开辟2倍于当前元素的新数组，然后将原数组中的元素拷贝到新数组中。Pop的时候，当元素的个数小于当前容量的1/4的时候，我们将原数组的大小容量减少1/2。 Resize方法基本就是数组复制： 123456789private void Resize(int capacity)&#123; T[] temp = new T[capacity]; for (int i = 0; i &lt; item.Length; i++) &#123; temp[i] = item[i]; &#125; item = temp;&#125; 当我们缩小数组的时候，采用的是判断1/4的情况，这样效率要比1/2要高，因为可以有效避免在1/2附件插入，删除，插入，删除，从而频繁的扩大和缩小数组的情况。下图展示了在插入和删除的情况下数组中的元素以及数组大小的变化情况： 分析： 1. Pop和Push操作在最坏的情况下与元素个数成比例的N的时间，时间主要花费在扩大或者缩小数组的个数时，数组拷贝上。 2. 元素在内存中分布紧凑，密度高，便于利用内存的时间和空间局部性，便于CPU进行缓存，较LinkList内存占用小，效率高。 链栈（链表实现）栈的链表实现： 我们首先定义一个内部类来保存每个链表的节点，该节点包括当前的值以及指向下一个的值，然后建立一个节点保存位于栈顶的值以及记录栈的元素个数; 12345678class Node&#123; public T Item&#123;get;set;&#125; public Node Next &#123; get; set; &#125;&#125;private Node first = null;private int number = 0; 现在来实现Push方法，即向栈顶压入一个元素，首先保存原先的位于栈顶的元素，然后新建一个新的栈顶元素，然后将该元素的下一个指向原先的栈顶元素。整个Push过程如下: 12345678void Push(T node)&#123; Node oldFirst = first; first = new Node(); first.Item= node; first.Next = oldFirst; number++;&#125; Pop方法也很简单，首先保存栈顶元素的值，然后将栈顶元素设置为下一个元素： 1234567T Pop()&#123; T item = first.Item; first = first.Next; number--; return item;&#125; Java中栈的实现–StackStack是Vector类的子类，所以这里我们再看一个Vector类，我们知道Vector类基本就是ArrayList的同步实现，有很多地方都是一样的，但是就扩容来说，ArrayList是扩1.5倍，而Vector却不是。 Vector成员变量&amp;构造方法 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; protected Object[] elementData;//底层也是个数组 protected int elementCount;//数组元素个数 protected int capacityIncrement;//扩容时增长数量，允许用户自己设置。如果这个值是 0 或者 负数，扩容时会扩大 2 倍，而不是 1.5 //创建一个容量是10的数组，同时增长量为 0 public Vector() &#123; this(10); &#125; //创建一个用户指定容量的数组，同时增长量为 0 public Vector(int initialCapacity) &#123; this(initialCapacity, 0); &#125; //创建指定容量大小的数组，设置增长量。如果增长量为 非正数，扩容时会扩大两倍 public Vector(int initialCapacity, int capacityIncrement) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); this.elementData = new Object[initialCapacity]; this.capacityIncrement = capacityIncrement; &#125; //创建一个包含指定集合的数组 public Vector(Collection&lt;? extends E&gt; c) &#123; //转成数组，赋值 elementData = c.toArray(); elementCount = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) //可能有这个神奇的 bug，用 Arrays.copyOf 重新创建、复制 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, elementCount, Object[].class); &#125; ...... ...... ......&#125; 添加方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//boolean add(E e)public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125;private void ensureCapacityHelper(int minCapacity) &#123; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125;//add(int index, E element)public void add(int index, E element) &#123; insertElementAt(element, index);&#125;public synchronized void insertElementAt(E obj, int index) &#123; modCount++; if (index &gt; elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + " &gt; " + elementCount); &#125; ensureCapacityHelper(elementCount + 1); System.arraycopy(elementData, index, elementData, index + 1, elementCount - index); elementData[index] = obj; elementCount++;&#125;//void addElement(E obj)public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj;&#125; 删 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//boolean remove(Object o)public boolean remove(Object o) &#123; return removeElement(o); &#125;public synchronized boolean removeElement(Object obj) &#123; modCount++; int i = indexOf(obj); if (i &gt;= 0) &#123; removeElementAt(i); return true; &#125; return false;&#125;public int indexOf(Object o) &#123; return indexOf(o, 0);&#125;public synchronized int indexOf(Object o, int index) &#123; if (o == null) &#123; for (int i = index ; i &lt; elementCount ; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = index ; i &lt; elementCount ; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;public synchronized void removeElementAt(int index) &#123; modCount++; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + " &gt;= " + elementCount); &#125; else if (index &lt; 0) &#123; throw new ArrayIndexOutOfBoundsException(index); &#125; int j = elementCount - index - 1; if (j &gt; 0) &#123; System.arraycopy(elementData, index + 1, elementData, index, j); &#125; elementCount--; elementData[elementCount] = null; /* to let gc do its work */&#125;//E remove(int index)public synchronized E remove(int index) &#123; modCount++; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); int numMoved = elementCount - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--elementCount] = null; // Let gc do its work return oldValue;&#125; 改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public synchronized E set(int index, E element) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125;//修改指定位置为指定元素public synchronized void setElementAt(E obj, int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + " &gt;= " + elementCount); &#125; //数组就是方便，直接更新就好了 elementData[index] = obj;&#125;//修改数组容量public synchronized void setSize(int newSize) &#123; modCount++; //元素个数超出容量就要扩容 if (newSize &gt; elementCount) &#123; ensureCapacityHelper(newSize); &#125; else &#123; //新增 elementCount - newSize 个元素 for (int i = newSize ; i &lt; elementCount ; i++) &#123; elementData[i] = null; &#125; &#125; elementCount = newSize;&#125;//排序，修改顺序public synchronized void sort(Comparator&lt;? super E&gt; c) &#123; final int expectedModCount = modCount; //用的是 Arrays.sort Arrays.sort((E[]) elementData, 0, elementCount, c); if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; modCount++;&#125;//缩小数组容量，减少占用资源public synchronized void trimToSize() &#123; modCount++; int oldCapacity = elementData.length; if (elementCount &lt; oldCapacity) &#123; //新建个小点的数组，赋值 elementData = Arrays.copyOf(elementData, elementCount); &#125;&#125; 查 1234567891011121314151617181920212223242526272829303132333435public synchronized E get(int index) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index);&#125;@SuppressWarnings("unchecked")E elementData(int index) &#123; return (E) elementData[index];&#125;//查找 o 从指定位置 index 开始第一次出现的位置public synchronized int indexOf(Object o, int index) &#123; if (o == null) &#123; for (int i = index ; i &lt; elementCount ; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = index ; i &lt; elementCount ; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;//查找 o 在数组中首次出现的位置public int indexOf(Object o) &#123; return indexOf(o, 0);&#125;//是否包含 O public boolean contains(Object o) &#123; return indexOf(o, 0) &gt;= 0;&#125; StackVector的直接子类，很多方法都是直接来自与Vector 构造方法 12public Stack() &#123;&#125; 内部就5个方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192//入栈//调用的 Vector.addElement()public E push(E item) &#123; addElement(item); return item;&#125;Vector 的 addElement() 方法，就是在数组尾部添加元素：public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj;&#125;//得到栈顶元素public synchronized E peek() &#123; //调用 Vector.size() 返回元素个数 int len = size(); if (len == 0) throw new EmptyStackException(); //调用 Vector.elementAt 得到栈顶元素 return elementAt(len - 1);&#125;Vector.elementAt(int):public synchronized E elementAt(int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + " &gt;= " + elementCount); &#125; return elementData(index);&#125;Vector.elementData(int):E elementData(int index) &#123; return (E) elementData[index];&#125;//出栈public synchronized E pop() &#123; E obj; int len = size(); //调用 peek() 获取顶端元素，一会儿返回 obj = peek(); //调用 Vector.removeElementAt 删除顶端元素 removeElementAt(len - 1); return obj;&#125;Vector.removeElementAt(int):public synchronized void removeElementAt(int index) &#123; modCount++; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + " &gt;= " + elementCount); &#125; else if (index &lt; 0) &#123; throw new ArrayIndexOutOfBoundsException(index); &#125; int j = elementCount - index - 1; if (j &gt; 0) &#123; System.arraycopy(elementData, index + 1, elementData, index, j); &#125; elementCount--; elementData[elementCount] = null; /* to let gc do its work */&#125;//查找栈中是否有元素public synchronized int search(Object o) &#123; int i = lastIndexOf(o); //返回的是栈顶到该元素出现的位置的距离 if (i &gt;= 0) &#123; return size() - i; &#125; return -1;&#125;//判断栈是不是为空public boolean empty() &#123; return size() == 0;&#125;Vector.size():public synchronized int size() &#123; return elementCount;&#125; 队列队列（Queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。 队列是一种先进先出（First In First Out） 的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。 循环队列（数组实现） 123456789101112131415161718192021222324public void Enqueue(T _item)&#123; if ((head - tail + 1) == item.Length) Resize(2 * item.Length); item[tail++] = _item;&#125;public T Dequeue()&#123; T temp = item[--head]; item[head] = default(T); if (head &gt; 0 &amp;&amp; (tail - head + 1) == item.Length / 4) Resize(item.Length / 2); return temp;&#125;private void Resize(int capacity)&#123; T[] temp = new T[capacity]; int index = 0; for (int i = head; i &lt; tail; i++) &#123; temp[++index] = item[i]; &#125; item = temp;&#125; 链队列Queue是一种先进先出的数据结构，和Stack一样，他也有链表和数组两种实现，理解了Stack的实现后，Queue的实现就比较简单了。 链队列的实现： Dequeue方法就是返回链表中的第一个元素，这个和Stack中的Pop方法相似：123456789public T Dequeue()&#123; T temp = first.Item; first = first.Next; number--; if (IsEmpety()) last = null; return temp;&#125; Enqueue和Stack的Push方法不同，他是在链表的末尾增加新的元素： 123456789101112131415public void Enqueue(T item)&#123; Node oldLast = last; last = new Node(); last.Item = item; if (IsEmpety()) &#123; first = last; &#125; else &#123; oldLast.Next = last; &#125; number++;&#125; Java中队列的实现–QueueJava 集合中的 Queue 继承自 Collection 接口 ，Deque, LinkedList, PriorityQueue, BlockingQueue 等类都实现了它。 Queue 用来存放 等待处理元素 的集合，这种场景一般用于缓冲、并发访问。 除了继承 Collection 接口的一些方法，Queue 还添加了额外的 添加、删除、查询操作。 内部方法add(E), offer(E) 在尾部添加: 12boolean add(E e);boolean offer(E e); 他们的共同之处是建议实现类禁止添加 null 元素，否则会报空指针 NullPointerException； 不同之处在于 add() 方法在添加失败（比如队列已满）时会报 一些运行时错误 错；而 offer() 方法即使在添加失败时也不会奔溃，只会返回 false。 注意：Queue 是个接口，它提供的 add, offer 方法初衷是希望子类能够禁止添加元素为 null，这样可以避免在查询时返回 null 究竟是正确还是错误。 事实上大多数 Queue 的实现类的确响应了 Queue 接口的规定，比如 ArrayBlockingQueue，PriorityBlockingQueue 等等。 但还是有一些实现类没有这样要求，比如 LinkedList。 remove(), poll() 删除并返回头部： 12E remove();E poll(); 当队列为空时 remove() 方法会报 NoSuchElementException 错; 而 poll() 不会奔溃，只会返回 null。 element(), peek() 获取但不删除： 12E element();E peek(); 当队列为空时 element() 抛出异常；peek() 不会奔溃，只会返回 null。 注意 1.虽然 LinkedList 没有禁止添加 null，但是一般情况下 Queue 的实现类都不允许添加 null 元素，为啥呢？因为 poll(), peek() 方法在异常的时候会返回 null，你添加了 null 以后，当获取时不好分辨究竟是否正确返回。 2.Queue 一般都是 FIFO 的，但是也有例外，比如优先队列 priority queue（它的顺序是根据自然排序或者自定义 comparator 的）；再比如 LIFO 的队列（跟栈一样，后来进去的先出去）。 不论进入、出去的先后顺序是怎样的，使用 remove()，poll() 方法操作的都是 头部 的元素；而插入的位置则不一定是在队尾了，不同的 queue 会有不同的插入逻辑。 Stack &amp; Queue的应用Stack用在递归—斐波那契数列斐波那契数列：前面相邻两项之和，构成了后一项。 12345678910111213public static int Fbi(int num)&#123; if(num&lt;2) return num == 0 ? 0 : 1; return Fbi(num-1)+Fbi(num-2);&#125;public static void main(String[] args) &#123; for (int num = 0; num &lt; 10; num++) &#123; System.out.print(Fbi(num)+","); &#125;&#125; Stack用于数组翻转1234567891011121314151617181920212223242526public class StackAndQueue &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;2,4,1,6,4,7&#125;; reverse(array); System.out.println(Arrays.toString(array)); &#125; public static &lt;T&gt; void reverse(T[] array)&#123; int begin = 0; int end = array.length-1; while (end &gt; begin) &#123; T temp = array[begin]; array[begin] = array[end]; array[end] = temp; begin++; end--; &#125; &#125;&#125; Stack用于后缀表达式这部分直接看书]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Structure（线性表）]]></title>
    <url>%2F2017%2F10%2F20%2FDataStructure%EF%BC%88%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节讲线性表：顺序表、链表 线性表概述 逻辑结构–线性表的定义线性表(List):零个或多个数据元素的有限序列。 线性表说的就是一种逻辑结构，相同数据类型的n个数据元素的有限序列，除第一个元素外，每个元素有且仅有一个直接前驱，除最后一个元素外，每个元素有且仅有一个直接后继。 线性表元素的个数n(n&gt;=0)定义为线性表的长度，当n=0时，称为空表。 在较复杂的线性表中，一个数据元素可以由若干个数据项组成。 线性表的特点： （1）元素个数有限 （2）逻辑上元素有先后次序 （3）数据类型相同 （4）仅讨论元素间的逻辑关系 注：线性表是逻辑结构，顺序表和链表是存储结构。 逻辑结构–抽象数据类型抽象数据类型（ADT）是一个实现包括储存数据元素的存储结构以及实现基本操作的算法。在这个数据抽象思想中，数据类型的定义和它的实现是分开的，这在软件设计中是一个重要的概念。这使得只研究和使用它的结构而不用考虑它的实现细节成为可能。 ADT包括数据数据元素，数据关系以及相关的操作。即ADT { 数据对象：（数据元素集合） 数据关系：（数据关系二元组结合） 基本操作：（操作函数的罗列） } 存储结构–顺序存储顺序表顺序表，使用数组实现，一组地址连续的存储单元，数组大小有两种方式指定，一是静态分配，二是动态扩展。 注：线性表从1开始，而数组从0开始。 优点：随机访问特性，查找O(1)时间，存储密度高；逻辑上相邻的元素，物理上也相邻；无须为表示表中元素之间的逻辑关系而增加额外的存储空间。 缺点：插入删除需移动大量元素；当线性表长度变化较大时，难以确定存储空间的容量。 顺序表相关的操作跟数组有关，一般都是移动数组元素。 这里说一下插入和删除时的边界条件，首先线性表从1开始，数组从0开始，单纯的文件说明不够直接，来看图说话吧。 数据长度和线性表长度的区别： 数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般不变。（动态数组除外） 线性表的长度是线性表中数据元素的个数。 在任何时刻，线性表的长度应该小于等于数组的长度 我们ArrayList就是我们这里说的顺序表，底层用的是动态数组的形式。利用了数组的动态扩容和数组拷贝。现在理解到内部elementData的数组长度(Capacity)每次都会被size要大，因为elementData.length是数组的大小(容量的大小)，而size是数组中存的数据的长度，也就是这里说的线性表的长度。所以每次minCapacity-elementData.length&gt;0的时候，就需要对elementData[]进行动态的扩容(1.5倍，扩的是Capacity，也就是数组的长度，和线性表的长度没关系，线性表的长度，也就是size只会于数据的多少有关)。下面是之前复习ArrayList时候的文章，里面直接利用源码去讲了动态数组的扩容和元素的删除：JavaSE复习（十）— ArrayList 存储结构–链式存储链表的定义是递归的，它或者为空null，或者指向另一个节点node的引用，这个节点含有下一个节点或链表的引用。 与顺序存储相比，允许存储空间不连续，插入删除时不需要移动大量的元素，只需修改指针即可，但查找某个元素，只能从头遍历整个链表。 为了表示每个数据元素Ai与其直接前驱/后继数据元素Ai-1/Ai+1之间的逻辑关系，对数据元素Ai来说，除了存储其本身的信息之外，还需要存储指示其直接前驱/后继的信息(存储位置)。我们把存储数据元素信息的域称为数据域，把存储直接前驱/后继位置的域称为指针域。指针域存储的信息称做指针或链。这两部分信心组成数据元素Ai的存储映像，称为结点(Node)。 Java中使用嵌套类来定义节点的抽象数据类型： 1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 我们把链表中第一个结点的存储位置叫做头指针。有时，我们为了更加方便地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息。 头指针和头结点的区别： 1. 头指针是指向链表第一个结点的指针，若链表有头结点，则是指向头结点的指针。 2. 无论链表是不是空链，头指针均不能为空。头指针是链表的必要元素，但是头结点却不一定是链表的必要元素。 单链表《大话数据结构》这一节的内容很重要。p60 链表结构中每个Node值包含一个指针域，指向这个结点的下一个结点，所以这种结构的链表叫做单链表。 循环链表与单链表的区别在于，表中最后一个节点的指针不为null，而改为指向头结点（第一个节点），从而整个链表形成一个环。判断循环单链表是否为空，判断是否头指针是不是指向null。 只有一个尾指针的循环单例表，可以很方便的操作表头和表尾，因为尾指针的后继就是头指针O(1) （单节点链表）。 双向链表（更特殊的一种循环链表）与双链表的区别在于，头结点的prev指针指向尾节点，尾节点的next指针指向头结点。 双向链表典型的例子就是LinkedList，对于双向链表的大多数操作，我都在 JavaSE基础（十一）–LinkedList 中参考LinkedList的源码做了很多分析，这里就不再说了。 顺序表和链表的区别 通过上面的对比，可以得出一些经验性的结论： 1. 若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用链表结构。 2. 当线性表中的元素个数变化较大或者根本不知道有多大时，最好用链表结构，这样可以不需要考虑存储空间的大小问题。而如果事先知道线性表的大致长度，用顺序存储结构效率会高很多。]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础（二十二）]]></title>
    <url>%2F2017%2F10%2F18%2FJavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节又补充了一点Hash表的东西，同时注意到了WeakHashMap的机制，最后聊了一下集合转数组的时候注意的一个点 再说Hash：从数据结构到集合源码 WeakHashMap下面的东西很多来自《Java核心技术》 设计WeakHashMap是为了解决一个问题。如果一个值，对应的键已经不再使用了，将会出现什么情况呢？假定对某个键的最后一次引用已经消亡，不再有任何途径引用这个值的对象了。但是，由于在程序中的任何部分没有再出现这个键，所以，这个键&amp;值对无法从映射中删除。 为什么垃圾回收机制不能删除它呢？难道删除无用的对象不是垃圾回收器的工作吗？ 遗憾的是，垃圾回收器跟踪的只是活动的对象。只要映射对象是活动的，其中所有的桶也就是活动的，所以形成了无法回收的现象。 因此，需要由程序负责从长期存活的映射表中删除那些无用的值。或者使用WeakHashMap完成这件事。当对键的唯一引用来自hash条目时，这一数据结构就会和垃圾回收机制协同工作一起删除键&amp;值对。 下面是这种机制的内部运行情况。WeakHashMap使用弱引用(weak references)保存键。WeakReference对象将引用保存到另一个对象中，在这里，就是散列键。对于这种类型的对象，垃圾回收器也会回收它，但是会将引用这个对象的弱引用放入队列中。WeakHashMap将周期性地检查队列，以便找出新添加的弱引用。一个弱引用进入队列意味着这个键不再被他人使用，并且已经被收集起来。于是，WeakHashMap将删除对应的条目。 关于集合转数组12345678910111213141516171819202122package jse_7;import java.util.Arrays;import java.util.HashSet;public class SetTest &#123; public static void main(String[] args) &#123; Integer[] array = &#123;2,3,1,5,0,8,7,9&#125;; HashSet&lt;Integer&gt; hashMap = new HashSet&lt;Integer&gt;(Arrays.asList(array)); Integer[] arrayConvert = (Integer[]) hashMap.toArray(); System.out.println(arrayConvert.toString()); &#125;&#125;/**Output： Exception in thread "main" java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.lang.Integer; at jse_7.SetTest.main(SetTest.java:14)*/ 1234567891011121314public class SetTest &#123; public static void main(String[] args) &#123; Integer[] array = &#123;2,3,1,5,0,8,7,9&#125;; HashSet&lt;Integer&gt; hashMap = new HashSet&lt;Integer&gt;(Arrays.asList(array)); System.out.println(hashMap.toArray().getClass()); &#125;&#125;/**Output: [Ljava.lang.Object;*/ toArray()方法返回的数组是一个Object[]数组，不能强转去改变它的类型。实际上，必须使用toArray()的一个变体形式，提供一个所需类型而且长度是0的数组。这样一来，返回的数组就会创建为相同的数组类型。 12345678910111213141516public class SetTest &#123; public static void main(String[] args) &#123; Integer[] array = &#123;2,3,1,5,0,8,7,9&#125;; HashSet&lt;Integer&gt; hashMap = new HashSet&lt;Integer&gt;(Arrays.asList(array)); Integer[] arrayConvert = hashMap.toArray(new Integer[0]); System.out.println(Arrays.toString(arrayConvert)); &#125;&#125;/**Output: [0, 1, 2, 3, 5, 7, 8, 9]*/ 上面的转换也可以写成： Integer[] arrayConvert = hashMap.toArray(new Integer[hashMap.size()]); 这样，不不会创建新的数组了。 注意：这个转换的时候一定要注意，生成的数组中数据的顺序和集合的类型是有关系的，也就是和相应集合内部村存储方法有关！！！]]></content>
      <categories>
        <category>Java_Base</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础（二十一）]]></title>
    <url>%2F2017%2F10%2F17%2FJavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节说三个集合中遇到的问题：asList、subList、fast-fail 问题总结 集合中的一些问题–asList避免使用基本数据类型数组转换为列表我们直接将一个数据转成集合的时候，经常使用这个方法，这样直接就避免了我们去写遍历的方法。 但是我们需要主要一点，就是在利用这个方法的时候，我们的数组中存的数据类型最好不要是基本数据类型（8种） 12345678public static void main(String[] args) &#123; int[] ints = &#123;1,2,3,4,5&#125;; List list = Arrays.asList(ints); System.out.println("list'size：" + list.size());&#125;------------------------------------outPut：list'size：1 程序的运行结果并没有像我们预期的那样是5而是逆天的1，这是什么情况？先看源码： 12345@SafeVarargs@SuppressWarnings("varargs")public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125; asList接受的参数是一个泛型的可变长度参数，我们知道基本数据类型是可变长度的，也就是说8个基本类型是无法作为asList的参数的， 要想作为泛型参数就必须使用其所对应的包装类型。 但是这个这个实例中为什么没有出错呢？因为该实例是将int 类型的数组当做其参数，而在Java中数组是一个对象，它是可以泛型化的。 所以该例子是不会产生错误的。既然例子是将整个int 类型的数组当做泛型参数，那么经过asList转换就只有一个int 的列表了。如下： 12345678910public static void main(String[] args) &#123; int[] ints = &#123;1,2,3,4,5&#125;; List list = Arrays.asList(ints); System.out.println("list 的类型:" + list.get(0).getClass()); System.out.println("list.get(0) == ints：" + list.get(0).equals(ints));&#125;--------------------------------------------outPut:list 的类型:class [Ilist.get(0) == ints：true 从这个运行结果我们可以充分证明list里面的元素就是int数组。下面吧int变成Integer 123456789101112public static void main(String[] args) &#123; Integer[] ints = &#123;1,2,3,4,5&#125;; List list = Arrays.asList(ints); System.out.println("list'size：" + list.size()); System.out.println("list.get(0) 的类型:" + list.get(0).getClass()); System.out.println("list.get(0) == ints[0]：" + list.get(0).equals(ints[0]));&#125;----------------------------------------outPut:list'size：5list.get(0) 的类型:class java.lang.Integerlist.get(0) == ints[0]：true asList产生的列表不可操作asList后直接得到的List集合不能执行改变List长度的操作！！！比如增加和删除 下面以add(E e)为例： 123456789101112131415161718192021222324package jse_7;import java.util.ArrayList;import java.util.Arrays;import java.util.List;public class AsListTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;9,0,1,0,3,5,1,7,2,7&#125;; List&lt;Integer&gt; list = Arrays.asList(array); list.add(0); System.out.println(list.toString()); &#125;&#125;直接报异常： Exception in thread "main" java.lang.UnsupportedOperationException at java.util.AbstractList.add(AbstractList.java:148) at java.util.AbstractList.add(AbstractList.java:108) at jse_7.AsListTest.main(AsListTest.java:14) 直接看asList(T… a) 的源码： 123public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a); &#125; asList接受参数后，直接new 一个ArrayList，到这里看应该是没有错误的啊？直接进入到Arrays.class看这个ArrayList： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable&#123; private static final long serialVersionUID = -2764017481108945198L; private final E[] a; ArrayList(E[] array) &#123; a = Objects.requireNonNull(array); &#125; @Override public int size() &#123; return a.length; &#125; @Override public Object[] toArray() &#123; return a.clone(); &#125; @Override @SuppressWarnings("unchecked") public &lt;T&gt; T[] toArray(T[] a) &#123; int size = size(); if (a.length &lt; size) return Arrays.copyOf(this.a, size, (Class&lt;? extends T[]&gt;) a.getClass()); System.arraycopy(this.a, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; @Override public E get(int index) &#123; return a[index]; &#125; @Override public E set(int index, E element) &#123; E oldValue = a[index]; a[index] = element; return oldValue; &#125; @Override public int indexOf(Object o) &#123; E[] a = this.a; if (o == null) &#123; for (int i = 0; i &lt; a.length; i++) if (a[i] == null) return i; &#125; else &#123; for (int i = 0; i &lt; a.length; i++) if (o.equals(a[i])) return i; &#125; return -1; &#125; @Override public boolean contains(Object o) &#123; return indexOf(o) != -1; &#125; @Override public Spliterator&lt;E&gt; spliterator() &#123; return Spliterators.spliterator(a, Spliterator.ORDERED); &#125; @Override public void forEach(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); for (E e : a) &#123; action.accept(e); &#125; &#125; @Override public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; Objects.requireNonNull(operator); E[] a = this.a; for (int i = 0; i &lt; a.length; i++) &#123; a[i] = operator.apply(a[i]); &#125; &#125; @Override public void sort(Comparator&lt;? super E&gt; c) &#123; Arrays.sort(a, c); &#125;&#125; 原来，asList中返回的ArrayList并不是我们用的那个List，而是Arrays中的一个内部类！！！ 通过这些代码可以看出asList返回的列表只不过是一个披着list的外衣，它并没有list的基本特性（变长）。该list是一个长度不可变的列表，传入参数的数组有多长，其返回的列表就只能是多长。 asList到真正List集合我们上面说，直接调用asList方法后，我们List并不是真正意义上的List集合，那么我们怎么样去做这个转换呢？ 建议直接把asList后的List直接作为ArrayList或者LinkedList的形参，调用 public ArrayList(Collection&lt;? extends E&gt; c) 这样的构造函数去创建！！！ 12345678910111213141516public class AsListTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;9,0,1,0,3,5,1,7,2,7&#125;; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(array)); //List&lt;Integer&gt; list = Arrays.asList(array); list.add(0, 0); System.out.println(list.toString()); &#125;&#125;Outut: [0, 9, 0, 1, 0, 3, 5, 1, 7, 2, 7] 集合中的一些问题–subListsubList返回仅仅只是一个视图1234567891011121314151617181920212223public class AsListTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;9,0,1,0,3,5,1,7,2,7&#125;; List&lt;Integer&gt; list_1 = new ArrayList&lt;Integer&gt;(Arrays.asList(array)); List&lt;Integer&gt; list_2 = list_1.subList(0, list_1.size()); List&lt;Integer&gt; list_3 = new ArrayList&lt;Integer&gt;(list_1); list_3.add(0); System.out.println(list_1.equals(list_3)); list_2.add(0); System.out.println(list_1.equals(list_2)); &#125;&#125;Output: false true 1234567891011121314151617181920public class AsListTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;9,0,1,0,3,5,1,7,2,7&#125;; List&lt;Integer&gt; list_1 = new ArrayList&lt;Integer&gt;(Arrays.asList(array)); List&lt;Integer&gt; list_2 = list_1.subList(0, list_1.size()); List&lt;Integer&gt; list_3 = new ArrayList&lt;Integer&gt;(list_1); list_2.add(0); System.out.println(list_1.equals(list_2)); System.out.println(list_1.equals(list_3)); &#125;&#125;Output: true false 强调：我们的list.equals，比较的是两个list的hash值Integer num = 0； 0的hashcode还是0 从第二个例子中明显的看出一个问题，为什么list_2，添加了一个元素，而list_3什么没做，但是反而list_3却和list_1不等了呢？ 直接看subList方法的源码： 1234public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; subListRangeCheck(fromIndex, toIndex, size); return new SubList(this, 0, fromIndex, toIndex); &#125; subListRangeCheck方式是判断fromIndex、toIndex是否合法，如果合法就直接返回一个subList对象，注意在产生该new该对象的时候传递了一个参数 this ，该参数非常重要，因为他代表着原始list。 1234567891011121314151617181920212223/*** 继承AbstractList类，实现RandomAccess接口*/private class SubList extends AbstractList&lt;E&gt; implements RandomAccess &#123; private final AbstractList&lt;E&gt; parent; //列表 private final int parentOffset; private final int offset; int size; //构造函数 SubList(AbstractList&lt;E&gt; parent, int offset, int fromIndex, int toIndex) &#123; this.parent = parent; this.parentOffset = fromIndex; this.offset = offset + fromIndex; this.size = toIndex - fromIndex; this.modCount = ArrayList.this.modCount; &#125; ····· ····· ·····&#125; 该SubLsit是ArrayList的内部类，它与ArrayList一样，都是继承AbstractList和实现RandomAccess接口。同时也提供了get、set、add、remove等list常用的方法。但是它的构造函数有点特殊，在该构造函数中有两个地方需要注意： 1、this.parent = parent;而parent就是在前面传递过来的list，也就是说this.parent就是原始list的引用。 2、this.offset = offset + fromIndex;this.parentOffset = fromIndex;。同时在构造函数中它甚至将modCount（fail-fast机制）传递过来了。 诚然，到了这里我们可以判断subList返回的SubList同样也是AbstractList的子类，同时它的方法如get、set、add、remove等都是在原列表上面做操作，它并没有像subString一样生成一个新的对象。所以subList返回的只是原列表的一个视图，它所有的操作最终都会作用在原列表上。 subList生成子列表后，不要做改变原列表长度的操作subList生成子列表后，不要做改变原列表长度的操作（直接生成的List）这个和asList很像，一旦直接生成了List，就不能做改变直接生成的List列表长度的操作 123456789101112131415161718192021public class AsListTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;9,0,1,0,3,5,1,7,2,7&#125;; List&lt;Integer&gt; list_1 = new ArrayList&lt;Integer&gt;(Arrays.asList(array)); List&lt;Integer&gt; list_2 = list_1.subList(0, list_1.size()); list_1.add(0); System.out.println(list_1.size()); System.out.println(list_2.size()); &#125;&#125;Output: 11 Exception in thread "main" java.util.ConcurrentModificationException at java.util.ArrayList$SubList.checkForComodification(ArrayList.java:1231) at java.util.ArrayList$SubList.size(ArrayList.java:1040) at jse_7.AsListTest.main(AsListTest.java:18) 分析：list_1正常输出，但是list_3就抛出ConcurrentModificationException异常，不错就是fail-fast机制，我们接下来会说这个机制。我们再看size方法： 1234public int size() &#123; checkForComodification(); return this.size;&#125; size方法首先会通过checkForComodification验证，然后再返回this.size。 1234private void checkForComodification() &#123; if (ArrayList.this.modCount != this.modCount) throw new ConcurrentModificationException(); &#125; 该方法表明当原列表的modCount与this.modCount不相等时就会抛出ConcurrentModificationException。同时我们知道modCount 在new的过程中 “继承”了原列表modCount，只有在修改该列表（子列表）时才会修改该值（先表现在原列表后作用于子列表）。而在该实例中我们是操作原列表，原列表的modCount当然不会反应在子列表的modCount上啦，所以才会抛出该异常。 对于子列表视图，它是动态生成的，生成之后就不要操作原列表了，否则必然都导致视图的不稳定而抛出异常。最好的办法就是将原列表设置为只读状态，要操作就操作子列表： 12345//通过subList生成一个与list1一样的列表 list3List&lt;Integer&gt; list3 = list1.subList(0, list1.size()); //对list1设置为只读状态list1 = Collections.unmodifiableList(list1); subList到真正的List和asList的机制一样，都是重新利用ArrayList的Collection的构造器！！！ 123456789101112131415161718public class AsListTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;9,0,1,0,3,5,1,7,2,7&#125;; List&lt;Integer&gt; list_1 = new ArrayList&lt;Integer&gt;(Arrays.asList(array)); List&lt;Integer&gt; list_2 = new ArrayList&lt;Integer&gt;(list_1.subList(0, list_1.size())); list_1.add(0); System.out.println(list_1.size()); System.out.println(list_2.size()); &#125;&#125;Output: 11 10 推荐使用subList处理局部列表在开发过程中我们一定会遇到这样一个问题：获取一堆数据后，需要删除某段数据。例如，有一个列表存在1000条记录，我们需要删除100-200位置处的数据，可能我们会这样处理： 123456789for(int i = 0 ; i &lt; list1.size() ; i++)&#123; if(i &gt;= 100 &amp;&amp; i &lt;= 200)&#123; list1.remove(i); /* * 当然这段代码存在问题，list remove之后后面的元素会填充上来， * 所以需要对i进行简单的处理，当然这个不是这里讨论的问题。 */ &#125;&#125; 这个应该是我们大部分人的处理方式吧，其实还有更好的方法，利用subList。在前面LZ已经讲过，子列表的操作都会反映在原列表上。所以下面一行代码全部搞定： list1.subList(100, 200).clear(); fast-fail在JDK的Collection中我们时常会看到类似于这样的话： 例如，ArrayList： 注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会 尽最大努力抛出 ConcurrentModificationException。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序 是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。 例如，HashMap： 注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大 努力抛出 ConcurrentModificationException。因此，编写依赖于此异常的程序的做法是错误的，正确做法是： 迭代器的快速失败行为应该仅用于检测程序错误。 在这两段话中反复地提到”快速失败”。那么何为”快速失败”机制呢？ “快速失败”也就是fail-fast，它是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。 fast-fail123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class FailFastTest &#123; private static List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); /** * @desc:线程one迭代list * @Project:test * @file:FailFastTest.java * @Authro:AbelChao * @data:2017年10月17日 */ private static class threadOne extends Thread&#123; public void run() &#123; Iterator&lt;Integer&gt; iterator = list.iterator(); while(iterator.hasNext())&#123; int i = iterator.next(); System.out.println("ThreadOne 遍历:" + i); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * @desc:当i == 3时，修改list * @Project:test * @file:FailFastTest.java * @Authro:AbelChao * @data:2017年10月17日 */ private static class threadTwo extends Thread&#123; public void run()&#123; int i = 0 ; while(i &lt; 6)&#123; System.out.println("ThreadTwo run：" + i); if(i == 3)&#123; list.remove(i); &#125; i++; &#125; &#125; &#125; public static void main(String[] args) &#123; for(int i = 0 ; i &lt; 10;i++)&#123; list.add(i); &#125; new threadOne().start(); new threadTwo().start(); &#125;&#125;Output: ThreadOne 遍历:0 ThreadTwo run：0 ThreadTwo run：1 ThreadTwo run：2 ThreadTwo run：3 ThreadTwo run：4 ThreadTwo run：5 Exception in thread "Thread-0" java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(Unknown Source) at java.util.ArrayList$Itr.next(Unknown Source) at test.ArrayListTest$threadOne.run(ArrayListTest.java:23) fail-fast产生原因通过上面的示例和讲解，我初步知道fail-fast产生的原因就在于程序在对 collection 进行迭代时，某个线程对该 collection 在结构上对其做了修改，这时迭代器就会抛出 ConcurrentModificationException 异常信息，从而产生 fail-fast。 要了解fail-fast机制，我们首先要对ConcurrentModificationException 异常有所了解。当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。同时需要注意的是，该异常不会始终指出对象已经由不同线程并发修改，如果单线程违反了规则，同样也有可能会抛出改异常。 诚然，迭代器的快速失败行为无法得到保证，它不能保证一定会出现该错误，但是快速失败操作会尽最大努力抛出ConcurrentModificationException异常，所以因此，为提高此类操作的正确性而编写一个依赖于此异常的程序是错误的做法，正确做法是：ConcurrentModificationException 应该仅用于检测 bug。下面我将以ArrayList为例进一步分析fail-fast产生的原因。 从前面我们知道fail-fast是在操作迭代器时产生的。现在我们来看看ArrayList中迭代器的源代码： 123456789101112131415161718192021222324252627private class Itr implements Iterator&lt;E&gt; &#123; int cursor; int lastRet = -1; int expectedModCount = ArrayList.this.modCount; public boolean hasNext() &#123; return (this.cursor != ArrayList.this.size); &#125; public E next() &#123; checkForComodification(); /** 省略此处代码 */ &#125; public void remove() &#123; if (this.lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); /** 省略此处代码 */ &#125; final void checkForComodification() &#123; if (ArrayList.this.modCount == this.expectedModCount) return; throw new ConcurrentModificationException(); &#125; &#125; 从上面的源代码我们可以看出，迭代器在调用next()、remove()方法时都是调用checkForComodification()方法，该方法主要就是检测modCount == expectedModCount ? 若不等则抛出ConcurrentModificationException 异常，从而产生fail-fast机制。所以要弄清楚为什么会产生fail-fast机制我们就必须要用弄明白为什么modCount != expectedModCount ，他们的值在什么时候发生改变的。 expectedModCount 是在Itr中定义的：int expectedModCount = ArrayList.this.modCount;所以他的值是不可能会修改的，所以会变的就是modCount。modCount是在 AbstractList 中定义的，为全局变量： protected transient int modCount = 0; 那么他什么时候因为什么原因而发生改变呢？请看ArrayList的源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public boolean add(E paramE) &#123; ensureCapacityInternal(this.size + 1); /** 省略此处代码 */ &#125; private void ensureCapacityInternal(int paramInt) &#123; if (this.elementData == EMPTY_ELEMENTDATA) paramInt = Math.max(10, paramInt); ensureExplicitCapacity(paramInt); &#125; private void ensureExplicitCapacity(int paramInt) &#123; this.modCount += 1; //修改modCount /** 省略此处代码 */ &#125; public boolean remove(Object paramObject) &#123; int i; if (paramObject == null) for (i = 0; i &lt; this.size; ++i) &#123; if (this.elementData[i] != null) continue; fastRemove(i); return true; &#125; else for (i = 0; i &lt; this.size; ++i) &#123; if (!(paramObject.equals(this.elementData[i]))) continue; fastRemove(i); return true; &#125; return false; &#125; private void fastRemove(int paramInt) &#123; this.modCount += 1; //修改modCount /** 省略此处代码 */ &#125; public void clear() &#123; this.modCount += 1; //修改modCount /** 省略此处代码 */ &#125; 从上面的源代码我们可以看出，ArrayList中无论add、remove、clear方法只要是涉及了改变ArrayList元素的个数的方法都会导致modCount的改变。 所以我们这里可以初步判断由于expectedModCount 得值与modCount的改变不同步 ，导致两者之间不等从而产生fail-fast机制。知道产生fail-fast产生的根本原因了，我们可以有如下场景： 有两个线程（线程A，线程B），其中线程A负责遍历list、线程B修改list。线程A在遍历list过程的某个时候（此时expectedModCount = modCount=N），线程启动，同时线程B增加一个元素，这是modCount的值发生改变（modCount + 1 = N + 1）。线程A继续遍历执行next方法时，通告checkForComodification方法发现expectedModCount = N ，而modCount = N + 1，两者不等，这时就抛出ConcurrentModificationException 异常，从而产生fail-fast机制。 所以，直到这里我们已经完全了解了fail-fast产生的根本原因了。知道了原因就好找解决办法了。 fail-fast解决办法通过前面的实例、源码分析，我想各位已经基本了解了fail-fast的机制，下面我就产生的原因提出解决方案。这里有两种解决方案： 方案一：在遍历过程中所有涉及到改变modCount值得地方全部加上synchronized或者直接使用Collections.synchronizedList，这样就可以解决。但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。 方案二：使用CopyOnWriteArrayList来替换ArrayList。推荐使用该方案。 CopyOnWriteArrayList为何物？ArrayList 的一个线程安全的变体，其中所有可变操作（add、set 等等）都是通过对底层数组进行一次新的复制来实现的。该类产生的开销比较大，但是在两种情况下，它非常适合使用。1：在不能或不想进行同步遍历，但又需要从并发线程中排除冲突时。2：当遍历操作的数量大大超过可变操作的数量时。 遇到这两种情况使用CopyOnWriteArrayList来替代ArrayList再适合不过了。那么为什么CopyOnWriterArrayList可以替代ArrayList呢？ 第一、CopyOnWriterArrayList的无论是从数据结构、定义都和ArrayList一样。它和ArrayList一样，同样是实现List接口，底层使用数组实现。在方法上也包含add、remove、clear、iterator等方法。 第二、CopyOnWriterArrayList根本就不会产生ConcurrentModificationException异常，也就是它使用迭代器完全不会产生fail-fast机制。请看： 12345678910private static class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123; /** 省略此处代码 */ public E next() &#123; if (!(hasNext())) throw new NoSuchElementException(); return this.snapshot[(this.cursor++)]; &#125; /** 省略此处代码 */ &#125; CopyOnWriterArrayList的方法根本就没有像ArrayList中使用checkForComodification方法来判断expectedModCount 与 modCount 是否相等。它为什么会这么做，凭什么可以这么做呢？我们以add方法为例： 1234567891011121314151617181920public boolean add(E paramE) &#123; ReentrantLock localReentrantLock = this.lock; localReentrantLock.lock(); try &#123; Object[] arrayOfObject1 = getArray(); int i = arrayOfObject1.length; Object[] arrayOfObject2 = Arrays.copyOf(arrayOfObject1, i + 1); arrayOfObject2[i] = paramE; setArray(arrayOfObject2); int j = 1; return j; &#125; finally &#123; localReentrantLock.unlock(); &#125; &#125; final void setArray(Object[] paramArrayOfObject) &#123; this.array = paramArrayOfObject; &#125; CopyOnWriterArrayList的add方法与ArrayList的add方法有一个最大的不同点就在于，下面三句代码： 123Object[] arrayOfObject2 = Arrays.copyOf(arrayOfObject1, i + 1);arrayOfObject2[i] = paramE;setArray(arrayOfObject2); 就是这三句代码使得CopyOnWriterArrayList不会抛ConcurrentModificationException异常。他们所展现的魅力就在于copy原来的array，再在copy数组上进行add操作，这样做就完全不会影响COWIterator中的array了。 所以CopyOnWriterArrayList所代表的核心概念就是：任何对array在结构上有所改变的操作（add、remove、clear等），CopyOnWriterArrayList都会copy现有的数据，再在copy的数据上修改，这样就不会影响COWIterator中的数据了，修改完成之后改变原有数据的引用即可。同时这样造成的代价就是产生大量的对象，同时数组的copy也是相当有损耗的。 保持compareTo和equals同步排序的东西，暂时还没有看到，先贴个参考： http://cmsblogs.com/?p=1242]]></content>
      <categories>
        <category>Java_Base</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础（二十）]]></title>
    <url>%2F2017%2F10%2F17%2FJavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Map接口的一点总结 Map接口Map： “键值”对映射的抽象接口。该映射不包括重复的键，一个键对应一个值。 SortedMap： 有序的键值对接口，继承Map接口。 NavigableMap： 继承SortedMap，具有了针对给定搜索目标返回最接近匹配项的导航方法的接口。 AbstractMap： 实现了Map中的绝大部分函数接口。它减少了“Map的实现类”的重复编码。 Dictionary： 任何可将键映射到相应值的类的抽象父类。目前被Map接口取代。 WeakHashMap： 基于“拉链法”实现的散列表。 TreeMap： 有序散列表，实现SortedMap 接口，底层通过红黑树实现。 HashTable： 基于“拉链法”实现的散列表。 HashMap： 是基于“拉链法”实现的散列表。底层采用“数组+链表”实现。在JDK8以后，加入了红黑树，当链表数量超过8时使用红黑树。 123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; Map接口的常用实现 HashMap &amp; Hashtable HashMap &amp; WeakHashMap因为并没有怎么了解过WeakHashMap，而且用的也不多，这里就不看了。 HashMap &amp; Hashtable — 又说底层实现”拉链法”Hash ，一般翻译做“ 散列” ，也有直接音译为“ 哈希” 的，就是把任意长度的输入（又叫做预映射， pre-image ），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不 同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 HASH 主要用于信息安全领域中加密算法，它把一些不同长度的信息转化成杂乱的128 位的编码, 这些编码值叫做HASH 值. 也可以说，hash 就是找到一种数据内容和数据存放地址之间的映射关系. 数组的特点是：寻址容易，插入和删除困难；而链表的特点是：寻址困难，插入和删除容易。那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易 的数据结构？答案是肯定的，这就是我们要提起的哈希表，哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法—— 拉链法，我们可以理解为“ 链表 的数组” ，如图： 1.首先HashMap里面实现一个静态内部类Entry 其重要的属性有 key , value, next,从属性key,value我们就能很明显的看出来Entry就是HashMap键值对实现的一个基础bean,我们上面说到HashMap的基 础就是一个线性数组,这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面。 2.既然是线性数组，为什么能随机存取？这里HashMap用了一个小算法，大致是这样实现： 123456789101112131415存储时: int hash = key.hashCode();--&gt; 这个hashCode方法这里不详述,只要理解每个key的hash是一个固定的int值 int index = hash % Entry[].length; Entry[index] = value; 取值时: int hash = key.hashCode(); int index = hash % Entry[].length; return Entry[index] 到这里我们轻松的理解了HashMap通过键值对实现存取的基本原理 3.疑问：如果两个key通过hash % Entry[].length得到的index相同，会不会有覆盖的危险？ 这里HashMap里面用到链式数据结构的一个概念.上面我们提到过Entry类里面有一个next属性,作用是指向下一个Entry。打个比方, 第一个键值对A进来,通过计算其key的hash得到的index=0，记做:Entry[0] = A.一会后又进来一个键值对B,通过计算其index也等于0,现在怎么办？HashMap会这样做:B.next = A,Entry[0] = B,如果又进来C,index也等于0,那么C.next = B,Entry[0] = C；这样我们发现index=0的地方其实存取了A,B,C三个键值对,他们通过next这个属性链接在一起。所以疑问不用担心。到这里为止，HashMap的大致实现，我们应该已经清楚了。当然HashMap里面也包含一些优化方面的实现，这里也啰嗦一下。 比如：Entry[]的长度一定后，随着map里面数据的越来越长，这样同一个index的链就会很长，会不会影响性能？HashMap里面设置一个因素（也称为加载因子），随着map的size越来越大，Entry[]会以一定的规则加长长度。 解决hash冲突的办法 1）开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列） 2）再哈希法 3）链地址法 4）建立一 公共溢出区 java 中hashmap的解决办法就是采用的链地址法 当我们往hashmap中put元素的时候，先根据key的hash值得到这个元素在数组中的位置（即下标），然后就可以把这个元素放到对应的位置中了。如果这个元素所在的位子上已经存放有其他元素了，那么在同一个位子上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。从hashmap中get元素时，首先计算key的hashcode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。从这里我们可以想象得到，如果每个位置上的链表只有一个元素，那么hashmap的get效率将是最高的。 HashMap的put原理1、首先判断Key是否为Null，如果为null，直接查找Enrty[0]，如果不是Null，先计算Key的HashCode，然后经过二次计算。得到Hash值，这里的Hash特征值是一个int值。 2、根据Hash值，要找到对应的数组啊，所以对Entry[]的长度length-1求余，得到的就是Entry数组的index。 3、找到对应的数组，就是找到了所在的链表，然后按照链表的操作对Value进行插入、删除和查询操作。 二次计算：1234567891011121314之前：static int hash(int h) &#123; // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125;jdk1.8:hashCode()的高16位异或低16位static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; HashMap中get方法得到元素位置得到Index我们可以看到在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过hashmap的数据结构是数组和链表的结合，所以我们当然希望这个hashmap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 所以我们首先想到的就是把hashcode对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式那？java中时这样做的， 123static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; 首先算得key得hashcode值，然后跟数组的长度-1做一次“与”运算（&amp;）。看上去很简单，其实比较有玄机。比如数组的长度是2的4次方，那么hashcode就会和2的4次方-1做“与”运算。很多人都有这个疑问，为什么hashmap的数组初始化大小都是2的次方大小时，hashmap的效率最高，我以2的4次方举例，来解释一下为什么数组大小为2的幂时hashmap访问的性能最高。 看下图，左边两组是数组长度为16（2的4次方），右边两组是数组长度为15。两组的hashcode均为8和9，但是很明显，当它们和1110“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hashcode的值会与14（1110）进行“与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！ 所以说，当数组长度为2的n次幂的时候，不同的key算得得index相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。说到这里，我们再回头看一下hashmap中默认的数组大小是多少，查看源代码可以得知是16，为什么是16，而不是15，也不是20呢，看到上面annegu的解释之后我们就清楚了吧，显然是因为16是2的整数次幂的原因，在小数据量的情况下16比15和20更能减少key之间的碰撞，而加快查询的效率。 所以，在存储大容量数据的时候，最好预先指定hashmap的size为2的整数次幂次方。就算不指定的话，也会以大于且最接近指定值大小的2次幂来初始化的，代码如下(HashMap的构造方法中)： 1234// Find a power of 2 &gt;= initialCapacity int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; resize 当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。 那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过160.75=12的时候，就把数组的大小扩展为216=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.751000 &lt; 1000, 也就是说为了让0.75 * size &gt; 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&amp;的问题，也避免了resize的问题。]]></content>
      <categories>
        <category>Java_Base</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础（十九）]]></title>
    <url>%2F2017%2F10%2F16%2FJavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[List接口的一点总结 List接口的总结这里我们之前说了ArrayList、LinkedList、Vector、Stack（Vector的子类），这里我们对List接口做一个总结。 List接口，直接继承了Collection接口，是有序的Collection。该接口可以对列表中的每一个元素的插入位置进行精确的控制，同时用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。 List接口框架图 红色框为接口，黑色为类。虚线为实现关系，实现为继承，绿色虚线代表依赖Collection： Collection 层次结构 中的根接口。它表示一组对象，这些对象也称为 collection 的元素。对于Collection而言，它不提供任何直接的实现，所有的实现全部由它的子类负责。 AbstractCollection： 提供 Collection 接口的骨干实现，以最大限度地减少了实现此接口所需的工作。对于我们而言要实现一个不可修改的 collection，只需扩展此类，并提供 iterator 和 size 方法的实现。但要实现可修改的 collection，就必须另外重写此类的 add 方法（否则，会抛出 UnsupportedOperationException），iterator 方法返回的迭代器还必须另外实现其 remove 方法。 Iterator： 迭代器。 ListIterator： 系列表迭代器，允许程序员按任一方向遍历列表、迭代期间修改列表，并获得迭代器在列表中的当前位置。 List： 继承于Collection的接口。它代表着有序的队列。 AbstractList： List 接口的骨干实现，以最大限度地减少实现“随机访问”数据存储（如数组）支持的该接口所需的工作。 Queue： 队列。提供队列基本的插入、获取、检查操作。 Deque： 一个线性 collection，支持在两端插入和移除元素。大多数 Deque 实现对于它们能够包含的元素数没有固定限制，但此接口既支持有容量限制的双端队列，也支持没有固定大小限制的双端队列。 AbstractSequentialList： 提供了 List 接口的骨干实现，从而最大限度地减少了实现受“连续访问”数据存储（如链接列表）支持的此接口所需的工作。从某种意义上说，此类与在列表的列表迭代器上实现“随机访问”方法。 LinkedList： List 接口的链接列表实现。它实现所有可选的列表操作。 ArrayList： List 接口的大小可变数组的实现。它实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。 Vector： 实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。 Stack： 后进先出（LIFO）的对象堆栈。它通过五个操作对类 Vector 进行了扩展 ，允许将向量视为堆栈。 Enumeration： 枚举，实现了该接口的对象，它生成一系列元素，一次生成一个。连续调用 nextElement 方法将返回一系列的连续元素。 ArrayList和LinkedList ArrayList和Vector]]></content>
      <categories>
        <category>Java_Base</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础（十八））]]></title>
    <url>%2F2017%2F10%2F16%2FJavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节我们聊的是Iterator和Iterable的东西 Iterator和Iterable Iterable 从上面这个图可以看出来，Iterable是属于java.lang包下的接顶级，而我们Iterator却是java.util包下的接口 1234567891011121314public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator(); default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125; &#125; default Spliterator&lt;T&gt; spliterator() &#123; return Spliterators.spliteratorUnknownSize(iterator(), 0); &#125;&#125; Iterable中封装了Iterator接口，只要实现了Iterable接口的类可以拥有增强的for循环，即只要实现了Iterable接口的类，就可以使用Iterator迭代器了。 集合Collection、List、Set都是Iterable的实现类，所以他们及其他们的子类都可以使用foreach进行迭代。 Iterator1234567891011121314public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); default void remove() &#123; throw new UnsupportedOperationException("remove"); &#125; default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (hasNext()) action.accept(next()); &#125;&#125; 对于我们的Collection、List、Set为什么会直接去实现Iterable而不是Iterator？ Iterator接口中的核心方法next()，hasNext()，remove()，都是依赖当前位置。如果这些集合直接实现Iterator接口，则势必导致集合对象中包含当前迭代位置的数据(指针)。当集合在不同方法间进行传递的时候，由于当前迭代位置不可知，所以next()的结果也不可知。除非再为Iterator接口添加一个reset()方法，用来重置当前迭代位置。 而当实现Iterable则不然，每次调用都返回一个从头开始的迭代器，各个迭代器之间互不影响。 记住了，我们的HashMap和Hashtable如果用foreach，其实就是两种： entrySet()：得到的是一个Entry[K,V]的Set集合，而Set集合是实现了Iterable接口的，所以我们可以用foreach keySet():得到的是一个K类型的Set集合，同理，也是可以使用foreach 测 试ArrayList/LinkedList 123456789101112131415161718192021222324252627public class IteratorTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;3,7,1,0,2,3,6,4,9,8&#125;; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(Arrays.asList(array)); Iterator&lt;Integer&gt; it = arrayList.iterator(); System.out.print("Iterator: "); while(it.hasNext())&#123; System.out.print(it.next()+","); &#125; System.out.println(); System.out.print("foreach: "); for (Integer num : arrayList) &#123; System.out.print(num+","); &#125; &#125;&#125;/**Output: Iterator: 3,7,1,0,2,3,6,4,9,8, foreach: 3,7,1,0,2,3,6,4,9,8,*/ HashSet12345678910111213141516171819202122232425262728293031public class IteratorTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;3,7,1,0,2,3,6,4,9,8&#125;; HashSet&lt;Integer&gt; hashSet = new HashSet&lt;Integer&gt;(Arrays.asList(array)); Iterator&lt;Integer&gt; it = hashSet.iterator(); System.out.print("Iterator: "); while(it.hasNext())&#123; System.out.print(it.next()+","); &#125; System.out.println(); System.out.print("foreach: "); for (Integer num : hashSet) &#123; System.out.print(num+","); &#125; &#125;&#125;/**Output: Iterator: 0,1,2,3,4,6,7,8,9, foreach: 0,1,2,3,4,6,7,8,9,分析： 正好是有序的，也就是在hash表中是这么存的*/ HashMap/Hashtable 12345678910111213141516171819202122232425262728public class IteratorTest &#123; public static void main(String[] args) &#123; HashMap&lt;Integer,String&gt; hashMap = new HashMap&lt;Integer,String&gt;(); hashMap.put(17, "session"); hashMap.put(1, "blemon"); hashMap.put(20, "water"); hashMap.put(18, "application"); Iterator&lt;Entry&lt;Integer,String&gt;&gt; it = hashMap.entrySet().iterator(); System.out.print("Iterator: "); while(it.hasNext())&#123; System.out.print(it.next()+","); &#125; System.out.println(); System.out.print("foreach: "); for (Entry&lt;Integer,String&gt; entry : hashMap.entrySet()) &#123; System.out.print(entry+","); &#125; &#125;&#125;/**Output: Iterator: 17=session,1=blemon,18=application,20=water, foreach: 17=session,1=blemon,18=application,20=water,*/]]></content>
      <categories>
        <category>Java_Base</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础（十七）]]></title>
    <url>%2F2017%2F10%2F16%2FJavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这部分我们去说Vector，也就是”线程安全的ArrayList” Vector 我们之前复习过我们ArrayList和LinkedList，在List接口中还有一个常用的类，就是Vector，之间我们也说过，这个Vector某种程度上就是可以看成是一个线程安全的ArrayList！！！ 同时我们要了解一件事是：Stack类是直接继承我们的Vector类的。因为用的不多，暂时先不介绍这个类。 Vector简介Vector可以实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。不过，Vector的大小是可以增加或者减小的，以便适应创建Vector后进行添加或者删除操作。 Vector实现List接口，继承AbstractList类，所以我们可以将其看做队列，支持相关的添加、删除、修改、遍历等功能。 Vector实现RandmoAccess接口，即提供了随机访问功能，提供提供快速访问功能。在Vector我们可以直接访问元素。 Vector 实现了Cloneable接口，支持clone()方法，可以被克隆。 123public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable Vector成员变量和构造方法123protected Object[] elementData;//就是和ArrayList的一样，transient Object[] elementData;protected int elementCount;protected int capacityIncrement; elementData ：”Object[]类型的数组”，它保存了Vector中的元素。按照Vector的设计elementData为一个动态数组，可以随着元素的增加而动态的增长，其具体的增加方式后面提到（ensureCapacity方法）。如果在初始化Vector时没有指定容器大小，则使用默认大小为10. elementCount：Vector 对象中的有效组件数。 capacityIncrement：向量的大小大于其容量时，容量自动增加的量。如果在创建Vector时，指定了capacityIncrement的大小；则，每次当Vector中动态数组容量增加时&gt;，增加的大小都是capacityIncrement。如果容量的增量小于等于零，则每次需要增大容量时，向量的容量将增大一倍。 12345678910111213141516171819202122232425262728293031323334353637/** * 构造一个空向量，使其内部数据数组的大小为 10，其标准容量增量为零。 */ public Vector() &#123; this(10); &#125;/** * 构造一个包含指定 collection 中的元素的向量，这些元素按其 collection 的迭代器返回元素的顺序排列。 */public Vector(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); elementCount = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, elementCount, Object[].class);&#125;/** * 使用指定的初始容量和等于零的容量增量构造一个空向量。 */public Vector(int initialCapacity) &#123; this(initialCapacity, 0);&#125;/** * 使用指定的初始容量和容量增量构造一个空的向量。 */public Vector(int initialCapacity, int capacityIncrement) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); this.elementData = new Object[initialCapacity]; this.capacityIncrement = capacityIncrement;&#125; Vector源码—增、删、改、查增 这里就看两个，一个是末尾添加，另一个是指定位置添加 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; &#125; public void add(int index, E element) &#123; insertElementAt(element, index); &#125;/**分析: 具体过程就是先确认容器的大小，看是否需要进行扩容操作，然后讲E元素添加到此向量的末尾。*/扩充操作private void ensureCapacityHelper(int minCapacity) &#123; //如果最小容积量大于数据长度 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;/** * 进行扩容操作 * 如果此向量的当前容量小于minCapacity，则通过将其内部数组替换为一个较大的数组俩增加其容量。 * 新数据数组的大小姜维原来的大小 + capacityIncrement， * 除非 capacityIncrement 的值小于等于零，在后一种情况下，新的容量将为原来容量的两倍，不过，如果此大小仍然小于 minCapacity，则新容量将为 minCapacity。 */private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; //当前容器大小 /* * 新容器大小 * 若容量增量系数(capacityIncrement) &gt; 0，则将容器大小增加到capacityIncrement * 否则将容量增加一倍 */ int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);&#125;/** * 判断是否超出最大范围 * MAX_ARRAY_SIZE：private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; */private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 对于Vector整个的扩容过程，就是根据capacityIncrement确认扩容大小的，若capacityIncrement &lt;= 0 则扩大一倍，否则扩大至capacityIncrement 。当然这个容量的最大范围为Integer.MAX_VALUE即，2^32 - 1，所以Vector并不是可以无限扩充的。 1234567891011121314151617public class VectorTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;9,2,1,48,5,7&#125;; Vector&lt;Integer&gt; vector = new Vector&lt;Integer&gt;(Arrays.asList(array)); vector.add(0); vector.add(0, 0); System.out.println(vector.toString()); &#125;&#125;/**Output: [0, 9, 2, 1, 48, 5, 7, 0]*/ 删 删除对象，按照指定角标删除，清空Vector 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public boolean remove(Object o) &#123; return removeElement(o);&#125;public synchronized boolean removeElement(Object obj) &#123; modCount++; int i = indexOf(obj); if (i &gt;= 0) &#123; removeElementAt(i); return true; &#125; return false;&#125;public synchronized E remove(int index) &#123; modCount++; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); int numMoved = elementCount - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--elementCount] = null; // Let gc do its work return oldValue;&#125;public synchronized void removeElementAt(int index) &#123; modCount++; //修改次数+1 if (index &gt;= elementCount) &#123; //删除位置大于容器有效大小 throw new ArrayIndexOutOfBoundsException(index + " &gt;= " + elementCount); &#125; else if (index &lt; 0) &#123; //位置小于 &lt; 0 throw new ArrayIndexOutOfBoundsException(index); &#125; int j = elementCount - index - 1; if (j &gt; 0) &#123; //从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。 //也就是数组元素从j位置往前移 System.arraycopy(elementData, index + 1, elementData, index, j); &#125; elementCount--; //容器中有效组件个数 - 1 elementData[elementCount] = null; //将向量的末尾位置设置为null&#125;public void clear() &#123; removeAllElements();&#125;public synchronized void removeAllElements() &#123; modCount++; // Let gc do its work for (int i = 0; i &lt; elementCount; i++) elementData[i] = null; elementCount = 0;&#125; 注意：我们一直强调，Vector就是线程安全的ArrayList，就连remove方法，也是一样的必须从后往前删！！！ 1234567891011121314151617181920212223242526272829303132333435363738public class VectorTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;9,2,1,48,5,7&#125;; Vector&lt;Integer&gt; vector = new Vector&lt;Integer&gt;(Arrays.asList(array)); for (int i = 0; i &lt; vector.size(); i++) &#123; vector.remove(i); &#125; System.out.println(vector.toString()); &#125;&#125;/**Output: [2, 48, 7]*/public class VectorTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;9,2,1,48,5,7&#125;; Vector&lt;Integer&gt; vector = new Vector&lt;Integer&gt;(Arrays.asList(array)); for (int i = vector.size()-1; i &gt;=0; i--) &#123; vector.remove(i); &#125; //vector.clear(); System.out.println(vector.toString()); &#125;&#125;/**Output: []*/ 改 这个其实就是一个set方法 12345678public synchronized E set(int index, E element) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 查 indexOf(Objcet o);indexOf(Object o,int index);get(int index); 12345678910111213141516public class VectorTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;9,2,1,48,5,7&#125;; Vector&lt;Integer&gt; vector = new Vector&lt;Integer&gt;(Arrays.asList(array)); int index = vector.get(1);//vector.indexOf(9,1); System.out.println("index: "+index); &#125;&#125;分析： indexOf(Object o)：查询对象第一次出现的角标 indexOf(Object o,int index)：从指定角标开始查对象出现的角标（包括我们指定的那个位置） get(Object o)：返回的是我们对象所在的角标（第一次出现）]]></content>
      <categories>
        <category>Java_Base</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础（十六）]]></title>
    <url>%2F2017%2F10%2F16%2FJavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这部分讲的是TreeMap和TreeSet TreeMap和TreeSet这部分的东西看过一点，但是发现因为TreeMap底层是利用红黑二叉树来实现的，但是数据结构中树的部分我还没有看到，所以这里先不说这个。 一个是看不懂，另一个是感觉这两个集合并不常用。]]></content>
      <categories>
        <category>Java_Base</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础（十五）]]></title>
    <url>%2F2017%2F10%2F16%2FJavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节讲的是我们的hashCode和equals什么时候需要复写，以及在HashMap、HashSet、Hashtable中的应用 HashMap、HashSet、Hashtable中HashCode()和equals()HashCode的定义 HashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，HashCode是用来在散列存储结构中确定对象的存储地址的； 如果两个对象相同， equals方法一定返回true，并且这两个对象的HashCode一定相同； 如果对象的equals方法被重写，那么对象的HashCode也尽量重写，并且产生HashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点； 两个对象的HashCode相同，并不一定表示两个对象就相同，也就是equals方法不一定返回true，只能够说明这两个对象在散列存储结构中，如Hashtable，他们存放在同一个篮子里。 HashCode的作用Java中的集合（Collection）有两类，一类是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。 equals方法可用于保证元素不重复，但是，如果每增加一个元素就检查一次，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，就要调用1000次equals方法。这显然会大大降低效率。于是，Java采用了哈希表的原理。 这可能也就是那几个类为什么叫Hash*的原因。 hashCode扮演的角色就可以说是寻域（寻找某个对象在集合中区域位置）** 哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。这样一来，当集合要添加新的元素时，先调用这个元素的HashCode方法，就一下子能定位到它应该放置的物理位置上。 如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了； 如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了； 不相同的话，也就是发生了Hash key相同导致冲突的情况，那么就在这个Hash key的地方产生一个链表，将所有产生相同HashCode的对象放到这个单链表上去，串在一起（很少出现）。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。 从Object角度看，JVM每new一个Object，它都会将这个Object丢到一个Hash表中去，这样的话，下次做Object的比较或者取这个对象的时候（读取过程），它会根据对象的HashCode再从Hash表中取这个对象。这样做的目的是提高取对象的效率。若HashCode相同再去调用equal。 HashCode与equalshashcode这个方法是用来鉴定2个对象是否相等的。 那你会说，不是还有equals这个方法吗？ 不错，这2个方法都是用来判断2个对象是否相等的。但是他们是有区别的。 一般来讲，equals这个方法是给用户调用的，如果你想判断2个对象是否相等，你可以重写equals方法，然后在代码中调用，就可以判断他们是否相等 了。简单来讲，equals方法主要是用来判断从表面上看或者从内容上看，2个对象是不是相等。 举个例子，有个学生类，属性只有姓名和性别，那么我们可以 认为只要姓名和性别相等，那么就说这2个对象是相等的。 hashcode方法一般用户不会去调用，比如在hashmap中，由于key是不可以重复的，他在判断key是不是重复的时候就判断了hashcode 这个方法，而且也用到了equals方法。这里不可以重复是说equals和hashcode只要有一个不等就可以了！ 所以简单来讲，hashcode相当于是一个对象的编码，就好像文件中的md5，他和equals不同就在于他返回的是int型的，比较起来不直观。我们一般在覆盖equals的同时也要 覆盖hashcode，让他们的逻辑一致。举个例子，还是刚刚的例子，如果姓名和性别相等就算2个对象相等的话，那么hashcode的方法也要返回姓名 的hashcode值加上性别的hashcode值，这样从逻辑上，他们就一致了。 要从物理上判断2个对象是否相等，用==就可以了。 在Java语言中，equals()和hashCode()两个函数的使用是紧密配合的，你要是自己设计其中一个，就要设计另外一个。在多数情况 下，这两个函数是不用考虑的，直接使用它们的默认设计就可以了。但是在一些情况下，这两个函数最好是自己设计，才能确保整个程序的正常运行。最常见的是当 一个对象被加入收集对象（collection object）时，这两个函数必须自己设计。 更细化的定义是：如果你想将一个对象A放入另一个收集对象B里，或者使用这个对象A为查找一个元对象在收集对 象B里位置的钥匙，并支持是否容纳，删除收集对象B里的元对象这样的操作，那么，equals()和hashCode()函数必须开发者自己定义。其他情 况下，这两个函数是不需要定义的。 对于equals，我们必须遵循如下规则： 1. 对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。 2. 反射性：x.equals(x)必须返回是“true”。 3. 类推性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。 4. 一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。 任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。 对于hashCode，我们应该遵循如下规则： 1. 在一个应用程序执行期间，如果一个对象的equals方法做比较所用到的信息没有被修改的话，则对该对象调用hashCode方法多次，它必须始终如一地返回同一个整数。 2. 如果两个对象根据equals(Object o)方法是相等的，则调用这两个对象中任一对象的hashCode方法必须产生相同的整数结果。 3. 如果两个对象根据equals(Object o)方法是不相等的，则调用这两个对象中任一个对象的hashCode方法，不要求产生不同的整数结果。但如果能不同，则可能提高散列表的性能。 至于两者之间的关联关系，我们只需要记住如下即可： 如果x.equals(y)返回“true”，那么x和y的hashCode()必须相等。 如果x.equals(y)返回“false”，那么x和y的hashCode()有可能相等，也有可能不等。 HashCode、equals实例：HashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的。（1）例如内存中有这样的位置 ： 0 1 2 3 4 5 6 7而我有个类，这个类有个字段叫ID，我要把这个类存放在以上8个位置之一，如果不用HashCode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。但如果用HashCode那就会使效率提高很多。 定义我们的HashCode为ID％8，比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是13，求得的余数是5，那么我们就把该类放在5这个位置。依此类推。 （2）但是如果两个类有相同的HashCode，例如9除以8和17除以8的余数都是1，也就是说，我们先通过 HashCode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 在这个桶里找到我们要的类。 测试一：只改写了HashCode没有改写equals12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758设计类:package jse_6;public class Person &#123; private Integer age; private String name; private Integer sex; private final Integer PRIME = 37; public Person() &#123; super(); &#125; public Person(Integer age, String name, Integer sex) &#123; super(); this.age = age; this.name = name; this.sex = sex; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getSex() &#123; return sex; &#125; public void setSex(Integer sex) &#123; this.sex = sex; &#125; public int hashCode()&#123; System.out.println("调用自定义的hashCode方法"); int hashResult = 1; hashResult = (hashResult + Integer.valueOf(age).hashCode() + Integer.valueOf(sex).hashCode()) * PRIME; hashResult = PRIME * hashResult + ((name == null) ? 0 : name.hashCode()); System.out.println("name:"+name +" hashCode:" + hashResult); return hashResult; &#125; @Override public String toString() &#123; return "Person [age=" + age + ", name=" + name + ", sex=" + sex + "]"; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940测试类：package jse_6;import java.util.HashSet;public class HashCodeTest &#123; public static void main(String[] args) &#123; Person p_1 = new Person(22,"blemon",0); Person p_2 = new Person(22,"blemon",0); HashSet&lt;Person&gt; hashSet = new HashSet&lt;Person&gt;(); System.out.println(p_1.hashCode()==p_2.hashCode()); System.out.println(p_1.equals(p_2)); hashSet.add(p_1); hashSet.add(p_2); System.out.println(hashSet); &#125;&#125;/**Output: 调用自定义的hashCode方法 name:blemon hashCode:-1386421552 调用自定义的hashCode方法 name:blemon hashCode:-1386421552 [Person [age=22, name=blemon, sex=0, PRIME=37], Person [age=22, name=blemon, sex=0, PRIME=37]]分析： 我们往hashSet中放的时候，就会先调用hashCode()，判断当前对象的hashCode()，一旦相同就会调用我们的 equals()，但是我们假设的是一旦三个属性一致，就是相同对象，但是因为equals()，判断后发现对象并不相同 所以，就可以在hashSet中存入了对象，这样其实就是把违背了set中不能存相同对象的设计。因此，我们一旦复写 hashCode()就必须要复写equals()方法*/ 以上这个示例，我们只是重写了HashCode方法，从上面的结果可以看出，虽然两个对象的HashCode相等，但是实际上两个对象并不是相等，因为我们没有重写equals方法，那么就会调用Object默认的equals方法，显示这是两个不同的对象。这里我们将生成的对象放到了HashSet中，而HashSet中只能够存放唯一的对象，也就是相同的（适用于equals方法）的对象只会存放一个，但是这里实际上是两个对象a,b都被放到了HashSet中，这样HashSet就失去了他本身的意义了。 测试二：改写了HashCode和equals 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class HashCodeTest &#123; public static void main(String[] args) &#123; HashSet&lt;Person&gt; hashSet = new HashSet&lt;Person&gt;(); Person p_1 = new Person(22,"blemon",0); Person p_2 = new Person(20,"water",1); Person p_3 = new Person(22,"blemon",0); System.out.println(p_1 == p_3); System.out.println(p_1.hashCode()==p_3.hashCode()); System.out.println(p_1.equals(p_3)); System.out.println("-----------------------分割线--------------------------"); hashSet.add(p_1); hashSet.add(p_2); hashSet.add(p_3); System.out.println(hashSet); &#125;&#125;/**Output: false 调用自定义的hashCode方法 name:blemon hashCode:-1386421552 调用自定义的hashCode方法 name:blemon hashCode:-1386421552 true 调用equals方法........... true -----------------------分割线-------------------------- 调用自定义的hashCode方法 name:blemon hashCode:-1386421552 调用自定义的hashCode方法 name:water hashCode:112933565 调用自定义的hashCode方法 name:blemon hashCode:-1386421552 调用equals方法........... [Person [age=20, name=water, sex=1, PRIME=37], Person [age=22, name=blemon, sex=0, PRIME=37]]分析： 第一个p_1==p_3，调用的是Object的equals()方法，但是后面的都是Person的。 看到只有Person对象的hashCode相同时，才会调用Person中equals方法。*/]]></content>
      <categories>
        <category>Java_Base</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础（十四）]]></title>
    <url>%2F2017%2F10%2F15%2FJavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[新的一周又开始了 这一节聊Hashtable，主要是他的构造函数和HashMap之间的区别与联系。 Map — HashTable 在java中与有两个类都提供了一个多种用途的hashTable机制，他们都可以将可以key和value结合起来构成键值对通过put(key,value)方法保存起来，然后通过get(key)方法获取相对应的value值。一个是前面提到的HashMap，还有一个就是马上要讲解的HashTable。对于HashTable而言，它在很大程度上和HashMap的实现差不多，如果我们对HashMap比较了解的话，对HashTable的认知会提高很大的帮助。他们两者之间只存在几点的不同，这个后面会阐述。 概述123public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable 从中可以看出HashTable继承Dictionary类，实现Map接口。其中Dictionary类是任何可将键映射到相应值的类（如 Hashtable）的抽象父类。每个键和每个值都是一个对象。在任何一个 Dictionary 对象中，每个键至多与一个值相关联。Map是”key-value键值对”接口。 HashTable采用”拉链法”实现哈希表，它定义了几个重要的参数：table、count、threshold、loadFactor、modCount。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * The hash table data. */private transient Entry&lt;?,?&gt;[] table;table:为一个Entry[]数组类型，Entry代表了“拉链”的节点，每一个Entry代表了一个键值对，哈希表的"key-value键值对"都是存储在Entry数组中的。------------------------------------------------------------------------------------------------------/** * The total number of entries in the hash table. */private transient int count;count：HashTable的大小，注意这个大小并不是HashTable的容器大小，而是他所包含Entry键值对的数量。------------------------------------------------------------------------------------------------------/** * The table is rehashed when its size exceeds this threshold. (The * value of this field is (int)(capacity * loadFactor).) * * @serial */private int threshold;threshold：Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值="容量*加载因子"。------------------------------------------------------------------------------------------------------/** * The load factor for the hashtable. * * @serial */private float loadFactor;loadFactor：加载因子。------------------------------------------------------------------------------------------------------/** * The number of times this Hashtable has been structurally modified * Structural modifications are those that change the number of entries in * the Hashtable or otherwise modify its internal structure (e.g., * rehash). This field is used to make iterators on Collection-views of * the Hashtable fail-fast. (See ConcurrentModificationException). */private transient int modCount = 0;modCount：用来实现“fail-fast”机制的（也就是快速失败）。所谓快速失败就是在并发集合中，其进行迭代操作时，若有其他线程对其进行结构性的修改，这时迭代器会立马感知到，并且立即抛出ConcurrentModificationException异常，而不是等到迭代完成之后才告诉你（你已经出错了）。 构造方法Hashtable()：默认构造函数，容量为11，加载因子为0.75。 123public Hashtable() &#123; this(11, 0.75f); &#125; Hashtable(int initialCapacity)：用指定初始容量和默认的加载因子 (0.75) 构造一个新的空哈希表。 123public Hashtable(int initialCapacity) &#123; this(initialCapacity, 0.75f); &#125; public Hashtable(int initialCapacity, float loadFactor)：用指定初始容量和指定加载因子构造一个新的空哈希表。其中initHashSeedAsNeeded方法用于初始化hashSeed参数，其中hashSeed用于计算key的hash值，它与key的hashCode进行按位异或运算。这个hashSeed是一个与实例相关的随机值，主要用于解决hash冲突。 123456789101112131415161718192021public Hashtable(int initialCapacity, float loadFactor) &#123; //验证初始容量 if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); //验证加载因子 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal Load: "+loadFactor); if (initialCapacity==0) initialCapacity = 1; this.loadFactor = loadFactor; //初始化table，获得大小为initialCapacity的table数组 table = new Entry[initialCapacity]; //计算阀值 threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1); //初始化HashSeed值 initHashSeedAsNeeded(initialCapacity);//我在源码中怎么没找到这句话 &#125; 构造一个与给定的 Map 具有相同映射关系的新哈希表。1234public Hashtable(Map&lt;? extends K, ? extends V&gt; t) &#123; this(Math.max(2*t.size(), 11), 0.75f); putAll(t);&#125; put与getPut Put(K key,V value)流程分析： 1. 判断 value 是否为空，为空则抛出异常； 2. 计算 key 的 hash 值，并根据 hash 值获得 key 在 table 数组中的位置 index，如果 table[index] 元素不为空，则进行迭代，如果遇到相同的 key，则直接替换，并返回旧 value； 3. 否则，我们可以将其插入到 table[index] 位置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162源码：public synchronized V put(K key, V value) &#123; // Make sure the value is not null确保value不为null if (value == null) &#123; throw new NullPointerException(); &#125; // Makes sure the key is not already in the hashtable. //确保key不在hashtable中 //首先，通过hash方法计算key的哈希值，并计算得出index值，确定其在table[]中的位置 //其次，迭代index索引位置的链表，如果该位置处的链表存在相同的key，则替换value，返回旧的value Entry tab[] = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; V old = e.value; e.value = value; return old; &#125; &#125; modCount++; if (count &gt;= threshold) &#123; // Rehash the table if the threshold is exceeded //如果超过阀值，就进行rehash操作 rehash(); tab = table; hash = hash(key); index = (hash &amp; 0x7FFFFFFF) % tab.length; &#125; // Creates the new entry. //将值插入，返回的为null Entry&lt;K,V&gt; e = tab[index]; // 创建新的Entry节点，并将新的Entry插入Hashtable的index位置，并设置e为新的Entry的下一个元素 tab[index] = new Entry&lt;&gt;(hash, key, value, e); count++; return null; &#125;测试：public class HashTableTest &#123; public static void main(String[] args) &#123; Hashtable&lt;Integer,String&gt; hashTable = new Hashtable&lt;Integer,String&gt;(); hashTable.put(0, "lemon"); hashTable.put(2,"water"); hashTable.put(3,"spring"); //hashTable.put(0, "reeee"); System.out.println(hashTable.toString()); &#125;&#125;/**Output: &#123;3=spring, 2=water, 0=lemon&#125;*/ 假设我们现在Hashtable的容量为5，已经存在了(5,5)，(13,13)，(16,16)，(17,17)，(21,21)这 5 个键值对，目前他们在Hashtable中的位置如下： 现在，我们插入一个新的键值对，put(16,22)，假设key=16的索引为1.但现在索引1的位置有两个Entry了，所以程序会对链表进行迭代。迭代的过程中，发现其中有一个Entry的key和我们要插入的键值对的key相同，所以现在会做的工作就是将newValue=22替换oldValue=16，然后返回oldValue=16. 在put(33,33)，key=33所在的索引位置为3，并且在该链表中也没有存在某个key=33的节点，所以就将该节点插入该链表的第一个位置. 在这个扩容的操作中有一个问题，那就是rehash操作1234567891011121314151617181920212223242526272829303132333435363738protected void rehash() &#123; int oldCapacity = table.length; //元素 Entry&lt;K,V&gt;[] oldMap = table; //新容量=旧容量 * 2 + 1 int newCapacity = (oldCapacity &lt;&lt; 1) + 1; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) &#123; if (oldCapacity == MAX_ARRAY_SIZE) return; newCapacity = MAX_ARRAY_SIZE; &#125; //新建一个size = newCapacity 的HashTable Entry&lt;K,V&gt;[] newMap = new Entry[]; modCount++; //重新计算阀值 threshold = (int)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1); //重新计算hashSeed boolean rehash = initHashSeedAsNeeded(newCapacity); table = newMap; //将原来的元素拷贝到新的HashTable中 for (int i = oldCapacity ; i-- &gt; 0 ;) &#123; for (Entry&lt;K,V&gt; old = oldMap[i] ; old != null ; ) &#123; Entry&lt;K,V&gt; e = old; old = old.next; if (rehash) &#123; e.hash = hash(e.key); &#125; int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity; e.next = newMap[index]; newMap[index] = e; &#125; &#125; &#125; 在这个rehash()方法中我们可以看到容量扩大两倍+1，同时需要将原来HashTable中的元素一一复制到新的HashTable中，这个过程是比较消耗时间的，同时还需要重新计算hashSeed的，毕竟容量已经变了。这里对阀值啰嗦一下：比如初始值11、加载因子默认0.75，那么这个时候阀值threshold=8，当容器中的元素达到8时，HashTable进行一次扩容操作，容量 = 8 2 + 1 =17，而阀值threshold=170.75 = 13，当容器元素再一次达到阀值时，HashTable还会进行扩容操作，一次类推。 也就是说我们的只要我们的键值对个数到达了8，而不是容量11的时候，就要开始下一次的扩充，这次扩充是先用之前的阈值重新算了容量，再又用容量和加载因子重新计算了阈值。 get(Object k) 相比较于 put 方法，get 方法则简单很多。其过程就是首先通过 hash()方法求得 key 的哈希值，然后根据 hash 值得到 index 索引（上述两步所用的算法与 put 方法都相同）。然后迭代链表，返回匹配的 key 的对应的 value；找不到则返回 null。 1234567891011public synchronized V get(Object key) &#123; Entry tab[] = table; int hash = hash(key); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return e.value; &#125; &#125; return null; &#125; Hashtable的遍历Hashtable可以说是基本上和HashMap的方法实现的差不多，不同的地方也就是一些别的线程安全的问题。 所以我们在遍历Hashtable的时候我们基本上也是用entrySet和keySet方法进行遍历 12345678910111213141516171819202122232425public class HashTableTest &#123; public static void main(String[] args) &#123; Hashtable&lt;Integer,String&gt; hashTable = new Hashtable&lt;Integer,String&gt;(); hashTable.put(0, "lemon"); hashTable.put(2,"water"); hashTable.put(3,"spring"); for (Entry&lt;Integer,String&gt; entry : hashTable.entrySet()) &#123; System.out.print(entry.getKey()+"..."+entry.getValue()+".."); &#125; System.out.println(""); System.out.println("----------"); for(Integer key : hashTable.keySet())&#123; System.out.print(key+".."+hashTable.get(key)+".."); &#125; &#125;&#125;Output: 3...spring..2...water..0...lemon.. ---------- 3..spring..2..water..0..lemon.. HashMap和HashTable的联系与区别 HashTable 基于 Dictionary 类，而 HashMap 是基于 AbstractMap。Dictionary 是任何可将键映射到相应值的类的抽象父类，而 AbstractMap 是基于 Map 接口的实现，它以最大限度地减少实现此接口所需的工作。 key和value是否允许null值其中key和value都是对象，并且不能包含重复key，但可以包含重复的value。Hashtable中，key和value都不允许出现null值。但是如果在Hashtable中有类似put(null,null)的操作，编译同样可以通过，因为key和value都是Object类型，但运行时会抛出NullPointerException异常。HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null hash值不同哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值。Hashtable计算hash值，直接用key的hashCode()，而HashMap重新计算了key的hash值，Hashtable在求hash值对应的位置索引时，用取模运算，而HashMap在求位置索引时，则用与运算，且这里一般先用hash&amp;0x7FFFFFFF后，再对length取模，&amp;0x7FFFFFFF的目的是为了将负的hash值转化为正值，因为hash值有可能为负数，而&amp;0x7FFFFFFF后，只有符号外改变，而后面的位都不变。 内部实现使用的数组初始化和扩容方式不同HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。 线程安全Hashtable 方法是同步，而HashMap则不是。我们可以看一下源码，Hashtable 中的几乎所有的 public 的方法都是 synchronized 的，而有些方法也是在内部通过 synchronized 代码块来实现。所以有人一般都建议如果是涉及到多线程同步时采用 HashTable，没有涉及就采用 HashMap，但是在 Collections 类中存在一个静态方法：synchronizedMap()，该方法创建了一个线程安全的 Map 对象，并把它作为一个封装的对象来返回]]></content>
      <categories>
        <category>Java_Base</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础（十三）]]></title>
    <url>%2F2017%2F10%2F15%2FJavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节聊HashSet，和HashMap的关系是个重点 Set — HashSet概述123public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable HashSet继承AbstractSet类，实现Set、Cloneable、Serializable接口。其中AbstractSet提供 Set 接口的骨干实现，从而最大限度地减少了实现此接口所需的工作。Set接口是一种不包括重复元素的Collection，它维持它自己的内部排序，所以随机访问没有任何意义。 注意：Set接口只是输出的时候不会按照我们存入的顺序输出，但是内部存的时候确是有固定的位置，也就是说：虽然Set中元素没有顺序，但是元素在set中的位置是有由该元素的HashCode决定的，其具体位置其实是固定的。 此外需要说明一点，在set接口中的不重复是由特殊要求的。 举一个例子:对象A和对象B，本来是不同的两个对象，正常情况下它们是能够放入到Set里面的，但是如果对象A和B的都重写了hashcode和equals方法，并且重写后的hashcode和equals方法是相同的话。那么A和B是不能同时放入到Set集合中去的，也就是Set集合中的去重和hashcode与equals方法直接相关。 123456789101112131415161718192021例如：public class Test&#123;public static void main(String[] args) &#123; Set&lt;String&gt; set=new HashSet&lt;String&gt;(); set.add("Hello"); set.add("world"); set.add("Hello"); System.out.println("集合的尺寸为:"+set.size()); System.out.println("集合中的元素为:"+set.toString()); &#125;&#125;/**Output: 集合的尺寸为:2 集合中的元素为:[world, Hello]分析： 由于String类中重写了hashcode和equals方法，所以这里的第二个Hello是加不进去的哦。*/ 构造方法12345//基于HashMap实现，底层使用HashMap保存所有元素private transient HashMap&lt;E,Object&gt; map;//定义一个Object对象作为HashMap的valueprivate static final Object PRESENT = new Object(); 123456789101112131415161718192021222324252627282930313233343536373839/** * 默认构造函数 * 初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。 */public HashSet() &#123; map = new HashMap&lt;&gt;();&#125;/** * 构造一个包含指定 collection 中的元素的新 set。 */public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c);&#125;/** * 构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和指定的加载因子 */public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor);&#125;/** * 构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和默认的加载因子（0.75）。 */public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity);&#125;/** * 在API中我没有看到这个构造函数，今天看源码才发现（原来访问权限为包权限，不对外公开的） * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合。 * dummy 为标识 该构造函数主要作用是对LinkedHashSet起到一个支持作用. * 注意：这个方法，只有在LinkedHashSet中可以用 */HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125; 看到构造之后，就会明白我们的HashSet底层就是我们的HashMap中Key的实现。 Map集合，就是有一对属性值的集合，属性包含key，和value。关键字key是唯一不重复的。Map是一个有序的集合，所以查询起来速度很快。而HashSet就像是把HashMap中value去掉，说白了就是只有一个key的HashMap集合。Set是数学中定义的集合，所以元素无序, 且不能重复添加。 我们都知道在HashMap中的key是不允许重复的，你换个角度看看，那不就是说Set集合吗？ 这里唯一一个需要处理的就是那个Map的value弄成一个固定值即可。 下面说两个一下HashSet使用和理解中容易出现的误区: a.HashSet中存放null值 HashSet中时允许出入null值的，但是在HashSet中仅仅能够存入一个null值哦。 b.HashSet中存储元素的位置是固定的 HashSet中存储的元素的是无序的，这个没什么好说的，但是由于HashSet底层是基于Hash算法实现的，使用了hashcode，所以HashSet中相应的元素的位置是固定的哦。 HashSet中的方法其实我们使用Set集合的次数并不多，主要还是ArrayList、LinkedList、HashMap，但是因为我们的HashSet有去重的效果，那么我们还是说一下它的方法。 12345678910public Iterator&lt;E&gt; iterator() &#123; return map.keySet().iterator(); &#125;/**分析： iterator()方法返回对此 set 中元素进行迭代的迭代器。返回元素的顺序并不是特定的。底层调用HashMap的 keySet返回所有的key，这点反应了HashSet中的所有元素都是保存在HashMap的key中，value则是使用的PRESENT 对象，该对象为static final。*/ 1234567public int size() &#123; return map.size(); &#125;/**分析： size()返回此 set 中的元素的数量（set 的容量）。底层调用HashMap的size方法，返回HashMap容器的大小。*/ 1234567public boolean isEmpty() &#123; return map.isEmpty(); &#125;/**Output: isEmpty()，判断HashSet()集合是否为空，为空返回 true，否则返回false。*/ 12345678910public boolean contains(Object o) &#123; return map.containsKey(o); &#125;/**Output: contains()，判断某个元素是否存在于HashSet()中，存在返回true，否则返回false。更加确切的讲应该是要满足 这种关系才能返回true：(o==null ? e==null : o.equals(e))。底层调用containsKey判断HashMap的key值是否 为空。*/ 12345678910111213public boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125;/** add()如果此 set 中尚未包含指定元素，则添加指定元素。如果此Set没有包含满足 (e==null ? e2==null : e.equals(e2)) 的e2时，则将e2添加到Set中，否则不添加且返回false。由于底层使用 HashMap的put方法将key = e，value=PRESENT构建成key-value键值对，当此e存在于HashMap的key中，则value将 会覆盖原有value，但是key保持不变，所以如果将一个已经存在的e元素添加中HashSet中，新添加的元素是不会 保存到HashMap中，所以这就满足了HashSet中元素不会重复的特性。 说白了，添加的时候不会重复，就是因为HashMap中的Key不能重复*/ 12345678public boolean remove(Object o) &#123; return map.remove(o)==PRESENT; &#125;/**分析： remove如果指定元素存在于此 set 中，则将其移除。底层使用HashMap的remove方法删除指定的Entry。*/ 123456public void clear() &#123; map.clear(); &#125;分析： clear从此 set 中移除所有元素。底层调用HashMap的clear方法清除所有的Entry。/]]></content>
      <categories>
        <category>Java_Base</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础（十二）]]></title>
    <url>%2F2017%2F10%2F15%2FJavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Set接口的基本实现有HashSet、TreeSet，但是两者底层都各自以来于Map接口的实现HashMap和TreeMap所以，Hash表有关的：我们先复习HashMap，再复习HashSet，再去看HashSet中的hashCode和equals方法，最后看HashTable与HashMap的区别，三者之间的联系Tree有关的：先复习TreeMap，再复习TreeSet 这节聊HashMap,遍历是个重点 Map —- HashMap HashMap也是我们使用非常多的一种集合，但是它并不属于Collection接口，它是基于Map接口的实现，以key-value的形式存在。在HashMap中，key-value总是会当做一个整体来处理，系统会根据hash算法来计算key-value的存储位置，我们总是可以通过key来快速地存、取value。 HashMap实现了Map接口，继承AbstractMap。其中Map接口定义了键映射到值的规则，而AbstractMap类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作，其实AbstractMap类已经实现了Map HashMap其实底层还是数组,但是遍历的时候，keySet()出来的是Set&lt;Entry&gt; 12public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable 成员变量1234567891011121314151617181920212223242526272829303132333435//创建 HashMap 时未指定初始容量情况下的默认容量 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; //HashMap 的最大容量static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//HashMap 默认的装载因子,当 HashMap 中元素数量超过 容量*装载因子 时，进行 resize() 操作static final float DEFAULT_LOAD_FACTOR = 0.75f;//用来确定何时将解决 hash 冲突的链表转变为红黑树static final int TREEIFY_THRESHOLD = 8;// 用来确定何时将解决 hash 冲突的红黑树转变为链表static final int UNTREEIFY_THRESHOLD = 6;/* 当需要将解决 hash 冲突的链表转变为红黑树时，需要判断下此时数组容量，若是由于数组容量太小（小于 MIN_TREEIFY_CAPACITY ）导致的 hash 冲突太多，则不进行链表转变为红黑树操作，转为利用 resize() 函数对 hashMap 扩容 */static final int MIN_TREEIFY_CAPACITY = 64;//保存Node&lt;K,V&gt;节点的数组 transient Node&lt;K,V&gt;[] table;//由 hashMap 中 Node&lt;K,V&gt; 节点构成的 settransient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;//记录 hashMap 当前存储的元素的数量transient int size;//记录 hashMap 发生结构性变化的次数（注意 value 的覆盖不属于结构性变化）transient int modCount;//threshold的值应等于 table.length * loadFactor, size 超过这个值时进行 resize()扩容int threshold;//记录 hashMap 装载因子final float loadFactor; 构造方法HashMap提供了三个构造函数： 1. HashMap():构造了一个具有默认初始容量（16）和默认加载因子（0.75）的空HashMap 2. HashMap(int initialCapacity)：构造一个带指定初始容量和默认加载因子（0.75）的空HashMap 3. HashMap(int initialCapacity,float loadFactor)：构造一个带指定初始容量和加载因子的空HashMap 4. HashMap(Map&lt; ? extends K, ? extends V&gt; m)：构造一个映射关系与指定 Map 相同的新 HashMap 容量 ：是哈希表中桶的数量，初始容量只是哈希表在创建时的容量，实际上就是Entry&lt; K,V&gt;[] table的容量 加载因子 ：是哈希表在其容量自动增加之前可以达到多满的一种尺度。它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。 当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。 HashMap是一种支持快速存取的数据结构，要了解它的性能必须要了解它的数据结构。 HashMap的数据结构 从上图我们可以看出HashMap底层实现还是数组，只是数组的每一项都是一条链。其中参数initialCapacity就代表了该数组的长度。下面为HashMap构造函数的源码： 1234567891011121314151617181920212223242526public HashMap(int initialCapacity, float loadFactor) &#123; //容量不能小于0 if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); //容量不能超出最大容量 if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; //加载因子不能&lt;=0 或者 为非数字 if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); //计算出大于初始容量的最小 2的n次方作为哈希表table的长度，下面会说明为什么要这样 int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; this.loadFactor = loadFactor; //设置HashMap的容量极限，当HashMap的容量达到该极限时就会进行扩容操作 threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1); //创建Entry数组 table = new Entry[capacity]; useAltHashing = sun.misc.VM.isBooted() &amp;&amp; (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD); init();&#125; 可以看到，这个构造函数主要做的事情就是： 1. 对传入的 容量 和 加载因子进行判断处理 2. 设置HashMap的容量极限 3. 计算出大于初始容量的最小 2的n次方作为哈希表table的长度，然后用该长度创建Entry数组（table），这个是最核心的 可以发现，一个HashMap对应一个Entry数组，来看看Entry这个元素的内部结构： 123456789101112131415static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next; int hash; /** * Creates new entry. */ Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; Entry是HashMap的一个内部类，它也是维护着一个key-value映射关系，除了key和value，还有next引用（该引用指向当前table位置的链表），hash值（用来确定每一个Entry链表在table中位置） 下面源码的数据结构这块，我还没看到，先贴个链接，之后再看： http://blog.csdn.net/jeffleo/article/details/54946424 HashMap—public V put(K key, V value) 传入key和value，判断key是否为null，如果为null，则调用putForNullKey，以null作为key存储到哈希表中； 然后计算key的hash值，根据hash值搜索在哈希表table中的索引位置，若当前索引位置不为null，则对该位置的Entry链表进行遍历，如果链中存在该key，则用传入的value覆盖掉旧的value，同时把旧的value返回，结束； 否则调用addEntry，用key-value创建一个新的节点，并把该节点插入到该索引对应的链表的头部 12345678910111213141516171819202122232425262728293031323334(只是jdk1.7的时候这么写，到1.8就变了)public V put(K key, V value) &#123; //当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因 if (key == null) return putForNullKey(value); //计算key的hash值 int hash = hash(key.hashCode()); ------(1) //计算key hash 值在 table 数组中的位置 int i = indexFor(hash, table.length); ------(2) //从i出开始迭代 e,找到 key 保存的位置 for (Entry&lt;K, V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; //判断该条链上是否有hash值相同的(key相同) //若存在相同，则直接覆盖value，返回旧value if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; //旧值 = 新值 e.value = value; e.recordAccess(this); return oldValue; //返回旧值 &#125; &#125; //修改次数增加1 modCount++; //将key、value添加至i位置处 addEntry(hash, key, value, i); return null; &#125;/**通过源码我们可以清晰看到HashMap保存数据的过程为：首先判断key是否为null，若为null，则直接调用putForNullKey方法。若不为空则先计算key的hash值，然后根据hash值搜索在table数组中的索引位置，如果table数组在该位置处有元素，则通过比较是否存在相同的key，若存在则覆盖原来key的value，否则将该元素保存在链头（最先保存的元素放在链尾）。若table在该处没有元素，则直接保存。*/ 先看迭代处。此处迭代原因就是为了防止存在相同的key值，若发现两个hash值（key）相同时，HashMap的处理方式是用新value替换旧value，这里并没有处理key，这就解释了HashMap中没有两个相同的key。 在看（1）、（2）处。这里是HashMap的精华所在。首先是hash方法，该方法为一个纯粹的数学计算，就是计算h的hash值。 1234static int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; 我们知道对于HashMap的table而言，数据分布需要均匀（最好每项都只有一个元素，这样就可以直接找到），不能太紧也不能太松，太紧会导致查询速度慢，太松则浪费空间。计算hash值后，怎么才能保证table元素分布均与呢？我们会想到取模，但是由于取模的消耗较大，HashMap是这样处理的：调用indexFor方法。 123static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; HashMap的底层数组长度总是2的n次方，在构造函数中存在：capacity &lt;&lt;= 1;这样做总是能够保证HashMap的底层数组长度为2的n次方。当length为2的n次方时，h&amp;(length - 1)就相当于对length取模，而且速度比直接取模快得多，这是HashMap在速度上的一个优化。 而至于底层数组的长度是2的n次方，除了可以从取模直接优化到取余，还有就是为了均匀分布table数据和充分利用空间。当length = 2^n时，不同的hash值发生碰撞的概率比较小，这样就会使得数据在table数组中分布较均匀，查询速度也较快。 理一遍：当我们想一个HashMap中添加一对key-value时，系统首先会计算key的hash值，然后根据hash值确认在table中存储的位置。若该位置没有元素，则直接插入。否则迭代该处元素链表并依此比较其key的hash值。如果两个hash值相等且key值相等(e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))),则用新的Entry的value覆盖原来节点的value。如果两个hash值相等但key值不等 ，则将该节点插入该链表的链头。 HashMap—public V get(Object key)12345678910111213141516171819202122232425public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 读取的步骤比较简单，调用hash（key）求得key的hash值，然后调用indexFor（hash）求得hash值对应的table的索引位置，然后遍历索引位置的链表，如果存在key，则把key对应的Entry返回，否则返回null。 HashMap的遍历 利用entrySet()得到Entry，再遍历这个Map(键值都遍历用这个) 12345678910111213141516171819202122public class HashMapTest &#123; public static void main(String[] args) &#123; HashMap&lt;Integer,String&gt; hashMap = new HashMap&lt;Integer,String&gt;(); hashMap.put(1, "blemon"); hashMap.put(0, "banana"); hashMap.put(3, "apple"); hashMap.put(2, "water"); for (Entry&lt;Integer,String&gt; entry : hashMap.entrySet()) &#123; System.out.println(entry.getKey()+"..."+entry.getValue()); &#125; &#125;&#125;/**Output: 0...banana 1...blemon 2...water 3...apple*/ 只要键，keySet（只要键用这个） 1234567891011121314public class HashMapTest &#123; public static void main(String[] args) &#123; HashMap&lt;Integer,String&gt; hashMap = new HashMap&lt;Integer,String&gt;(); hashMap.put(1, "blemon"); hashMap.put(0, "banana"); hashMap.put(3, "apple"); hashMap.put(2, "water"); for (Integer key : hashMap.keySet()) &#123; System.out.println(key+"..."+hashMap.get(key)); &#125; &#125;&#125; 迭代器（不要用） 1234567891011121314151617public class HashMapTest &#123; public static void main(String[] args) &#123; HashMap&lt;Integer,String&gt; hashMap = new HashMap&lt;Integer,String&gt;(); hashMap.put(1, "blemon"); hashMap.put(0, "banana"); hashMap.put(3, "apple"); hashMap.put(2, "water"); Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = hashMap.entrySet().iterator(); while(iterator.hasNext())&#123; Map.Entry&lt;Integer, String&gt; entry = iterator.next(); System.out.println(entry.getKey()+"..."+entry.getValue()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java_Base</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础（十一）]]></title>
    <url>%2F2017%2F10%2F14%2FJavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节我们聊LinkedList List —- LinkedList概述LinkedList与ArrayList一样实现List接口，只是ArrayList是List接口的大小可变数组的实现，LinkedList是List接口链表的实现。基于链表实现的方式使得LinkedList在插入和删除时更优于ArrayList，而随机访问则比ArrayList逊色些。 LinkedList实现所有可选的列表操作，并允许所有的元素包括null。 除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。 此类实现 Deque 接口，为 add、poll 提供先进先出队列操作，以及其他堆栈和双端队列操作。 所有操作都是按照双重链接列表的需要执行的。在列表中编索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。 同时，与ArrayList一样此实现不是同步的。 LinkedList的链式线性表的特点为: 适合于在链表中间需要频繁进行插入和删除操作。 LinkedList的链式线性表的缺点为: 随机访问速度较慢。查找一个元素需要从头开始一个一个的找。速度你懂的。 可以这样理解LinkedList就是一种双向循环链表的链式线性表，只不过存储的结构使用的是链式表而已。 LinkedList和ArrayListArrayList数组线性表的特点为:类似数组的形式进行存储，因此它的随机访问速度极快。ArrayList数组线性表的缺点为:不适合于在线性表中间需要频繁进行插入和删除操作。因为每次插入和删除都需要移动数组中的元素。 LinkedList的链式线性表的特点为: 适合于在链表中间需要频繁进行插入和删除操作。LinkedList的链式线性表的缺点为: 随机访问速度较慢。查找一个元素需要从头开始一个一个的找。速度你懂的。 源码分析接下的代码，都是前面是源码，后面是具体实现实例 定义与属性 123456789101112131415161718192021222324public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializabletransient int size = 0;transient Node&lt;E&gt; first;transient Node&lt;E&gt; last;/**说明关键字 transient： 一个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。 然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化， 打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作 （主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。 换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。 总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前 添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。 1. 一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。 2. transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。 变量如果是用户自定义类变量，则该类需要实现Serializable接口。 3. 被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。*/ 构造方法 LinkedList的构造方法比ArrayList少一个，ArrayList多了一个直接定义空间长度的构造函数 public ArrayList(int initialCapacity) ,对于我们ArrayList而言，无参构造的默认容量是10 LinkedList提供了两个构造方法：LinkedList()和LinkedList(Collection&lt;? extends E&gt; c)。 1234567891011121314/** * 构造一个空列表。 */public LinkedList() &#123; header.next = header.previous = header;&#125;/** * 构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。 */public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; LinkedList()构造一个空列表。里面没有任何元素，仅仅只是将header节点的前一个元素、后一个元素都指向自身。 LinkedList(Collection&lt;? extends E&gt; c)： 构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。该构造函数首先会调用LinkedList()，构造一个空列表，然后调用了addAll()方法将Collection中的所有元素添加到列表中。以下是addAll()的源代码： 12345678910111213141516171819202122232425262728293031323334353637383940/** * 添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。 */public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c);&#125;/** * 将指定 collection 中的所有元素从指定位置开始插入此列表。其中index表示在其中插入指定collection中第一个元素的索引 */public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; //若插入的位置小于0或者大于链表长度，则抛出IndexOutOfBoundsException异常 if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size); Object[] a = c.toArray(); int numNew = a.length; //插入元素的个数 //若插入的元素为空，则返回false if (numNew == 0) return false; //modCount:在AbstractList中定义的，表示从结构上修改列表的次数 modCount++; //获取插入位置的节点，若插入的位置在size处，则是头节点，否则获取index位置处的节点 Entry&lt;E&gt; successor = (index == size ? header : entry(index)); //插入位置的前一个节点，在插入过程中需要修改该节点的next引用：指向插入的节点元素 Entry&lt;E&gt; predecessor = successor.previous; //执行插入动作 for (int i = 0; i &lt; numNew; i++) &#123; //构造一个节点e，这里已经执行了插入节点动作同时修改了相邻节点的指向引用 // Entry&lt;E&gt; e = new Entry&lt;E&gt;((E) a[i], successor, predecessor); //将插入位置前一个节点的下一个元素引用指向当前元素 predecessor.next = e; //修改插入位置的前一个节点，这样做的目的是将插入位置右移一位，保证后续的元素是插在该元素的后面，确保这些元素的顺序 predecessor = e; &#125; successor.previous = predecessor; //修改容量大小 size += numNew; return true;&#125; LinkedList的增、删、改、查增 add(E e)、add(int index, E element)、 addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)、AddFirst(E e)、addLast(E e) 123456789101112131415161718192021222324252627282930313233343536373839add(E e):将指定元素添加到此列表的结尾 public boolean add(E e) &#123; linkLast(e); return true; &#125;public class LinkedListTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;7,34,45,3,9&#125;; LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;Integer&gt;(Arrays.asList(array)); linkedList.add(22); System.out.println(linkedList.toString()); &#125;&#125;/**Output: [7, 34, 45, 3, 9, 22]分析： add(E e)的底层使用了linkLast方法： void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125;*/ 12345678910111213141516171819202122232425262728add(int index, E element):指定位置插入元素public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));&#125;public class LinkedListTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;7,34,45,3,9&#125;; LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;Integer&gt;(Arrays.asList(array)); linkedList.add(2,22); System.out.println(linkedList.toString()); &#125;&#125; /**Output: [7, 34, 22, 45, 3, 9]*/ 123456789101112131415161718192021222324addAll(Collection&lt;? extends E&gt; c)：添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序addAll(int index, Collection&lt;? extends E&gt; c)：将指定 collection 中的所有元素从指定位置开始插入此列表。public class LinkedListTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;7,34,45,3,9&#125;; LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;Integer&gt;(Arrays.asList(array)); List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(array)); linkedList.addAll(list); System.out.println(linkedList.toString()); linkedList.addAll(3,list); System.out.println(linkedList.toString()); &#125;&#125; Output: [7, 34, 45, 3, 9, 7, 34, 45, 3, 9] [7, 34, 45, 7, 34, 45, 3, 9, 3, 9, 7, 34, 45, 3, 9] 1234567891011121314151617181920212223242526addFirst(E e): 将指定元素插入此列表的开头。addLast(E e): 将指定元素添加到此列表的结尾。public class LinkedListTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;7,34,45,3,9&#125;; LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;Integer&gt;(Arrays.asList(array)); List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(Arrays.asList(array)); linkedList.addAll(list); linkedList.addFirst(100); linkedList.addLast(100); System.out.println(linkedList.toString()); &#125;&#125;/**Output: [100, 7, 34, 45, 3, 9, 7, 34, 45, 3, 9, 100]*/ 删 remove()、 remove(int index)、 remove(Object o)、 removeFirst()、removeFirstOccurrence(Object o)removeLast()、removeLastOccurrence(Object o)、clear() 1234567891011121314151617181920212223242526remove():获取并移除此列表的头（第一个元素）remove(int index):移除此列表中指定位置处的元素remove(Object o)：从此列表中移除首次出现的指定元素（如果存在）public class LinkedListTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;7,34,45,3,9&#125;; LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;Integer&gt;(Arrays.asList(array)); for (int x = linkedList.size()-1; x &gt;= 0; x--) &#123; linkedList.remove(x); &#125; System.out.println(linkedList.toString()); &#125;&#125; /**分析：List中的ArrayList和LinkedList在删除的时候需要注意一点，就是一旦一个元素被删除，那么后面的元素就会跟着排上去，也就是说只要删除后长度够，你删掉的那个位置一直是有值的。所以我们在删除的时候都需要从后往前删！！！这个非常重要还有一点就是之前在ArrayList中讲到的，remove(Obj o)/remove(int x)，在List存的是Integer和int之间需要注意的*/ 123456789101112131415161718192021222324252627282930removeFirst():移除并返回此列表的第一个元素removeFirstOccurrence(Object o):从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）removeLast()：移除并返回此列表的最后一个元素。removeLastOccurrence(Object o)：从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。public class LinkedListTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;7,34,2,3,2,3,22,3,4,4,1,31,45,3,2,9&#125;; LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;Integer&gt;(Arrays.asList(array)); Integer removeFirst = linkedList.removeFirst(); Integer removeLast = linkedList.removeLast(); linkedList.removeFirstOccurrence(2); linkedList.removeLastOccurrence(2); System.out.println("removeFirst : "+removeFirst+"..."+"removeLast : "+removeLast); System.out.println(linkedList.toString()); &#125;&#125;/**Output: removeFirst : 7...removeLast : 9 [34, 3, 2, 3, 22, 3, 4, 4, 1, 31, 45, 3]*/ 改 12345678910111213141516171819202122232425262728293031set(int index, E element)public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal; &#125;public class LinkedListTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;7,31,45,3,2,9&#125;; LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;Integer&gt;(Arrays.asList(array)); Integer oldValue = linkedList.set(0, 100); System.out.println(oldValue); System.out.println(linkedList.toString()); &#125;&#125; /**Output: 7 [100, 31, 45, 3, 2, 9]注意一点，ArrayList中也set方法，注意这两个set方法，都有返回值（修改前的对象），类型是集合存储类型！！！（ArrayList中没注意到）*/ 查 get(int index)：返回此列表中指定位置处的元素。 getFirst()：返回此列表的第一个元素。 getLast()：返回此列表的最后一个元素。 indexOf(Object o)：返回此列表中首次出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。 lastIndexOf(Object o)：返回此列表中最后出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。 这里我们需要再将ArrayList和LinkedList做一个比较（indexOf(Object o)） 1234567891011121314151617public class LinkedListTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;7,31,45,3,2,9&#125;; LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;Integer&gt;(Arrays.asList(array)); ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(Arrays.asList(array)); System.out.println("LinkedList: "+linkedList.indexOf(1)+"...ArrayList: "+arrayList.indexOf(1)); &#125;&#125;/**Output: LinkedList: -1...ArrayList: -1*/ 注意：看清楚函数的参数！！！尤其是对于我们的remove，如果直接写数字，一定会走int参数的，而不是object的，因为在顶层对这里并没有装箱！！！ 从数据结构看源码我们知道，ArrayList底层是到动态数据，而我们的LinkedList底层是双向链表的形式。 成员变量 &amp; 构造函数直接看LinkedList的成员变量和构造函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; transient int size = 0; /** * Pointer to first node. * Invariant: (first == null &amp;&amp; last == null) || * (first.prev == null &amp;&amp; first.item != null) */ transient Node&lt;E&gt; first; /** * Pointer to last node. * Invariant: (first == null &amp;&amp; last == null) || * (last.next == null &amp;&amp; last.item != null) */ transient Node&lt;E&gt; last; /** * Constructs an empty list. */ public LinkedList() &#123; &#125; /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; ...... ...... ......&#125; 可以看出来LinkedList的成员变量只有三个： 头节点 first 尾节点 last 容量 size（链表长度） 而我们知道，节点Node是一个双向的节点，是LinkedList中的一个内部类： 1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 内部函数（不给外部调用）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879插入结点：/** * Links e as first element. * 插入到头部，使插入的节点变成链表的第一个结点 */private void linkFirst(E e) &#123; //得到原始头结点 f final Node&lt;E&gt; f = first; //新建节点newNode，newNode的prev指针指向null，next指针指向f结点（其实指向的是f结点的数据域） final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); //让全局的头结点等于新建的结点 first = newNode; //如果原始的链表是个空链，那么新建的结点也是尾结点 if (f == null) last = newNode; else //如果原始链表不是空链表，那么让原始头结点的prev指针，指向新建结点.不用管原始头结点的next指针，依然指向之前的结点 f.prev = newNode; //链表长度+1，修改次数+1 size++; modCount++;&#125;/** * Links e as last element. * 插入到尾部，使插入的结点成为链表的最后一个结点 */void linkLast(E e) &#123; //得到链表中原始的最后一个结点 final Node&lt;E&gt; l = last; //新建结点newNode,newNode的next指针指向null，prev指针指向原始的尾结点（其实是原始尾结点的数据域） final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //使全局变量的尾结点等于新建结点 last = newNode; //如果原始链表是个空链表，那么新建节点也是头结点 if (l == null) first = newNode; else //否则，原始链表不是空链表，让原始尾结点的next指针，指向新建节点。不用管原始尾节点的prev指针，依然指向之前的结点 l.next = newNode; //链表长度+1，修改次数+1 size++; modCount++;&#125;/** * Inserts element e before non-null Node succ. * 在指定的结点前插入我们的结点 */void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null;（假设指定的结点succ不是空结点） //得到指定结点的前一个结点 pred final Node&lt;E&gt; pred = succ.prev; //新建结点newNode，newNode的prev指针指向pred结点，next指针指向succ结点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); //succ的prev指针指向newNode结点 succ.prev = newNode; //如果我们的指定的结点是头结点，那么succ的prev指针指向的pred结点就是null，那么在succ前插入结点就是头结点 if (pred == null) first = newNode; else pred.next = newNode;//否则，让succ结点原始的前一个结点pred的next指针指向newNode //链表长度+1，修改次数+1 size++; modCount++;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106删除结点：/** * Unlinks non-null first node f. * 如果不是空链，删除头结点，并返回被删除结点的数据 */private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; //获取链表头结点的数据 final E element = f.item; //获取头结点的下一个结点 final Node&lt;E&gt; next = f.next; //释放头结点的数据域 f.item = null; //释放头结点的next指针，头结点的prev指针本来就是null f.next = null; // help GC //现在原始头结点的下一个结点是新链表的头结点了 first = next; //如果原始链表只有一个结点，那么删除结点后，直接变成空链 if (next == null) last = null; else next.prev = null;//否则，让新链表的头结点的prev指针指向null //链表长度-1，修改次数+1，返回被删除结点的数据域值 size--; modCount++; return element;&#125;/** * Unlinks non-null last node l. * 删除链表的之后一个结点 */private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; //得到原始链表中最后一个结点的数据 final E element = l.item; //得到原始链表中最后一个结点的前一个结点 final Node&lt;E&gt; prev = l.prev; //释放原尾结点的数据域 l.item = null; //释放原尾结点的prev指针 l.prev = null; // help GC //让原尾结点的前一个结点成为新链表的尾结点 last = prev; //如果原链表只有一个结点，删除后，变为空链 if (prev == null) first = null; else prev.next = null;//否则，让新链表的尾结点的next指针指向null //链表长度-1，修改次数+1，返回被删除结点的数据域值 size--; modCount++; return element;&#125;/** * Unlinks non-null node x. * 删除指定结点 */E unlink(Node&lt;E&gt; x) &#123; // assert x != null; //得到指定结点的数据，指定结点的前一个结点和后一个结点 final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; //如果前一个结点是null，那么这个指定结点就是头结点，一旦删除，新链表的头结点的就是指定结点的下一个结点 if (prev == null) &#123; first = next; &#125; else &#123; //否则，指定结点的前一个结点，在删除指定结点之后，next指针指向指定结点的下一个结点next,释放指定结点的prev指针 prev.next = next x.prev = null; &#125; //如果指定结点的下一个结点是null，那么指定结点就是原链表的最后一个结点，一旦删除，prev结点就是最后一个一结点 if (next == null) &#123; last = prev; &#125; else &#123; //否则，next结点的prev指针指向prev结点，释放原始结点x的next指针 next.prev = prev; x.next = null; &#125; //释放被删除结点的数据域，链表长度-1，修改次数+1，返回被删除结点的数据域值 x.item = null; size--; modCount++; return element;&#125; 123456789101112131415161718192021222324查找结点：/** * Returns the (non-null) Node at the specified element index. * 采用了二分查找的方式进行查找 */Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); //如果要查找的结点小于链表长度的一半，从头结点查，否则从结点查 if (index &lt; (size &gt;&gt; 1)) &#123; //让结点x等于头结点 Node&lt;E&gt; x = first; //直接遍历到index，然后返回结点 for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; //直接从尾结点开始遍历 Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 外部方法这部分我只说几个，因为很多其实就是调用了之前的内部方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384增加//普通的在尾部添加元素public boolean add(E e) &#123; linkLast(e); return true;&#125;//在指定位置添加元素public void add(int index, E element) &#123; checkPositionIndex(index);//先检查角标是不是越界了 //指定位置也有可能是在尾部 if (index == size) linkLast(element); else linkBefore(element, node(index));&#125;//添加一个集合的元素public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c);&#125;public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; checkPositionIndex(index); //把 要添加的集合转成一个 数组 Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; //创建两个节点，分别指向要插入位置前面和后面的节点 Node&lt;E&gt; pred, succ; //要添加到尾部 if (index == size) &#123; succ = null; pred = last; &#125; else &#123; //要添加到中间， succ 指向 index 位置的节点，pred 指向它前一个 succ = node(index); pred = succ.prev; &#125; //遍历要添加内容的数组 for (Object o : a) &#123; @SuppressWarnings("unchecked") E e = (E) o; //创建新节点，头指针指向 pred Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); //如果 pred 为空，说明新建的这个是头节点 if (pred == null) first = newNode; else //pred 指向新建的节点 pred.next = newNode; //pred 后移一位 pred = newNode; &#125; //添加完后需要修改尾指针 last if (succ == null) &#123; //如果 succ 为空，说明要插入的位置就是尾部，现在 pred 已经到最后了 last = pred; &#125; else &#123; //否则 pred 指向后面的元素 pred.next = succ; succ.prev = pred; &#125; //元素个数增加 size += numNew; modCount++; return true;&#125;//添加到头部，时间复杂度为 O(1)public void addFirst(E e) &#123; linkFirst(e);&#125;//添加到尾部，时间复杂度为 O(1)public void addLast(E e) &#123; linkLast(e);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//删除头部节点public E remove() &#123; return removeFirst();&#125;//删除指定位置节点public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index));&#125;//删除包含指定元素的节点，这就得遍历了public boolean remove(Object o) &#123; if (o == null) &#123; //遍历终止条件，不等于 null for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125;//删除头部元素public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);&#125;//删除尾部元素public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l);&#125;//删除首次出现的指定元素，从头遍历public boolean removeFirstOccurrence(Object o) &#123; return remove(o);&#125;//删除最后一次出现的指定元素，倒过来遍历public boolean removeLastOccurrence(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125; 12345678910改：//set 很简单，找到这个节点，替换数据就好了public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566查://挨个遍历，获取第一次出现位置public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1;&#125;//倒着遍历，查询最后一次出现的位置public int lastIndexOf(Object o) &#123; int index = size; if (o == null) &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (x.item == null) return index; &#125; &#125; else &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (o.equals(x.item)) return index; &#125; &#125; return -1;&#125;//是否包含指定元素public boolean contains(Object o) &#123; return indexOf(o) != -1;&#125;//获取指定位置的元素，需要遍历public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125;//获取第一个元素，很快public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;&#125;//最后一个元素，也很快public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item;&#125;]]></content>
      <categories>
        <category>Java_Base</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础（十）]]></title>
    <url>%2F2017%2F10%2F13%2FJavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节我们聊ArrayList List—–ArrayList概述ArrayList是实现List接口的动态数组，所谓动态就是它的大小是可变的。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。 每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。默认初始容量为10。随着ArrayList中元素的增加，它的容量也会不断的自动增长。在每次添加新的元素时，ArrayList都会检查是否需要进行扩容操作，扩容操作带来数据向新数组的重新拷贝，所以如果我们知道具体业务数据量，在构造ArrayList时可以给ArrayList指定一个初始容量，这样就会减少扩容时数据的拷贝问题。 当然在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。 注意，ArrayList实现不是同步的。 如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。所以为了保证同步，最好的办法是在创建时完成，以防止意外对列表进行不同步的访问：List list = Collections.synchronizedList(new ArrayList(...)); ArrayList数组线性表的特点为:类似数组的形式进行存储，因此它的随机访问速度极快。 ArrayList数组线性表的缺点为:不适合于在线性表中间需要频繁进行插入和删除操作。因为每次插入和删除都需要移动数组中的元素。 1. 如果在初始化ArrayList的时候没有指定初始化长度的话，默认的长度为10. 2. ArrayList在增加新元素的时候如果超过了原始的容量的话，ArrayList扩容ensureCapacity的方案为“(原始容量*3)/2+1&quot;。 123456789101112public void ensureCapacity(int minCapacity) &#123; modCount++; int oldCapacity = elementData.length; if (minCapacity &gt; oldCapacity) &#123; Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; if (newCapacity &lt; minCapacity) newCapacity = minCapacity; // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125;&#125; 在这里有一个疑问，为什么每次扩容处理会是1.5倍，而不是2.5、3、4倍呢？通过google查找，发现1.5倍的扩容是最好的倍数。 因为一次性扩容太大(例如2.5倍)可能会浪费更多的内存(1.5倍最多浪费33%，而2.5被最多会浪费60%，3.5倍则会浪费71%……)。但是 一次性扩容太小，需要多次对数组重新分配内存，对性能消耗比较严重。所以1.5倍刚刚好，既能满足性能需求，也不会造成很大的 内存消耗。 处理这个ensureCapacity()这个扩容数组外，ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的 功能。它可以通过trimToSize()方法来实现。该方法可以最小化ArrayList实例的存储量。 1234567public void trimToSize() &#123; modCount++; int oldCapacity = elementData.length; if (size &lt; oldCapacity) &#123; elementData = Arrays.copyOf(elementData, size); &#125; &#125; 3. .ArrayList是线程不安全的，在多线程的情况下不要使用。如果一定在多线程使用List的，您可以使用Vector，因为Vector和 ArrayList基本一致，区别在于Vector中的绝大部分方法都使用了同步关键字修饰，这样在多线程的情况下不会出现并发错误， 还有就是它们的扩容方案不同，ArrayList是通过原始容量*3/2+1,而Vector是允许设置默认的增长长度，Vector的默认扩容方式为 原来的2倍。 源码分析ArrayList是实现List接口的，底层采用数组实现，所以它的操作基本上都是基于对数组的操作。 ArrayList的底层使用了数组12345private static final int DEFAULT_CAPACITY = 10;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;transient Object[] elementData; // non-private to simplify nested class access 这里Object[] elementData，就是我们的ArrayList容器，下面介绍的基本操作都是基于该elementData变量来进行操作的。 ArrayList有三个构造器 123456789101112131415161718192021222324252627282930313233343536373839404142434445下面的内容都是源码：/** * Constructs an empty list with an initial capacity of ten. */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;/** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125;/** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 1234567891011测试构造器public class ArrayListTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;2,1,3,2,2,1,3&#125;; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(Arrays.asList(array)); System.out.println(arrayList.toString()); &#125;&#125; 1234567891011121314151617181920测试ArrayList的构造函数：public class ArrayListTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;2,1,3,2,2,1,3&#125;; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(Arrays.asList(array)); System.out.println(arrayList.toString()); List&lt;String&gt; list = new ArrayList&lt;String&gt;(); System.out.println(list.size()); List&lt;Double&gt; doubleList = new ArrayList&lt;Double&gt;(20);//虽然输出还是0，但是ArrayList底层的数组长度已经变换了,this.elementData = new Object[initialCapacity]; for (int x = 0; x&lt;30;x++) &#123; doubleList.add(1.1);//虽然指定了长度，也就是说在10-20的这个长度内，每次添加不用再重新去扩容 &#125; System.out.println(doubleList.size()); &#125;&#125; ArrayList的增、删、改、查下面的代码均是前面是源码，后面是举例实现 增 ArrayList提供了add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)这个四个方法来实现ArrayList增加。 123456789101112131415161718192021222324add(E e)：将指定的元素添加到此列表的尾部。public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;public class ArrayListTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;2,1,3,2,2,1,3&#125;; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(Arrays.asList(array)); arrayList.add(77); System.out.println(arrayList.toString()); &#125;&#125;/**Output： [2, 1, 3, 2, 2, 1, 3, 77]*/ 12345678910111213141516171819202122232425262728add(int index, E element):将指定的元素插入此列表中的指定位置。但是这个位置一定是在原始集合中存在的长度范围内，不然会报异常public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125;public class ArrayListTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;2,1,3,2,2,1,3&#125;; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(Arrays.asList(array)); arrayList.add(4,77); System.out.println(arrayList.toString()); &#125;&#125;/**Output： [2, 1, 3, 2, 77, 2, 1, 3]*/ 1234567891011121314151617181920212223242526272829addAll(Collection&lt;? extends E&gt; c)：按照指定 collection 的迭代器所返回的元素顺序，将该 collection 中的所有元素添加到此列表的尾部。public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125;public class ArrayListTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;2,1,3,2,2,1,3&#125;; Integer[] addArray = new Integer[]&#123;77,88,99&#125;; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(Arrays.asList(array)); arrayList.addAll(Arrays.asList(addArray)); System.out.println(arrayList.toString()); &#125;&#125;/**Output: [2, 1, 3, 2, 2, 1, 3, 77, 88, 99]*/ 12345678910111213141516171819202122232425262728293031323334353637addAll(int index, Collection&lt;? extends E&gt; c)：从指定的位置开始，将指定 collection 中的所有元素插入到此列表中。public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;&#125;public class ArrayListTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;2,1,3,2,2,1,3&#125;; Integer[] addArray = new Integer[]&#123;77,88,99&#125;; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(Arrays.asList(array)); arrayList.addAll(2,Arrays.asList(addArray)); System.out.println(arrayList.toString()); &#125;&#125;/**Output: [2, 1, 77, 88, 99, 3, 2, 2, 1, 3]*/ 删 ArrayList提供了remove(int index)、remove(Object o)、clear()、removeRange(int fromIndex, int toIndex)、removeAll()四个方法进行元素的删除。 其中ArrayList内部有一个fastRemove()，这个方法才是我们调用的public类型的Remove中底层调用的方法，还有一个就是数组的拷贝 ：public static native void arraycopy(Object src, int srcPos,Object dest, int destPos,int length); 123456789101112131415161718192021222324252627282930313233343536373839404142remove(int index)：移除此列表中指定位置上的元素。 public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125;public class ArrayListTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;2,1,3,2,2,1,3&#125;; //Integer[] addArray = new Integer[]&#123;77,88,99&#125;; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(Arrays.asList(array)); //arrayList.addAll(2,Arrays.asList(addArray)); arrayList.remove(2); //arrayList.removeAll(arrayList); System.out.println(arrayList.toString()); &#125;&#125;/**Output: [2, 1, 2, 2, 1, 3]分析： 利用list进行删除的时候，有一个问题，就是我们需要从后往前删，但是如果想清空list的话，用clear()方法比较好*/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647remove(Obj o):移除此列表中首次出现的指定元素（如果存在）。public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;public class ArrayListTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;2,1,3,2,2,1,3&#125;; //Integer[] addArray = new Integer[]&#123;77,88,99&#125;; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(Arrays.asList(array)); //arrayList.addAll(2,Arrays.asList(addArray)); Integer firstNum = 2; arrayList.remove(firstNum); //arrayList.removeAll(arrayList); //arrayList.clear(); System.out.println(arrayList.toString()); &#125;&#125;/**Output: [1, 3, 2, 2, 1, 3]分析： 这个时候我们就需要注意了，remove(int x)、remove(Obj o)；一旦我们ArrayList中存的是数字，也就是 ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();注意，这里我们List中存的是包装类，不是 基本数据类型的int，所以在remove时，如果直接写入一个数字，那么删除的就是对应角标的数据，但是如果我们 写入的是一个包装类对象，那么删除的就是这个集合中第一次出现的这个对象*/ 123456789101112131415161718192021222324252627removeRange(int fromIndex, int toIndex)：移除列表中索引在 fromIndex（包括）和 toIndex（不包括）之间的所有元素。protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work int newSize = size - (toIndex-fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize;&#125;clear():清空List集合public void clear() &#123; modCount++; // clear to let GC do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0;&#125; 改 set（int index, E element）方法： 1234567891011121314151617181920212223public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125;public class ArrayListTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;2,1,3,2,2,1,3&#125;; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(Arrays.asList(array)); arrayList.set(0, 99); System.out.println(arrayList.toString()); &#125;&#125;Output: [99, 1, 3, 2, 2, 1, 3] 查 123456789101112131415161718192021public E get(int index) &#123; RangeCheck(index); return (E) elementData[index]; &#125;public class ArrayListTest &#123; public static void main(String[] args) &#123; Integer[] array = new Integer[]&#123;2,1,3,2,2,1,3&#125;; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(Arrays.asList(array)); Integer getNum = arrayList.get(0); System.out.println(getNum); &#125;&#125;Output: 2 ArrayList的遍历12345678910111213141516171819202122232425262728public class Test&#123;public static void main(String[] args) &#123; List&lt;String&gt; list=new ArrayList&lt;String&gt;(); list.add("Hello"); list.add("World"); list.add("HAHAHAHA"); //第一种遍历方法使用foreach遍历List for (String str : list) &#123; //也可以改写for(int i=0;i&lt;list.size();i++)这种形式 System.out.println(str); &#125; //第二种遍历，把链表变为数组相关的内容进行遍历 String[] strArray=new String[list.size()]; list.toArray(strArray); for(int i=0;i&lt;strArray.length;i++) //这里也可以改写为foreach(String str:strArray)这种形式 &#123; System.out.println(strArray[i]); &#125; //第三种遍历 使用迭代器进行相关遍历 Iterator&lt;String&gt; ite=list.iterator(); while(ite.hasNext()) &#123; System.out.println(ite.next()); &#125; &#125;&#125; 又说ArrayList#add(E e) – 扩容机制这是10.18线性表复习完之后，反过来又去看了源码，聊一聊底层的扩容。 源码分析我们知道ArrayList是动态数组的实现。从源码中我们可以看出，在内部其实有Capacity和size两个变量去定义我们elementData[]，前者是这个数组在内存中分配的空间大小，后者是数组中数据量的大小，也就是我们说的数组的长度。 看清楚！！这两个其实不是一个概念！！！ 我们就用空参数的构造函数为例： ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;() 这句话完之后，我们arrayList对应底层数组elementData[]的size为0，但是Capacity确实10！！！ 直接看add(E e)源码：size表示的是执行添加之前的元素个数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;/**添加E对象，这个时候我们进入ensureCapacityInternal，底层数组的size+1(0--&gt;1)作为参数，但是Capacity还是10*/接下来我们看第一句话这个函数：private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;/**参数minCapacity是这个elementData[]所需的最小Capacity，添加第一个元素的时候这个参数就是1，随后判断我们的element是不是空数组，也就是数组长度(length)是0，这个时候当然是空数组，所以我们的minCapacity变成了10，再进入下一个函数 ensureExplicitCapacity(minCapacity);*/进入下一个函数：private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;/**其实这里我们就是说已经要开始添加了，但是有一个问题，就是我们需要在添加前，让我们全局的修改次数+1。现在我们数组所需的最小Capacity是10，而数组的长度还是0呢！！！（我们并没有改变数组的长度，在前面的操作中！）所以，所需最小容量大于了数组的长度，那么就开始扩大Cpacity grow(minCapacity)*/进入扩容：private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;/**我们的旧Cpacity是数组的长度！！新Capacity是1.5倍的旧数组Capacity！！！但是我们添加第一个数据的时候，我们的新数组长度也是小于10的，所以我们直接进行数组复制就可以了。复制完之后我们数组的Capacity就改变了*/现在我们来看我们添加第10个元素时候的情况: ensureCapacityInternal的参数是9+1=10，也就是所需最小Capacity就是10，因为这个时候elementData不再是空数组了，而变成了一个长度是10的数组，直接进入 ensureExplicitCapacity(minCapacity); 所以我们的minCapacity-elementData.length=0=0（从添加第一个开始这个数组长度就是10了）,不会进入 grow(minCapacity)，所以直接就回到add方法中elementData[10] = 第10个数据值。但是一旦添加第11个数据时： ensureCapacityInternal的参数是10+1=11，直接进入 ensureExplicitCapacity(minCapacity);minCapacity - elementData.length = 11-10=1&gt;0，扩容。newCapacity = 15，所以内部的elementData的长度又成了15！！ 流程1. 设置断点 1234567892.执行第一句话：ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;()，执行完毕后，形成一个空参数的elementData[0]数组。默认cpacity是10。/** * Constructs an empty list with an initial capacity of ten. */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 3. 开始循环，执行完循环判断，i = 1 4. 进入循环，添加完第一个元素，elementData[0] --&gt; elementData[10]，size变为1 ，这个时候，数组的长度已经变成了10， 但是只有第一个地址有值。 注意：size是集合中元素的个数(可以为null，但是不是所有都是null)，这个参数是对用户看的，elementData.length是内部动态数组的长度， 并不是一个概念！！！ 5. 不断添加，直到开始添加第10个数据时，数组长度还是10，但是size=9 6. 第10个数据添加完毕，此时，动态数组饱和。size=10=minCapacity 7. 开始添加第11个数据，这个时候ensureCapacityInternal(size+1)参数就成了11，到了自己函数中就是minCapacity是11，但是这个时候我们的elementData.length = 10,所以扩容，进入grow(minCapacity),oldCpacity是原数组长度，也就是10，newCpacity是1.5倍的oldCapacity就成了15，这个时候开始复制数组，复制的新数组长度是newCapacity，也就是15。所以elementData[10]--&gt;elementData[15] 8. 直接输出，以size为基准 又说ArrayList#remove(Object o)/(int index)源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//内部方法private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1;// if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125;//外部方法public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125;protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // clear to let GC do its work int newSize = size - (toIndex-fromIndex); for (int i = newSize; i &lt; size; i++) &#123; elementData[i] = null; &#125; size = newSize;&#125; System.arraycopy &amp; Arrays.copyOfSystem.arraycopy 其实ArrayList中用到了很多次System.arraycopy方法，但是我们一直没有细看过，这里了解一下这个拷贝的方法。 12345678910public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) 从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。从 src 引用的源数组到 dest 引用的目标数组，数组组件的一个子序列被复制下来。被复制的组件的编号等于 length 参数。源数组中位置在 srcPos 到 srcPos+length-1 之间的组件被分别复制到目标数组中的destPos 到 destPos+length-1 位置。 但是使用这个方法我们需要注意一个问题，如果我们只是想对原始数组进行一个复制，对于一维数组而言，肯定没有问题，但是对于二维数组而言，就有一个比较严重的问题，就是复制之后，一旦修改了其中一个数组，那么另一个数组的数据也会被修改。 java其实没有二维数组的概念，平常实现的二维数组只是元素是一维数组的一维数组，而数组也是引用类型，继承自Object类。数组是new出来的。这些性质也就导致arraycopy()二维数组时出现的问题。 如果是一维数组，那么元素都是基础类型（如int，double等），使用arraycopy()方法后，是把原数组的值传给了新数组，属于值传递。而如果是二维数组，数组的第一维装的是一个一维数组的引用，第二维里是元素数值。对二维数组应用arraycopy()方法后，第一维的引用被复制给新数组的第一维，也就是两个数组的第一维都指向相同的“那些数组”。而这时改变其中任何一个数组的元素的值，其实都修改了“那些数组”的元素的值，所以原数组和新数组的元素值都一样了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class TestArrayCopy &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO 自动生成方法存根 String[] s1 = &#123;"中国","山西","太原","TYUT","zyy","加拿大","不知道哪个州","不知道哪个市","不知道哪个学校","yxf"&#125;; String[] s2 = new String[10]; System.arraycopy(s1, 0, s2, 0, 10); s2[6] = "假设蒙大拿州"; s2[7] = "假设蒙特利尔市"; s2[8] = "假设Montreal商学院"; System.out.println("This is s1"); for(int i = 0;i &lt; s1.length ;i++)&#123; System.out.print(s1[i] + ","); &#125; System.out.println("\nThis is s2"); for(int i = 0;i &lt; s2.length ;i++)&#123; System.out.print(s2[i] + ","); &#125; String[][] s3 = &#123;&#123;"中国","山西","太原","TYUT","zyy"&#125;,&#123;"加拿大","不知道哪个州","不知道哪个市","不知道哪个学校","yxf"&#125;&#125;; String[][] s4 = new String[s3.length][s3[0].length]; System.arraycopy(s3, 0, s4, 0, s3.length); System.out.println("\nThis is original s3"); for(int i = 0;i &lt; s3.length ;i++)&#123; for(int j = 0; j&lt; s3[0].length ;j++)&#123; System.out.print(s3[i][j] + ","); &#125; &#125; s4[1][1] = "假设蒙大拿州"; s4[1][2] = "假设蒙特利尔市"; s4[1][3] = "假设Montreal商学院"; System.out.println("\nThis is s3 after s4 has changed."); for(int i = 0;i &lt; s3.length ;i++)&#123; for(int j = 0; j&lt; s3[0].length ;j++)&#123; System.out.print(s3[i][j] + ","); &#125; &#125; System.out.println("\nThis is s4"); for(int i = 0;i &lt; s4.length ;i++)&#123; for(int j = 0; j &lt; s4[0].length ; j++)&#123; System.out.print(s4[i][j] + ","); &#125; &#125; &#125; &#125; /**Output: This is s1 中国,山西,太原,TYUT,zyy,加拿大,不知道哪个州,不知道哪个市,不知道哪个学校,yxf, This is s2 中国,山西,太原,TYUT,zyy,加拿大,假设蒙大拿州,假设蒙特利尔市,假设Montreal商学院,yxf, This is original s3 中国,山西,太原,TYUT,zyy,加拿大,不知道哪个州,不知道哪个市,不知道哪个学校,yxf, This is s3 after s4 has changed. 中国,山西,太原,TYUT,zyy,加拿大,假设蒙大拿州,假设蒙特利尔市,假设Montreal商学院,yxf, This is s4 中国,山西,太原,TYUT,zyy,加拿大,假设蒙大拿州,假设蒙特利尔市,假设Montreal商学院,yxf, */ Arrays.copy 该方法对于不同的数据类型都有相应的方法重载。 123456789101112//复杂数据类型 public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; &#125; public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123; return (T[]) copyOf(original, newLength, original.getClass()); &#125; 由U类型复制为T类型？original - 要复制的数组newLength - 要返回的副本的长度newType - 要返回的副本的类型 1234567//基本数据类型（其他类似byte，short···） public static int[] copyOf(int[] original, int newLength) &#123; int[] copy = new int[newLength]; System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; &#125; 观察其源代码发现copyOf()，在其内部创建了一个新的数组，然后调用arrayCopy()向其复制内容，返回出去。总结： 1.copyOf()的实现是用的是arrayCopy(); 2.arrayCopy()需要目标数组，对两个数组的内容进行可能不完全的合并操作。 3.copyOf()在内部新建一个数组，调用arrayCopy()将original内容复制到copy中去，并且长度为newLength。返回copy; 4.arraycopy 方法会因为新数组大小比久数组大小小而报IndexOutOfBoundsException; copyOf 则不会因此报错，因为copyOf 的返回值是在内部new 好的copy 数组，而该copy 数组new 的大小就等于newLength ， 故即使在客户端指定好了新数组newArray 的大小，接收到返回值后也是指向底层new 出来的数组copy 。换句话说 ( 也可以因此推出其他的区别) ，在客户端代码中即使不给新数组new 对象，如：String[] newStr = null;那么对于arraycopy 是会报NullPointerException 的错误的，而对于java.util.Arrays 中的copyOf 方法则由于jdk 底层已经new 出了对象 而不会报该错误！不过需要特别注意的是：copyOf 方法最后也是调用System.arraycopy 的方法， 不过由于前面的准备，异常情况就不会出现了。]]></content>
      <categories>
        <category>Java_Base</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础（九）]]></title>
    <url>%2F2017%2F10%2F13%2FJavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B9%9D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[接下来的一部分我们都会去聊集合框架的东西 集合框架（一）简介基本介绍 Collection接口 Collection接口是最基本的集合接口，它不提供直接的实现，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。Collection所代表的是一种规则，它所包含的元素都必须遵循一条或者多条规则。如有些允许重复而有些则不能重复、有些必须要按照顺序插入而有些则是散列，有些支持排序但是有些则不支持。 在Java中所有实现了Collection接口的类都必须提供两套标准的构造函数，一个是无参，用于创建一个空的Collection，一个是带有Collection参数的有参构造函数，用于创建一个新的Collection，这个新的Collection与传入进来的Collection具备相同的元素。 List接口 List接口为Collection直接接口。List所代表的是有序的Collection，即它用某种特定的插入顺序来维护元素顺序。用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。 1. ArrayList ArrayList是一个动态数组，也是我们最常用的集合。它允许任何符合规则的元素插入甚至包括null。每一个ArrayList都有一个初始 容量（10），该容量代表了数组的大小。随着容器中的元素不断增加，容器的大小也会随着增加。在每次向容器中增加元素的同时都会 进行容量检查，当快溢出时，就会进行扩容操作。所以如果我们明确所插入元素的多少，最好指定一个初始容量值，避免过多的进行扩容 操作而浪费时间、效率。 size、isEmpty、get、set、iterator 和 listIterator 操作都以固定时间运行。add 操作以分摊的固定时间运行，也就是说， 添加 n 个元素需要 O(n) 时间（由于要考虑到扩容，所以这不只是添加元素会带来分摊固定时间开销那样简单）。 ArrayList擅长于随机访问。同时ArrayList是非同步的。 2. LinkedList 同样实现List接口的LinkedList与ArrayList不同，ArrayList是一个动态数组，而LinkedList是一个双向链表。所以它除了有 ArrayList的基本操作方法外还额外提供了get，remove，insert方法在LinkedList的首部或尾部。 由于实现的方式不同，LinkedList不能随机访问，它所有的操作都是要按照双重链表的需要执行。在列表中索引的操作将从开头或结尾 遍历列表（从靠近指定索引的一端）。这样做的好处就是可以通过较低的代价在List中进行插入和删除操作。 与ArrayList一样，LinkedList也是非同步的。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建 List时构造一个同步的List： List list = Collections.synchronizedList(new LinkedList(...)); 3. Vector 与ArrayList相似，但是Vector是同步的。所以说Vector是线程安全的动态数组。它的操作与ArrayList几乎一样。 4. Stack Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop 方法， 还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。 Set接口 Set是一种不包括重复元素的Collection。它维持它自己的内部排序，所以随机访问没有任何意义。与List一样，它同样运行null的存在但是仅有一个。由于Set接口的特殊性，所有传入Set集合中的元素都必须不同，同时要注意任何可变对象，如果在对集合中元素进行操作时，导致e1.equals(e2)==true，则必定会产生某些问题。实现了Set接口的集合有：EnumSet、HashSet、TreeSet。 1. EnumSet 是枚举的专用Set。所有的元素都是枚举类型。 2. HashSet HashSet堪称查询速度最快的集合，因为其内部是以HashCode来实现的。它内部元素的顺序是由哈希码来决定的，所以它不保证set 的迭代顺序；特别是它不保证该顺序恒久不变。 3. TreeSet 基于TreeMap，生成一个总是处于排序状态的set，内部以TreeMap来实现。它是使用元素的自然顺序对元素进行排序，或者根据创建Set 时提供的 Comparator 进行排序，具体取决于使用的构造方法。 Queue 队列，它主要分为两大类，一类是阻塞式队列，队列满了以后再插入元素则会抛出异常，主要包括ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue。另一种队列则是双端队列，支持在头、尾两端插入和移除元素，主要包括：ArrayDeque、LinkedBlockingDeque、LinkedList。 Map接口Map与List、Set接口不同，它是由一系列键值对组成的集合，提供了key到Value的映射。同时它也没有继承Collection。在Map中它保证了key与value之间的一一对应关系。也就是说一个key对应一个value，所以它不能存在相同的key值，当然value值可以相同。实现map的有：HashMap、TreeMap、HashTable、Properties、EnumMap 1. HashMap 以哈希表数据结构实现，查找对象时通过哈希函数计算其位置，它是为快速查询而设计的，其内部定义了一个hash表数组 （Entry[] table），元素会通过哈希转换函数将元素的哈希地址转换成数组中存放的索引，如果有冲突，则使用散列链表的形式将 所有相同哈希地址的元素串起来，可能通过查看HashMap.Entry的源码它是一个单链表结构。 2. TreeMap 键以某种排序规则排序，内部以red-black（红-黑）树数据结构实现，实现了SortedMap接口 3. HashTable 也是以哈希表数据结构实现的，解决冲突时与HashMap也一样也是采用了散列链表的形式，不过性能比HashMap要低 集合框架的异同ArrayList和Vector 1. vector是线程同步的，所以它也是线程安全的，而arraylist是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用 arraylist效率比较高。 2. 如果集合中的元素的数目大于目前集合数组的长度时，vector增长率为目前数组长度的100%,而arraylist增长率为目前数组长度 的50%.如过在集合中使用数据量比较大的数据，用vector有一定的优势。 3. 如果查找一个指定位置的数据，vector和arraylist使用的时间是相同的，都是0(1),这个时候使用vector和arraylist都可以。 而如果移动一个指定位置的数据花费的时间为0(n-i)n为总长度，这个时候就应该考虑到使用linklist,因为它移动一个指定位置的数据所花费的时间为0(1),而查询一个指定位置的数据时花费的时间为0(i)。 ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素， 但是插入数据要设计到数组元素移动等内存操作，所以索引数据快插入数据慢，Vector由于使用了synchronized方法（线程安全） 所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要 记录本项的前后项即可，所以插入数度较快！ ArrayList和LinkedList 1. ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 2. 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 3. 对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。 这一点要看实际情况的。若只对单条数据插入或删除，ArrayList的速度反而优于LinkedList。但若是批量随机的插入删除数据，LinkedList的速度大大优于ArrayList. 因为ArrayList每插入一条数据，要移动插入点及之后的所有数据。 HashMap和TreeMap 1. HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果 你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的），TreeMap (TreeMap实现SortedMap接口)。 2. 在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。 使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。 这个TreeMap没有调优选项，因为该树总处于平衡状态。 HashMap和HashTable 1. Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 。 2. 同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 。 3. 值：只有HashMap可以让你将空值作为一个表的条目的key或value]]></content>
      <categories>
        <category>Java_Base</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础（八）]]></title>
    <url>%2F2017%2F10%2F13%2FJavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节聊异常 异常基本概念 异常指不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。异常是一个事件，它发生在程序运行期间，干扰了正常的指令流程。Java通 过API中Throwable类的众多子类描述各种不同的异常。因而，Java异常都是对象，是Throwable子类的实例，描述了出现在一段编码中的 错误条件。当条件生成时，错误将引发异常。 在 Java 中，所有的异常都有一个共同的祖先 Throwable（可抛出）。 Throwable： 有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。 Error： 是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。 Exception（异常）: 是程序本身可以处理的异常。 Exception 类有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常。（NullPointerException、ArithmeticException、ArrayIndexOutOfBoundException） 注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。 通常，Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。 可查异常（编译器要求必须处置的异常）： 正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。 除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。 不可查异常(编译器不要求强制处置的异常): 包括运行时异常（RuntimeException与其子类）和错误（Error）。 Exception 这种异常分两大类运行时异常和非运行时异常(编译异常)。程序中应当尽可能去处理这些异常。 运行时异常： 都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。 运行时异常的特点： 是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。 非运行时异常（编译异常）： 是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。 处理异常的机制总体来说，Java规定：对于可查异常必须捕捉、或者声明抛出。允许忽略不可查的RuntimeException和Error。 try..catch..finally 123456789try &#123; // 可能会发生异常的程序代码 &#125; catch (Type1 id1)&#123; // 捕获并处置try抛出的异常类型Type1 &#125; catch (Type2 id2)&#123; //捕获并处置try抛出的异常类型Type2 &#125; finally&#123; //一定会执行的语句&#125; 123456789101112131415161718192021测试一：无finally子句public class ExceptionTest &#123; public static void main(String[] args) &#123; int a = 7; int b = 0; try&#123; System.out.println(a/b); &#125;catch(Exception e)&#123; //e.printStackTrace(); System.out.println("异常被抛出"); &#125; System.out.println("捕获异常后才会输出"); &#125;&#125;/**Output: 异常被抛出 捕获异常后才会输出*/ 12345678910111213141516171819202122232425262728293031323334353637测试二：有finally子句public class ExceptionTest &#123; public static void main(String[] args) &#123; int i = 0; String greetings[] = &#123; " Hello world !", " Hello World !! ", " HELLO WORLD !!!" &#125;; while (i &lt; 4) &#123; try &#123; // 特别注意循环控制变量i的设计，避免造成无限循环 System.out.println(greetings[i++]); &#125; catch (ArrayIndexOutOfBoundsException e) &#123; System.out.println("数组下标越界异常"); &#125; finally &#123; System.out.println("--------------------------"); &#125; &#125; &#125;&#125;/**Output: Hello world ! -------------------------- Hello World !! -------------------------- HELLO WORLD !!! -------------------------- 数组下标越界异常 --------------------------分析： try &#123; System.out.println (greetings[i]); i++; &#125; 如果try写成这个样子，就会进入一个死循环*/ 小结： try 块：用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。 catch 块：用于处理try捕获到的异常。 finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。在以下4种特殊情况下，finally块不会被执行： 1）在finally语句块中发生了异常。 2）在前面的代码中用了System.exit()退出程序。 3）程序所在的线程死亡。 4）关闭CPU。 try-catch-finally 规则(异常处理语句的语法规则）：1) 必须在 try 之后添加 catch 或 finally 块。try 块后可同时接 catch 和 finally 块，但至少有一个块。2) 必须遵循块顺序：若代码同时使用 catch 和 finally 块，则必须将 catch 块放在 try 块之后。3) catch 块与相应的异常类的类型相关。4) 一个 try 块可能有多个 catch 块。若如此，则执行第一个匹配块。即Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个catch代码块，不会再执行其他的 catch代码块5) 可嵌套 try-catch-finally 结构。6) 在 try-catch-finally 结构中，可重新抛出异常。7) 除了下列情况，总将执行 finally 做为结束：JVM 过早终止（调用 System.exit(int)）；在 finally 块中抛出一个未处理的异常；计算机断电、失火、或遭遇病毒攻击。 try-catch-finally语句块的执行顺序:1) 当try没有捕获到异常时：try语句块中的语句逐一被执行，程序将跳过catch语句块，执行finally语句块和其后的语句； 2) 当try捕获到异常，catch语句块里没有处理此异常的情况：当try语句块里的某条语句出现异常时，而没有处理此异常的catch语句块时，此异常将会抛给JVM处理，finally语句块里的语句还是会被执行，但finally语句块后的语句不会被执行； 3) 当try捕获到异常，catch语句块里有处理此异常的情况：在try语句块中是按照顺序来执行的，当执行到某一条语句出现异常时，程序将跳到catch语句块，并与catch语句块逐一匹配，找到与之对应的处理程序，其他的catch语句块将不会被执行，而try语句块中，出现异常之后的语句也不会被执行，catch语句块执行完后，执行finally语句块里的语句，最后执行finally语句块后的语句； throws和throwthrows：一个方法可能会抛出异常，但是方法本身不能处理这个异常，就在方法后面抛出异常 123methodname throws Exception1,Exception2,..,ExceptionN &#123; &#125; 1234567891011121314151617181920212223242526public class ExceptionTest &#123; public static void pop() throws NegativeArraySizeException &#123; // 定义方法并抛出NegativeArraySizeException异常 int[] arr = new int[-3]; // 创建数组 &#125; public static void main(String[] args) &#123; // 主方法 try &#123; // try语句处理异常信息 pop(); // 调用pop()方法 &#125; catch (NegativeArraySizeException e) &#123; System.out.println("pop()方法抛出的异常");// 输出异常信息 &#125; &#125; &#125;/**Output: pop()方法抛出的异常分析： pop方法没有处理异常NegativeArraySizeException，而是由main函数来处理。注意: 静态类中可以有非静态方法，但是一旦一个类中有静态方法，那么这个类一定是静态类。 但是，在一个静态方法中，我们是不能直接调用非静态方法的，除非是利用创建对象进行调用！！！相反的，在非 静态方法中我们却可以直接调用静态的方法。*/ throw：在语句中抛出异常 12345678910111213141516171819202122232425262728293031323334353637public class ExceptionTest &#123; static int quotient(int x, int y) throws MyException &#123; // 定义方法抛出异常 if (y &lt; 0) &#123; // 判断参数是否小于0 throw new MyException("除数不能是负数"); // 异常信息 &#125; return x/y; // 返回值 &#125; public static void main(String args[]) &#123; // 主方法 int a =3; int b =0; try &#123; // try语句包含可能发生异常的语句 int result = quotient(a, b); // 调用方法quotient() &#125; catch (MyException e) &#123; // 处理自定义异常 System.out.println(e.getMessage()); // 输出异常信息 &#125; catch (ArithmeticException e) &#123; // 处理ArithmeticException异常 System.out.println("除数不能为0"); // 输出提示信息 &#125; catch (Exception e) &#123; // 处理其他异常 System.out.println("程序发生了其他的异常"); // 输出提示信息 &#125; &#125; &#125;class MyException extends Exception &#123; // 创建自定义异常类 String message; // 定义String类型变量 public MyException(String ErrorMessagr) &#123; // 父类方法 message = ErrorMessagr; &#125; public String getMessage() &#123; // 覆盖getMessage()方法 return message; &#125; &#125; /**Output: 除数不能为0*/ 总结：throws是方法抛出异常。在方法声明中，如果添加了throws子句，表示该方法即将抛出异常，异常的处理交由它的调用者，至于调用者任何处理则不是它的责任范围内的了。所以如果一个方法会有异常发生时，但是又不想处理或者没有能力处理，就使用throws吧！ 而throw是语句抛出异常。它不可以单独使用，要么与try…catch配套使用，要么与throws配套使用。 常见的异常在Java中提供了一些异常用来描述经常发生的错误，对于这些异常，有的需要程序员进行捕获处理或声明抛出，有的是由Java虚拟机自动进行捕获处理。Java中常见的异常类: runtimeException子类: 1. java.lang.ArrayIndexOutOfBoundsException 数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。 2. java.lang.ArithmeticException 算术条件异常。譬如：整数除零等。 3. java.lang.NullPointerException 空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等 4. java.lang.ClassNotFoundException 找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。 5. java.lang.NegativeArraySizeException 数组长度为负异常 6. java.lang.ArrayStoreException 数组中包含不兼容的值抛出的异常 7. java.lang.SecurityException 安全性异常 8. java.lang.IllegalArgumentException 非法参数异常 IOException: 1. IOException：操作输入流和输出流时可能出现的异常。 2. EOFException 文件已结束异常 3. FileNotFoundException 文件未找到异常 其他 ClassCastException 类型转换异常类 ArrayStoreException 数组中包含不兼容的值抛出的异常 SQLException 操作数据库异常类 NoSuchFieldException 字段未找到异常 NoSuchMethodException 方法未找到抛出的异常 NumberFormatException 字符串转换为数字抛出的异常 StringIndexOutOfBoundsException 字符串索引超出范围抛出的异常 IllegalAccessException 不允许访问某类异常 InstantiationException 当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常]]></content>
      <categories>
        <category>Java_Base</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础（七）]]></title>
    <url>%2F2017%2F10%2F12%2FJavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节我们在聊一下数组 再谈数组数据的创建（声明和初始化）格式一：int[] arr = new int[5] 格式二：int[] arr = new int[]{1，2，3，4}int[] arr = {2,3,4,5} 不管在其他语言中数组是什么，在java中它就是对象。一个比较特殊的对象。 123456789101112131415public class Test &#123; public static void main(String[] args) &#123; int[] array = new int[10]; System.out.println("array的父类是：" + array.getClass().getSuperclass()); System.out.println("array的类名是：" + array.getClass().getName()); &#125;&#125;/**Output: array的父类是：class java.lang.Object array的类名是：[I分析： 从上面示例可以看出,数组的是Object的直接子类,它属于“第一类对象”，但是它又与普通的java对象存在很大的不同，从它的类名就可以看出：[I，这是什么东东？？在JDK中我就没有找到这个类，话说这个"[I”都不是一个合法标识符。*/ 我们再看如下示例： 1234567891011121314151617181920public class Test &#123; public static void main(String[] args) &#123; int[] array_00 = new int[10]; System.out.println("一维数组：" + array_00.getClass().getName()); int[][] array_01 = new int[10][10]; System.out.println("二维数组：" + array_01.getClass().getName()); int[][][] array_02 = new int[10][10][10]; System.out.println("三维数组：" + array_02.getClass().getName()); &#125;&#125;/**Output: 一维数组：[I 二维数组：[[I 三维数组：[[[I分析：通过这个实例我们知道：[代表了数组的维度，一个[表示一维，两个[表示二维。可以简单的说数组的类名由若干个'['和数组元素类型的内部名称组成。*/ 不清楚我们再看： 123456789101112131415public class Test &#123; public static void main(String[] args) &#123; System.out.println("Object[]:" + Object[].class); System.out.println("Object[][]:" + Object[][].class); System.err.println("Object[][][]:" + Object[][][].class); System.out.println("Object:" + Object.class); &#125;&#125;/**Output: Object[]:class [Ljava.lang.Object; Object[][]:class [[Ljava.lang.Object; Object[][][]:class [[[Ljava.lang.Object; Object:class java.lang.Object*/ 从这个实例我们可以看出数组的“庐山真面目”。同时也可以看出数组和普通的Java类是不同的，普通的java类是以全限定路径名+类名来作为自己的唯一标示的，而数组则是以若干个[+L+数组元素类全限定路径+类来最为唯一标示的。这个不同也许在某种程度上说明了数组也普通java类在实现上存在很大的区别，也许可以利用这个区别来使得JVM在处理数组和普通java类时作出区分。 数组的使用方法数组的使用方法无非就是四个步骤：声明数组、分配空间、赋值、处理。 声明数组：就是告诉计算机数组的类型是什么。有两种形式：int[] array、int array[]。 分配空间：告诉计算机需要给该数组分配多少连续的空间，记住是连续的。array = new int[10]; 赋值：赋值就是在已经分配的空间里面放入数据。array[0] = 1 、array[1] = 2……其实分配空间和赋值是一起进行的，也就是完成数组的初始化。有如下三种形式： 123int a[] = new int[2]; //默认为0,如果是引用数据类型就为nullint b[] = new int[] &#123;1,2,3,4,5&#125;; int c[] = &#123;1,2,3,4,5&#125;; 处理：就是对数组元素进行操作。通过数组名+有效的下标来确认数据。 数组的性能在项目设计中数组使用的越来越少了，而且它确实是没有List、Set这些集合使用方便，但是在某些方面数组还是存在一些优势的，例如：速度，而且集合类的底层也都是通过数组来实现的。 1234567891011121314151617Long time1 = System.currentTimeMillis(); for(int i = 0 ; i &lt; 100000000 ;i++)&#123; sum += arrays[i%10]; &#125; Long time2 = System.currentTimeMillis(); System.out.println("数组求和所花费时间：" + (time2 - time1) + "毫秒"); Long time3 = System.currentTimeMillis(); for (int i = 0; i &lt; 100000000; i++) &#123; sum += list.get(i%10); &#125; Long time4 = System.currentTimeMillis(); System.out.println("List求和所花费时间：" + (time4 - time3) + "毫秒");/**Output: 数组求和所花费时间：696毫秒 List求和所花费时间：3498毫秒*/ 从上面的时间消耗上面来说数组对于基本类型的求和计算的速度是集合的5倍左右。其实在list集合中，求和当中有一个致命的动作：list.get(i)。这个动作是进行拆箱动作，Integer对象通过intValue方法自动转换成一个int基本类型，在这里就产生了不必要的性能消耗。 数组的常用 数组转list集合12345678910111213141516171819202122Integer[] arr = new Integer[]&#123;2,3,4,5&#125;;List&lt;Integer&gt; arrsyList = new ArrayList&lt;Integer&gt;(Arrays.asList(arr));System.out.println(arrsyList);/**Output: [2,3,4,5]分析：直接利用了ArrayList中的一个构造方法，参数是Collectionpublic ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125;*/ 提一下：list集合转数据System.out.println(Arrays.toString(list.toArray())); 数组转set集合 1234567891011121314String[] array2=new String[]&#123;"黄渤","张艺兴","孙红雷","小猪","牙哥","黄磊"&#125;;Set&lt;String&gt; set=new HashSet&lt;String&gt;(Arrays.asList(array2));System.out.println(set);/**Output： [小猪, 牙哥, 黄渤, 黄磊, 孙红雷, 张艺兴]分析：public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c);&#125;*/ 填充数组 12int[] arr=new int[5];Arrays.fill(arr, 10); //将数组全部填充10 复制数组 12345678910 int[] arr6 = &#123;3, 7, 2, 1&#125;; int[] arr7=Arrays.copyOf(arr6, 10);//指定新数组的长度 int[] arr8=Arrays.copyOfRange(arr6, 1, 3);////只复制从索引[1]到索引[3]之间的元素（不包括索引[3]的元素） System.out.println(Arrays.toString(arr7)); System.out.println(Arrays.toString(arr8));/**Output: [3, 7, 2, 1, 0, 0, 0, 0, 0, 0] [7, 2]*/ 去数组中重复的元素 123456789101112131415161718Integer[] arr = new Integer[]&#123;2,3,4,5,2,3,4,5,5,3,3,3,3,2,4,54,3,3,2,2,4,2,1&#125;;Set&lt;Integer&gt; set_2 = new HashSet&lt;Integer&gt;(Arrays.asList(arr));System.out.println(set_2);Integer[] arr_2 = new Integer[set_2.size()];int count = 0;for (Integer s : set_2) &#123; arr_2[count++] = s;&#125;System.out.println(Arrays.toString(arr_2));/**Output: [1, 2, 3, 4, 5, 54] [1, 2, 3, 4, 5, 54]分析： HashSet本身就会存的时候会判断一下是不是这个数据我原来有，有的话我就不存了*/]]></content>
      <categories>
        <category>Java_Base</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础（六）]]></title>
    <url>%2F2017%2F10%2F12%2FJavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节聊内部类 内部类内部类基础内部类我们从外面看是非常容易理解的，无非就是在一个类的内部在定义一个类。 为什么要使用内部类？在《Think in java》中有这样一句话：使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。 在我们程序设计中有时候会存在一些使用接口很难解决的问题，这个时候我们可以利用内部类提供的、可以继承多个具体的或者抽象的类的能力来解决这些程序设计问题。可以这样说，接口只是解决了部分问题，而内部类使得多重继承的解决方案变得更加完整。 1、内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。 2、在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。 3、创建内部类对象的时刻并不依赖于外围类对象的创建。 4、内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。 5、内部类提供了更好的封装，除了该外围类，其他类都不能访问。 内部类的对象总有一个隐式引用，它指向创建它的外部类对象！！！但是这个引用在内部类的定义中是不可见的。 内部类中声明的所有静态域都必须是final。原因很简单。我们希望一个静态域只有一个实例，不过对于每个外部对象，会分别有一个单独的内部类实例。如果这个域不是final，它可能就不是唯一的。 内部类中不能有static。 当我们在创建一个内部类的时候，它无形中就与外围类有了一种联系，依赖于这种联系，它可以无限制地访问外围类的元素。123456789101112131415161718192021222324252627282930313233343536373839public class OutClass &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public class InnerClass&#123; public InnerClass()&#123; name = "lemon"; age=23; &#125; public void fun()&#123; System.out.println("name: "+getName()+"..age: "+getAge()); &#125; &#125; public static void main(String[] args) &#123; OutClass outClass = new OutClass(); OutClass.InnerClass innerClass = outClass.new InnerClass(); innerClass.fun(); &#125;&#125;/**Output: name: lemon..age: 23*/ 在这个应用程序中，我们可以看到内部了InnerClass可以对外围类OuterClass的属性进行无缝的访问，尽管它是private修饰的。这是因为当我们在创建某个外围类的内部类对象时，此时内部类对象必定会捕获一个指向那个外围类对象的引用，只要我们在访问外围类的成员时，就会用这个引用来选择外围类的成员。 其实在这个应用程序中我们还看到了如何来引用内部类：引用内部类我们需要指明这个对象的类型：OuterClasName.InnerClassName。同时如果我们需要创建某个内部类对象，必须要利用外部类的对象通过.new来创建内部类： OuterClass.InnerClass innerClass = outerClass.new InnerClass(); 同时如果我们需要生成对外部类对象的引用，可以使用OuterClassName.this，这样就能够产生一个正确引用外部类的引用了。当然这点实在编译期就知晓了，没有任何运行时的成本。 其实，这里说的就是内部类和外围类的.this和.new 12345678910111213141516171819202122232425package jse_4;public class OuterClass &#123; public void fun()&#123; System.out.println("OutClass/..."); &#125; public class InnerClass&#123; public OuterClass getOuterClass()&#123; return OuterClass.this; &#125; &#125; public static void main(String[] args) &#123; OuterClass outerClass = new OuterClass(); OuterClass.InnerClass innerClass = outerClass.new InnerClass(); innerClass.getOuterClass().fun(); &#125;&#125;/**Output: OuterClass...*/ 到这里了我们需要明确一点，内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类（当然他们之间还是有联系的）。对于一个名为OuterClass的外围类和一个名为InnerClass的内部类，在编译成功后，会出现这样两个class文件：OuterClass.class和OuterClass$InnerClass.class。 内部类分类成员内部类成员内部类也是最普通的内部类，它是外围类的一个成员，所以他是可以无限制的访问外围类的所有 成员属性和方法，尽管是private的，但是外围类要访问内部类的成员属性和方法则需要通过内部类实例来访问。 在成员内部类中要注意两点： 1. 成员内部类中不能存在任何static的变量和方法； 2. 成员内部类是依附于外围类的，所以只有先创建了外围类才能够创建内部类。 12345678910111213141516171819202122232425262728293031323334public class OuterClass &#123; private String str; public void outerDisplay()&#123; System.out.println("outerClass..."); &#125; public class InnerClass&#123; public void innerDisplay()&#123; //使用外围内的属性 str = "chenssy..."; System.out.println(str); //使用外围内的方法 outerDisplay(); &#125; &#125; /*推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 */ public InnerClass getInnerClass()&#123; return new InnerClass(); &#125; public static void main(String[] args) &#123; OuterClass outer = new OuterClass(); OuterClass.InnerClass inner = outer.getInnerClass(); inner.innerDisplay(); &#125;&#125;/**Output: chenssy... outerClass...*/ 推荐使用getxxx()来获取成员内部类，尤其是该内部类的构造函数无参数时 。 局部匿名类 有这样一种内部类，它是嵌套在方法和作用于内的，对于这个类的使用主要是应用与解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类，局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法和属性中被使用，出了该方法和属性就会失效。 1234567891011121314151617181920定义在方法里：public class Parcel5 &#123; public Destionation destionation(String str)&#123; class PDestionation implements Destionation&#123; private String label; private PDestionation(String whereTo)&#123; label = whereTo; &#125; public String readLabel()&#123; return label; &#125; &#125; return new PDestionation(str); &#125; public static void main(String[] args) &#123; Parcel5 parcel5 = new Parcel5(); Destionation d = parcel5.destionation("chenssy"); &#125;&#125; 123456789101112131415161718192021222324252627定义在作用域中：public class Parcel6 &#123; private void internalTracking(boolean b)&#123; if(b)&#123; class TrackingSlip&#123; private String id; TrackingSlip(String s) &#123; id = s; &#125; String getSlip()&#123; return id; &#125; &#125; TrackingSlip ts = new TrackingSlip("chenssy"); String string = ts.getSlip(); &#125; &#125; public void track()&#123; internalTracking(true); &#125; public static void main(String[] args) &#123; Parcel6 parcel6 = new Parcel6(); parcel6.track(); &#125;&#125; 静态内部类 静态内部类与非静态内部类之间存在一个最大的区别，我们知道非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围内，但是静态内部类却没有。没有这个引用就意味着： 1. 它的创建是不需要依赖于外围类的。 2. 它不能使用任何外围类的非static成员变量和方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class OuterClass &#123; private String sex; public static String name="lemon"; /** * 静态内部类 */ static class InnerClass_1&#123; public static String name_1 = "Inner_lemon_1"; private String alies = "Abel"; public void innerFun_1()&#123; /* * 静态内部类不能访问外围类中的非静态成员或方法 */ //outerFun();Cannot make a static reference to the non-static method outerFun() from the type OuterClass System.out.println("InnerFun_1---&gt;OuterClass name: "+name); System.out.println("InnerClass-name-1: "+name_1+"--- InnerClass-alies-1: "+alies); &#125; &#125; /** * 非静态内部类 */ class InnerClass_2&#123; public String name_2 = "Inner_lemon_2"; public void innerFun_2()&#123; outerFun_1(); System.out.println("InnerClass-name-2: "+name_2); &#125; &#125; /** * 外围类方法 */ public void outerFun_1()&#123; System.out.println("Outer--Function--1"); &#125; public void outerFun_2()&#123; System.out.println("Outer--Functon--2"); /* 外围类访问静态内部类 */ System.out.println(InnerClass_1.name_1); new InnerClass_1().innerFun_1(); /* 外围类访问非静态内部类*/ /* 非静态内部类的创建需要依赖外围类的创建*/ OuterClass.InnerClass_2 inner_2 = new OuterClass().new InnerClass_2(); System.out.println(inner_2.name_2); inner_2.innerFun_2(); &#125; public static void main(String[] args) &#123; OuterClass outer = new OuterClass(); outer.outerFun_2(); &#125;&#125;/**Output: Outer--Functon--2 Inner_lemon_1 InnerFun_1---&gt;OuterClass name: lemon InnerClass-name-1: Inner_lemon_1--- InnerClass-alies-1: Abel Inner_lemon_2 Outer--Function--1 InnerClass-name-2: Inner_lemon_2*/ 匿名内部类匿名内部类的使用 其实匿名内部类就是局部内部类 匿名内部类由于没有名字，所以它的创建方式有点儿奇怪。创建格式如下： 1234new 父类构造器（参数列表）|实现接口（） &#123; //匿名内部类的类体部分 &#125; 在这里我们看到使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。当然这个引用是隐式的。 1234567891011121314151617181920212223242526272829303132333435363738public abstract class Bird &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public abstract int fly();&#125;public class Test &#123; public void test(Bird bird)&#123; System.out.println(bird.getName() + "能够飞 " + bird.fly() + "米"); &#125; public static void main(String[] args) &#123; Test test = new Test(); test.test(new Bird() &#123; public int fly() &#123; return 10000; &#125; public String getName() &#123; return "大雁"; &#125; &#125;); &#125;&#125;/**Output: 大雁能够飞 10000米*/ 在Test类中，test()方法接受一个Bird类型的参数，同时我们知道一个抽象类是没有办法直接new的，我们必须要先有实现类才能new出来它的实现类实例。所以在mian方法中直接使用匿名内部类来创建一个Bird实例。 由于匿名内部类不能是抽象类，所以它必须要实现它的抽象父类或者接口里面所有的抽象方法。 对于这段匿名内部类代码其实是可以拆分为如下形式： 123456789101112public class WildGoose extends Bird&#123; public int fly() &#123; return 10000; &#125; public String getName() &#123; return "大雁"; &#125;&#125;WildGoose wildGoose = new WildGoose();test.test(wildGoose); 在这里系统会创建一个继承自Bird类的匿名类的对象，该对象转型为对Bird类型的引用。 对于匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用。对于上面的实例，如果我们需要对test()方法里面内部类进行多次使用，建议重新定义类，而不是使用匿名内部类。 注意事项 在使用匿名内部类的过程中，我们需要注意如下几点： 1. 使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。 2. 匿名内部类中是不能定义构造函数的。 3. 匿名内部类中不能存在任何的静态成员变量和静态方法。 4. 匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。 5. 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。 使用的形参为何要为final 我们给匿名内部类传递参数的时候，若该形参在内部类中需要被使用，那么该形参必须要为final。也就是说：当所在的方法的形参需要被内部类里面使用时，该形参必须为final。 为什么必须要为final呢？ 首先我们知道在内部类编译成功后，它会产生一个class文件，该class文件与外部类并不是同一class文件，仅仅只保留对外部类的引用。当外部类传入的参数需要被内部类调用时，从java程序的角度来看是直接被调用： 123456789public class OuterClass &#123; public void display(final String name,String age)&#123; class InnerClass&#123; void display()&#123; System.out.println(name); &#125; &#125; &#125;&#125; 直到这里还没有解释为什么是final？在内部类中的属性和外部方法的参数两者从外表上看是同一个东西，但实际上却不是，所以他们两者是可以任意变化的，也就是说在内部类中我对属性的改变并不会影响到外部的形参，而然这从程序员的角度来看这是不可行的，毕竟站在程序的角度来看这两个根本就是同一个，如果内部类该变了，而外部方法的形参却没有改变这是难以理解和不可接受的，所以为了保持参数的一致性，就规定使用final来避免形参的不改变。 简单理解就是，拷贝引用，为了避免引用值发生改变，例如被外部类的方法修改等，而导致内部类得到的值不一致，于是用final来让该引用不可改变。 故如果定义了一个匿名内部类，并且希望它使用一个其外部定义的参数，那么编译器会要求该参数引用是final的。]]></content>
      <categories>
        <category>Java_Base</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础（五）]]></title>
    <url>%2F2017%2F10%2F11%2FJavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这篇聊的是反射的东西 反射基本原理Reflect引入 Java程序中，许多对象在运行时都会出现两种类型： 编译时类型和运行时类型。例如，Person p = new Student(); 这行代码将会生成一个p变量，该变量的编译时类型为Person，运行时类型则为Student; 除此之外，还有更极端的情况，程序在运行时间接收到外部传入的一个对象，该对象的编译时类型是Object，但程序又需要调用该对象运行时类型的方法。为了解决这些问题，程序需要在运行时发现对象和类的真实信息。 为了解决这个问题，我们有以下两种做法： 1、假设在编译时和运行时都完全知道类型的具体信息，在这种情况下，我们可以直接先使用instanceof运算符进行判断，再利用强制类型转换，将其转换成其运行时类型的变量即可;2、假如在编译时根本无法预知该对象和类可能属于哪些类，程序只能依靠运行时的信息来发现该对象和类的真实信息！！！这就必须使用反射！！！ 当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成这3个步骤，所有有时也把这3个步骤统称为类加载或类初始化类加载，指的是将类的.class文件读入内存，并为之创建一个java.lang.Class对象！！！也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象！！！ 当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成这3个步骤，所有有时也把这3个步骤统称为类加载或类初始化类加载，指的是将类的.class文件读入内存，并为之创建一个java.lang.Class对象！！！也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象！！！！ tips: 类是某一类对象的抽象，类是概念层次的东西。但是，有没有想过:类，本身也是一种对象。 就像我们说概念主要用于定义、描述其他事物，但概念本身也是一种事物，那么概念本身也需要被描述 — 这有点像一个哲学命题。但事实就是这样，每个类是一批具有相同特征的对象的抽象（或者说概念），而系统中所有的类实际上也是实例！！！它们都是java.lang.Class的实例。 类的加载、连接、初始化 一、加载 类的加载，是由类加载器完成。 类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为“系统类加载器”。除此之外，开发者也可以通过ClassLoader基类来创建自己的类加载器。通过使用不同的加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源： 1. 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式 2. 从JAR包加载class文件，这种方式也是很常见的，JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件 3. 通过网络加载class文件 4. 把一个Java源文件动态编译，并执行加载 二、类的连接当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为下面3个阶段： 1. 验证：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致 2. 准备：类准备阶段，则负责为类的静态Field分配内存，并设置默认初始值 3. 解析：将类的二进制数据中的符号引用替换成直接引用 三、类的初始化 在类的初始化阶段，虚拟机负责对类进行初始化，主要就是对静态Field进行初始化。在java类中对静态Field指定初始值有两种方式： 1. 声明静态Field时指定初始值 2. 使用静态初始化块为静态Field指定初始值 其他 声明变量时指定初始值，静态初始化块都将被当成类的初始化语句。JVM会按这些语句在程序中的排列顺序依次执行它们： 1. 假如这个类还没有加载和连接，则程序先加载并连接该类 2. 假如该类的直接父类还没有被初始化，则先初始化其直接父类（系统对直接父类的初始化步骤也遵循1~3步骤。JVM最先初始化的总是java.lang.Object类） 3. 假如类中有初始化语句，则系统依次执行这些初始化语句 类初始化的时机当Java程序首次通过下面6种方式来使用某个类或接口时，系统就会初始化该类或接口 1. 创建类的实例。为某个类创建实例的方式包括：使用new关键字来创建实例；通过反射来创建实例；通过反序列化的方式来创建实例 2. 调用某个类的静态方法 3. 访问某个类或借口的静态Field，或为该静态Field赋值 4. 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象。例如：Class.forName(&quot;Person&quot;); 如果系统还未初始化 Person类，这行代码将会导致该Person类被初始化，并返回Person类对应的java.lang.Class对象。 5. 初始化某个类的子类。当初始化某个类的子类时，该子类的所有父类都会被初始化 6. 直接使用java.exe命令来运行某个主类。当运行某个主类时，程序会先初始化该主类 Except：对于一个final型的静态Field，如果该Field的值在编译时就可以确定下来，那么这个Field相当于“宏变量”。Java编译器 会在编译时直接把这个Field出现的地方替换成它的值，因此即使程序使用该静态Field（相当于使用常量），也不会导致该类的初始化 获得Class对象 （实例化Class类对象）每个类被加载之后，系统都会为该类生成一个对应的Class对象，通过该Class对象就可以访问到JVM中的这个类。在Java程序中获得Class对象通常有以下3种方式： 1. 使用Class类的forName(String clazzName)静态方法。该方法需要传入字符串参数，该字符串参数的值是某个类的全限定类名（必须添加完整包名）. 2. 调用某个类的class属性来获取该类对应的Class对象。例如，Person.class将会返回Person类对应的Class对象. 3. 调用某个对象的getClass()方法。该方法是java.lang.Object类中的一个方法，所以所有的Java对象都可以调用该方法，该方法返回该对象所属类对应的Class对象. Class类API1234567891011121314package org.forfan06.getclassdemo; class X&#123; &#125; public class GetClassDemo01&#123; public static void main(String args[])&#123; X x = new X(); System.out.println(x.getClass().getName()); &#125; &#125; /**Output: org.forfan06.getclassdemo.X*/ 所有类的对象实际上都是Class类的实例！！在Java中Object类是所有类的父类，所有类的对象实际上也都是java.lang.Class类的实例；所有的对象都可以转变为java.lang.Class类型表示。 在定义Class类时也使用了泛型声明。为了不让程序出现警告信息，可以指定好其操作的泛型类型。 （一）获取Class对应类所包含的构造器 Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes): 返回此Class对象对应类的指定public构造器 Constructor&lt;?&gt;[] getConstructors(): 返回此Class对象对应类的所有public构造器 Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;...parameterTypes): 返回此Class对象对应类的指定构造器，与构造器的访问权限无关 Constructor&lt;?&gt;[] getDeclaredConstructors(): 返回此Class对象对应类的所有构造器，与构造器的访问权限无关。 （二）获取Class对应类所包含的方法 Method getMethod(String name, Class&lt;?&gt;...parameterTypes): 返回此Class对象对应类的指定public方法 Method[] getMethods(): 返回此Class对象所表示的类的所有public方法 Method getDeclaredMethod(String name, Class&lt;?&gt;...parameterTypes): 返回此Class对象对应类的指定方法，与方法的访问权限无关 Method[] getDeclaredMethods(): 返回此Class对象对应类的全部方法，与方法的访问权限无关 （三）访问Class对应类所包含的Field Field getField(String name): 返回此Class对象对应类的指定public Field Field[] getFields(): 返回此Class对象对应类的所有public Field Field getDeclaredField(String name): 返回此Class对象对应类的指定Field，与Field的访问权限无关 Field[] getDeclaredFields(): 返回此Class对象对应类的全部Field，与Field的访问权限无关 （四）访问Class对应类上所包含的Annotation &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass): 试图获取该Class对象对应类上指定类型的Annotation；如果该类型的注释不存在，则返回null Annotation[] getAnnotations(): 返回该Class对象对应类上的所有Annotation Annotation[] getDeclaredAnnotations(): 返回直接修饰该Class对应类的所有Annotation （五）访问Class对象对应类包含的内部类 Class&lt;?&gt;[] getDeclaredClasses(): 返回该Class对象对应类里包含的全部内部类 （六）访问Class对象对应类所在的外部类 Class&lt;?&gt; getDeclaringClass(): 返回该Class对象对应类所在的外部类 （七）访问该Class对象对应类所继承的父类、所实现的接口等 Class&lt;?&gt;[] getInterfaces(): 返回该Class对象对应类所实现的全部接口 （八）访问该Class对象对应类所继承的父类 Class&lt;? super T&gt; getSuperclass(): 返回该Class对象对应类的超类的Class对象 （九）获取Class对象对应类的修饰符、所在包、类名等基本信息 int getModifiers(): 返回此类或接口的所有修饰符。修饰符由public、protected、private、final、static、abstract等对应的常量组成；返回的整数应使用Modifier工具类的方法来解码，才可以获取真实的修饰符。 Package getPackage(): 获取此类的包 String getName(): 以字符串形式返回此Class对象所表示的类的名称 String getSimpleName(): 以字符串形式返回此Class对象所表示的类的简称 （十）判断Class对象对应类是否为接口、枚举、注释类型等等 boolean isAnnotation(): 返回此Class对象是否表示一个注释类型（由@interface定义） boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass): 判断此Class对象是否使用了Annotation注释修饰 boolean isAnonymousClass(): 返回此Class对象是否是一个匿名类 boolean isArray(): 返回此Class对象是否表示一个数组类 boolean isEnum(): 返回此Class对象是否表示一个枚举（由enum关键字定义） boolean isInterface(): 返回此Class对象是否表示一个接口（由interface定义） boolean isInstance(Object obj): 判断obj是否是此Class对象的实例，该方法完全可以代替instanceof操作符 上面的多个getMethod()方法和getConstructor()方法中，都需要传入多个类型为Class&lt;?&gt;的参数，用于获取指定的方法或指定的构造器。关于这个参数的作用，假设某个类中包含如下3个info方法签名： public void info() public void info(String str) public void info(String str, Integer num) 这3个同名方法属于重载，它们的方法名相同，但参数列表不同。在Java语言中要确定一个方法光有方法名师不行的。如果需要确定一个方法，应该由方法名和形参列表来确定，但形参名没有任何实际意义，所以只能由形参类型来确定。 Class类的使用了解了Class类的实例化过程（3种实例化Class类对象的方法： forName(String name)、className.class、object.getClass()）后， 我们又该如何去使用Class类呢？？？实际上Class类在开发中最常见的用法就是实例化对象的操作，即可以通过一个给定的字符串（此字符串包含了完整的“ 包.类名 ” 的路径）来实例化一个类的对象 通过发生来生成对象有如下两种方式： 1. 使用Class对象的newInstance()方法来创建该Class对象对应类的实例， 这种方式要求：该Class对象的对应类中有默认构造器 （无参构造方法），而，执行newInstance()方法时，实际上是利用默认构造器（无参构造方法）来创建该类的实例 2. 先使用Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建该Class对象对应类的实 例。通过这种方式可以选择使用指定的构造器来创建实例。 可以跟上形参类型列表。 通过第一种方式来创建对象是比较常见的情形，因为在很多Java EE框架中都需要根据配置文件信息来创建对象，从配置文件读取的只是某个类的字符串类名，程序需要根据该字符串来创建对象的实例，就必须使用反射。 通过无参构造，也就是Class.forName() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ObjectPoolFactory&#123; //定义一个对象池，前面是对象名，后面是实例对象 private Map&lt;String, Object&gt; objectPool = new HashMap&lt;&gt;(); //定义一个创建对象的方法 //该方法只要传入一个字符串类名，程序可以根据该类名生成Java对象 private Object createObject(String clazzname) throws InstantiationException, IllegalAccessException, ClassNotFoundException&#123; //根据字符串来获取对象的Class对象 Class&lt;?&gt; clazz = Class.forName(clazzname); return clazz.newInstance(); //通过Class对象的默认构造器创建对象，并返回 &#125; //该方法根据指定文件来初始化对象池 //它会根据配置文件来创建对象 public void initPool(String filename) throws InstantiationException, IllegalAccessException, ClassNotFoundException&#123; try( FileInputStream input = new FileInputStream(filename) )&#123; Properties pros = new Properties(); pros.load(input); for(String name: pros.stringPropertyNames())&#123; //每取出一个对key-value，就根据value创建一个对象 //调用createObject方法创建对象，并将对象添加到对象池中 objectPool.put(name, createObject(pros.getProperty(name))); &#125; &#125;catch(IOException e)&#123; e.printStackTrace(); &#125; &#125; public Object getObject(String name)&#123; //从objectPool中取出指定name对应的对象 return objectPool.get(name); &#125; public static void main(String args[]) throws Exception&#123; ObjectPoolFactory pf = new ObjectPoolFactory(); pf.initPool("obj.txt"); System.out.println(pf.getObject("a")); System.out.println(pf.getObject("b")); &#125; &#125; /**当obj.txt里面的内容是a=java.util.Dateb=java.text.SimpleDateFormat运行结果如下： Mon Sep 01 14:28:44 CST 2014 java.text.SimpleDateFormat@a9427c06 分析： createObject()拿到类的名字，得到Class对象，在实例化类对象。 initPool()读Properties文件（里面都是键值对），给HashMap赋值 getObject()，从HashMap中通过key取对象*/ 通过有参构造方法，实例化对象 如果不想利用默认构造器来创建Java对象，而想利用指定的构造器来创建Java对象，则需要利用Constructor对象，每个Constructor对应一个构造器。为了利用指定的构造器来创建Java对象，在操作时需要明确地调用类中的构造方法，并将参数传递进去之后才可以进行实例化操作。操作步骤如下： 1. 获取该类的Class对象。（通过Class类中的getConstructors()方法取得本类中的全部构造方法） 2. 利用Class对象的getConstructors()方法来获取指定的构造器。 （向构造方法中传递一个对象数组进去，里面包含了构造方法中所需的各个参数） 3. 调用Constructor的newInstance()方法来创建Java对象。 （通过Constructor实例化对象） 12345678910111213141516171819202122public class CreateJFrame&#123; public static void main(String args[]) throws Exception&#123; //获取JFrame对应的class对象 Class&lt;?&gt; jframeClazz = Class.forName("javax.swing.JFrame"); //获取JFrame中带一个字符串参数的构造器 //通过Class类中的方法：class.getConstructor(Class&lt;?&gt;...parameterTypes) Constructor&lt;?&gt; ctor = jframeClazz.getConstructor(String.class); //调用Constructor的newInstance()方法创建对象 Object obj = ctor.newInstance("测试窗口"); //输出JFrame对象 System.out.println(obj); &#125; &#125; /**Output: javax.swing.JFrame[frame0,0,0,0x0,invalid,hidden,layout=java.awt.BorderLayout,title=测试窗口,resizable,normal,defaultCloseOperation=HIDE_ON_CLOSE,rootPane=javax.swing.JRootPane[,0,0,0x0,invalid,layout=javax.swing.JRootPane$RootL分析：如果要唯一地确定某个类中的构造器，只要指定构造器的形参列表即可。在获取构造器时传入了一个String类型，表明想获取只有一个字符串参数的构造器。使用指定构造器的newInstance()方法来创建一个Java对象，当调用Constructor对象的newInstance()方法时通常需要传入参数，因为调用Constructor的newInstance()方法实际上等于调用了它对应的构造器，传给newInstance()方法的参数将作为对应构造器的参数！！！*/ 测试： 12345678package jse_3;public interface China &#123; public static final String NATIONAL = "China"; public static final String AUTHOR = "AbelChao"; public void sayChinese(); public String sayHello(String name,int age);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243package jse_3;public class Person implements China&#123; private String name; private int age; public Person() &#123; super(); &#125; public Person(String name)&#123; this.name = name; &#125; public Person(String name,int age)&#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public void sayChinese() &#123; System.out.println("国籍： "+China.AUTHOR+" 作者： "+China.NATIONAL); &#125; @Override public String sayHello(String name, int age) &#123; return name+"..."+age; &#125; @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + "]"; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package jse_3;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;public class ReflectTest &#123; public static void main(String[] args) throws InstantiationException, IllegalAccessException, NoSuchMethodException, SecurityException, IllegalArgumentException, InvocationTargetException &#123; Class&lt;?&gt; clazz = null; try &#123; clazz = Class.forName("jse_3.Person"); //获得父类 Class&lt;?&gt; superClass = clazz.getSuperclass(); System.out.println(superClass); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; Person p = (Person) clazz.newInstance(); System.out.println(p); //获取所有的接口 Class&lt;?&gt;[] interfaces = clazz.getInterfaces(); for (Class&lt;?&gt; c : interfaces) &#123; System.out.println(c.getName()); &#125; //获得所有的构造方法 Constructor&lt;?&gt;[] cons = clazz.getConstructors(); for (Constructor&lt;?&gt; constructor : cons) &#123; System.out.println(constructor.getName()+"("+constructor.getParameterCount()+")"); &#125; clazz.getMethod("sayChinese").invoke(p); clazz.getMethod("sayHello", String.class,int.class).invoke(p,"AbelChao",22); &#125;&#125;/**Output: class java.lang.Object Person [name=null, age=0] jse_3.China jse_3.Person(0) jse_3.Person(2) jse_3.Person(1) 国籍： AbelChao 作者： China AbelChao..22*/]]></content>
      <categories>
        <category>Java_Base</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础（四）]]></title>
    <url>%2F2017%2F10%2F11%2FJavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节聊我们的抽象类。抽象方法、接口 抽象类和抽象方法 定义与注意点抽象方法：使用abstract关键字修饰，同时方法没有方法体（也就是没有{}）抽象类：含有抽象方法的类，就是抽象类（但是抽象类中也可以没有抽象方法，用关键字abstract修饰） 在使用抽象类和抽象方法的时候需要注意： 1. 抽象类不能被实例化，也就是不能直接用关键字new去产生对象 2. 抽象类的子类必须覆盖抽象类中所有的抽象方法后，才可以被实例化，不然就也还是一个抽象类 3. 抽象类和普通雷一样，有构造方法，一般方法、属性，抽象方法 4. 抽象类中一旦声明（写出来了而不是没写状态下的默认）了构造方法，在子类中必须对其明确调用。 5. 构造方法、私有方法、final修饰的方法不能声明为抽象方法 6. 构造方法只能被public protect private修饰；抽象方法只能被public、protected修饰 测试12345678910111213141516171819202122232425262728293031323334353637383940测试一：（默认构造方法）public abstract class Person &#123; String name="Abel"; public abstract String talk(); public String speak()&#123; return "P's Lemon"; &#125;&#125;class Student extends Person&#123; String name="Chao"; @Override public String talk() &#123; return "Stu: "+this.name; &#125; public String speak()&#123; return "Stu's Lemon"; &#125;&#125;class test&#123; public static void main(String[] args) &#123; Person p = new Student(); Student stu = new Student(); System.out.println(stu.talk()+"..."+stu.speak()+"..."+stu.name); System.out.println("-------------------------------"); System.out.println(p.talk()+"..."+p.speak()+"..."+p.name); &#125;&#125;/**Output： Stu: Chao...Stu's Lemon...Chao ----&gt;一旦子类中没有name字段，那么就会输出父类的 ------------------------------- Stu: Chao...Stu's Lemon...Abel*/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364测试二：（父类中直接声明了有参构造而没有声明无参构造，这样也就是直接把无参构造的函数抹掉了）public abstract class Person &#123; String name="Abel"; /*public Person() &#123; super(); &#125;*/ public Person(String name) &#123; this.name = name; &#125; public abstract String talk(); public String speak()&#123; return "P's Lemon"; &#125;&#125;class Student extends Person&#123; String name="Chao"; public Student(String name) &#123; super(name); &#125; @Override public String talk() &#123; return "Stu: "+this.name; &#125; public String speak()&#123; return "Stu's Lemon"; &#125;&#125;class test&#123; public static void main(String[] args) &#123; Person p = new Student("cc"); Student stu = new Student("tt"); System.out.println(stu.talk()+"..."+stu.speak()+"..."+stu.name); System.out.println("-------------------------------"); System.out.println(p.talk()+"..."+p.speak()+"..."+p.name); &#125;&#125;/**Output： Stu: Chao...Stu's Lemon...Chao ------------------------------- Stu: Chao...Stu's Lemon...ccAnalysis:main方法中第一条语句是一个多态，父类对象指向子类引用（Person是抽象的，不能直接new），第二条就是简单的实例化对象。第一条输出，stu中必须重写talk方法，而this也指的当前对象，也就是实例化时左边的类对象，子类中name就是Chao，接着就是子类自己的speak方法（自己有，不必向上转型）最后是stu对象的name，当然也就是Chao（有参构造中并没有去设置this.name=name）.接下来的输出，p的talk方法，p变量的引用类是一个抽象的，方法也是抽象的，就走了子类的实现，p.speak就是典型的多态重写，最后的p.name，是因为我们的new Student("cc"),有参构造中的语句是super(name),直接到了父类的有参构造，而在父类的有参构造中却有this.name = name，所以也就改变了p变量的全局name值为参数name值，输出了cc同样的，一旦我们在子类的有参构造中加入了this.name = name;name我们的第二条语句，就会改变stu的name，也就是输出为： Stu: Chao...Stu's Lemon...tt ------------------------------- Stu: Chao...Stu's Lemon...cc*/ 也就有了这么一句话：抽象类中可以包含非抽象方法，但是一旦包含了抽象方法，那么这个类一定是抽象类！！！ 抽象类和接口抽象类前面也说过了，直接上一个代码再看一下抽象类：12345678910111213141516171819202122232425262728293031323334353637public abstract class Animal &#123; public abstract void cry();&#125;public class Cat extends Animal&#123; @Override public void cry() &#123; System.out.println("猫叫：喵喵..."); &#125;&#125;public class Dog extends Animal&#123; @Override public void cry() &#123; System.out.println("狗叫:汪汪..."); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Animal a1 = new Cat(); Animal a2 = new Dog(); a1.cry(); a2.cry(); &#125;&#125;/**Output: 猫叫：喵喵... 狗叫:汪汪...*/ 接 口接口是一种比抽象类更加抽象的“类”。这里给“类”加引号是我找不到更好的词来表示，但是我们要明确一点就是，接口本身就不是类，从我们不能实例化一个接口就可以看出。如new Runnable();肯定是错误的，我们只能new它的实现类。 接口是抽象类的延伸，java了保证数据安全是不能多重继承的，也就是说继承只能存在一个父类，但是接口不同，一个类可以同时实现多个接口，不管这些接口之间有没有关系，所以接口弥补了抽象类不能多重继承的缺陷，但是推荐继承和接口共同使用，因为这样既可以保证数据安全性又可以实现多重继承。 在使用接口过程中需要注意如下几个问题： 1、一个Interface的方所有法访问权限自动被声明为public。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错！ 2、接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name。 3、接口中不存在实现的方法，只有声明，没有定义。 4、实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现。 5、不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用（refer to)一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现了某个特定的接口。例如：if(anObject instanceof Comparable){}。 6、在实现多接口的时候一定要避免方法名的重复。 接口和抽象类的区别抽象类方式中，抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法，但是接口方式中，它仅能够有静态、不能修改的成员数据（但是我们一般是不会在接口中使用成员数据），同时它所有的方法都必须是抽象的。在某种程度上来说，接口是抽象类的特殊化。 1、 抽象层次不同。抽象类是对类抽象，而接口是对行为的抽象。2、 跨域不同。抽象类所体现的是一种继承关系，要想使得继承关系合理，父类和派生类之间必须存在”is-a” 关系，即父类和派生类在概念本质上应该是相同的。对于接口则不然，并不要求接口的实现者和接口定义在概念本质上是一致的， 仅仅是实现了接口定义的契约而已。3、 设计层次不同。抽象类是自底向上抽象而来的，接口是自顶向下设计出来的。 举例说明：我觉得这个例子真的好！ 我们有一个Door的抽象概念，它具备两个行为open()和close()，此时我们可以定义通过抽象类和接口来定义这个抽象概念：1234567891011抽象类：abstract class Door&#123; abstract void open(); abstract void close()；&#125;接口：interface Door&#123; void open(); void close();&#125;至于其他的具体类可以通过使用extends使用抽象类方式定义Door或者Implements使用接口方式定义Door，这里发现两者并没有什么很大的差异。 但是现在如果我们需要门具有报警的功能，那么该如何实现呢？ 解决方案一：给Door增加一个报警方法:clarm();1234567891011abstract class Door&#123; abstract void open(); abstract void close(); abstract void alarm();&#125;interface Door&#123; void open(); void close(); void alarm();&#125; 这种方法违反了面向对象设计中的一个核心原则 ISP (Interface Segregation Principle)—见批注，在Door的定义中把Door概念本身固有的行为方法和另外一个概念”报警器”的行为方 法混在了一起。这样引起的一个问题是那些仅仅依赖于Door这个概念的模块会因为”报警器”这个概念的改变而改变，反之依然。 解决方案二：既然open()、close()和alarm()属于两个不同的概念，那么我们依据ISP原则将它们分开定义在两个代表两个不同概念的抽象类里面，定义的方式有三种： 1、两个都使用抽象类来定义。 2、两个都使用接口来定义。 3、一个使用抽象类定义，一个是用接口定义。 由于java不支持多继承所以第一种是不可行的。后面两种都是可行的，但是选择何种就反映了你对问题域本质的理解。 如果选择第二种都是接口来定义，那么就反映了两个问题：1、我们可能没有理解清楚问题域，AlarmDoor在概念本质上到底是门还报警器。2、如果我们对问题域的理解没有问题，比如我们在分析时确定了AlarmDoor在本质上概念是一致的，那么我们在设计时就没有正确的反映出我们的设计意图。因为你使用了两个接口来进行定义，他们概念的定义并不能够反映上述含义。 ISP（Interface Segregation Principle）：面向对象的一个核心原则。它表明使用多个专门的接口比使用单一的总接口要好。一个类对另外一个类的依赖性应当是建立在最小的接口上的。一个接口代表一个角色，不应当将不同的角色都交给一个接口。没有关系的接口合并在一起，形成一个臃肿的大接口，这是对角色和接口的污染。 解决方案三：第三种，如果我们对问题域的理解是这样的：AlarmDoor本质上Door，但同时它也拥有报警的行为功能，这个时候我们使用第三种方案恰好可以阐述我们的设计意图。AlarmDoor本质是们，所以对于这个概念我们使用抽象类来定义，同时AlarmDoor具备报警功能，说明它能够完成报警概念中定义的行为功能，所以alarm可以使用接口来进行定义。如下：1234567891011121314abstract class Door&#123; abstract void open(); abstract void close();&#125;interface Alarm&#123; void alarm();&#125;class AlarmDoor extends Door implements Alarm&#123; void open()&#123;&#125; void close()&#123;&#125; void alarm()&#123;&#125;&#125; 总结：1、 抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。2、 在抽象类中可以拥有自己的成员变量和非抽象类方法，但是接口中只能存在静态的不可变的成员数据（不过一般都不在接口中定义成员数据），而且它的所有方法都是抽象的。3、抽象类和接口所反映的设计理念是不同的，抽象类所代表的是“is-a”的关系，而接口所代表的是“like-a”的关系。]]></content>
      <categories>
        <category>Java_Base</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础（三）]]></title>
    <url>%2F2017%2F10%2F11%2FJavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节聊继承、多态、封装 继承 继承所描述的是“is-a”的关系，如果有两个对象A和B，若可以描述为“A是B”，则可以表示A继承B，其中B是被继承者称之为父类或者超类，A是继承者称之为子类或者派生类。 同时在使用继承时需要记住三句话： 1、子类拥有父类非private的属性和方法。 2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。 3、子类可以用自己的方式实现父类的方法。（以后介绍）。 继承中的构造器12345678910111213141516171819202122232425public class Person &#123; protected String name; protected int age; protected String sex; Person()&#123; System.out.println("Person Constrctor..."); &#125;&#125;public class Husband extends Person&#123; private Wife wife; Husband()&#123; System.out.println("Husband Constructor..."); &#125; public static void main(String[] args) &#123; Husband husband = new Husband(); &#125;&#125;Output:Person Constrctor...Husband Constructor... 通过这个示例可以看出，构建过程是从父类“向外”扩散的，也就是从父类开始向子类一级一级地完成构建。而且我们并没有显示的引用父类的构造器，这就是java的聪明之处：编译器会默认给子类调用父类的构造器。 但是，这个默认调用父类的构造器是有前提的：父类有默认构造器。如果父类没有默认构造器，我们就要必须显示的使用super()来调用父类构造器，否则编译器会报错：无法找到符合父类形式的构造器。1234567891011121314151617181920212223242526public class Person &#123; protected String name; protected int age; protected String sex; Person(String name)&#123; System.out.println("Person Constrctor-----" + name); &#125;&#125;public class Husband extends Person&#123; private Wife wife; Husband()&#123; super("chenssy");//重点理解这里 System.out.println("Husband Constructor..."); &#125; public static void main(String[] args) &#123; Husband husband = new Husband(); &#125;&#125;Output:Person Constrctor-----chenssyHusband Constructor... 对于继承而已，子类会默认调用父类的构造器，但是如果没有默认的父类构造器(无参)，子类必须要显示的指定父类的构造器，而且必须是在子类构造器中做的第一件事(第一行代码)。 protected关键字 对于protected而言，它指明就类用户而言，他是private，但是对于任何继承与此类的子类而言或者其他任何位于同一个包的类而言，他却是可以访问的。12345678910111213141516171819202122232425262728293031323334353637public class Person &#123; private String name; private int age; private String sex; protected String getName() &#123; return name; &#125; protected void setName(String name) &#123; this.name = name; &#125; public String toString()&#123; return "this name is " + name; &#125; /** 省略其他setter、getter方法 **/&#125;public class Husband extends Person&#123; private Wife wife; public String toString()&#123; setName("chenssy"); //调用父类的setName(); return super.toString(); //调用父类的toString()方法 &#125; public static void main(String[] args) &#123; Husband husband = new Husband(); System.out.println(husband.toString()); &#125;&#125;Output：this name is chenssy 向上转型12345678910111213141516171819public class Person &#123; public void display()&#123; System.out.println("Play Person..."); &#125; static void display(Person person)&#123; person.display(); &#125;&#125;public class Husband extends Person&#123; public static void main(String[] args) &#123; Husband husband = new Husband(); Person.display(husband); //向上转型 &#125;&#125;Output: Play Person... 在这我们通过Person.display(husband)。这句话可以看出husband是person类型。 将子类转换成父类，在继承关系上面是向上移动的，所以一般称之为向上转型。由于向上转型是从一个叫专用类型向较通用类型转换，所以它总是安全的，唯一发生变化的可能就是属性和方法的丢失。这就是为什么编译器在“未曾明确表示转型”活“未曾指定特殊标记”的情况下，仍然允许向上转型的原因。 多态（重载、重写—补充）多态：指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。 1234567891011121314151617181920212223242526272829303132333435class Wine&#123; public void fun1()&#123; System.out.println("Wine的Fun1"); fun2(); &#125; public void fun2()&#123; System.out.println("Wine的Fun2"); &#125;&#125;class JNC extends Wine&#123; public void fun1(String str)&#123; System.out.println("JNC的Fun1"); &#125; public void fun2()&#123; System.out.println("JNC的Fun2"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Wine wine = new JNC(); wine.fun1(); wine.fun2(); &#125;&#125;/**输出： Wine的Fun1 JNC的Fun2 JNC的Fun2分析： Wine创建的父类对象(wine，这是个父类对象！！！)指向子类引用，因为我们的子类中并没有重写fun1(),所以走的是父类的fun1(),但是在fun1()中调用fun2()的方法时，因为在子类中重写了，所以直接调用的是子类中fun2()*/ 多态的实现条件 Java实现多态有三个必要条件：继承、重写、向上转型。 对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。 实现形式在Java中有两种形式可以实现多态。继承和接口。 1. 基于继承实现的多态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Wine&#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Wine() &#123; &#125; public String drink()&#123; return "喝的是 "+getName(); &#125; public String toString() &#123; return "Wine [name=" + name + "]"; &#125;&#125;class JNC extends Wine&#123; public JNC()&#123; setName("JNC"); &#125; public String drink()&#123; return "喝的是 "+getName(); &#125; public String toString() &#123; return "JNC :"+getName(); &#125;&#125;class JGJ extends Wine&#123; public JGJ()&#123; setName("JGJ"); &#125; public String drink()&#123; return "喝的是 " + getName(); &#125; public String toString()&#123; return "JGJ :" + getName(); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Wine jnc = new JNC(); Wine jgj = new JGJ(); System.out.println(jnc.toString()+": "+jnc.drink()); System.out.println(jgj.toString()+": "+jgj.drink()); System.out.println("-------------------------------"); &#125;&#125;/**输出： JNC :JNC: 喝的是 JNC JGJ :JGJ: 喝的是 JGJ -------------------------------分析： 我们创建的是两个父类对象，指向了两个子类引用，但是父类中的方法都被子类所重写，所以，虽然调用的是父类的方法，但是使用的却是子类的方法实体*/ 2. 基于接口实现的多态 继承是通过重写父类的同一方法的几个不同子类来体现的，那么就可就是通过实现接口并覆盖接口中同一方法的几不同的类体现的。 在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法。 测试用例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class A &#123; public String show(D obj) &#123; return ("A and D"); &#125; public String show(A obj) &#123; return ("A and A"); &#125; &#125;class B extends A&#123; public String show(B obj)&#123; return ("B and B"); &#125; public String show(A obj)&#123; return ("B and A"); &#125; &#125;class C extends B&#123;&#125;class D extends B&#123;&#125;public class Test &#123; public static void main(String[] args) &#123; A a1 = new A();//正常的父类对象 A a2 = new B();//多态 B b = new B(); C c = new C(); D d = new D(); System.out.println("1--" + a1.show(b)); System.out.println("2--" + a1.show(c)); System.out.println("3--" + a1.show(d)); System.out.println("4--" + a2.show(b)); System.out.println("5--" + a2.show(c)); System.out.println("6--" + a2.show(d)); System.out.println("7--" + b.show(b)); System.out.println("8--" + b.show(c)); System.out.println("9--" + b.show(d)); &#125;&#125;/**输出： 1--A and A 2--A and A 3--A and D 4--B and A 5--B and A 6--A and D 7--B and B 8--B and B 9--A and D*/ 重新分析我们代码的执行顺序(继承，静态块，构造快，构造方法，一般方法，多态之间的顺序)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105测试一：class Person&#123; String name; int age; //Student stu = new Student(); //Person stu = new Student(); &#123; System.out.println("父类的构造块"); &#125; static&#123; System.out.println("父类的静态块"); &#125; Person()&#123; System.out.println("父类的无参构造"); &#125; Person(String name,int age)&#123; this.name = name; this.age = age; System.out.println("父类的有参构造器"); &#125; public void eat()&#123; System.out.println("父类吃饭"); &#125; public void fun()&#123; System.out.println("父类的fun方法"); &#125;&#125;public class Student extends Person&#123; int grade; //Student stu = new Student(); //Person p = new Student(); &#123; System.out.println("子类构造快"); &#125; static &#123; System.out.println("子类静态块"); &#125; Student()&#123; //super(); System.out.println("子类的无参构造"); &#125; Student(String name,int age,int grade)&#123; //super(name,age) this.grade = grade; System.out.println("子类有参构造： "+name+".."+age+".."+grade); &#125; public void eat()&#123; System.out.println("子类吃饭"); &#125; public void fun()&#123; System.out.println("子类的fun方法"); &#125; public static void main(String[] args) &#123; System.out.println("子类Main方法"); Student s1 = new Student(); s1.fun();//fun()的会报错，因为main是个静态方法，静态方法中不能有非静态的东西 Student s2 = new Student("张三",19,99); Person p = new Person(); s1.eat(); s2.eat(); &#125;&#125;/**输出： 父类的静态块 子类静态块 子类Main方法 父类的构造块 父类的无参构造 子类构造快 子类的无参构造 子类的fun方法 父类的构造块 父类的无参构造 子类构造快 子类有参构造： 张三..19..99 父类的构造块 父类的无参构造 子类吃饭 子类吃饭分析： Main方法在Student类中，先加载Student类，但是Student类继承了我们的Person类，所以要先加载Person，所以先执行了Person中的静态块，再执行Student中的静态块，静态块执行完之后我们开始执行我们的Main方法，所以输出了Main方法中的第一句话，接着加载了我们的Student对象实例化，因为两个类都已经记载，所以静态块不再执行，开始执行父类的构造块，父类的无参构造函数，父类执行完成后，执行子类的构造块，子类的无参构造函数，接着Main方法的下一条语句，接着又开始实例化子类（有参），所以，加载父类的构造块，加载父类的无参构造块，父类加载完成后，加载子类构造块，子类有参构造（这里注意！！一旦我们有了父类的无参构造，那么子类不管是什么构造，初始化的时候都要执行父类的无参构造！！一旦我们删掉父类的无参构造，程序会直接报错）接着就是程序的顺序执行了！！！*/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100测试二：（把Main方法放到父类中，其他不变）class Person&#123; String name; int age; //Student stu = new Student(); //Person stu = new Student(); &#123; System.out.println("父类的构造块"); &#125; static&#123; System.out.println("父类的静态块"); &#125; Person()&#123; System.out.println("父类的无参构造"); &#125; Person(String name,int age)&#123; this.name = name; this.age = age; System.out.println("父类的有参构造器"); &#125; public void eat()&#123; System.out.println("父类吃饭"); &#125; public void fun()&#123; System.out.println("父类的fun方法"); &#125; public static void main(String[] args) &#123; System.out.println("父类Main方法"); Student s1 = new Student(); s1.fun();//fun()的会报错，因为main是个静态方法，静态方法中不能有非静态的东西 Student s2 = new Student("张三",19,99); Person p = new Person(); s1.eat(); s2.eat(); p.fun(); &#125;&#125;public class Student extends Person&#123; int grade; //Student stu = new Student(); //Person p = new Student(); &#123; System.out.println("子类构造快"); &#125; static &#123; System.out.println("子类静态块"); &#125; Student()&#123; //super(); System.out.println("子类的无参构造"); &#125; Student(String name,int age,int grade)&#123; //super(name,age) this.grade = grade; System.out.println("子类有参构造： "+name+".."+age+".."+grade); &#125; public void eat()&#123; System.out.println("子类吃饭"); &#125; public void fun()&#123; System.out.println("子类的fun方法"); &#125;&#125;/**输入： 父类的静态块 父类Main方法 子类静态块 父类的构造块 父类的无参构造 子类构造快 子类的无参构造 子类的fun方法 父类的构造块 父类的无参构造 子类构造快 子类有参构造： 张三..19..99 父类的构造块 父类的无参构造 子类吃饭 子类吃饭 父类的fun方法分析： 和上面的不同就在于，我先加载的是父类，然后直接进入了父类的Main方法*/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107测试三：引入多态class Person&#123; String name; int age; //Student stu = new Student(); //Person stu = new Student(); &#123; System.out.println("父类的构造块"); &#125; static&#123; System.out.println("父类的静态块"); &#125; Person()&#123; System.out.println("父类的无参构造"); &#125; Person(String name,int age)&#123; this.name = name; this.age = age; System.out.println("父类的有参构造器"); &#125; public void eat()&#123; System.out.println("父类吃饭"); &#125; public void fun()&#123; System.out.println("父类的fun方法"); &#125;&#125;public class Student extends Person&#123; int grade; //Student stu = new Student(); //Person p = new Student(); &#123; System.out.println("子类构造快"); &#125; static &#123; System.out.println("子类静态块"); &#125; Student()&#123; //super(); System.out.println("子类的无参构造"); &#125; Student(String name,int age,int grade)&#123; //super(name,age) this.grade = grade; System.out.println("子类有参构造： "+name+".."+age+".."+grade); &#125; public void eat()&#123; System.out.println("子类吃饭"); &#125; public void fun()&#123; System.out.println("子类的fun方法"); &#125; public static void main(String[] args) &#123; System.out.println("子类Main方法"); Person p1 = new Student(); p1.fun(); Person p2 = new Student("张三",23,99); p2.eat(); Person p3 = new Person(); p2.fun(); Student stu = new Student(); p2.eat(); &#125;&#125;/**输出： 父类的静态块 子类静态块 子类Main方法 父类的构造块 父类的无参构造 子类构造快 子类的无参构造 子类的fun方法 父类的构造块 父类的无参构造 子类构造快 子类有参构造： 张三..23..99 子类吃饭 父类的构造块 父类的无参构造 子类的fun方法 父类的构造块 父类的无参构造 子类构造快 子类的无参构造 子类吃饭分析： Main方法在子类中，先加载子类，加载子类的前需要先加载父类，也就先加载了父、子类中的静态块，然后进入子类的Main方法，顺序执行，一个多态，其实还是new的子类，所以先加载父类的构造块和无参构造函数，接着加载子类的构造块和无参构造函数，顺序执行，fun方法在子类中被重写，所以执行的是子类的方法，接着就和测试一的分析大致相同了*/ 综上所述，java中子类继承父类程序各成员的执行顺序应该是：父类的静态代码块—&gt;子类的静态代码块—&gt;主方法（执行哪个程序就执行哪个程序的主方法）—&gt;父类的非静态代码块—&gt;父类的无参构造函数—&gt;子类的非静态代码块—&gt;子类的无参构造函数（若实际子类执行的是有参构造函数，则不执行无参构造函数）—&gt;成员函数（指定执行哪个就执行哪个成员函数，若重写了父类成员函数，则只执行子类的成员函数） 封装封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。系统的其他对象只能通过包裹在数据外面的已经授权的操作来与这个封装的对象进行交流和交互。也就是说用户是无需知道对象内部的细节（当然也无从知道），但可以通过该对象对外的提供的接口来访问该对象。 对于封装而言，一个对象它所封装的是自己的属性和方法，所以它是不需要依赖其他对象就可以完成自己的操作。 使用封装有三大好处： 1、良好的封装能够减少耦合。 2、类内部的结构可以自由修改。 3、可以对成员进行更精确的控制。 4、隐藏信息，实现细节。]]></content>
      <categories>
        <category>Java_Base</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础（二）]]></title>
    <url>%2F2017%2F10%2F10%2FJavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这一节聊聊类，其实就是静态块、构造块、构造函数、一般块的执行顺序 关于类 构造器构造器是一个创建对象时被自动调用的特殊方法，为的是初始化。构造器的名称应与类的名称一致。当创建一个个对象时，系统会该对象的属性默认初始化，基本类型属性的值为0（数值类型），false（布尔类型），把所有的引用类型设置为null.构造器可以改变这种默认的初始化。构造器的作用：是创建java对象的重要途径，是不是说构造器完全负责创建java对象？答：是创建java对象的重要途径，通过new关键字调用构造器时，构造器也确实返回了该类的对象，但这个对象并不是完全由构造器负责创建的。首先要注意的是Java的构造器并不是函数，所以他并不能被继承，这在我们extends的时候写子类的构造器时比较的常见，即使子类构造器参数和父类的完全一样，我们也要写super就是因为这个原因。 构造器的修饰符比较的有限，仅仅只有public private protected这三个，其他的例如任何修饰符都不能对其使用，也就是说构造器不允许被成名成抽象、同步、静态等等访问限制以外的形式。 因为构造器不是函数，所以它是没有返回值的，也不允许有返回值。但是这里要说明一下，构造器中允许存在return语句，但是return什么都不返回，如果你指定了返回值，虽然编译器不会报出任何错误，但是JVM会认为他是一个与构造器同名的函数罢了，这样就会出现一些莫名其妙的无法找到构造器的错误，这里是要加倍注意的。 构造的粗略过程如下： 1、分配对象空间，并将对象中成员初始化为0或者空，java不允许用户操纵一个不定值的对象。 2、执行属性值的显式初始化（这里有一点变化，一会解释，但大体是这样的）。 3、执行构造器 4、将变量关联到堆中的对象上 解析关键字Static1. static方法：static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的， 因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法， 因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。 但是要注意的是，虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的。 另外记住，即使没有显示地声明为static，类的构造器实际上也是静态方法。 举个简单的例子： 123456789101112131415161718class Code&#123; private static String str1 = "static"; private String str2 = "nonStatic"; public Code()&#123;&#125; public void T1()&#123; System.out.println(str1); System.out.println(str2); &#125; public static void T2()&#123; System.out.println(str1); //System.out.println(str2); //T1(); //这两句话就直接报错，因为静态方法中不能引用非静态的东西 &#125;&#125; 2. static变量：static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副 本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有 的副本互不影响。 static成员变量的初始化顺序按照定义的顺序进行初始化。 3. static静态块：static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何 地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。 4. 能通过this访问静态成员变量吗？（static是不允许用来修饰局部变量） 12345678910111213141516public class Main &#123; static int value = 33; public static void main(String[] args) throws Exception&#123; new Main().printValue(); &#125; private void printValue()&#123; int value = 3; System.out.println(this.value); &#125;&#125;/**输出： 33*/ 注意：这里面主要考察队this和static的理解。this代表什么？this代表当前对象，那么通过new Main()来调用printValue的话， 当前对象就是通过new Main()生成的对象。而static变量是被对象所享有的，因此在printValue中的this.value的值毫无疑问是33。 在printValue方法内部的value是局部变量，根本不可能与this关联，所以输出结果是33。在这里永远要记住一点：静态成员变量虽然 独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要访问权限足够）。 5. 测试一: 12345678910111213141516171819202122232425262728293031323334353637public class Test extends Base&#123; static&#123; System.out.println("test static"); &#125; public Test()&#123; System.out.println("test constructor"); &#125; public static void main(String[] args) &#123; new Test(); &#125;&#125; class Base&#123; static&#123; System.out.println("base static"); &#125; public Base()&#123; System.out.println("base constructor"); &#125;&#125;/**输出： base static test static base constructor test constructor至于为什么是这个结果，我们先不讨论，先来想一下这段代码具体的执行过程，在执行开始，先要寻找到main方法，因为main方法是程序的入口，但是在执行main方法之前，必须先加载Test类，而在加载Test类的时候发现Test类继承自Base类，因此会转去先加载Base类，在加载Base类的时候，发现有static块，便执行了static块。在Base类加载完成之后，便继续加载Test类，然后发现Test类中也有static块，便执行static块。在加载完所需的类之后，便开始执行main方法。在main方法中执行new Test()的时候会先调用父类的构造器，然后再调用自身的构造器。因此，便出现了上面的输出结果。*/ 6. 测试二：引入，我们构造函数初始化的时候先初始化父类的成员变量，再初始化自己的成员变量，再进入构造函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Test &#123; Person person = new Person("Test"); static&#123; System.out.println("test static"); &#125; public Test() &#123; System.out.println("test constructor"); &#125; public static void main(String[] args) &#123; new MyClass(); &#125;&#125; class Person&#123; static&#123; System.out.println("person static"); &#125; public Person(String str) &#123; System.out.println("person "+str); &#125;&#125; class MyClass extends Test &#123; Person person = new Person("MyClass"); static&#123; System.out.println("myclass static"); &#125; public MyClass() &#123; System.out.println("myclass constructor"); &#125;&#125;/**输出： test static myclass static person static person Test test constructor person MyClass myclass constructor类似地，我们还是来想一下这段代码的具体执行过程。首先加载Test类，因此会执行Test类中的static块。接着执行new MyClass()，而MyClass类还没有被加载，因此需要加载MyClass类。在加载MyClass类的时候，发现MyClass类继承自Test类，但是由于Test类已经被加载了，所以只需要加载MyClass类，那么就会执行MyClass类的中的static块。在加载完之后，就通过构造器来生成对象。而在生成对象的时候，必须先初始化父类的成员变量，因此会执行Test中的Person person = new Person()，而Person类还没有被加载过，因此会先加载Person类并执行Person类中的static块，接着执行父类的构造器，完成了父类的初始化，然后就来初始化自身了，因此会接着执行MyClass中的Person person = new Person()，最后执行MyClass的构造器。*/ 7. 测试三： 1234567891011121314151617181920public class Test &#123; static&#123; System.out.println("test static 1"); &#125; public static void main(String[] args) &#123; &#125; static&#123; System.out.println("test static 2"); &#125;&#125;/**输出： test static 1 test static 2虽然在main方法中没有任何语句，但是还是会输出，原因上面已经讲述过了。另外，static块可以出现类中的任何地方（只要不是方法内部，记住，任何方法内部都不行），并且执行是按照static块的顺序执行的。*/ 静态块、构造块、普通块、构造方法、主函数的执行顺序记住：静态块&gt;Main方法&gt;构造块&gt;构造方法（构造块和构造方法之后在对象实例化的时候才会调用） 1. 普通代码块：在方法或者语句中出现的{}就称为普通代码块。普通代码块和一般的语句执行顺序由他们在代码中出现的次序决定 ---&quot;先出现，先执行&quot;。 123456789101112131415public class Code&#123; public static void main(String[] args)&#123; &#123;System.out.println("普通代码块---1")&#125; System.out.println("Main方法语句"); &#123;System.out.println("普通代码块---2")&#125; &#125;&#125;/**输出： 普通代码块---1 Main方法语句 普通代码块---2*/ 2. 构造代码块：直接在类中定义且没有static修饰的代码块{}称为构造代码块。构造代码块在创建对象时被调用，并且构造代码块执行次序优先于类构造函数 123456789101112131415161718192021 public class Code&#123; &#123;System.out.println("构造代码块---1")&#125; public Code()&#123; System.out.println("构造函数代码"); &#125; &#123;System.out.println("构造代码块---2")&#125; public static void main(String[] args)&#123; System.out.println("Main方法代码"); new Code(); &#125; &#125;/**输出： Main方法代码 构造代码块---1 构造代码块---2 构造函数代码*/ 3. 静态代码块：在java中使用static关键字声明的代码块。静态块用于初始化类，为类的属性初始化。每个静态代码块只会执行一次。 由于JVM在加载类的时候会先执行静态代码块，所以静态块先于主方法执行。如果类中包含多个静态代码块，那么将按照&quot;先定义的代码先执行，后定义的代码后执行&quot; 注意：1、静态代码块不能存在于任何方法体内。 2、静态代码块中不能直接调用静态实例化的变量和实例方法，需要通过类的实例化对象来访问。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Code&#123; &#123; System.out.println("Code的构造块"); &#125; static&#123; System.out.println("Code的静态代码块"); &#125; public Code()&#123; System.out.println("Code的构造方法"); &#125; &#125; public class CodeBlock03&#123; &#123; System.out.println("CodeBlock03的构造块"); &#125; static&#123; System.out.println("CodeBlock03的静态代码块"); &#125; public CodeBlock03()&#123; System.out.println("CodeBlock03的构造方法"); &#125; public static void main(String[] args)&#123; System.out.println("CodeBlock03的主方法"); new Code(); new Code(); new CodeBlock03(); new CodeBlock03(); &#125; &#125;/**输出： CodeBlock03的静态代码块 CodeBlock03的主方法 Code的静态代码块 Code的构造块 Code的构造方法 Code的构造块 Code的构造方法 CodeBlock03的构造块 CodeBlock03的构造方法 CodeBlock03的构造块 CodeBlock03的构造方法*/ 4. 综合测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Code&#123; &#123; System.out.println("Code构造块"); &#125; static&#123; System.out.println("Code静态块"); &#125; public Code()&#123; System.out.println("Code构造方法"); &#125;&#125;public class StaticTest &#123; static&#123; System.out.println("1"); &#125; public static void main(String[] args) &#123; staticFun(); StaticTest t1 = new StaticTest(); Code c1 = new Code(); Code c2 = new Code(); StaticTest t2 = new StaticTest(); &#125; &#123; System.out.println("2"); &#125; public StaticTest()&#123; String str = "StaticTest"; System.out.println(str); System.out.println("3"); System.out.println("a="+a+",b="+b); &#125; public static void staticFun()&#123; System.out.println("4"); &#125; int a = 110; static int b = 12;&#125;/**输出： 1 4 2 StaticTest 3 a=110,b=12 Code静态块 Code构造块 Code构造方法 Code构造块 Code构造方法 2 StaticTest 3 a=110,b=12我们的Main方法在StaticTest类中，所以我们先走的就是这个类的静态块（主函数在哪个类中先走哪一个静态块，没有主函数会直接报错），同时我们的构造块和构造函数，只有在实例化（new）对象的时候才会调用!!!*/]]></content>
      <categories>
        <category>Java_Base</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE基础（一）]]></title>
    <url>%2F2017%2F10%2F09%2FJavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[之前看过了SSH的框架，大概写了之前的ERP的小项目，其实就是不停的增删改查，然后修改jsp。那个项目最重点的是学习了如何去抽取一个模板类，同时业务层和数据层也加入了接口去规范代码。数据层的查询，也不是利用简单的QHL，而是使用了比较复杂，但是可以查询条件和分页的QBC，整个难度其实是上升了不少，需要慢慢去消化。 从今天开始，开始复习之前学习过的东西，因为本来就是一个看了忘，忘了看的过程。加油吧。 这篇讲了 String、StringBuilder、Scanner、Arrays、Date、一点杂的东西 String常用API1. 检验两个字符串是否相等（&quot;==&quot; &amp; equals()） 12345678910String str_1 = "blemon";String str_2 = "blemonTree";str_1.equals(str_2);"sss".equals(str_2);str_1.equalsIgnoreCase("hhh");/**注意：一定不要使用"=="号检测两个字符串是否相等！这个运算符只能确定两个字符串是否放在了同一个位置上。当然，如果两个字符串确定是在一个位置上时，她们必然相等。但是，完全有可能将内容相同的多个字符串的拷贝放在不同的位置上。也是就说，如果虚拟机始终将相同的字符串共享，就可以使用==运算符检测是否相等。但是实际上只有字符串常量是共享的，而+或者是substring等操作产生的结果并不是共享的。*/ 2. 空串和Null串 12if(str != null &amp;&amp; str.length() != 0)//首先要检查str是否为null。 3. char charAt(int index) 4. boolean startsWith(String prefix) / boolean endsWith(String suffix)：判断字符串是否以指定的字符串开始或结束 5. int indexOf(String str) 12345String str = "helloBlemon22"; System.out.println(str.indexOf("ell"));//1System.out.println(str.indexOf("e",2));//7 从角标2开始找（包括2），e在第7位System.out.println(str.indexOf("ellss"));//-1 6. String replace(String/Char oldString,String/Char newString)/ replaceAll(String regex,String replacement)/String replaceFirst(String regex,String replacement) 7. String substring(int beginIndex)/(int beginIndex,int endIndex) 8. String toLowerCase()/toUpperCase() 9. String trim()/length() StringBuilder1. StringBuilder() 2. int length() 3. StringBuilder append(String str/char c) 4. String toString() 5. void setCharAt(int x,char c) 6. StringBuilder insert(int offset,String str) 7. StringBuilder delete(int startIndex,int endIndex) Scanner1. Scanner(InputStream in) ---&gt; Scanner scanner = new Scanner(System.in) 2. String nextLine() 3. String next() 4. int nextInt() 5. boolean hasNext() 1234567891011public static void main(String[] args) &#123; Scanner scanner = new Scanner(System.in); System.out.println("what is your name?"); String name = scanner.nextLine(); System.out.println("How old aer you?"); int age = scanner.nextInt(); System.out.println("Hello,"+name+",Next year,you'll be "+(age+1));&#125; Arrays1. static String toString(type[] arr) 2. static void sort(type[] arr) 123456public static void main(String[] args) &#123; int[] arr = new int[]&#123;22,3,4,22,3,24,5,4,3&#125;; System.out.println(Arrays.toString(arr)); Arrays.sort(arr); System.out.println(Arrays.toString(arr));&#125; Date 1. Date deadline = new Date();其实是有两部分组成的：表达式new Date()构造了一个Date类型的对象，并且它的值是对新创建对象的引用。这个引用存储在了deadline这个变量中。 注意：一定要意识到，任何对象变量并没有实际包含一个对象，而仅仅引用了这个对象!! 2. 实际开发中，不管是之前写的ERP还是购物商城的案例，其实我们页面上收集我们的日期，我们用的都只是jQuery的插件，所以我们Date类型我们一般不会去用,而用Long来收集时间数据。 注意：在开发中，我们用Long这个字段来表示我们的日期，获取到的直接就是我们系统的当前时间（Long time = System.currentTimeMillis();），剩下的都只用利用Format类对这个字段进行修改形成视图值(String)而已。 在这里我们先不去讨论我们视图值和真实值之间的在类中的创建关系，其实就是一句话，真实值set的时候直接利用format方法提供我们的视图值初始化，也就是我们的视图值不再提供set方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** 下面给出我们格式转换的代码：*/public class FormatUtil &#123; public static final String formatDate(Long time)&#123; DateFormat df = new SimpleDateFormat("yyyy-MM-dd"); return df.format(new Date(time)); &#125; public static final String formatTime(Long time)&#123; DateFormat df = new SimpleDateFormat("HH:mm:ss"); return df.format(new Date(time)); &#125; public static final String formatDateTime(Long time)&#123; DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); return df.format(new Date(time)); &#125; public static final String formatMoney(Double money)&#123; DecimalFormat df = new DecimalFormat("#.00"); return df.format(money); &#125;&#125;/** 测试代码，测试Date输出，测试日历**/public static void main(String[] args) &#123; Date nowTime = new Date(); LocalDate nowLocalTime = LocalDate.now(); System.out.println(nowTime+"..."+nowLocalTime);//Tue Oct 10 09:29:40 CST 2017...2017-10-10 System.out.println(nowLocalTime.getYear()+"..."+nowTime.getTime());//2017...1507598980266 Long time = System.currentTimeMillis();&#125;public static void main(String[] args) &#123; LocalDate date = LocalDate.now(); System.out.println(date.toString());//2017-10-10 int month = date.getMonthValue(); int today = date.getDayOfMonth(); System.out.println(month+"..."+today);//10...10 date = date.minusDays(today -1); System.out.println(date.toString());//2017-10-1 int value = date.getDayOfWeek().getValue(); System.out.println(value);//7 ---&gt; 这个月第一天是周几 System.out.println("Mon Tue Wed Thu Fri Sat Sun"); for(int x=0;x&lt;value;x++)&#123; System.out.print(" "); &#125; while(date.getMonthValue()==month)&#123; System.out.printf("%3d",date.getDayOfMonth()); if(date.getDayOfMonth() == today)&#123; System.out.print("*"); &#125;else&#123; System.out.print(" "); &#125; date =date.plusDays(1); if(date.getDayOfWeek().getValue() ==1 )&#123; System.out.println(); &#125; &#125; if(date.getDayOfWeek().getValue()!=1)&#123; System.out.println(); &#125;&#125; 杂1. Double.isNaN(x):用来判断我们的x是不是一个非数字的值。 2. final这个关键字一旦定义到变量上面，我们的变量值就不可再更改。同时，类似于 public static final Double NUM = 2.3; 这样的code只能出现在类中，而不能出现在方法中，定义后作为一个类常量存在。 3. Math.PI、Math.E、Math.sqrt(x)、Math.pow(x,a)、Math.sin/cos/exp/log10 4. n++和++n：单独使用的时候是没有区别的，最后n的值都会自加1，但是如果还有别的运算符的话，就会有区别，例如： 123456int n = 7;int a = 2* ++n; //a=16,n=8 int b = 2* n++; //b=14,n=8/** 区别在于：++在前就是先n自加，再执行别的运算；++在后，就先进行运算，运算完之后再进行自加*/]]></content>
      <categories>
        <category>Java_Base</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建站]]></title>
    <url>%2F2017%2F10%2F08%2F%E5%BB%BA%E7%AB%99%2F</url>
    <content type="text"><![CDATA[关于Hexo建站准备工作 下载 Node.js 下载 Git 申请 GitHub 下载 GitHub Desktop 搭建环境安装HEXO 1. 利用 npm 命令即可安装。在任意位置点击鼠标右键，选择Git Base。 2. 输入命令全局安装hexo：npm install -g hexo （-g是指全局安装的意思） 创建Blog文件夹 1. 安装完成后，在你喜爱的文件夹下（如E:\GitHub\MyBlog），执行以下指令(在E:\GitHub\MyBlog内点击鼠标右键，选择Git Bash)，Hexo 即会自动在目标文件夹建立网站所需要的所有文件。 2. 输入指令：hexo init（初始化hexo，会生成一些文件夹和文件） 3. 安装依赖包，输入指令：npm install 进入hexo 1. 上面的操作，hexo环境基本已经搭建完成。 2. 在我们的E:\GitHub\MyBlog文件夹下(cd \e\GitHub\MyBlog)，注入指令： hexo clean hexo generate（hexo g） hexo server（hexo s） 3. 现在我们已经搭建起本地的hexo博客了，执行以下命令(在C:\Hexo)，然后到浏览器输入localhost:4000,直接进入。 GitHub建库连接建库 1. 创建的时候注意Repository的名字。比如我的Github账号是AbelChao，那么我应该创建的Repository的名字是：AbelChao.github.io。 修改配置文件 1. 复制我们库的HTTPS链接（可以用SSH）：https://github.com/AbelChao/AbelChao.github.io.git 2. 进入E:\GitHub\MyBlog下的_config.yml，修改最后的deploy： deploy: type: git repo: http://github.com/AbelChao/AbelChao.github.io.git branch: master 注意：我们复制的是https:，但是这里我们需要改成http：;同时我们的type也不是github，而是git 3. 安装文件，输入指令：npm install hexo-deployer-git –save 设置SSH 1. 重新打开一个Git Bash，在Git Bash输入以下指令（任意位置点击鼠标右键），输入指令：ls -al ~/.ssh，检查是否已经存在了SSH keys。 2. 如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件：C:\Users\Administrator\.ssh（id_rsa、id_rsa.pub、known_hosts） 3. 输入以下指令（邮箱就是你注册Github时候的邮箱）后，回车：ssh-keygen -t rsa -C &quot;whbai_xd@163.com&quot;（注册GitHub时候的邮箱） 4. Git Bash中会提示要你输入passphrase（我没有输入直接回车，如果你输入的话，要记得，到时候会用到）。 5. 输入指令：ssh-agent -s 6. 继续输入指令：ssh-add ~/.ssh/id_rsa （这里输入之后可能会报错，我就报错了：Could not open a connection to your authentication agent） 7. 改变指令：eval `ssh-agent -s` 8. 继续指令：ssh-add 9. 到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴）：clip &lt; ~/.ssh/id_rsa.pub 10. 进入GitHub中的Settings/SHH and GPC keys，添加我们的SSH 11. 输入你的Github密码即可完成SSH Key的添加。嗯，最后还是测试一下吧，键入以下命令：ssh -T git@github.com 12. 你可能会看到有警告，没事，输入“yes”就好。 13. 看到Hi AbelChao!You&apos;re successfully authenticated,but GitHub does not provide shell access. 部署键入命令 1. hexo generate 2. hexo deploy 登录 1. OK，我们的博客就已经完全搭建起来了，在浏览器输入（当然，是你的用户名）：http:AbelChao.github.io/ 2. 注意：每次修改本地文件后，需要键入hexo generate才能保存。每次使用命令时，都要在E:\GitHub\MyBlog目录下。每次想要上传文件到Github时，就应该先键入hexo generate保存之后，再键入hexo deploy。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
