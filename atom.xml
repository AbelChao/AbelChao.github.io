<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AbelChao</title>
  
  <subtitle>超超白</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://abelchao.com/"/>
  <updated>2018-07-18T03:15:59.601Z</updated>
  <id>http://abelchao.com/</id>
  
  <author>
    <name>AbelChao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>找找找工作的过程</title>
    <link href="http://abelchao.com/2018/07/18/%E6%89%BE%E6%89%BE%E6%89%BE%E5%B7%A5%E4%BD%9C%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>http://abelchao.com/2018/07/18/找找找工作的过程/</id>
    <published>2018-07-18T01:00:00.000Z</published>
    <updated>2018-07-18T03:15:59.601Z</updated>
    
    <content type="html"><![CDATA[<script src="/crypto-js.js"></script><script src="/mcommon.js"></script><h3 id="encrypt-message">等我签了再看吧</h3><link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.min.css"> <link rel="stylesheet" href="//cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"> <script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <script src="//cdn.bootcss.com/bootstrap/3.3.5/js/bootstrap.min.js"></script> <div id="security"> <div> <div class="input-group"> <input type="text" class="form-control" aria-label="Enter the password." id="pass"/> <div class="input-group-btn"> <button type="button" class="btn btn-default" onclick="decryptAES()">Decrypt</button> </div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> U2FsdGVkX19QxM+hxbyEZSqutsQS1BevtZOzmVsGyH9UOC65PTgFaTm/hVBwQX5rtDKhzIza1HWfnNGVm9fmN/ADX8w1AOf2RGAn+BU0PmwfQjUuzOPBlnYPavmQDk6xu2DXnZPWTYdLOqhBEQBbp6UCnq5H7lL8a0gQAMBmcypBLExoOJKBYtdveND90TGkXlDufY1tkIH9Z663v0mMoyWiwMf0sYDEvoHXRbi3y7Lfwe6q2YgEp+EJZEmt+hTeN7GSa73rH4MHIxsKBx3Az2ayREr2/O0mOHHvFXSv1hNXpYcA7DI8CV++G2j2zoX/PtgYo4TaCl4UW2S7ANfy6wxTbUhQXm+/xQEc0TodWWedWB3cl8De2q6xWTTVbzNHtFZ7ByUEZ8I5JmMNhuy0/M2YRsSzCrYNiMFvExRphyJq+bQPKg3/669yEvGpIgm/IAiB8Q7fav8kZL7trzM7qEPOv3HiUPS8w2CFY4/5B+iaanOFP8PeKFp4z6p1OK9Tic4W/vmVwuqXCJjyj78xX7OiMHFPOZKICridmFLeauCDvr0KKkepJVqP8MmSEf5T0pfgxfEaauTN8r26g1SGN4X35hPt9pWi/mVZmILIWnFIRUmEs5AXQk7aXBY1YqMrBDlkAF4z9vqsEH5Ua5eyDDVymbWNgXtu74HGuV6q919ssRFUcAePTLYE3Nu4yfaA/buTsYDryV2z1lIT/QQvyyPvGgre5RA0TFcm/oeow0ApQjI3I9XLCrNKikGzUjT5Dsw2I1vMP+ld9oMj8LzbSEu9Z4V77ggoI5j+uaswsYwMgUX3rAUo7zAWRXK9vcEk/qKb7LNPhHBvVaKCaOBE0/zfyMz0IyHjy/0zKhhf+lt6C6o1Nv2bBNSUgxdxDabN0lrZQ0D+MQ4oM/5SVFcWVNG30NbSi4OzWxXGDq4DuWD7Czv7+OrEA+Lw/+CN3omRiWHlZew+5V+UWrvAzzywX24KH9fwTgeSsX2ALco4zuAcR6O3urCrg3H2Den+aplqsXxkhooHDzXONpdlOQvp8vqBVLrpUQ+ocKgt1MfvndYRaMvg9kLNQgiGDJyf4n+MbE/PyUK+cBX22WrpjLGAHsIeHARfGIlaVi/o5HryBTmR/My+6+XtqFFaHB6enVvdxeLQjASWlw25sSsqvVYpWoWE0TMF1rzEJ0RgWBkkaZXpLb7EpFUNBcI0u4/jofdMbFG+Cfeged2r6jIrzMbjHPV1Klw7OnO977fdybMnzNYaJ0l5czmbYVk7uqjQNtXzzzSyEFweLNkG5iBoRV6DmAxSLJn+VNxkVt5QTBcBLQdxUeNFK3z/r8rWm4XQleR6rPzXsE5nluHr+5z4av3FvXK91nIYZZ077Tr2zmf/0O/J12BvIbZIGusyLDrLnVnniKMZJ7Yo6JAZaTuW1VpCoSA97/QXHbDI+wxYS2c1lWG8xoIbrJOzmw7EM8e36PA4QbsDF34DY4pP3uJLR2GH+BIxT57aHG6iaUHaC6ZeMTy3CU6STAiQnthg3cD0FCSl3ZDXBCx6+mprQkEQIU3A8Tcs6STGb+PlM2RKwUlxXml7lxQSgbG/ERZ2xy9+YNexH2nZ6U5FUJkI5LLIeAjxhRKdxuNRlvq2cvlnEUdOdmYfS7pPig+/mzo/llcyKE39bq+B/UosCy/bK/xVmOtfGvzz7fkK2wDuAvw61u00ngnHO0y/9Yv/JhsdzdPh+B7IFQGPW3m97pHtnBP/GwGs2OpzMJQjME4qNiBK98FZGzgeazPNJ3FsV+4JWPF/LcNYKK7a9JnMbYos+B+O4zm18hsIbiO4GhgrLQxw2UWdG3CnB4aFunuf7ljNkHHJxxbsnFexyQ1CTobkJLQngnv8qbOO/IQfW+MsTjQKTcNpvPMWepEdm8vxv1plwLM+fmbETpCw0ARuJnVUqBvZEGM22Fz8lMW7jtiI+v/LDCk1qSmsqzT8lmSgK95GHF1KrLsF9mBcCYy+n/v/QlhldkZal7vzaeNGZZoFrNj72vimh/QD3PyyEXslZnpyWk+75W6QqzrcmffPKCAPQdKKC3gl6A87/gwesSFYyqkQzIs5RROuAXQ9XbQu6e3CbZ2tFsIpuwGKecZPWGWWXeR4xMCjNgl3fTgDkXTUOlYPy6UTPtNOayXPsOEMy6ck92PrlXCOPmYOTMbMw+2ri0JaDREqd4HvD6c6YkUixZHCTfVguHurL1UX0553iE2EhgY0hey7bIcmItuKrCdQZnyGFjWGFeujo58r+Imz1jSHFSEIkzLmSlEWlRMmT3u8NBlGL2IvD66L1Pj3v7w8g+GQ2tH7wNGojPZlWaxuUvLEiL1w9yk+2+fMDy50shJAJjf3kaZ5NZbSghEd19eS3xBotmuCmrRy8AtB+Fmg6u2NehcCgMHhKsK1WavMTkrUKF1TkTEfIBIk3yPHO2/dLpPqq3CJebNH2ZnlkhiW0OlLB2I5qQdR0nIOqswag9uqx1S3vOFNNvj38LL3Xj15ZeUG/ruvEouOleMKwUOdV9DAjH8E1fRgZJZTwyzQ39LfhjQUt3BI18s3H9tQTnXn6Sc8gT2ZKvl5ub+u+lYFPHHlT5/SPf/qXzLIGCKOr+noSfJpeDckxfpAROUdi5xYfRtGLGCklwwlPkubTk8MHshYIf9d9pXFD0bY68L88ciKPsQnAgIy1PDpj0Yr7tmH5goU8DZjmLnesHZwJpBRCCoUBPXDzdkhB7VSNcQoa4XZj1/ytkqKCxzTu8G9/TshxUeN1zaGDfOxUjnDmCdnGovf34yhL5FS8dUXl1Ktv1GryLHtmeyViNYdtC3AHnMf1EcJ+/scQu1DASzieEbYOkzO/0I0H5tChtjnkg4PqRM+Pz08qhwRdZr69d2BlmFTOdfp9lGDSr4gO0xQw1WTi+IC4oFvrPZN0MTOVKFIIrdieg3zVVAro9m2/LOh1ch2SLNcQd/Fp708E+7l8VoGZMnhhkCW7O3/l44qrN9NDPQ2hJeGJlAsei2Jktm0urkeTqTWYav8DbwGxXapsFw4+oRpZzaZHYYQJ7CEe3BQMgq+FEB1pW9Bg41gLsf6A+NbXFjgIEjjJXJ+dBSMxcqCb4CrI+jtSlutZd9LsJunjbXGbm4BIcTXtidv4shyLdbF/KNIcNjLr3wMzVj/8C6BfLOEMVZg0zek0/N91z/z7OYbG3CpldXxKnFZ01NOWB/nHJPvxeWlK+k1+HYm2Fa4ramfYDViyJ97BlUXgpY+gmw4LTuJolqTyKmIwAzRq+EUlwcQ8Nt4JGjoEXuRfzYnZzJ8cvG6CU50ySlEhEnacuo8lm+2hgxnTR+kq+e049+p2djMmyOaQLxOREjr2Ki6fdcWZ91DX2QQ8PMDjquFeriSxnSpt6BX2g1SsXBUg3kgORkQfnXWxRS1zVujKvQOIBsi0Y1ALCbmCvjGJjAQWXwJjDgkkRKwk1zbtGUqWHuGP7BTfH5T7L7Uo8K3TIIGdv7edRHzsI7Jww9Mq3PHykJ7wlpJjdNbL/KTSuURwWX6eJGTbpWXCvC/qffQxz9hqJX/fThwDH7mYqO8teSMJ8BGRuupFa1i5LAP58GzwRcsgzf+BsfhQnYAN4SRQ/O/ebvNsokPtgRBkzH53z/mWMnWp9a5yofkHo4a08ah7+ks1Us1/OxV0pjIXGuhcf5yRgcB59Rai/Sz0Vs6Q4nMojQovTPlmi5so4g7+B0kXkr97q9q8aLlq0YEbZrbBVkDBpWy6TXRfFtGdDorAUXZW2+iuiU3JDfQzgo1lUR4N1Eh/9FPPF79lCacM7q98TOQr7JWuCWxyhs5SRJVYnW587FWft596PvvSdq1g1QGXNuBebxnLbMHWW4i1zopYNUY1OeZKMs/H83UDgHnH76BHShcduWTI8xhx0vu8gFuzE6p+ujwsURbSa/2VRtx0WT61WDy+nHG1F5OvDrqsPXpPR/r9q+IbF/08stTT8gkOoHoka5RreTbdf7NJHcqo6V+hG1hx1QZMG1Xn22BaEr0Y5+C0N6JKQnq3PW6y/qzoFFW87lf6TUB8XxlLGzrfZqzuLchzT5yPoRsTs9clWLQUqV9rDDvuKaczPU2jL00GdmueCDJpSwV6dk5qQLsCkUoxa9+2YHQ4WnqxrgdE69YYWNZqzywCrhAvrI7vUTE8zYpEdIykIeWJZ1uGH1xe0Zp9JTqsyKPILs4uzAtl7n9LCkaud6jz7ZrLI2wVOExYJAb+gbpM3lWg77WUWHFSZCe9gGBEmqslROeOCZUDgyUvzRDIDZX8eqe0gQlCpZN0rBpaapCSHaZFJ7yNK0aSmEtzfXRVF9pPqlokuobBhQg8jCO5DENHhxHD2hcR6hVO7gexIHbDrkO8mVJ8Pv28ODjFP4UtYLtPVLtZgzuHPBzPdfO/VE0O6O6XDZbs0Nt/EQ3/wt4xGYigxzUf1J4O1GXyIGj8lmmF4/uvf12ipZvZ3UUdFwhVgPMgq0KH0WJ6PBgJSJtwv13nTO42kXvidNhCWPgkjoctmXEAUAzwn1KGWhzaWWk4wL2HUTN/7c1nI1jVrIEEH9tkWBcozUjU+nOJvC5oKliK4S2qILjPVtzzXkoNOl17hxGW8yadQLr6mWaV/17PjAWRw5YB/TBBo0rNsbmH7NpjYoaSTx0V3WkLkct/lvvp48bib5SGeDDshoNOUmeaAv/mrp0fB2ixHDzeFo4T1sv3d+BeEY7MLR7bG9oYKApv/0ob/MUIOZrDFI2L/apN+8hX3Vul2OHWYcJhOPX44mJqPje+YCQi1TWOIIn+mTNFGtDrrzb2TYvHw/aiL3sc9TyOsoA5xchs4leEAviD9u5fuB3qijspvgKAn0n+qOwryUOKMS7VHwF27OiPzC0O2qfu6mTL71KQ6azIOCF+6ttm5fPAO4BPql00C4UBm96KMjmemOpMgTweTdv84BiYlhToFhT8hefJuWDEPOXLzwHBu+unNfWKS+xNH4reyvOxVPIaaOPeH3gmZiVxmn3n635RV/Z+MiTyC/3sk/L9KqOkoulEZc1eiTWSbfGaodfJh4YI/f3dMyPH90naNqxcY3TRD33pdn5dJPpEIzAW9ot4xxN6JJby7S5eWuqTp3wEy+ucvLRwchMCIXs3OGoKYJI+xnGsg5H5aPNbniO4rS3SGs3QmZVaj11rP3GsquyWac4SFC3gTMc/aZbvhyRybPRpYZLk3FiP1hmvKW6yMr6pHikNHvXNzKfbLqsMIbUk/mGVQLHcNUIGOHsSKp3Aj5dMhoiIfZrHJWPm02a1+bg8OBzkD5tZ0+uOtR15Y5b7i+I4UpLWzdSItioIGGcYFxhc4wfcFvTsVp/auPktgMpRIVkj48DoeFKt5mKPQJYmwayHr/FxjY4cO9gwXq+CHrCYt7vF779cVmLuGIc9s+2TLpC+E7hJwoEACz1KLh7RSX28D79UOQUBKvVoLlKOp0emRfzHG8AUWvJbbItOp+by1M8ji7fuzSXL+e5Bo6rEBs57QktbVZXa5ZhT95xbR35kFeHu+EMJt/kAgpVWGzaV0MguB5H2GFWR2qrmQicufyw1p2Sy51Kdp0vyVzfi5M2CPNjlEWIZvSboeWGZxhq/P5/bzfsrlkFJ0y73Zqgb2CU+QS1M1Yoykg5fgxQjSIDlKCpFNIm2+fiMXVaF01G6gEy/+5H356xObXHvf645E3xlXX9f/FjF2rylnovjnHUKN23+V+P8nZUz0cSbWLu6rNz/U6j9OmmvyG/362OkQ7Oe/woeiqBdH37sDFur2ZIL6TlH8PjcJlZwZLsTvYAytZdf3/i1wbc7Y4QtLoaSnPUIWOm+TxR48vFzegPZukY7jg7TOWq8avp7yxxTjZ0SRKLvUuVgIaOs8eX6LtmHkYl004Ye/5H9/6beEf3AVr5exLucOl1QTKS4GwpOJB317+aMWy43l/hkjqgypPPCLCQYRzMy0TGzPds1zz0fUw2l04utDnKcWZOoZd/jpTIpffGdgNTKhLnQbcjN6BAT3iatKbPfgCs5HjxYPn9ZJVaRJxV4KHQQ1dsM+JKVToLDGnG01VCGKaHG2quY+T9qLfcJ9nL/UovSsYO4GTEjWvv/ZVX8OANyiccZGkM73dZLZUytNCWpyh88bpTpnzAmt2Y51klLZEPW9WnbLIwKk2e2Ae0rOVLw7AlLMLA2nidgizu8AHrZSkomcKX1V2kTFEz9dShzAdPHs1xw+c7d0J+iV7nK93NKg+4Ll3XQbue5ZOrwRhtLRaQu5/93XD9i2oyPsX0v0FRD6vu5JzeSrjVfTuKYZZkYEAeSqK9tQsLmEzbj2ZL6ZR+IuiF5zekTqKc4rLnOuMv7q6hYRZac9KTC0rzRBjvT2oFTgM3VbuhzhGrCscMl5LBzeEL0f+HLakMKUfdgfi2Pjk56vsEYd0IDEYhg9JuMy8l2AadtgSUykGEl8+2kpYjjIRBWmHEl/i1Lm2oTR6g6Z28MyaEY9oUsOxLZmdUiA32z4xVlGkbAyW2uu04k/JX9m3SFwQkhHPd63j+XlvDgnPVTQghQ/m1k6jNNcwKaCWgEGhvgPvLP572ePdSHwIMljNZ8iq8vajjSEILbn88e8/duwZfvunsNfhg1BsKU7SFM9iJLLZAlHliuwi8zc46m41fYy2DWwRfXTsCVkCrwK5Uwx/OSeYkNBUtvLlv3cIlPzeAuooGWE3btlH0Q6Yq72ZKy6SvyaZ6RqvbnrnSdAMPbfwfFl8m7splcQvUkiXwCtNS7pKKTHAnOJR9rPDnLnP/VWqC7cxpcTjQTEJd37sX5GsM40JbOnV4nP/xvLzCVFiena6a88Nl0beCBGxcfdvTR4J1nii1XESQFI7c3iYZWiMFM8ev7GFfIFxsNb6V24mD5O1Bh2Cs75E5am/yN2+CAn8CKrYePGn/2c8clkJEQi7GOvV0851gbO8jUfF2Yw0ldKmasVv3cvzEC5S8kbOYrUNKrJMmRnmA2JJ7YjH906EeN0uM0erKbiqZB7UP81i60RRqPBIiddw4ZO7suJ4HV8RMRG1QqlhucFXjgaTFb1yw+Q46zlg+UkZvbUl8k4GIAy72U35k+56Y8SQD+qF0xGj7Yi4pLMkJbNHRBbRWIWOOVialEvAADzHADvL7pEqfwAge/GmxgziUlbq/QQUqRuRuNMibDCC63wFfDpEVR1uIwdRADgVGQy1DFn6sgNCeKLmxtFqoImNZX/r1IDlVLuy5g5Ay5EWq/km2qD0+0mItLDtXEIhliMip1Hvr4TtSWxFWVQJrduqhRVMEBR/fUZDStBbnMk/UEj7FGSMruFzEvclE4jEIz8ZXQvCOg/Zm/nTMjGcBgvQW8xdrd/PV3NSKexi28rw6eGe0QolTtJe3F1M5wnLHxPsdl5Hs6m1FiS7bTQL6uc1UvVFCL8zMbnkrKERAFc1LDQhwHu5j7jS/Fz2kX02OKX6YXPcXbaE7215ZsrjUSkpPqpsg5HsPG+anhqTImZISYTC/jqQ2lhRfFlgtSEOtzs+u7Dp2UVWXNG6EBWHAdn8/mtdpvztPTnpAtumAr1yFKbza5mWUUxxHOXCgeMPpT55xgx/u4UVnqs/AippIINWMlyzavulxS11/foibn3BYDbBbaQgSF2TDMXU5hHAT1UD0cO5cB53utc4mqcWdBOZs9oiHFx93ixtkX5zzCPwXTMwcw/ZEWtiAWSSQvU2eS06YHl72mre3K5X0XVynT/S5SVOP3CUaBwmANdQSEu+EagrMf1Vh8xioQtWm4U9w/we01hMB+xTVnK4XNN2KxCQXd356iAihowKiwZKFZaMfIKYHh2w7XZ2HYnFsGQsOJ/uZUJa9kHP0oek9D5vAHEjqNtXx73weydCu5TkHzLD9vgRMaw5y66TGwS4YzlIwq+bxCE9o6+wJ4J0RhWqm4cqTr8K12vEWJnhebxiq2EGUMiCdhhu3e7NCBYCTwN2XY6rKI3yGhmzyGSxPRU1fcdcZt+tDnTb+wTPdNL1GtNckQtGK1EKEImVeSR+TQXB88vSk0zOXtfoFGQ1eYvZogGX88RwC/W9mHNknfnsC0TkLNUpMYQKWNuifeQ+vtC1aFJNgDLDLFKJd9Vi5UkiUIamcazoDvyYzEXf5u33tub17SkOQcjkS4nD95qcXBaZL3i35JjV/p93YmPpBYRIsCV8ZSeHrDs1lyr0RjCYmKVqon5tlPO1Imt9HaM07uw6s1dEDbMhARtpOq1Grf8YSBqiPRC8cLmLiWXuuvl9I7cB2SCYVcYjDBtVH+9I7jXHlmnuhxWZZFF+8icgiBzyfEkNQXiwDPb8CCx1jzF78sNNCbl2ilQ5JzgfUKvFTPpCx6xEJOj84S1pdCIHvAWT8AAJaRs7/6sJ2Smkr5QCI0HaXbDVHKp/pGrgsGfDvHrT73GcEaZqT3GKWSdTMupOMM+UX+1eLe8W6Fx559QwLLanywEILK+llH6Mr/vg7fjp70kkp+VGEeOxXSou4ljxjWcGQ1AgkOSD0p/4XNdhGlnBiAKayTQN0sm/lFYQwuqc8UfLcB9B090LoGm4iYrjHh1PbacsikglTcs1u6KAd3FY/9cLW7Sx5wlp+Cx+xgfjOoxyxybixk8gIdp24Cn3cVE9bLLa7QwPJig11AR3+MHw9dOoBL12ZhwWZqn6q8dsUEzxMLd+yyfe/+ntKqdUnoc6SeYaAKxjeFP2lj4aYFrGtrYu+FHE29u0ZBBMuYlW4IbiJ+k4qqe90bP36gv0XN99t89NeALBs+e5e6roPTXqjZV++6xoXvTAt1DPHrXbQE+cmw5Y257V+GEIomG5hu8ZdFqQG1SfT3aXytJv4SMPeK4B7YGlwin2WGZ7GfwXvYu085rzn5iGAGY9DVkjEcOJTT59R6HGSVi21/hficGmHJr6jthfoBEJxIi1i+XDfilcR+p7ohS5sifgIQiOrYz2F4Gm1z3kxfysvx00OIEmFxztOnPue7JH9J5xc1sUUfVEF+CbLmhKfRUcLK5YVrvY/YyvuusKaCaiLSQWM7oaKSXAXWS0UV5xQPCwzxy8UyA2/d5lp8K542d2k3QlVCot4oAfP57XyHeoA6xg/MzigfauNS5DAgDdoaMa0/2Xs9LEpN0Qs4XiPLIShEvgFEfrEGLzk+ZrSTvTuLEh1XqKS46PSKQkwAS4tYZ8lHMG0uFdjqRkR6womtlZ+yqtna1Hn4aFv4mnY8c6uDWCT0IZA8+sxUCXX8oRNVTjjs2vLLAq6N6ptSsWrqSo+U6DAaqzr4oQHOWxe6WFB2NmV5QkTunCDKEYp/P6PZVKgVANKkRQ/xy4rYrjrub0wfr+i3YDwrLTMPu1jcRqgwQWQc4JAswur+Iy2ZBSO2PPxzSNM40O18AwuV/dkDaf567UcBCSmsjACDbMcjfh0Vs96VDFuW9YZ6CXoiIrClwhRnNsKwD+jFtjj604mtdv0o+4hZrN3k7C3w0CEpbrze1sL </div>]]></content>
    
    <summary type="html">
    
      还是写呢，别急啊
    
    </summary>
    
      <category term="Find" scheme="http://abelchao.com/categories/Find/"/>
    
    
      <category term="Find" scheme="http://abelchao.com/tags/Find/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode（1-30）</title>
    <link href="http://abelchao.com/2018/07/16/LeetCode%EF%BC%881-30%EF%BC%89/"/>
    <id>http://abelchao.com/2018/07/16/LeetCode（1-30）/</id>
    <published>2018-07-16T01:00:00.000Z</published>
    <updated>2018-07-17T07:42:44.541Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oxk1vrcj4.bkt.clouddn.com/v2-ee8927c8015db2fd307a14986e67581e_r.jpg" alt=""></p><p><strong>LeetCode（1-30）</strong><br><a id="more"></a></p><h1 id="Two-Sum"><a href="#Two-Sum" class="headerlink" title="Two Sum"></a>Two Sum</h1><p>这个题的意思是，给定一个数组，判断这个数组中是不是有两个数字之和等于目标数字，如果有返回这两个数字的下标，如果没有返回-1</p><p>解题思路，利用Map，一个一个获取数字。把当前数字和当前数字与目标数字的插值存入Map的key,value存角标，一旦后面有数字等于了这个插值，就结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        map.put(target-nums[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(nums[i]))&#123;</span><br><span class="line">                result[<span class="number">0</span>] = map.get(nums[i])+<span class="number">1</span>;</span><br><span class="line">                result[<span class="number">1</span>] = i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(target-nums[i],i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Add-Two-Numbers"><a href="#Add-Two-Numbers" class="headerlink" title="Add Two Numbers"></a>Add Two Numbers</h1><p>将两个反向的数字链表相加，正向输出。</p><p>解题思路：</p><p>利用递归，result.next = addTwoNumbers(l1.next,l2.next);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span> || l2==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> l1==<span class="keyword">null</span>?l2:l1;</span><br><span class="line">        <span class="keyword">int</span> val = l1.val+l2.val;</span><br><span class="line">        ListNode result = <span class="keyword">new</span> ListNode(val%<span class="number">10</span>);</span><br><span class="line">        result.next = addTwoNumbers(l1.next,l2.next);</span><br><span class="line">        <span class="keyword">if</span>(val&gt;=<span class="number">10</span>)</span><br><span class="line">            result.next = addTwoNumbers(<span class="keyword">new</span> ListNode(val/<span class="number">10</span>),result.next);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Longest-Substring-Without-Repeating-Characters"><a href="#Longest-Substring-Without-Repeating-Characters" class="headerlink" title="Longest Substring Without Repeating Characters"></a>Longest Substring Without Repeating Characters</h1><p>求最大无重复字符的子串</p><p>解题思路:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    "滑动窗口" </span></span><br><span class="line"><span class="comment">    比方说 abcabccc 当你右边扫描到abca的时候你得把第一个a删掉得到bca，</span></span><br><span class="line"><span class="comment">    然后"窗口"继续向右滑动，每当加到一个新char的时候，左边检查有无重复的char，</span></span><br><span class="line"><span class="comment">    然后如果没有重复的就正常添加，</span></span><br><span class="line"><span class="comment">    有重复的话就左边扔掉一部分（从最左到重复char这段扔掉），在这个过程中记录最大窗口长度</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//滑动窗口</span></span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            left = Math.max(left,map.containsKey(c)?map.get(c)+<span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">            max = Math.max(max,i-left+<span class="number">1</span>);</span><br><span class="line">            map.put(c,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="median-of-two-sorted-arrays"><a href="#median-of-two-sorted-arrays" class="headerlink" title="median-of-two-sorted-arrays"></a>median-of-two-sorted-arrays</h1><p>两个数组升序排序后的中位数</p><p>下面的这个解法不是O（N+M）的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> B[])</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:A)</span><br><span class="line">            list.add(i);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:B)</span><br><span class="line">            list.add(i);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        <span class="keyword">if</span>(size%<span class="number">2</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">double</span>)list.get(size/<span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (list.get(size/<span class="number">2</span>)+list.get(size/<span class="number">2</span>-<span class="number">1</span>))/<span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="longest-palindromic-substring"><a href="#longest-palindromic-substring" class="headerlink" title="longest-palindromic-substring"></a>longest-palindromic-substring</h1><p>manacher算法求最长子串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Manacher算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String result = s;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"#"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            sb.append(s.charAt(i)+<span class="string">"#"</span>);</span><br><span class="line">        s = sb.toString();</span><br><span class="line">        len = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] radius = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> maxRight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> center = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> resLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> resCenter = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=maxRight)</span><br><span class="line">                radius[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                radius[i] = Math.min(maxRight-i,radius[<span class="number">2</span>*center-i]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(i+radius[i]&lt;len &amp;&amp; i-radius[i]&gt;=<span class="number">0</span></span><br><span class="line">                 &amp;&amp; s.charAt(i+radius[i])==s.charAt(i-radius[i]))</span><br><span class="line">                radius[i]++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i+radius[i]&gt;maxRight)&#123;</span><br><span class="line">                center = i;</span><br><span class="line">                maxRight = i+radius[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(resLen&lt;radius[i])&#123;</span><br><span class="line">                resLen = radius[i];</span><br><span class="line">                resCenter = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s.substring(resCenter-resLen+<span class="number">1</span>,resCenter+resLen).replace(<span class="string">"#"</span>,<span class="string">""</span>);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Zigzag-Conversion"><a href="#Zigzag-Conversion" class="headerlink" title="Zigzag Conversion"></a>Zigzag Conversion</h1><p><a href="https://www.cnblogs.com/springfor/p/3889414.html" target="_blank" rel="noopener">https://www.cnblogs.com/springfor/p/3889414.html</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> nRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span> || s.length()==<span class="number">0</span> || nRows==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(nRows==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">2</span>*nRows-<span class="number">2</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nRows;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;len;j+=size)&#123;</span><br><span class="line">                sb.append(s.charAt(j));</span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; i!=nRows-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp = j+size-<span class="number">2</span>*i;</span><br><span class="line">                    <span class="keyword">if</span>(temp&lt;len)</span><br><span class="line">                        sb.append(s.charAt(temp));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Reverse-Integer"><a href="#Reverse-Integer" class="headerlink" title="Reverse Integer"></a>Reverse Integer</h1><p>反转整数，遇到100，10的时候返回1。<br>考虑到溢出的问题，需要用long保存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            res = res*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res &gt;Integer.MAX_VALUE || res &lt; Integer.MIN_VALUE) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="String-to-Integer"><a href="#String-to-Integer" class="headerlink" title="String to Integer"></a>String to Integer</h1><p>重点在于边界条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">atoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span> || str.trim().length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        str = str.trim();</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        <span class="keyword">char</span> flag = <span class="string">'+'</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(<span class="number">0</span>)==<span class="string">'+'</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(<span class="number">0</span>)==<span class="string">'-'</span>)&#123;</span><br><span class="line">            flag = <span class="string">'-'</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i&lt;len &amp;&amp; str.charAt(i)&gt;=<span class="string">'0'</span> &amp;&amp; str.charAt(i)&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">            res = res*<span class="number">10</span>+(str.charAt(i)-<span class="string">'0'</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(flag==<span class="string">'-'</span>)</span><br><span class="line">            res = -res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(res&gt;Integer.MAX_VALUE)</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">if</span>(res&lt;Integer.MIN_VALUE)</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Palindrome-Number"><a href="#Palindrome-Number" class="headerlink" title="Palindrome Number"></a>Palindrome Number</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不能把数字变成字符串，那么就把生成一个反转数，就和这个题一样了：reverse integer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> temp = x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            res = res*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res==temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Regular-Expression-Matching"><a href="#Regular-Expression-Matching" class="headerlink" title="Regular Expression Matching"></a>Regular Expression Matching</h1><p>正则匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.matches(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="container-with-most-water"><a href="#container-with-most-water" class="headerlink" title="container-with-most-water"></a>container-with-most-water</h1><p><a href="https://blog.csdn.net/five0918/article/details/52504775" target="_blank" rel="noopener">https://blog.csdn.net/five0918/article/details/52504775</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height==<span class="keyword">null</span> || height.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            maxArea = Math.max(maxArea, Math.min(height[left], height[right])*(right-left));</span><br><span class="line">            <span class="keyword">if</span>(height[left]&lt;height[right])</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Integer-to-Roman"><a href="#Integer-to-Roman" class="headerlink" title="Integer to Roman"></a>Integer to Roman</h1><h1 id="Roman-to-Integer"><a href="#Roman-to-Integer" class="headerlink" title="Roman to Integer"></a>Roman to Integer</h1><h1 id="Longest-Common-Prefix"><a href="#Longest-Common-Prefix" class="headerlink" title="Longest Common Prefix"></a>Longest Common Prefix</h1><p>思路：</p><p>原数组排序，然后把第一个和最后一个比较就可以</p><p><a href="https://blog.csdn.net/zsy112371/article/details/52433799" target="_blank" rel="noopener">https://blog.csdn.net/zsy112371/article/details/52433799</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs==<span class="keyword">null</span> || strs.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        Arrays.sort(strs);</span><br><span class="line">        <span class="keyword">int</span> len = strs.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span>[] shortStr = strs[<span class="number">0</span>].toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] longStr = strs[len-<span class="number">1</span>].toCharArray();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> shortLen = shortStr.length;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;shortLen;i++)</span><br><span class="line">            <span class="keyword">if</span>(longStr[i]==shortStr[i])</span><br><span class="line">                sb.append(shortStr[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> sb.toString();</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"># 3Sum  </span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length&lt;<span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = nums.length;</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> left = i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> right = len-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line"><span class="keyword">int</span> sum = nums[i]+nums[left]+nums[right];</span><br><span class="line"><span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">List&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">temp.add(nums[i]);</span><br><span class="line">temp.add(nums[left]);</span><br><span class="line">temp.add(nums[right]);</span><br><span class="line">list.add(temp);</span><br><span class="line">left++;</span><br><span class="line">right--;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>])</span><br><span class="line">left++;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>])</span><br><span class="line">right--;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">right--;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">left++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3Sum-Closest"><a href="#3Sum-Closest" class="headerlink" title="3Sum Closest"></a>3Sum Closest</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length&lt;<span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len = nums.length;</span><br><span class="line">Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> left = i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> right = len-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line"><span class="keyword">int</span> sum = nums[i]+nums[left]+nums[right];</span><br><span class="line"><span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line"><span class="keyword">if</span>(sum-target&lt;min)&#123;</span><br><span class="line">min = sum-target;</span><br><span class="line">result = sum;</span><br><span class="line">&#125;</span><br><span class="line">right--;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line"><span class="keyword">if</span>(target-sum&lt;min)&#123;</span><br><span class="line">min = target-sum;</span><br><span class="line">result = sum;</span><br><span class="line">&#125;</span><br><span class="line">left++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Letter-Combinations-of-a-Phone-Number"><a href="#Letter-Combinations-of-a-Phone-Number" class="headerlink" title="Letter Combinations of a Phone Number"></a>Letter Combinations of a Phone Number</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4Sum"><a href="#4Sum" class="headerlink" title="4Sum"></a>4Sum</h1><p><a href="https://blog.csdn.net/mine_song/article/details/69401855" target="_blank" rel="noopener">https://blog.csdn.net/mine_song/article/details/69401855</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] num, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span> || nums.length&lt;<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;i+<span class="number">1</span> &amp;&amp; nums[j]==nums[j-<span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> left = j+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> right = len-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i]+nums[j]+nums[left]+nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                        ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                        temp.add(nums[i]);</span><br><span class="line">                        temp.add(nums[j]);</span><br><span class="line">                        temp.add(nums[left]);</span><br><span class="line">                        temp.add(nums[right]);</span><br><span class="line">                        list.add(temp);</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>])</span><br><span class="line">                            left++;</span><br><span class="line">                        <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>])</span><br><span class="line">                            right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Remove-Nth-Node-From-End-Of-Number"><a href="#Remove-Nth-Node-From-End-Of-Number" class="headerlink" title="Remove Nth Node From End Of Number"></a>Remove Nth Node From End Of Number</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line"> </span><br><span class="line">        ListNode fakeNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode temp = fakeNode;</span><br><span class="line">        temp.next = slow;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>&amp;&amp;fast!=<span class="keyword">null</span>;i++)</span><br><span class="line">            fast = fast.next;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        temp.next = slow.next;</span><br><span class="line">        <span class="keyword">return</span> fakeNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Valid-Parentheses"><a href="#Valid-Parentheses" class="headerlink" title="Valid Parentheses"></a>Valid Parentheses</h1><p>符号匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c==<span class="string">'('</span>||c==<span class="string">'&#123;'</span>||c==<span class="string">'['</span>)&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((c == <span class="string">')'</span> || c == <span class="string">']'</span> || c == <span class="string">'&#125;'</span>)&amp;&amp; stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">char</span> pop = stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (!((pop == <span class="string">'('</span> &amp;&amp; c == <span class="string">')'</span>) || (pop == <span class="string">'['</span> &amp;&amp; c == <span class="string">']'</span>) || (pop == <span class="string">'&#123;'</span> &amp;&amp; c == <span class="string">'&#125;'</span>))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.size()==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="merge-two-sorted-lists"><a href="#merge-two-sorted-lists" class="headerlink" title="merge-two-sorted-lists"></a>merge-two-sorted-lists</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode h1, ListNode h2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(h1==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> h2;</span><br><span class="line">        <span class="keyword">if</span>(h2==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> h1;</span><br><span class="line"></span><br><span class="line">        ListNode fakeNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode cur = fakeNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(h1!=<span class="keyword">null</span> &amp;&amp; h2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(h1.val&lt;h2.val)&#123;</span><br><span class="line">                cur.next = h1;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                h1 = h1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = h2;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                h2 = h2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(h1!=<span class="keyword">null</span>)</span><br><span class="line">            cur.next = h1;</span><br><span class="line">        <span class="keyword">if</span>(h2!=<span class="keyword">null</span>)</span><br><span class="line">            cur.next = h2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fakeNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Generate-Parentheses"><a href="#Generate-Parentheses" class="headerlink" title="Generate Parentheses"></a>Generate Parentheses</h1><p>生成括号，给定括号的个数，生成一共有几种可能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Merge-k-Sorted-Lists"><a href="#Merge-k-Sorted-Lists" class="headerlink" title="Merge k Sorted Lists"></a>Merge k Sorted Lists</h1><h1 id="Swap-Nodes-in-Pairs"><a href="#Swap-Nodes-in-Pairs" class="headerlink" title="Swap Nodes in Pairs"></a>Swap Nodes in Pairs</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode fakeNode = head.next;</span><br><span class="line">        head.next = swapPairs(head.next.next);</span><br><span class="line">        fakeNode.next = head;</span><br><span class="line">        <span class="keyword">return</span> fakeNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Reverse-Nodes-in-k-Group"><a href="#Reverse-Nodes-in-k-Group" class="headerlink" title="Reverse Nodes in k-Group"></a>Reverse Nodes in k-Group</h1><h1 id="Remove-Duplicates-from-Sorted-Array"><a href="#Remove-Duplicates-from-Sorted-Array" class="headerlink" title="Remove Duplicates from Sorted Array"></a>Remove Duplicates from Sorted Array</h1><p>Given1-&gt;1-&gt;2, return1-&gt;2.<br>Given1-&gt;1-&gt;2-&gt;3-&gt;3, return1-&gt;2-&gt;3.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.val == cur.next.val)</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Given1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5, return1-&gt;2-&gt;5.<br>Given1-&gt;1-&gt;1-&gt;2-&gt;3, return2-&gt;3.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode FakeHead=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        FakeHead.next=head;</span><br><span class="line">        ListNode pre=FakeHead;</span><br><span class="line">        ListNode cur=head; </span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123; </span><br><span class="line">            <span class="keyword">while</span>(cur.next!=<span class="keyword">null</span>&amp;&amp;cur.val==cur.next.val)&#123;</span><br><span class="line">                cur=cur.next;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(pre.next==cur)&#123;</span><br><span class="line">                pre=pre.next;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                pre.next=cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> FakeHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Remove-Element"><a href="#Remove-Element" class="headerlink" title="Remove Element"></a>Remove Element</h1><h1 id="Implement-strStr"><a href="#Implement-strStr" class="headerlink" title="Implement strStr"></a>Implement strStr</h1><pre><code>如果子串在原串中存在，就返回第一次出现位置之后的所有字符串，否则输出null</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = haystack.indexOf(needle);</span><br><span class="line">        <span class="keyword">if</span>(index&gt;-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> haystack.substring(index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Divide-Two-Integers"><a href="#Divide-Two-Integers" class="headerlink" title="Divide Two Integers"></a>Divide Two Integers</h1><h1 id="Substring-with-Concatenation-of-All-Words"><a href="#Substring-with-Concatenation-of-All-Words" class="headerlink" title="Substring with Concatenation of All Words"></a>Substring with Concatenation of All Words</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oxk1vrcj4.bkt.clouddn.com/v2-ee8927c8015db2fd307a14986e67581e_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LeetCode（1-30）&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://abelchao.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://abelchao.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>排序的知识点</title>
    <link href="http://abelchao.com/2018/07/11/%E6%8E%92%E5%BA%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://abelchao.com/2018/07/11/排序知识点/</id>
    <published>2018-07-11T01:00:00.000Z</published>
    <updated>2018-07-11T12:51:01.244Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oxk1vrcj4.bkt.clouddn.com/v2-f6339408c5e6ac4c81ea34fac868a775_hd.jpg" alt=""></p><p><strong>排序的知识点</strong><br><a id="more"></a></p><ol><li><p>序列事先已经基本有序，插入和冒泡会明显减少比较次数，快速排序与主元的选择有关，若一般选子序列左侧第一个元素比较，则第一个元素最好是大小居中的，以使得分成的两个子数组长度大致相等。性能才最佳，快速排序也与初始输入集有关。</p></li><li><p>堆、归并、直接选择,基数排序的复杂度与初始序列的有序无关。但是只有选择排序的比较次数与初始序列无关;元素的移动次数与关键字的初始排列次序无关的是基数排序.</p></li><li><p>有环图不能进行拓扑排序。</p></li><li><p>在待排序数据基本有序的情况下，直接插入排序效果最好。</p></li><li><p>每经过一次元素的交换会产生新的逆序的是快速排序。</p></li><li><p>快速排序，在初始序列无序的条件下最快，一旦有序，退化成冒泡排序，时间复杂度是O（n^2），原来是O（nlog2n）。</p></li><li><p>二分法插入排序所需比较次数与待排序的初始排序状态无关。</p></li><li><p>外排中使用置换选择排序的目的，是为了增加初始归并段的长度。</p></li><li><p>若记录的初始状态已经按关键码基本有序，则选用直接插入排序或冒泡排序发为宜</p></li><li><p>选择排序是小的往前走，冒泡排序是大的往后走。</p></li><li><p>从未排序序列中依次取出元素与已排序序列中的元素进行比较，将其放入已经排序序列的正确位置上</p></li><li><p>快排应该用在顺序存储的序列上。</p></li><li><p>若记录的初始状态已经按关键码基本有序，则选用直接插入排序或冒泡排序发为宜</p></li><li><p>小堆顶从左开始，大堆顶从右开始.</p></li><li><p>将两个各有N个元素的有序表归并成一个有序表,其最少的比较次数是N</p></li></ol><p>但是合并M个长度为N的已排序数组的时间复杂度是O(mn(logm))</p><ol><li><p>插入排序N次,前N+1或者后N+1个数有序.</p></li><li><p>拓扑排序算法适用于有向无环图.</p></li><li><p>推排序每趟总能选出一个最大值或者最小值位于根节点.</p></li><li><p>快排选出的枢纽在一趟排序中就位于了它的最终位置.</p></li><li><p>冒泡排序在初始关键字序列为逆序的情况下执行的交换次数最多</p></li><li><p>堆排序不需要等到整个排序结束就可以选出最大的或者最小的前N个数,但是快排和基数排序都不可以.</p></li><li><p>简单排序中,比较次数与移动次数O(n*n)和O(n)</p></li><li><p>数据表A中每个元素距其最终位置不远，为了节省时间，应该采取的算法是直接插入</p></li><li><p>计数排序辅助数组的长度为max-min+1，max和min为待排序序列的最大值和最小值，故C的长度为：3-0+1=4</p></li><li><p>要与关键字的初始排列次序无关那么就是最好,最坏,一般的情况下排序时间复杂度不变,总共有 堆排序,归并排序,选择排序,基数排序</p></li><li><p>线性表的长度是n,则在最坏情况下,冒泡排序需要的比较次数是n(n-1)/2</p></li><li><p>m个元素k路归并的归并趟数s=logk(m)，代入数据：logk(100)≦3</p></li><li><p>快速排序的平均比较次数最少.</p></li><li><p>选择排序每扫描一次数组,只需要一次交换.</p></li><li><p>有向无环图才能进行拓扑排序.</p></li><li><p>快速排序是在比较排序中平均性能最好的，但还有线性时间排序啊，比如：基数排序，计数排序，桶排序.</p></li><li><p>快速排序,冒泡排序,直接插入排序的最坏复杂度都是n(n-1)/2</p></li><li><p>希尔在某趟排序结束后不一定能选出一个元素放到其最终位置上.</p></li><li><p>归并排序算法在输入数据逆序情况下排序速度最快</p></li><li><p>如果在一个排序算法的执行过程中，没有一对元素被比较过两次或以上，则称该排序算法为节俭排序算法.插入和归并.</p></li><li><p>外排序一般用外存存放数据，采用多路归并的方法进行排序.100Mb的内存,对1Gb的数据进行排序.</p></li><li><p>希尔排序和堆排序都利用了顺序存储的随机访问特性.而链式存储不支持这种性质.</p></li><li><p>将两个各有n个元素的有序表归并成一个有序表,最少的比较次数是N</p></li><li><p>同一待排序序列分别进行折半插入排序和直接插入排序，两者之间元素之间的比较次数不同.</p></li><li><p>注意插入排序是从第二个元素开始向前比(第一个没得比)，到最后一个元素。所以一共n-1趟。</p></li><li><p>基数排序是稳定的，但是应用于整数，不是实数！</p></li><li><p>选择每次从未排序的记录中挑出最小(或最大)关键码字的记录,加入到已排序记录的末尾.起泡排序是加到已排序的开头</p></li><li><p>基于比较的排序的时间复杂度下限O(nlogn)</p></li><li><p>利用顺序统计思路找出n个数字的中位数可以再O(n)时间内完成</p></li><li><p>基于比较的排序问题的时间复杂度下界是O(n*logn)</p></li><li><p>因为希尔排序 是缩小增量排序，所以对于初始序列有序还是无序没有直接关系。</p></li><li><p>插入的排序趟数是固定的n-1，即使序列有序，也要依次从第二个元素开始，向前找它的插入位置。</p></li></ol><p>49.总排序趟数与初始状态无关的有：（除了快速排序和优化的冒泡，其他都是）<br>算法复杂度与初始状态无关的有：堆排序、归并排序、选择排序、基数排序。<br>元素总比较次数与初始状态无关的有：选择排序、基数排序。<br>元素总移动次数与初始状态无关的有：归并排序、基数排序。</p><ol><li><p>Insertion sort and bubble sort are not effcient for large data sets.</p></li><li><p>外部排序最常用的算法是多路归并排序</p></li><li><p>拓扑排序不是内排序</p></li><li><p>最好的内排序是快速</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oxk1vrcj4.bkt.clouddn.com/v2-f6339408c5e6ac4c81ea34fac868a775_hd.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;排序的知识点&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://abelchao.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://abelchao.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>时间复杂度与空间复杂度</title>
    <link href="http://abelchao.com/2018/07/09/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>http://abelchao.com/2018/07/09/时间复杂度和空间复杂度/</id>
    <published>2018-07-09T01:00:00.000Z</published>
    <updated>2018-07-09T13:27:22.799Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oxk1vrcj4.bkt.clouddn.com/v2-6a8c5ef5d6a497bf93746b44dab12219_r.jpg" alt=""></p><p><strong>时间复杂度与空间复杂度</strong><br><a id="more"></a></p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><h2 id="大O渐进表示法"><a href="#大O渐进表示法" class="headerlink" title="大O渐进表示法"></a>大O渐进表示法</h2><p>一个算法语句总的执行次数是关于问题规模N的某个函数，记为分f(N),N称为问题的规模。语句总的执行次数<br>记为T[N],当N不断变化时，T[N]也在变化，算法的执行次数的增长速率和f(N)的增长速率相同。<br>则T[N]=O(f(N)),称O(f(N))为时间复杂度的O渐进表示法。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先要说的是，时间复杂度的计算并不是计算程序具体运行的时间，而是算法执行语句的次数。</p><p>计算方法：</p><pre><code>1. 用常数1代替运行时间中的所有加法常数2. 修改后的运行次数函数中，只保留最高阶项3. 去除最高阶项的系数按数量级递增排列，常见的时间复杂度有： 常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n^2)，立方阶O(n^3),…， k次方阶O(n^k),指数阶O(2^n)。 </code></pre><h2 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h2><p>如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (x &lt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">该算法执行次数是<span class="number">10</span>，是一个常数，用时间复杂度表示是O(<span class="number">1</span>)。</span><br></pre></td></tr></table></figure><h2 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h2><p>当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> 该算法<span class="keyword">for</span>循环，最外层循环每执行一次，内层循环都要执行n次，执行次数是根据n所决定的，时间复杂度是O（n^<span class="number">2</span>）</span><br></pre></td></tr></table></figure><h2 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h2><p>循环不仅与n有关，还与执行循环所满足的判断条件有关。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; n &amp;&amp; arr[i]!=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在此循环，如果arr[i]不等于<span class="number">1</span>的话，时间复杂度是O（n）。如果arr[i]等于<span class="number">1</span>的话，则循环不能执行，时间复杂度是<span class="number">0</span>。</span><br></pre></td></tr></table></figure><h2 id="例四"><a href="#例四" class="headerlink" title="例四"></a>例四</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>;     </span><br><span class="line"><span class="keyword">while</span> (i&lt;=n)  </span><br><span class="line">  i=i*<span class="number">2</span>; </span><br><span class="line"></span><br><span class="line">T(n)=O(log2n )</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>算法的时间复杂度和两个因素有关：算法中的最大嵌套循环层数；最内层循环结构中循环的次数。</code></pre><h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p>空间复杂度(Space Complexity) 是对一个算法在运行过程中临时占用存储空间大小的量度，记做 S(n)=O(f(n)) ，其中n为问题的规模。</p><p>对于一个算法来说，空间复杂度和时间复杂度往往是相互影响的。当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，当追求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。</p><h1 id="常见排序算法的时间复杂度和空间复杂度"><a href="#常见排序算法的时间复杂度和空间复杂度" class="headerlink" title="常见排序算法的时间复杂度和空间复杂度"></a>常见排序算法的时间复杂度和空间复杂度</h1><pre><code>空间复杂度，时间复杂度，稳定性，初始序列对排序的时间复杂度的影响。</code></pre><p><img src="http://oxk1vrcj4.bkt.clouddn.com/20160511201657270.png" alt=""></p><pre><code>注意：    1. 基数排序的复杂度中，r代表关键字的基数，d代表长度，n代表关键字的个数。    2. 初始数据集排列顺序与比较次数无关的有：堆排序、归并排序，选择排序。  （一堆海归选基友）。</code></pre><h1 id="常见的数据结构的基本操作复杂度"><a href="#常见的数据结构的基本操作复杂度" class="headerlink" title="常见的数据结构的基本操作复杂度"></a>常见的数据结构的基本操作复杂度</h1><p><img src="http://oxk1vrcj4.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180709211936.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oxk1vrcj4.bkt.clouddn.com/v2-6a8c5ef5d6a497bf93746b44dab12219_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度与空间复杂度&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://abelchao.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://abelchao.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>毕业论文（Massive MIMO）</title>
    <link href="http://abelchao.com/2018/06/27/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://abelchao.com/2018/06/27/毕业论文（一）/</id>
    <published>2018-06-27T01:00:00.000Z</published>
    <updated>2018-07-04T07:15:44.540Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oxk1vrcj4.bkt.clouddn.com/80330356603457038.jpg" alt=""></p><p><strong>Massive MIMO 预编码技术研究与实现</strong><br><a id="more"></a></p><h1 id="Massive-MIMO-预编码技术研究与实现"><a href="#Massive-MIMO-预编码技术研究与实现" class="headerlink" title="Massive MIMO 预编码技术研究与实现"></a>Massive MIMO 预编码技术研究与实现</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>移动技术的发展</strong></p><ol><li>第一代：模拟技术和频分多址（FDMA）</li><li>第二代：时分多址（TDMA）和频分多址（FDMA），第二代移动通信系统与第一代移动通信相比将时间和频率结合在一起使用并以此来寻址，增强了整个系统抗干扰能力和抗衰落能力。</li><li>第三代：码分多址（CDMA），比第二代，其抗干扰能力和抗多径能力增强，但是由于第三代移动通信系统采用闭环功率控制，这个在电路交换中很容易实现，但是在高速分组业务中，由于数据传输速率很快，而功率控制很慢，导致3G不能传输高速数据。<br>另外，由于3G的带宽有限，传输速率和抗干扰能力之间存在矛盾。</li><li>第四代：正交频分复用（OFDM）和多入多出（MIMO）。OFDM是多载波传输的一种。</li></ol><p><strong>Massive MIMO的优势和缺点</strong></p><ol><li>深度挖掘空间维度资源，使得多个用户可以在同一时频资源上与基站同时进行通信，从而可以很大程度上提升频率效率。</li><li>大幅度降低上下行发射功率，提高功率效率。</li><li>波束集中在很窄的范围内，大幅度降低了干扰。</li><li><p>基站天线数量趋于无穷时，最简单的线性预编码也能获得很好的性能，且信道中的噪声和不相关干扰可以忽略不计。</p></li><li><p>Massive MIMO仅考虑时分双工（TDD，Time Division Duplex）系统，该系统利用信道的互易性来获取信道状态信息，然而，因为当前导频空间的维数是有限的，不同小区可能会采用相同的导频序列进行信号发送，导致基站不能区分信号来自哪个小区，不可避免的形成导频污染。</p></li><li>信道模型还不成熟</li><li>预编码中矩阵的维度较高，简单的线性预编码中存在矩阵求逆，导致其计算复杂度大幅度提升。</li><li>功耗大幅度增加，因此需要设计天线单元和阵列。</li></ol><p><strong>什么是导频？什么是导频污染</strong></p><h2 id="研究现状"><a href="#研究现状" class="headerlink" title="研究现状"></a>研究现状</h2><p>   在多用户Massive MIMO系统中，不同信道之间存在相互间的干扰，如何消除这些干扰成为Massive MIMO的主要问题<br>。预编码技术作为Massive MIMO系统中的一项关键技术，通过对发射信号进行预处理，使不同信道之间的干扰得以消除，从而解决多用户Massive MIMO的干扰问题。但由于Massive MIMO系统中，天线数量是目前LTEA的十倍以上，发射天线数目与接收天线数目比值很大，导致Massive MIMO预编码算法必然存在复杂度巨大的问题。</p><p>   最佳的MIMO预编码方案是脏纸编码(dirty paper coding，DPC)，其是以不可承受的复杂性为代价来实现信道容<br>量的提升。与脏纸编码相比，其他非线性预编码方案复杂性低，可以实现接近脏纸编码的信道容量，如矢量扰动(VP)，格子辅助预编码等。但当基站天线数量变大时这些算法的复杂度太高，阻碍了其在MassiveMIMO中的运用。幸运的是，当BS天线数量大幅度增加时削弱了信道间的干扰，此时，Massive MIMO系统采用简单的、计算复杂度低的线性预编码方案就可以获得很好的性能。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ol><li>系统模型和原理，对Massive MIMO系统的频谱效率进行了分析。基站侧天线数量越多，非线性预编码的复杂性太高难以承受，而线性预编码的计算复杂度虽然高，但是相比非线性预编码来说已经降低很多了。</li><li>ZF、RZF预编码算法的性能仿真，比较采用MRT、RZF、ZF预编码算法的系统频率效率。</li><li>TRE和MDPE预编码算法。单小区Massive MIMO系统低复杂度的TPE算法；MDPE算法的改进。</li></ol><h2 id="系统模型"><a href="#系统模型" class="headerlink" title="系统模型"></a>系统模型</h2><p>在多用户MIMO系统中，发射端将输入数据进行串并转换后转变成几路并行的子数据流，再进行预编码处理，然后通过不同的发射天线将进行信号发送。接收端进行一系列的解码处理后即可得到用户所需的数据。MIMO技术将信道分成了几个并行的子信道，在不增加带宽的情况下重复利用频谱资源。理论上频谱效率、无线传输速率、抗干扰、抗衰落能力都可以得到极大提高。</p><p>基于随机矩阵理论的证明表明：理想场景下，Massive MIMO可以消除不相关的声和小尺度衰落的影响。每个小区内终端数量独立于小区的大小，与信道相干时间关。简单的信号处理方法可以在Massive MIMO系统中使用并达到很好的性能。</p><p>本文主要考虑典型的Massive MIMO系统，即在基站侧有N个天线，同时服务K个单天线用户(N》K)，接收信号Y∈C融1，下行链路系统框图如图2．2，接收信号可以表示为式(2.1)：</p><p><img src="http://oxk1vrcj4.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180703195102.png" alt=""></p><p><img src="http://oxk1vrcj4.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180703195144.png" alt=""></p><h3 id="点对点"><a href="#点对点" class="headerlink" title="点对点"></a>点对点</h3><p>单小区，基站配有N个发射天线，接收端配有K个接收天线。接收信号可以表示为</p><p><img src="http://oxk1vrcj4.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180703201159.png" alt=""></p><h3 id="多用户"><a href="#多用户" class="headerlink" title="多用户"></a>多用户</h3><h3 id="多小区"><a href="#多小区" class="headerlink" title="多小区"></a>多小区</h3><h2 id="预编码技术"><a href="#预编码技术" class="headerlink" title="预编码技术"></a>预编码技术</h2><p>Massive MIMO预编码技术从实现方式上可以分为基于非码本和基于码本。而从类型上可以分为非线性和线性。基于非码本的预编码技术包含了非线性预编码和线性预编码两类，这两类预编码都需要发送端获知全部或者部分的信道状态信息(ChannelState Information，CSI)，其信道反馈信息较大，但性能较好。</p><h3 id="基于码本的预编码"><a href="#基于码本的预编码" class="headerlink" title="基于码本的预编码"></a>基于码本的预编码</h3><p>基于码本的预编码通常都是线性预编码，是在发送端和接收端保存相同的码本集合。接收端通过信道估计获得当前的CSI，然后，根据CSI和码本选择方案从码本集合中选取性能最好的码本，并将对应的预编码矩阵指示序号(Precoding matrix index，PMI)反馈给基站，基站根据PMI从码本集合中选取对应的码本进行预编码。基于码本的预编码需要的信道信息反馈量较小，计算复杂度低，现有的码本设计方法(如：基于2D．DFT码本设计)性能较差，不适用于MassiveMIMO系统。新型的码本设计方法(如：基于BD．DFT扩展的码本设计)能够达到不错的性能。</p><h3 id="非线性"><a href="#非线性" class="headerlink" title="非线性"></a>非线性</h3><h3 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h3><p><img src="http://oxk1vrcj4.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180703202743.png" alt=""></p><p><strong>1. ZF预编码</strong></p><p><strong>2. MMSE预编码</strong></p><p><strong>3. MRT预编码</strong></p><h2 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h2><p><img src="http://oxk1vrcj4.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180703203420.png" alt=""></p><p>上图中，首先，采用matlab滋数randint(100*K枣b，1)产生信源(100为信道变化～次发送信号信号数量，K为终端用户数，b为调制阶数)，然后，经过64QAM调制、复用(鼯16)、预编码、发送信号归一化、乘以P^1/2(P为发送功率)、过信道(信道矩阵服从CN(0，1)分布)、加噪声(n为高斯自噪声)、除以P^1/2，a，p(预编码归一化因子)、解复用、解MQAM调制，最后，得到接收信号(每个dB循环10000次)。</p><h3 id="ZF与MMSE算法中SNR和BER的比较"><a href="#ZF与MMSE算法中SNR和BER的比较" class="headerlink" title="ZF与MMSE算法中SNR和BER的比较"></a>ZF与MMSE算法中SNR和BER的比较</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">%基于ZF准则和MMSE准则的预编码性能比较</span><br><span class="line"><span class="function">function <span class="title">zf_mmse</span><span class="params">()</span></span></span><br><span class="line"><span class="function">clear all</span></span><br><span class="line"><span class="function">close all</span></span><br><span class="line"><span class="function">format <span class="keyword">long</span></span>; %将数据显示为长整型科学计数 </span><br><span class="line">Nt=<span class="number">4</span>;%天线个数</span><br><span class="line">Nr=<span class="number">4</span>;</span><br><span class="line">SNR=[<span class="number">0</span>:<span class="number">2</span>:<span class="number">20</span>];%设置不同信噪比</span><br><span class="line">channel_n=<span class="number">100</span>*ones(<span class="number">1</span>,length(SNR));</span><br><span class="line">error_mmselinp=zeros(<span class="number">1</span>,length(SNR));%初始化误码率</span><br><span class="line">error_zflinp=zeros(<span class="number">1</span>,length(SNR));</span><br><span class="line"><span class="keyword">for</span> loop_ebno=<span class="number">1</span>:length(SNR)%不同信噪比的循环</span><br><span class="line">    snr=<span class="number">10</span>.^(SNR(loop_ebno)/<span class="number">10</span>);%将信噪比从分贝形式转化成比例表示</span><br><span class="line">    ea=<span class="number">1</span>;%每个天线发射的功率，也即信号向量中每个元素的功率</span><br><span class="line">    es=ea*Nt;%总共的发射功率</span><br><span class="line">    sigma_n2=es/snr;%噪声功率</span><br><span class="line">    num=<span class="number">200</span>;%发送数据个数</span><br><span class="line">    tic,</span><br><span class="line">    <span class="keyword">for</span> loop_channel=<span class="number">1</span>:channel_n(loop_ebno)%信道的实现次数的循环</span><br><span class="line">        H=sqrt(<span class="number">1</span>/<span class="number">2</span>)*(randn(Nr,Nt)+j*randn(Nr,Nt));%信道增益矩阵</span><br><span class="line">        mmse_F=H<span class="string">'*inv(H*H'</span>+sigma_n2/ea*eye(Nt));</span><br><span class="line">        zf_F=H<span class="string">'*inv(H*H'</span>); %求出F^,文献MIMO信道预编码技术研究  </span><br><span class="line">        beta_mmse=sqrt(es/norm(mmse_F,<span class="string">'fro'</span>).^<span class="number">2</span>);</span><br><span class="line">        beta_zf=sqrt(es/norm(zf_F,<span class="string">'fro'</span>).^<span class="number">2</span>);%计算zf_F的Frobenius范数%%求出缩放因子beta</span><br><span class="line">        F_mmse=beta_mmse*mmse_F; </span><br><span class="line">        F_zf=beta_zf*zf_F;%求出预编码矩阵F=F^×beta</span><br><span class="line">        <span class="keyword">for</span> loop_num=<span class="number">1</span>:num%在一帧数据符号中，信道保持不变。一帧总共有num个数据发送</span><br><span class="line">            gen_u=(sign(randn(Nt,<span class="number">1</span>))+j*sign(randn(Nt,<span class="number">1</span>)));%产生信号</span><br><span class="line">            u=sqrt(<span class="number">1</span>/<span class="number">2</span>)*gen_u;%归一化信号功率</span><br><span class="line">            x_mmse=F_mmse*u;</span><br><span class="line">            x_zf=F_zf*u;%发送信号</span><br><span class="line">            noise=sqrt(sigma_n2/<span class="number">2</span>)*(randn(Nr,<span class="number">1</span>)+j*randn(Nr,<span class="number">1</span>));%生成噪声功率为sigma_n2的噪声</span><br><span class="line">            noise1=sqrt(sigma_n2/<span class="number">2</span>)*(randn(Nr,<span class="number">1</span>)+j*randn(Nr,<span class="number">1</span>));</span><br><span class="line">            y_mmse=H*x_mmse+noise;</span><br><span class="line">            y_zf=H*x_zf+noise1;</span><br><span class="line">            r_mmse=<span class="number">1</span>/beta_mmse*y_mmse;</span><br><span class="line">            r_zf=<span class="number">1</span>/beta_zf*y_zf;%接收信号</span><br><span class="line">            rev_data_mmse=sign(real(r_mmse))+j*sign(imag(r_mmse));%对接收信号进行判决</span><br><span class="line">            rev_data_zf=sign(real(r_zf))+j*sign(imag(r_zf));</span><br><span class="line">            error_mmselinp(<span class="number">1</span>,loop_ebno)=error_mmselinp(<span class="number">1</span>,loop_ebno)+sum(((abs(rev_data_mmse-gen_u)).^<span class="number">2</span>)/<span class="number">4</span>);%计算误比特数</span><br><span class="line">            error_zflinp(<span class="number">1</span>,loop_ebno)=error_zflinp(<span class="number">1</span>,loop_ebno)+sum(((abs(rev_data_zf-gen_u)).^<span class="number">2</span>)/<span class="number">4</span>);</span><br><span class="line">        end </span><br><span class="line">    end </span><br><span class="line">    toc</span><br><span class="line">    ber_mmselinp(<span class="number">1</span>,loop_ebno)=error_mmselinp(<span class="number">1</span>,loop_ebno)/(num*Nt*<span class="number">2</span>*channel_n(loop_ebno));%注意每一个信噪比产生的数据数=channel_n(loop_ebno)*num*Nt*<span class="number">2</span>,</span><br><span class="line">                                                                                          %乘以<span class="number">2</span>是因为，产生的数据符号式复数，相当于进行了<span class="number">4</span>QAM调制</span><br><span class="line">    ber_zflinp(<span class="number">1</span>,loop_ebno)=error_zflinp(<span class="number">1</span>,loop_ebno)/(num*Nt*<span class="number">2</span>*channel_n(loop_ebno));</span><br><span class="line">end </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%画出不同准则下误码率和信噪比的曲线</span><br><span class="line">P1=semilogy(SNR,ber_mmselinp,<span class="string">'o-r'</span>);</span><br><span class="line">hold on</span><br><span class="line">P2=semilogy(SNR,ber_zflinp,<span class="string">'*-k'</span>);</span><br><span class="line">set(P1,<span class="string">'Linewidth'</span>,[<span class="number">2</span>]);%P1线宽<span class="number">2</span>号</span><br><span class="line">set(P2,<span class="string">'Linewidth'</span>,[<span class="number">2</span>]);%P2线宽<span class="number">2</span>号</span><br><span class="line">grid on;</span><br><span class="line">xlabel(<span class="string">'symbol SNR(dB)'</span>);ylabel(<span class="string">'BER'</span>);</span><br><span class="line">title(<span class="string">'基于ZF准则和MMSE准则的预编码性能比较'</span>)</span><br><span class="line">leg1=<span class="string">'mmselinear'</span>;%设置图例</span><br><span class="line">leg2=<span class="string">'zflinear'</span>;</span><br><span class="line">legend(leg1,leg2);</span><br></pre></td></tr></table></figure><p><img src="http://oxk1vrcj4.bkt.clouddn.com/4r4t%E7%9A%84ZF%E4%B8%8EMMSE.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oxk1vrcj4.bkt.clouddn.com/80330356603457038.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Massive MIMO 预编码技术研究与实现&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="5G信号源" scheme="http://abelchao.com/categories/5G%E4%BF%A1%E5%8F%B7%E6%BA%90/"/>
    
    
      <category term="5G信号源" scheme="http://abelchao.com/tags/5G%E4%BF%A1%E5%8F%B7%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode（二）</title>
    <link href="http://abelchao.com/2018/06/26/LeetCode%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://abelchao.com/2018/06/26/LeetCode（二）/</id>
    <published>2018-06-26T01:00:00.000Z</published>
    <updated>2018-07-02T12:49:32.700Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oxk1vrcj4.bkt.clouddn.com/v2-ae91c349972a51da6a0791851fd53267_hd.jpg" alt=""></p><p><strong>LeetCode（二）</strong><br><a id="more"></a></p><h1 id="unique-paths"><a href="#unique-paths" class="headerlink" title="unique paths"></a>unique paths</h1><pre><code>就是机器人走方格，和走点数的唯一不同就是返回条件不一样</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//走交叉点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getPath</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> column)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">0</span>||column==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> getPath(row-<span class="number">1</span>,column)+getPath(row,column-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//走方格</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getPath</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> column)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">1</span>||column==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> getPath(row-<span class="number">1</span>,column)+getPath(row,column-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//走方格非递归</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePath3</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;m;i++)&#123;</span><br><span class="line">            map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">            map[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                map[i][j] = map[i-<span class="number">1</span>][j]+map[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="sort-color"><a href="#sort-color" class="headerlink" title="sort color"></a>sort color</h1><pre><code>new int[]{0,1,1,0,2,0,1,1,0,2,1}，数组排序，只有0，1，2三个数</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//就是把0，1，2得到数量后顺序排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> w = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:A)</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">                r++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">1</span>)</span><br><span class="line">                w++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b++;</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;r)</span><br><span class="line">                A[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;=r &amp;&amp; i&lt;r+w)</span><br><span class="line">                A[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                A[i] = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="remove-duplicates-from-sorted-array"><a href="#remove-duplicates-from-sorted-array" class="headerlink" title="remove duplicates from sorted array"></a>remove duplicates from sorted array</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span>||A.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = A[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]==temp)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count++;</span><br><span class="line">                temp = A[i];</span><br><span class="line">                A[++t] = temp; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="remove-duplicates-from-sorted-list"><a href="#remove-duplicates-from-sorted-list" class="headerlink" title="remove-duplicates-from-sorted-list"></a>remove-duplicates-from-sorted-list</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur.next != <span class="keyword">null</span> &amp;&amp; cur.val == cur.next.val)</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">deleteDuplicates</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">Node h = head;</span><br><span class="line"><span class="keyword">while</span>(h!=<span class="keyword">null</span>)&#123;</span><br><span class="line">Node temp = h;</span><br><span class="line"><span class="keyword">while</span>(temp.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(h.val==temp.next.val)&#123;</span><br><span class="line">temp.next = temp.next.next;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">h = h.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="remove-duplicates-from-sorted-list-ii"><a href="#remove-duplicates-from-sorted-list-ii" class="headerlink" title="remove-duplicates-from-sorted-list-ii"></a>remove-duplicates-from-sorted-list-ii</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode FakeHead=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        FakeHead.next=head;</span><br><span class="line">        ListNode pre=FakeHead;</span><br><span class="line">        ListNode cur=head; </span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123; </span><br><span class="line">            <span class="keyword">while</span>(cur.next!=<span class="keyword">null</span>&amp;&amp;cur.val==cur.next.val)&#123;</span><br><span class="line">                cur=cur.next;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(pre.next==cur)&#123;</span><br><span class="line">                pre=pre.next;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                pre.next=cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> FakeHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="merge-two-sorted-lists"><a href="#merge-two-sorted-lists" class="headerlink" title="merge-two-sorted-lists"></a>merge-two-sorted-lists</h1><pre><code>归并排序的第二步</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode h1, ListNode h2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(h1==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> h2;</span><br><span class="line">        <span class="keyword">if</span>(h2==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> h1;</span><br><span class="line"></span><br><span class="line">        ListNode fakeNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode cur = fakeNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(h1!=<span class="keyword">null</span> &amp;&amp; h2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(h1.val&lt;h2.val)&#123;</span><br><span class="line">                cur.next = h1;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                h1 = h1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = h2;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                h2 = h2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(h1!=<span class="keyword">null</span>)</span><br><span class="line">            cur.next = h1;</span><br><span class="line">        <span class="keyword">if</span>(h2!=<span class="keyword">null</span>)</span><br><span class="line">            cur.next = h2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fakeNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="insert-lists"><a href="#insert-lists" class="headerlink" title="insert lists"></a>insert lists</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">sortListByInsert</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">Node fakeNode = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line">Node pre = fakeNode;</span><br><span class="line">Node cur = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">Node next = cur.next;</span><br><span class="line">pre = fakeNode;</span><br><span class="line"><span class="keyword">while</span>(pre.next!=<span class="keyword">null</span> &amp;&amp; pre.next.val&lt;=cur.val)&#123;</span><br><span class="line">pre = pre.next;</span><br><span class="line">&#125;</span><br><span class="line">cur.next = pre.next;</span><br><span class="line">pre.next = cur;</span><br><span class="line">cur = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fakeNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="remove-nth-node-from-end-of-list"><a href="#remove-nth-node-from-end-of-list" class="headerlink" title="remove-nth-node-from-end-of-list"></a>remove-nth-node-from-end-of-list</h1><pre><code>1-&gt;2-&gt;3-&gt;4-&gt;5 (1-&gt;2-&gt;3-&gt;5)</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line"></span><br><span class="line">        ListNode fakeNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode temp = fakeNode;</span><br><span class="line"></span><br><span class="line">        temp.next = slow;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>&amp;&amp;fast!=<span class="keyword">null</span>;i++)</span><br><span class="line">            fast = fast.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp.next = slow.next;</span><br><span class="line">        <span class="keyword">return</span> fakeNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="path-sum"><a href="#path-sum" class="headerlink" title="path-sum"></a>path-sum</h1><pre><code>给定一棵二叉树和一个数，判断是否存在一条从根节点到任意节点的路径，其所经过的节点值之和等于给定的数</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span> &amp;&amp; sum - root.val==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> (hasPathSum(root.left,sum-root.val)||hasPathSum(root.right,sum-root.val));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="symmetric-tree"><a href="#symmetric-tree" class="headerlink" title="symmetric-tree"></a>symmetric-tree</h1><pre><code>二叉树是否镜像</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span> isSymmetric(root.left,root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode left,TreeNode right)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left==<span class="keyword">null</span> &amp;&amp; right==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span>(left==<span class="keyword">null</span> || right==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(left.val!=right.val)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (isSymmetric(left.left,right.right) &amp;&amp; isSymmetric(left.right,right.left));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="minimum-path-sum"><a href="#minimum-path-sum" class="headerlink" title="minimum-path-sum"></a>minimum-path-sum</h1><pre><code>最小路径和</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">1</span>]+grid[<span class="number">0</span>][j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">                dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="spiral-matrix"><a href="#spiral-matrix" class="headerlink" title="spiral-matrix"></a>spiral-matrix</h1><pre><code>顺时针打印矩阵（螺旋矩阵）</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">if</span>(row&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        <span class="keyword">int</span> column = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(column&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(row&gt;start*<span class="number">2</span> &amp;&amp; column&gt;start*<span class="number">2</span>)&#123;</span><br><span class="line">            printByClockwise(matrix,row,column,start,list);</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printByClockwise</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span> row,<span class="keyword">int</span> column,<span class="keyword">int</span> start,List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> endRow = row-<span class="number">1</span>-start;</span><br><span class="line">        <span class="keyword">int</span> endColumn = column-<span class="number">1</span>-start;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从左往后打印</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=endColumn;i++)</span><br><span class="line">            list.add(matrix[start][i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从上往下打印</span></span><br><span class="line">        <span class="keyword">if</span>(endRow&gt;start)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">1</span>;i&lt;=endRow;i++)</span><br><span class="line">                list.add(matrix[i][endColumn]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从右往左打印</span></span><br><span class="line">        <span class="keyword">if</span>(endRow&gt;start &amp;&amp; endColumn&gt;start)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=endColumn-<span class="number">1</span>;i&gt;=start;i--)</span><br><span class="line">                list.add(matrix[endRow][i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(endRow-<span class="number">1</span>&gt;start &amp;&amp; endColumn&gt;start)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=endRow-<span class="number">1</span>;i&gt;=start+<span class="number">1</span>;i--)</span><br><span class="line">                list.add(matrix[i][start]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="spiral-matrix-ii"><a href="#spiral-matrix-ii" class="headerlink" title="spiral-matrix-ii"></a>spiral-matrix-ii</h1><pre><code>给一个数字n，1^2,2^2,...n^2。（旋转生成）</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">1</span>, rowStart = <span class="number">0</span>, rowEnd = n - <span class="number">1</span>, colStart = <span class="number">0</span>, colEnd = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= n * n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = colStart; i &lt;= colEnd; i++) &#123;</span><br><span class="line">                res[rowStart][i] = index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = rowStart + <span class="number">1</span>; i &lt;= rowEnd; i++) &#123;</span><br><span class="line">                res[i][colEnd] = index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = colEnd - <span class="number">1</span>; i &gt;= colStart; i--) &#123;</span><br><span class="line">                res[rowEnd][i] = index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = rowEnd - <span class="number">1</span>; i &gt; rowStart; i--) &#123;</span><br><span class="line">                res[i][colStart] = index++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            rowStart += <span class="number">1</span>;</span><br><span class="line">            rowEnd -= <span class="number">1</span>;</span><br><span class="line">            colStart += <span class="number">1</span>;</span><br><span class="line">            colEnd -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Jump-Game"><a href="#Jump-Game" class="headerlink" title="Jump Game"></a>Jump Game</h1><pre><code>假设有一个数组，该数组中的元素全部都是非负整数。当前起点为数组中下标为零的位置，要走到数组的最后一个下标。其中，数组中每一个元素代表当前下标下可以前进的最大步数。如果可以从起点走向终点，那么返回true，否则返回false。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="permutations"><a href="#permutations" class="headerlink" title="permutations"></a>permutations</h1><pre><code>全排列</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//对数组元素进行从小到大排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        solve(list, nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(ArrayList&lt;Integer&gt; list, <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!list.contains(nums[i])) &#123;</span><br><span class="line">                list.add(nums[i]);</span><br><span class="line">                solve(list, nums);</span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="swap-nodes-in-pairs"><a href="#swap-nodes-in-pairs" class="headerlink" title="swap-nodes-in-pairs"></a>swap-nodes-in-pairs</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">swapPairs</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">Node fakeNode = head.next;</span><br><span class="line">head.next = swapPairs(head.next.next);</span><br><span class="line">fakeNode.next = head;</span><br><span class="line"><span class="keyword">return</span> fakeNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Sum-Root-to-Leaf-Numbers"><a href="#Sum-Root-to-Leaf-Numbers" class="headerlink" title="Sum Root to Leaf Numbers"></a>Sum Root to Leaf Numbers</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> helper(root,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(root.left==<span class="keyword">null</span> &amp;&amp; root.right==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> sum*<span class="number">10</span>+root.val;</span><br><span class="line"><span class="keyword">return</span> helper(root.left,sum*<span class="number">10</span>+root.val)+helper(root.right,sum*<span class="number">10</span>+root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oxk1vrcj4.bkt.clouddn.com/v2-ae91c349972a51da6a0791851fd53267_hd.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LeetCode（二）&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://abelchao.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://abelchao.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode（一）</title>
    <link href="http://abelchao.com/2018/06/25/LeetCode%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://abelchao.com/2018/06/25/LeetCode（一）/</id>
    <published>2018-06-25T01:00:00.000Z</published>
    <updated>2018-06-26T03:40:42.891Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oxk1vrcj4.bkt.clouddn.com/bcc9eaa4f63e56a0eff354b37bbeac42_r.jpg" alt=""></p><p><strong>LeetCode（一）</strong><br><a id="more"></a></p><h1 id="maximum-depth-of-binary-tree（就是高度）"><a href="#maximum-depth-of-binary-tree（就是高度）" class="headerlink" title="maximum depth of binary tree（就是高度）"></a>maximum depth of binary tree（就是高度）</h1><pre><code>二叉树的最大深度其实就是左子树或者右子树中较大深度的子树高度+1，当传入节点是null时，返回0</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="minimum-depth-of-binary-tree"><a href="#minimum-depth-of-binary-tree" class="headerlink" title="minimum depth of binary tree"></a>minimum depth of binary tree</h1><pre><code>二叉树的最小深度递归解决是最好的，当左子树或右子树为null时，直接判断另外的一个，一旦都不为null，才取最小值。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> run(root.right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.right==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> run(root.left)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.min(run(root.left),run(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="evaluate-reverse-polish-notation"><a href="#evaluate-reverse-polish-notation" class="headerlink" title="evaluate reverse polish notation"></a>evaluate reverse polish notation</h1><pre><code>逆波兰法的两步操作（本题只考了第二步，其实第一步最难，因为需要考虑-是负号还是减号的问题，还要把数字和符号分开）：    1. 中缀表达式到后缀表达式        1. List与Stack分别作为后缀表达式的保存集合和符号位置变换利用的栈。        2. 遇到数字直接进入List，遇到符号（、+、-、*、/、）需要入栈，但是入栈之前需要考虑栈顶符号和入栈符号的优先级问题：            1. （，直接入栈            2. ），从栈顶开始弹出，直到遇到）或者栈的size等于0（第二个条件基本不会成立，可以不写），弹出的符号进入List            3. +，-，只要遇到的不是（，就需要出栈（直到遇到（或者栈的size等于0，就入栈），其他的就直接入栈。            4. /，*，只有遇到的不是（，+，-的时候，或者栈的size等于0，就需要直接出栈，其他的就是弹出。    2. 后缀表达式计算值        1. 遇到数字进栈。        2. 遇到符号，弹出栈顶两个操作数，计算后，把计算得到的结果再压入栈        3. 栈中最后剩余的数字就是答案。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//逆波兰法的最后一步，数字进栈，符号出栈，计算后，又入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(String[] tokens)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s:tokens)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.matches(<span class="string">"[\\+\\-\\*\\/]&#123;1&#125;"</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> n1 = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> n2 = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> n = calculate(n1,n2,s);</span><br><span class="line">                stack.push(n);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(Integer.parseInt(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> n1,<span class="keyword">int</span> n2,String symbol)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(symbol.equals(<span class="string">"+"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> n1+n2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(symbol.equals(<span class="string">"*"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> n1*n2;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(symbol.equals(<span class="string">"/"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> n2/n1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n2-n1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="max-points-on-a-line"><a href="#max-points-on-a-line" class="headerlink" title="max points on a line"></a>max points on a line</h1><pre><code>求二维平面上n个点中，最多共线的点数（穷举，不会）</code></pre><h1 id="sort-list"><a href="#sort-list" class="headerlink" title="sort list"></a>sort list</h1><pre><code>链表排序（时间复杂度nlogn），归并排序</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//找到链表的中间节点，然后递归对前半部分和后半部分分别进行归并排序，最后对两个排好序的链表进行Merge</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode firstHalf = head;</span><br><span class="line">        <span class="keyword">while</span>(fast.next!=<span class="keyword">null</span> &amp;&amp; fast.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode secondHalf = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode leftList = <span class="keyword">null</span>;</span><br><span class="line">        ListNode rightList = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(firstHalf!=secondHalf)&#123;</span><br><span class="line">            leftList = sortList(firstHalf);</span><br><span class="line">            rightList = sortList(secondHalf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merge(leftList,rightList);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode leftList,ListNode rightList)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftList==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> rightList;</span><br><span class="line">        <span class="keyword">if</span>(rightList==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> leftList;</span><br><span class="line">        </span><br><span class="line">        ListNode mergeNode = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode temp = mergeNode;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(rightList!=<span class="keyword">null</span> &amp;&amp; leftList!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(rightList.val&lt;leftList.val)&#123;</span><br><span class="line">                temp.next = rightList;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">                rightList = rightList.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                temp.next = leftList;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">                leftList = leftList.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(rightList!=<span class="keyword">null</span>)</span><br><span class="line">            temp.next = rightList;</span><br><span class="line">        <span class="keyword">if</span>(leftList!=<span class="keyword">null</span>)</span><br><span class="line">            temp.next = leftList;</span><br><span class="line">        <span class="keyword">return</span> mergeNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="single-number"><a href="#single-number" class="headerlink" title="single number"></a>single number</h1><pre><code>找到一个数组中只出现一次的数，其他的数字都出现了2次。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把数组中所有的数都进行异或，那么相同的数字异或后成为0，而0与任何数异或为本数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:A)</span><br><span class="line">            n = n^i;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="single-number-2"><a href="#single-number-2" class="headerlink" title="single number 2"></a>single number 2</h1><pre><code>找到一个数组中只出现一次的数，其他的数字都出现了3次。int是32位的，4个字节。把数组中的每一个数，都变成2进制，进行位运算，通过每个数字&amp;1，可以判断出这一位上1的个数。一旦1的个数进行%k，余不尽，那么把这一位再左移i位，后面前面都是0，计算出这个数，累加就可以了。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = A.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length;j++)</span><br><span class="line">                count+=(A[j]&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">            result+=(count%<span class="number">3</span>)&lt;&lt;i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="reverse-integer"><a href="#reverse-integer" class="headerlink" title="reverse integer"></a>reverse integer</h1><pre><code>反转Integer数，考虑到溢出。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            res = res*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)((res&gt;Integer.MAX_VALUE||res&lt;Integer.MIN_VALUE)?<span class="number">0</span>:res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="palindrome-number"><a href="#palindrome-number" class="headerlink" title="palindrome-number"></a>palindrome-number</h1><pre><code>回文数字</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不能把数字变成字符串，那么就把生成一个反转数，就和这个题一样了：reverse integer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = x;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="number">0</span>)&#123;</span><br><span class="line">            res = res * <span class="number">10</span> + temp % <span class="number">10</span>;</span><br><span class="line">            temp = temp / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res==x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="linked-list-cycle"><a href="#linked-list-cycle" class="headerlink" title="linked list cycle"></a>linked list cycle</h1><pre><code>单向链表是否有环快慢节点是否相等</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(slow==fast)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="linked-list-cycle-ii"><a href="#linked-list-cycle-ii" class="headerlink" title="linked list cycle-ii"></a>linked list cycle-ii</h1><pre><code>环的入口地址</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="keyword">null</span> || fast.next==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        slow = head;</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="linked-list-cycle-iii"><a href="#linked-list-cycle-iii" class="headerlink" title="linked list cycle-iii"></a>linked list cycle-iii</h1><pre><code>环长</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLoopLength</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Node fast = head;</span><br><span class="line">Node slow = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">fast = fast.next.next;</span><br><span class="line">slow = slow.next;</span><br><span class="line"><span class="keyword">if</span>(slow==fast)&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">count++;</span><br><span class="line">fast = fast.next.next;</span><br><span class="line">slow = slow.next;</span><br><span class="line"><span class="keyword">if</span>(slow==fast)</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="maximum-subarray"><a href="#maximum-subarray" class="headerlink" title="maximum subarray"></a>maximum subarray</h1><pre><code>让我们找到一个连续的子数组，它的sum是最大的。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span> || A.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = A.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            sum = Math.max(sum+A[i],A[i]);</span><br><span class="line">            max = Math.max(sum,max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="search-insert-position"><a href="#search-insert-position" class="headerlink" title="search insert position"></a>search insert position</h1><pre><code>在一个排好序的数组查找某值，存在则返回对应的value,不存在则返回能插入到数组中的index，  其实就是找到第一个大于等于目标值的下标。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = A.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">            <span class="keyword">if</span>(target==A[i]||target&lt;A[i])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="same-tree"><a href="#same-tree" class="headerlink" title="same tree"></a>same tree</h1><pre><code>判断两个树是不是相等</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || q == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">        <span class="keyword">return</span> (p.val==q.val) &amp;&amp; isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="balanced-binary-tree"><a href="#balanced-binary-tree" class="headerlink" title="balanced binary tree"></a>balanced binary tree</h1><pre><code>一个树是不是平衡二叉树</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(height(root.left) - height(root.right))&gt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(height(node.left),height(node.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="climbing-stairs"><a href="#climbing-stairs" class="headerlink" title="climbing -stairs"></a>climbing -stairs</h1><pre><code>n个台阶的楼梯，每次能够上1或2个台阶，有多少种不同到达顶部的走法？</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>; dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="search-a-2d-matrix"><a href="#search-a-2d-matrix" class="headerlink" title="search-a-2d-matrix"></a>search-a-2d-matrix</h1><pre><code>排序的二维数组中查找一个数字</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length==<span class="number">0</span>||matrix[<span class="number">0</span>].length==<span class="number">0</span>||matrix==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[rows*cols];</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;cols;j++)</span><br><span class="line">                arr[t++] = matrix[i][j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:arr)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i&gt;target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="binary-tree-preorder-inorder-postorder-traversal"><a href="#binary-tree-preorder-inorder-postorder-traversal" class="headerlink" title="binary tree preorder/inorder/postorder traversal"></a>binary tree preorder/inorder/postorder traversal</h1><pre><code>二叉树的前中后序遍历</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">System.out.print(root.val);</span><br><span class="line">preorderTraversal(root.left);</span><br><span class="line">preorderTraversal(root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">inorderTraversal(root.left);</span><br><span class="line">System.out.print(root.val);</span><br><span class="line">inorderTraversal(root.right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">postorderTraversal(root.left);</span><br><span class="line">postorderTraversal(root.right);</span><br><span class="line">System.out.print(root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="binary-tree-level-order-traversal"><a href="#binary-tree-level-order-traversal" class="headerlink" title="binary tree level order traversal"></a>binary tree level order traversal</h1><pre><code>二叉树的层序遍历</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelorderTraversal(TreeNode root)&#123;</span><br><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">ArrayList&lt;TreeNode&gt; tempList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">tempList.add(root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!tempList.isEmpty())&#123;</span><br><span class="line">ArrayList&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ArrayList&lt;TreeNode&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(TreeNode node : tempList)&#123;</span><br><span class="line">intList.add(node.val);</span><br><span class="line"><span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)</span><br><span class="line">temp.add(node.left);</span><br><span class="line"><span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)</span><br><span class="line">temp.add(node.right);</span><br><span class="line">&#125;</span><br><span class="line">list.add(intList);</span><br><span class="line">tempList = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="best-time-to-buy-and-sell-stock"><a href="#best-time-to-buy-and-sell-stock" class="headerlink" title="best time to buy and sell stock"></a>best time to buy and sell stock</h1><pre><code>假设你有一个数组，里面存放的第i个元素表示第i天的股票的价格，如果你最多只允许进行一次交易（买进和卖出股票视为一次交易）   请设计一个算法得到最大利润。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> minBuy = prices[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">minBuy = Math.min(minBuy,prices[i]);</span><br><span class="line">maxProfit = Math.max(maxProfit,prices[i]-minBuy);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="best-time-to-buy-and-sell-stock-ii"><a href="#best-time-to-buy-and-sell-stock-ii" class="headerlink" title="best time to buy and sell stock ii"></a>best time to buy and sell stock ii</h1><pre><code>无限制买入卖出，之后后一天比前一天的大，就卖出，利润就是差值，但是注意的是，卖出的当天，也算是新的买入点</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保证后面的比前面的高，就可以卖出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&gt;prices[i-<span class="number">1</span>])</span><br><span class="line">                maxProfit+=(prices[i]-prices[i-<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rotate-image"><a href="#rotate-image" class="headerlink" title="rotate image"></a>rotate image</h1><pre><code>顺时针旋转矩阵90°</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = matrix.length;</span><br><span class="line">        <span class="keyword">int</span>[][] temp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">                temp[j][n-i-<span class="number">1</span>] = matrix[i][j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">                matrix[i][j] = temp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="container-with-most-water"><a href="#container-with-most-water" class="headerlink" title="container with most water"></a>container with most water</h1><pre><code>我们假设最初的最大蓄水量为0。然后我们分别从数组的两侧进行扫描，由于不允许倾斜，因此蓄水量仅与较低的那个边有关。因此 area=min(height[right],height[left])∗(right−left) 如果height[left] &lt; height[right]，那么left右移，找到一个比height[left]大的值。反之，则right左移。同时需要保持跟踪最大</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height==<span class="keyword">null</span> || height.length&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = height.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = len-<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            maxArea = Math.max(maxArea,Math.min(height[left],height[right])*(right-left));</span><br><span class="line">            <span class="keyword">if</span>(height[left]&lt;height[right])</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="unique-binary-search-trees"><a href="#unique-binary-search-trees" class="headerlink" title="unique binary search trees"></a>unique binary search trees</h1><pre><code>https://www.cnblogs.com/grandyang/p/4299608.html</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">                dp[i] += dp[j]*dp[i-j-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="integer-to-roman-Roman-to-Integer"><a href="#integer-to-roman-Roman-to-Integer" class="headerlink" title="integer to roman / Roman to Integer"></a>integer to roman / Roman to Integer</h1><p><a href="https://www.cnblogs.com/TenosDoIt/p/3793503.html" target="_blank" rel="noopener">https://www.cnblogs.com/TenosDoIt/p/3793503.html</a><br><a href="https://www.cnblogs.com/grandyang/p/4120857.html" target="_blank" rel="noopener">https://www.cnblogs.com/grandyang/p/4120857.html</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String[] M = &#123;<span class="string">""</span>, <span class="string">"M"</span>, <span class="string">"MM"</span>, <span class="string">"MMM"</span>&#125;;</span><br><span class="line">        String[] C = &#123;<span class="string">""</span>, <span class="string">"C"</span>, <span class="string">"CC"</span>, <span class="string">"CCC"</span>, <span class="string">"CD"</span>, <span class="string">"D"</span>, <span class="string">"DC"</span>, <span class="string">"DCC"</span>, <span class="string">"DCCC"</span>, <span class="string">"CM"</span>&#125;;</span><br><span class="line">        String[] X = &#123;<span class="string">""</span>, <span class="string">"X"</span>, <span class="string">"XX"</span>, <span class="string">"XXX"</span>, <span class="string">"XL"</span>, <span class="string">"L"</span>, <span class="string">"LX"</span>, <span class="string">"LXX"</span>, <span class="string">"LXXX"</span>, <span class="string">"XC"</span>&#125;;</span><br><span class="line">        String[] I = &#123;<span class="string">""</span>, <span class="string">"I"</span>, <span class="string">"II"</span>, <span class="string">"III"</span>, <span class="string">"IV"</span>, <span class="string">"V"</span>, <span class="string">"VI"</span>, <span class="string">"VII"</span>, <span class="string">"VIII"</span>, <span class="string">"IX"</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> M[num/<span class="number">1000</span>] + C[(num%<span class="number">1000</span>)/<span class="number">100</span>] + X[(num%<span class="number">100</span>)/<span class="number">10</span>] + I[num%<span class="number">10</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oxk1vrcj4.bkt.clouddn.com/bcc9eaa4f63e56a0eff354b37bbeac42_r.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LeetCode（一）&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="LeetCode" scheme="http://abelchao.com/categories/LeetCode/"/>
    
    
      <category term="LeetCode" scheme="http://abelchao.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://abelchao.com/2018/06/11/%E6%8E%92%E5%BA%8F/"/>
    <id>http://abelchao.com/2018/06/11/排序/</id>
    <published>2018-06-11T01:00:00.000Z</published>
    <updated>2018-06-11T13:24:27.845Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oxk1vrcj4.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180518165301.png" alt=""></p><p><strong>选择、冒泡、插入、希尔、快速、归并</strong><br><a id="more"></a></p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xd.sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> SortFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Blemon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018年6月11日 下午9:22:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortFactory</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortBySelect</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">int</span> length = arr.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;length;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&gt;arr[j])&#123;</span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[i];</span><br><span class="line">arr[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortByBubble</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp;</span><br><span class="line"><span class="keyword">int</span> length = arr.length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">temp = arr[j+<span class="number">1</span>];</span><br><span class="line">arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortByInsert</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> length = arr.length;</span><br><span class="line"><span class="keyword">int</span> temp,j;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line">temp = arr[i];</span><br><span class="line"><span class="keyword">for</span>(j=i-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">if</span>(temp&lt;arr[j])</span><br><span class="line">arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortByShell</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,j,temp;</span><br><span class="line"><span class="keyword">int</span> step = arr.length;</span><br><span class="line"><span class="keyword">int</span> length = arr.length;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">step = step/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(i=step;i&lt;length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&lt;arr[i-step])&#123;</span><br><span class="line">temp = arr[i];</span><br><span class="line"><span class="keyword">for</span>(j=i-step;j&gt;=<span class="number">0</span>;j-=step)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j]&gt;temp)</span><br><span class="line">arr[j+step] = arr[j];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">arr[j+step] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">while</span>(step&gt;<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortByQuick</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">qucikSort(arr,<span class="number">0</span>,arr.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">qucikSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> f,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f&gt;=e)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">int</span> axis = partition(arr,f,e);</span><br><span class="line">qucikSort(arr,f,axis-<span class="number">1</span>);</span><br><span class="line">qucikSort(arr,axis+<span class="number">1</span>,e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> f,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> key = arr[f];</span><br><span class="line"><span class="keyword">while</span>(f&lt;e)&#123;</span><br><span class="line"><span class="keyword">while</span>(arr[e]&gt;=key &amp;&amp; f&lt;e)</span><br><span class="line">e--;</span><br><span class="line">arr[f] = arr[e];</span><br><span class="line"><span class="keyword">while</span>(arr[f]&lt;=key &amp;&amp; f&lt;e)</span><br><span class="line">f++;</span><br><span class="line">arr[e] = arr[f];</span><br><span class="line">&#125;</span><br><span class="line">arr[f] = key;</span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sortByMerge</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> length = arr.length;</span><br><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">mergeSort(arr,<span class="number">0</span>,length-<span class="number">1</span>,result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> f,<span class="keyword">int</span> e,<span class="keyword">int</span>[] result)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f&lt;e)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (f+e)/<span class="number">2</span>;</span><br><span class="line">mergeSort(arr,f,mid,result);</span><br><span class="line">mergeSort(arr,mid+<span class="number">1</span>,e,result);</span><br><span class="line">merge(arr,f,mid,e,result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> f,<span class="keyword">int</span> mid,<span class="keyword">int</span> e,<span class="keyword">int</span>[] result)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i=f;</span><br><span class="line"><span class="keyword">int</span> j=mid+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=e)</span><br><span class="line"><span class="keyword">if</span>(arr[i]&lt;arr[j])</span><br><span class="line">result[t++] = arr[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">result[t++] = arr[j++];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">result[t++] = arr[i++];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(j&lt;=e)</span><br><span class="line">result[t++] = arr[j++];</span><br><span class="line"></span><br><span class="line">t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(f&lt;=e)</span><br><span class="line">arr[f++] = result[t++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oxk1vrcj4.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180518165301.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;选择、冒泡、插入、希尔、快速、归并&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://abelchao.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://abelchao.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>单向链表（有环）</title>
    <link href="http://abelchao.com/2018/06/07/%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%88%E6%9C%89%E7%8E%AF%EF%BC%89/"/>
    <id>http://abelchao.com/2018/06/07/单向链表（有环）/</id>
    <published>2018-06-07T01:00:00.000Z</published>
    <updated>2018-07-04T03:08:28.838Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oxk1vrcj4.bkt.clouddn.com/v2-d62bbcb75581d11905386fa62e58b3c4_hd.jpg" alt=""></p><p><strong>单向链表的一些操作</strong><br><a id="more"></a></p><h1 id="SingleLink"><a href="#SingleLink" class="headerlink" title="SingleLink"></a>SingleLink</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1. 正向打印链表</span></span><br><span class="line"><span class="comment">2. 反向打印链表（递归）</span></span><br><span class="line"><span class="comment">3. 反转链表（非递归）</span></span><br><span class="line"><span class="comment">4. 倒数第K个节点（快节点先走k-1步）</span></span><br><span class="line"><span class="comment">5. 删除倒数第K个数</span></span><br><span class="line"><span class="comment">6. 链表的中间节点</span></span><br><span class="line"><span class="comment">7. 判断链表是否有环</span></span><br><span class="line"><span class="comment">8. 环的入口地址</span></span><br><span class="line"><span class="comment">9. 环长</span></span><br><span class="line"><span class="comment">10. 链表长度</span></span><br><span class="line"><span class="comment">11. 链表是否相交</span></span><br><span class="line"><span class="comment">12. 寻找两个链表的交点</span></span><br><span class="line"><span class="comment">13. 链表尾部添加节点</span></span><br><span class="line"><span class="comment">14. 链表指定位置添加节点</span></span><br><span class="line"><span class="comment">15. 删除指定指定位置的节点</span></span><br><span class="line"><span class="comment">16. 删除有序链表中重复的节点，只保留一个</span></span><br><span class="line"><span class="comment">17. 删除有序链表中重复的节点，一个都不保留*</span></span><br><span class="line"><span class="comment">18. 合并两个排序的链表（归并第二步）</span></span><br><span class="line"><span class="comment">19. 链表排序（归并）</span></span><br><span class="line"><span class="comment">20. 链表排序（插入）*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">Node next;</span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.val = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLink_5</span></span>&#123;</span><br><span class="line"><span class="comment">//1. 正向打印链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLink</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">Node fakeNode = head;</span><br><span class="line"><span class="keyword">while</span>(fakeNode!=<span class="keyword">null</span>)&#123;</span><br><span class="line">System.out.print(fakeNode.val+<span class="string">" "</span>);</span><br><span class="line">fakeNode = fakeNode.next;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 反向打印链表（递归）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printLinkByReverse</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">printLinkByReverse(head.next);</span><br><span class="line">System.out.print(head.val+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 反转链表（非递归）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseLink</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">Node reverseNode = <span class="keyword">null</span>;</span><br><span class="line">Node work = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(work!=<span class="keyword">null</span>)&#123;</span><br><span class="line">Node temp = work.next;</span><br><span class="line">work.next = reverseNode;</span><br><span class="line">reverseNode = work;</span><br><span class="line">work = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> reverseNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 倒数第K个节点（快节点先走k-1步）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">findFromEndKth</span><span class="params">(Node head,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span>||k&lt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">Node fast = head;</span><br><span class="line">Node slow = head;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k-<span class="number">1</span>&amp;&amp;fast!=<span class="keyword">null</span>;i++)</span><br><span class="line">fast = fast.next;</span><br><span class="line"><span class="keyword">if</span>(fast==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">fast = fast.next;</span><br><span class="line">slow = slow.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 删除倒数第K个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">deleteFromEndKth</span><span class="params">(Node head,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span>||k&lt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">Node fakeNode = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line">fakeNode.next = head;</span><br><span class="line">Node pre = fakeNode;</span><br><span class="line"></span><br><span class="line">Node fast = head;</span><br><span class="line">Node slow = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k-<span class="number">1</span>&amp;&amp;fast!=<span class="keyword">null</span>;i++)</span><br><span class="line">fast = fast.next;</span><br><span class="line"><span class="keyword">if</span>(fast==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">fast = fast.next;</span><br><span class="line">slow = slow.next;</span><br><span class="line">pre = pre.next;</span><br><span class="line">&#125;</span><br><span class="line">pre.next = slow.next;</span><br><span class="line"><span class="keyword">return</span> fakeNode.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 链表的中间节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">findMiddleNode</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">Node fast = head;</span><br><span class="line">Node slow = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span> &amp;&amp; fast.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">fast = fast.next.next;</span><br><span class="line">slow = slow.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//7. 判断链表是否有环</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">existLoop</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">Node fast = head;</span><br><span class="line">Node slow = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span> &amp;&amp; fast.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">fast = fast.next.next;</span><br><span class="line">slow = slow.next;</span><br><span class="line"><span class="keyword">if</span>(fast==slow)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//8. 环的入口地址</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLoopEntrance</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">Node fast = head;</span><br><span class="line">Node slow = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span> &amp;&amp; fast.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">fast = fast.next.next;</span><br><span class="line">slow = slow.next;</span><br><span class="line"><span class="keyword">if</span>(fast==slow)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fast==<span class="keyword">null</span> || fast.next==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">slow = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">slow = slow.next;</span><br><span class="line">fast = fast.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//9. 环长</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getLoopLength</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Node fast = head;</span><br><span class="line">Node slow = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span> &amp;&amp; fast.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">fast = fast.next.next;</span><br><span class="line">slow = slow.next;</span><br><span class="line"><span class="keyword">if</span>(fast==slow)&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">fast = fast.next.next;</span><br><span class="line">slow = slow.next;</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span>(fast==slow)</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//10. 链表长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line"><span class="keyword">boolean</span> exist = existLoop(head);</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">Node temp = head;</span><br><span class="line"><span class="keyword">if</span>(!exist)&#123;</span><br><span class="line"><span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">len++;</span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> loopLen = getLoopLength(head);</span><br><span class="line">Node entrance = getLoopEntrance(head);</span><br><span class="line"><span class="keyword">while</span>(temp!=entrance)&#123;</span><br><span class="line">temp = temp.next;</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line">len = len+loopLen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//11. 链表是否相交</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isIntersect</span><span class="params">(Node h1,Node h2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(h1==<span class="keyword">null</span> &amp;&amp; h2==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span>(h1==<span class="keyword">null</span> || h2==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">Node tail1 = h1;</span><br><span class="line">Node tail2 = h2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(tail1.next!=<span class="keyword">null</span>)</span><br><span class="line">tail1 = tail1.next;</span><br><span class="line"><span class="keyword">while</span>(tail2.next!=<span class="keyword">null</span>)</span><br><span class="line">tail2 = tail2.next;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tail1==tail2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//12. 寻找两个链表的交点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getIntersection</span><span class="params">(Node h1,Node h2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(h1==<span class="keyword">null</span> &amp;&amp; h2==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(h1==<span class="keyword">null</span> || h2==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">Node tail1 = h1;</span><br><span class="line">Node tail2 = h2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> len1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(tail1.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">tail1 = tail1.next;</span><br><span class="line">len1++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(tail2.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">tail2 = tail2.next;</span><br><span class="line">len2++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(tail1!=tail2)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> gap = len1&gt;len2?len1-len2:len2-len1;</span><br><span class="line"></span><br><span class="line">Node t1 = h1;</span><br><span class="line">Node t2 = h2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(len1&gt;len2)&#123;</span><br><span class="line"><span class="keyword">while</span>(gap&gt;<span class="number">0</span>)&#123;</span><br><span class="line">t1 = t1.next;</span><br><span class="line">gap--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(gap&gt;<span class="number">0</span>)&#123;</span><br><span class="line">t2 = t2.next;</span><br><span class="line">gap--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(t1!=t2)&#123;</span><br><span class="line">t1 = t1.next;</span><br><span class="line">t2 = t2.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//13. 链表尾部添加节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">add</span><span class="params">(Node head,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">Node node = <span class="keyword">new</span> Node(v);</span><br><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">Node fakeNode = head;</span><br><span class="line"><span class="keyword">while</span>(fakeNode.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">fakeNode = fakeNode.next;</span><br><span class="line">&#125;</span><br><span class="line">fakeNode.next = node;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//14. 链表指定位置添加节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">add</span><span class="params">(Node head,<span class="keyword">int</span> v,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">Node node = <span class="keyword">new</span> Node(v);</span><br><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span>||k&lt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">node.next = head;</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">2</span>;</span><br><span class="line">Node fakeNode = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(fakeNode!=<span class="keyword">null</span> &amp;&amp; count&lt;k-<span class="number">2</span>)&#123;</span><br><span class="line">fakeNode = fakeNode.next;</span><br><span class="line">&#125;</span><br><span class="line">node.next = fakeNode.next;</span><br><span class="line">fakeNode.next = node;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//15. 删除指定指定位置的节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">delete</span><span class="params">(Node head,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span> || k&lt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line">head = head.next;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">Node fakeNode = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line">fakeNode.next = head;</span><br><span class="line">Node pre = fakeNode;</span><br><span class="line">Node cur = had;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(cur!=<span class="keyword">null</span> &amp;&amp; count&lt;k-<span class="number">2</span>)&#123;</span><br><span class="line">cur = cur.next;</span><br><span class="line">pre = pre.next;</span><br><span class="line">&#125;</span><br><span class="line">pre.next = cur.next;</span><br><span class="line"><span class="keyword">return</span> fakeNode.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//16. 删除有序链表中重复的节点，只保留一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">deleteDuplicate</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">Node cur = head;</span><br><span class="line"><span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(cur.next!=<span class="keyword">null</span> &amp;&amp; cur.next.val==cur.val)&#123;</span><br><span class="line">cur.next = cur.next.next;</span><br><span class="line">&#125;</span><br><span class="line">cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//17. 删除有序链表中重复的节点，一个都不保留*</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">deleteDuplicate</span><span class="params">(Node head,<span class="keyword">boolean</span> hold)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(hold)</span><br><span class="line"><span class="keyword">return</span> deleteDuplicate(head);</span><br><span class="line"></span><br><span class="line">Node fakeNode = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line">fakeNode.next = head;</span><br><span class="line">Node pre = fakeNode.next;</span><br><span class="line">Node cur = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(cur.next!=<span class="keyword">null</span> &amp;&amp; cur.next.val==cur.val)&#123;</span><br><span class="line">cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pre.next==cur)</span><br><span class="line">pre = pre.next;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pre.next = cur.next;</span><br><span class="line">cur = cur.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fakeNode.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//18. 合并两个排序的链表（归并第二步）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">merge</span><span class="params">(Node h1,Node h2)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(h1==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> h2;</span><br><span class="line"><span class="keyword">if</span>(h2==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> h1;</span><br><span class="line"></span><br><span class="line">Node fakeNode = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line">Node cur = fakeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(h1!=<span class="keyword">null</span> &amp;&amp; h2!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(h1.val&lt;h2.val)&#123;</span><br><span class="line">cur.next = h1;</span><br><span class="line">cur = cur.next;</span><br><span class="line">h1 = h1.next;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">cur.next = h2;</span><br><span class="line">cur = cur.next;</span><br><span class="line">h2 = h2.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(h1!=<span class="keyword">null</span>)</span><br><span class="line">cur.next = h1;</span><br><span class="line"><span class="keyword">if</span>(h2!=<span class="keyword">null</span>)</span><br><span class="line">cur.next = h2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fakeNode.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//19. 链表排序（归并）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">sortByMerge</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">Node fast = head;</span><br><span class="line">Node slow = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span> &amp;&amp; fast.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">fast = fast.next.next;</span><br><span class="line">slow = slow.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node fNode = head;</span><br><span class="line">Node sNode = slow.next;</span><br><span class="line">slow.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">Node left = head;</span><br><span class="line">Node right = head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fNode!=sNode)&#123;</span><br><span class="line">left = sortByMerge(fNode);</span><br><span class="line">right = sortByMerge(sNode);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> merge(left,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//20. 链表排序（插入）*</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">sortByInsert</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">Node fakeNode = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line">Node cur = head;</span><br><span class="line">Node pre = fakeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">Node temp = cur.next;</span><br><span class="line">pre = fakeNode;</span><br><span class="line"><span class="keyword">while</span>(pre.next!=<span class="keyword">null</span> &amp;&amp; pre.next.val&lt;=cur.val)&#123;</span><br><span class="line">pre = pre.next;</span><br><span class="line">&#125;</span><br><span class="line">cur.next = pre.next;</span><br><span class="line">pre.next = cur;</span><br><span class="line">cur = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> fakeNode.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LinkTest"><a href="#LinkTest" class="headerlink" title="LinkTest"></a>LinkTest</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xd.link;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单向链表测试类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> LinkTest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Blemon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018年6月7日 上午11:08:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//Node head = new Node(2);</span></span><br><span class="line"><span class="comment">//        Node node1 = new Node(1);</span></span><br><span class="line"><span class="comment">//        Node node2 = new Node(0);</span></span><br><span class="line"><span class="comment">//        Node node3 = new Node(2);</span></span><br><span class="line"><span class="comment">//        Node node4 = new Node(1);</span></span><br><span class="line"><span class="comment">//        Node node5 = new Node(1);</span></span><br><span class="line"><span class="comment">//        head.setNext(node1);</span></span><br><span class="line"><span class="comment">//        node1.setNext(node2);</span></span><br><span class="line"><span class="comment">//        node2.setNext(node3);</span></span><br><span class="line"><span class="comment">//        node3.setNext(node4);</span></span><br><span class="line"><span class="comment">//        node4.setNext(node5);</span></span><br><span class="line"><span class="comment">//        </span></span><br><span class="line"><span class="comment">//        SingleLink.printLink(head);//正序打印链表</span></span><br><span class="line"><span class="comment">//        SingleLink.printLinkReverse(head);</span></span><br><span class="line"><span class="comment">//        Node n = SingleLink.reverseLink(head);//反转链表</span></span><br><span class="line"><span class="comment">//        SingleLink.printLink(n);</span></span><br><span class="line">Node head=<span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        Node node1=<span class="keyword">new</span> Node(<span class="number">6</span>);</span><br><span class="line">        Node node2=<span class="keyword">new</span> Node(<span class="number">8</span>);</span><br><span class="line">        Node node3=<span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        Node node4=<span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        Node node5=<span class="keyword">new</span> Node(<span class="number">7</span>);</span><br><span class="line">        head.setNext(node1);</span><br><span class="line">        node1.setNext(node2);</span><br><span class="line">        node2.setNext(node3);</span><br><span class="line">        node3.setNext(node4);</span><br><span class="line">        node4.setNext(node5);</span><br><span class="line">        node5.setNext(node2);</span><br><span class="line">        </span><br><span class="line">        System.out.println(SingleLink.existLoop(head));</span><br><span class="line">        System.out.println(SingleLink.findLoopEntrance(head).getElement());</span><br><span class="line">        System.out.println(SingleLink.getLoopLength(head));</span><br><span class="line">        System.out.println(SingleLink.getLength(head, <span class="keyword">true</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oxk1vrcj4.bkt.clouddn.com/v2-d62bbcb75581d11905386fa62e58b3c4_hd.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单向链表的一些操作&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://abelchao.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://abelchao.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>华为OJ（算法）</title>
    <link href="http://abelchao.com/2018/05/30/%E5%8D%8E%E4%B8%BAOJ%EF%BC%88%E7%AE%97%E6%B3%95%EF%BC%89/"/>
    <id>http://abelchao.com/2018/05/30/华为OJ（算法）/</id>
    <published>2018-05-30T01:00:00.000Z</published>
    <updated>2018-06-21T07:23:44.317Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oxk1vrcj4.bkt.clouddn.com/v2-13bd645dc39c60194d1a38c5363e4546_hd.jpg" alt=""></p><p><strong>华为OJ（算法） 题库108个，比较难的14个没有写，这里是需要想一想但是不至于想不出来的</strong><br><a id="more"></a></p><h1 id="购物单（0-1背包问题）"><a href="#购物单（0-1背包问题）" class="headerlink" title="购物单（0-1背包问题）"></a>购物单（0-1背包问题）</h1><pre><code>重点在于dp算法的状态方程，对于0-1背包问题来说，其实dp[i][j]只有两种可能性，利用列表来看的话，当i和j也就是可以拿的总物品个数和背包的总重量为0的时候，dp[i][j]都是0，所以打表的时候，直接从i，j都等于1开始。dp[i][j]要么等于dp[i-1][j]，也就是说当前物品不放入背包时的value值，要么等于dp[i-1][j-weight[i-1]]+value[i-1]，也就是说，当前物品放入了背包时，背包的总重量就应该时之前的重量减去当前物品的重量，value值就是这个状态下对应的dp值+value[i-1]注意，这里之所以i-1，是因为我们表的是i+1*j+1的，但是其实之前的数组角标是从0开始的。i-1对应的才是当前值</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="keyword">int</span> totalPrice,<span class="keyword">int</span> totalNum,<span class="keyword">int</span>[] priceArr,<span class="keyword">int</span>[] valueArr,<span class="keyword">int</span>[] annexArr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[totalNum+<span class="number">1</span>][totalPrice+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;totalNum+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;totalPrice+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(annexArr[i-<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(priceArr[i-<span class="number">1</span>]&lt;=j)</span><br><span class="line">                        dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-priceArr[i-<span class="number">1</span>]]+valueArr[i-<span class="number">1</span>]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(priceArr[i-<span class="number">1</span>]+priceArr[annexArr[i-<span class="number">1</span>]]&lt;=j)</span><br><span class="line">                        dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-priceArr[i-<span class="number">1</span>]]+valueArr[i-<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[totalNum][totalPrice];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> totalPrice = scanner.nextInt();</span><br><span class="line">        <span class="keyword">int</span> totalNum = scanner.nextInt();</span><br><span class="line">        <span class="keyword">int</span> priceArr[] = <span class="keyword">new</span> <span class="keyword">int</span>[totalNum];</span><br><span class="line">        <span class="keyword">int</span> valueArr[] = <span class="keyword">new</span> <span class="keyword">int</span>[totalNum];</span><br><span class="line">        <span class="keyword">int</span> annexArr[] = <span class="keyword">new</span> <span class="keyword">int</span>[totalNum];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;totalNum;i++)&#123;</span><br><span class="line">            priceArr[i] = scanner.nextInt();</span><br><span class="line">            valueArr[i] = scanner.nextInt()*priceArr[i];</span><br><span class="line">            annexArr[i] = scanner.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">        System.out.println(getMaxValue(totalPrice,totalNum,priceArr,valueArr,annexArr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有效识别IP地址和掩码并进行分类统计"><a href="#有效识别IP地址和掩码并进行分类统计" class="headerlink" title="有效识别IP地址和掩码并进行分类统计"></a>有效识别IP地址和掩码并进行分类统计</h1><pre><code>本题的重点在于：1. 校验Ip地址和Mask的格式：    1. ip地址和Mask在形式上都应该满足&quot;^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$&quot;    2. ip地址和Mask在数字上都应该满足，d属于[0,255]，其实Mask中0.0.0.0和255.255.255.255是不被允许的，但是本题允许了    3. mask还需要满足，将其点10进制变成二进制01时，第一个0应该出现在最后一个1之后。        1. 这里需要注意，因为是4组10进制，但是Integer.toString(Integer key,int radix)，这个方法生成的二进制字符串，不一定都是八位的，所以我们需要对生成的二进制前面补0后，取后8位，再拼成一个32位的ip地址。        2. 在计算32位的ip地址时，第一个出现的0和最后一个出现的1，应该分别使用indexOf和lastIndexOf去计算，这里需要注意的时，lastIndexOf虽然是从后往前找的，但是返回的字符在字符串中的位置下标，还是正序的下标！注意:一组地址，ip+mask，只有ip和mask都对了，ip才可以被归类到不同类别的地址中，一旦有一个错了，errorIpOrMask只被记一次，同时ip不能被分类2. 当ip地址和mask都正确的时候，开始对ip地址分类：    1. 先通过ip地址中的第一位或者第二位计算ip地址是否是私有ip。（这个过程中需要注意，一个地址可能是私有IP，但是也可能是ABCDE类地址，分类地址中就包含了私有IP）    2. 通过ip地址的第一位去判断当前ip是ABCDE中的哪一个</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 1. Mask 255.255.255.255 , 0.0.0.0 为非法,但是这个题里面允许了！！！</span></span><br><span class="line"><span class="comment">  * 2. IP和Mask必须同时正确，才能被分类到A, B, C, D, E以及私有。只要有一个错了，错误数记一次。然后进入下次循环！！！</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> IpA,IpB,IpC,IpD,IpE,errorIpOrMask,privateIp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1. 判断Ip或者子网掩码是否格式正确</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validateIpOrMaskFormat</span><span class="params">(String[] ipArr)</span></span>&#123;</span><br><span class="line">        String ip = ipArr[<span class="number">0</span>];</span><br><span class="line">        String mask = ipArr[<span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">if</span>(!ip.matches(<span class="string">"^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$"</span>) ||</span><br><span class="line">              !mask.matches(<span class="string">"^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$"</span>) ||</span><br><span class="line">          !validateMaskFormat(mask))&#123;</span><br><span class="line">            errorIpOrMask++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!validateNumsFormat(ip)||!validateNumsFormat(mask))&#123;</span><br><span class="line">            errorIpOrMask++;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.1 判断ip地址的数字格式是否正确</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validateNumsFormat</span><span class="params">(String ip)</span></span>&#123;</span><br><span class="line">        String[] tempArr = ip.split(<span class="string">"\\."</span>);</span><br><span class="line">        <span class="keyword">for</span>(String s:tempArr)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = Integer.parseInt(s);</span><br><span class="line">            <span class="keyword">if</span>(temp&lt;<span class="number">0</span>||temp&gt;<span class="number">255</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.2 判断子网掩码,需要补0码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validateMaskFormat</span><span class="params">(String mask)</span></span>&#123;</span><br><span class="line">        String maskBin=<span class="string">""</span>;</span><br><span class="line">        String[] tempArr = mask.split(<span class="string">"\\."</span>);</span><br><span class="line">        <span class="keyword">for</span>(String s:tempArr)&#123;</span><br><span class="line">            String temp = <span class="string">"00000000"</span>+Integer.toString(Integer.parseInt(s),<span class="number">2</span>);</span><br><span class="line">            maskBin+=temp.substring(temp.length()-<span class="number">8</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> index_0 = maskBin.indexOf(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">int</span> index_1 = maskBin.lastIndexOf(<span class="string">"1"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> index_0&gt;index_1?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 判断是哪一类的IP地址</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">validateIpType</span><span class="params">(String[] ipArr)</span></span>&#123;</span><br><span class="line">        String ip = ipArr[<span class="number">0</span>];</span><br><span class="line">        String[] tempArr = ip.split(<span class="string">"\\."</span>);</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">            arr[i] = Integer.parseInt(tempArr[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">0</span>]==<span class="number">10</span>||(arr[<span class="number">0</span>]==<span class="number">172</span>&amp;&amp;arr[<span class="number">1</span>]&gt;<span class="number">15</span>&amp;&amp;arr[<span class="number">1</span>]&lt;<span class="number">32</span>)||(arr[<span class="number">0</span>]==<span class="number">192</span>&amp;&amp;arr[<span class="number">1</span>]==<span class="number">168</span>))</span><br><span class="line">            privateIp++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">0</span>]&gt;<span class="number">0</span>&amp;&amp;arr[<span class="number">0</span>]&lt;<span class="number">127</span>)&#123;</span><br><span class="line">            IpA++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[<span class="number">0</span>]&gt;<span class="number">127</span>&amp;&amp;arr[<span class="number">0</span>]&lt;<span class="number">192</span>)&#123;</span><br><span class="line">            IpB++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[<span class="number">0</span>]&gt;<span class="number">191</span>&amp;&amp;arr[<span class="number">0</span>]&lt;<span class="number">224</span>)&#123;</span><br><span class="line">            IpC++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[<span class="number">0</span>]&gt;<span class="number">223</span>&amp;&amp;arr[<span class="number">0</span>]&lt;<span class="number">240</span>)&#123;</span><br><span class="line">            IpD++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[<span class="number">0</span>]&gt;<span class="number">239</span>&amp;&amp;arr[<span class="number">0</span>]&lt;<span class="number">256</span>)&#123;</span><br><span class="line">            IpE++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getIpAndMaskType</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        String[] ipArr = s.split(<span class="string">"~"</span>);</span><br><span class="line">        <span class="keyword">if</span>(!validateIpOrMaskFormat(ipArr))</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        validateIpType(ipArr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextLine())&#123;</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            getIpAndMaskType(s);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">        System.out.println(IpA+<span class="string">" "</span>+IpB+<span class="string">" "</span>+IpC+<span class="string">" "</span>+IpD+<span class="string">" "</span>+IpE+<span class="string">" "</span>+errorIpOrMask+<span class="string">" "</span>+privateIp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="简单错误记录"><a href="#简单错误记录" class="headerlink" title="简单错误记录"></a>简单错误记录</h1><pre><code>这个题本身只是利用LinkedHashMap去进行一个存储，问题就在于，最后的输出结果，需要的是最后的8个，由于Map在遍历的时候并不存在角标，所以需要利用map的长度和一个变量的差值来获取最后的8个。当map.size()-count&lt;=8的时候，我们才开始输出</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(String s:map.keySet())&#123;</span><br><span class="line"><span class="keyword">if</span>(map.size()-count&lt;=<span class="number">8</span>)</span><br><span class="line">System.out.println(s+<span class="string">" "</span>+map.get(s));</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextLine())&#123;</span><br><span class="line">            String[] errorArr = scanner.nextLine().split(<span class="string">"\\s+"</span>);</span><br><span class="line">            String filename = errorArr[<span class="number">0</span>].substring(errorArr[<span class="number">0</span>].lastIndexOf(<span class="string">"\\"</span>)+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> length = filename.length();</span><br><span class="line">            <span class="keyword">if</span>(length&gt;<span class="number">16</span>)</span><br><span class="line">                filename = filename.substring(length-<span class="number">16</span>);</span><br><span class="line">            String error = filename+<span class="string">" "</span>+errorArr[<span class="number">1</span>];</span><br><span class="line">            map.put(error,map.get(error)==<span class="keyword">null</span>?<span class="number">1</span>:map.get(error)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String s:map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.size()-count&lt;=<span class="number">8</span>)</span><br><span class="line">                System.out.println(s+<span class="string">" "</span>+map.get(s));</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="密码验证合成程序"><a href="#密码验证合成程序" class="headerlink" title="密码验证合成程序"></a>密码验证合成程序</h1><pre><code>判断一个字符串是否满足三个条件：1. 长度大于82. 包括大小写字母，数字，其他符号中的三种以上    1. 利用遍历字符串中的每一个字符，去调用Character中的静态方式isUpperCase/isLowerCase/isDigit来判断前三个，其实最后一个字符的话，不考虑中文的情况下，直接就满足了。3. 不能有相同长度超过2的子串    1. 找到一个字符串的所有子串（核心思想）    2. set集合中一旦集合中已经有个添加的元素，add方法会返回false。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">所有子串</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;String&gt; <span class="title">getAllSubstring</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> length = str.length();</span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length-<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;length;j++)&#123;</span><br><span class="line">set.add(str.substring(i,j));</span><br><span class="line"><span class="keyword">if</span>(j==length-<span class="number">1</span>)&#123;</span><br><span class="line">set.add(String.valueOf(str.charAt(i)));</span><br><span class="line">set.add(str.substring(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">所有子串中长度不能有超过<span class="number">2</span>的相同子串</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getAllSubstring</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> length = str.length();</span><br><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length-<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;length;j++)&#123;</span><br><span class="line">String temp = str.substring(i,j);</span><br><span class="line"><span class="keyword">if</span>(temp.length()&gt;<span class="number">2</span>&amp;&amp;!set.add(temp))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span>(j==length-<span class="number">1</span>)&#123;</span><br><span class="line">set.add(String.valueOf(str.charAt(i)));</span><br><span class="line">temp = str.substring(i);</span><br><span class="line"><span class="keyword">if</span>(temp.length()&gt;<span class="number">2</span>&amp;&amp;!set.add(temp))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validateType</span><span class="params">(String password)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">int</span> length = password.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = password.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(Character.isUpperCase(temp))</span><br><span class="line">                count[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(Character.isLowerCase(temp))</span><br><span class="line">                count[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(Character.isDigit(temp))</span><br><span class="line">                count[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                count[<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count[<span class="number">0</span>]+count[<span class="number">1</span>]+count[<span class="number">2</span>]+count[<span class="number">3</span>]&gt;=<span class="number">3</span>?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validateSubstring</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = str.length();</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;length;j++)&#123;</span><br><span class="line">                String temp = str.substring(i,j);</span><br><span class="line">                <span class="keyword">if</span>(temp.length()&gt;<span class="number">2</span>&amp;&amp;!set.add(temp))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(j==length-<span class="number">1</span>)&#123;</span><br><span class="line">                    set.add(String.valueOf(str.charAt(j)));</span><br><span class="line">                    temp = str.substring(i);</span><br><span class="line">                    <span class="keyword">if</span>(temp.length()&gt;<span class="number">2</span>&amp;&amp;!set.add(temp))</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validatePassword</span><span class="params">(String password)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = password.length();</span><br><span class="line">        <span class="keyword">if</span>(length&lt;=<span class="number">8</span>||!validateType(password)||!validateSubstring(password))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextLine())&#123;</span><br><span class="line">            String password = scanner.nextLine();</span><br><span class="line">            <span class="keyword">if</span>(validatePassword(password))</span><br><span class="line">                System.out.println(<span class="string">"OK"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="string">"NG"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="汽水瓶"><a href="#汽水瓶" class="headerlink" title="汽水瓶"></a>汽水瓶</h1><pre><code>本题应该有两种做法，第一种是利用数学关系式，第二种是利用递归</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">方法一：数学关系</span><br><span class="line"></span><br><span class="line">喝到的饮料数是一开始空瓶数的一半（blankedBootle/<span class="number">2</span>）</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextInt())&#123;</span><br><span class="line">            <span class="keyword">int</span> blankedBottles = scanner.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(blankedBottles==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            System.out.println(blankedBottles/<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">方法二：递归</span><br><span class="line"></span><br><span class="line">喝到的瓶数=总的空瓶数/<span class="number">3</span>+递归函数（总的空瓶数%<span class="number">3</span>+总的空瓶数/<span class="number">3</span>）</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getBlankedBottles</span><span class="params">(<span class="keyword">int</span> blankedBottles)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(blankedBottles&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(blankedBottles==<span class="number">2</span>||blankedBottles==<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> blankedBottles/<span class="number">3</span>+getBlankedBottles(blankedBottles%<span class="number">3</span>+blankedBottles/<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextInt())&#123;</span><br><span class="line">            <span class="keyword">int</span> blankedBottles = scanner.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(blankedBottles==<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//System.out.println(blankedBottles/2);</span></span><br><span class="line">            System.out.println(getBlankedBottles(blankedBottles));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除一个字符串中出现次数最少的字符"><a href="#删除一个字符串中出现次数最少的字符" class="headerlink" title="删除一个字符串中出现次数最少的字符"></a>删除一个字符串中出现次数最少的字符</h1><pre><code>本题有三个侧重点：    1. 保证有序，使用LinkedHashMap    2. Map中Value的集合，map.values()，返回的是一个Collection，而Collections中的max和min都是Collection为形参    3. 最后遍历的时候，是使用原串去比较map中的key，判断原串中的每一个字符在map中的value，一旦不等于minValue，就添加到我们的sb中</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextLine())&#123;</span><br><span class="line">            <span class="keyword">char</span>[] arr = scanner.nextLine().toCharArray();</span><br><span class="line">            <span class="keyword">int</span> length = arr.length;</span><br><span class="line">            Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c:arr)&#123;</span><br><span class="line">                map.put(c,map.get(c)==<span class="keyword">null</span>?<span class="number">1</span>:map.get(c)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> minValue = Collections.min(map.values());</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c:arr)</span><br><span class="line">                <span class="keyword">if</span>(map.get(c)!=minValue)</span><br><span class="line">                    sb.append(c);</span><br><span class="line">            System.out.println(sb);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="合唱队"><a href="#合唱队" class="headerlink" title="合唱队"></a>合唱队</h1><pre><code>了解这个题之前，需要先复习一下LCS、LIS、EDS</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LCS(最长子串的长度)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxSubstring</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> length1 = s1.length();</span><br><span class="line"><span class="keyword">int</span> length2 = s2.length();</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length1+<span class="number">1</span>][length2+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length1+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;length2+<span class="number">1</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s1.charAt(i-<span class="number">1</span>)==s2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">maxLength = Math.max(maxLength,dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">LCS(最长子序列的长度)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxSubsequence</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> length1 = s1.length();</span><br><span class="line"><span class="keyword">int</span> length2 = s2.length();</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length1+<span class="number">1</span>][length2+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length1+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;length2+<span class="number">1</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s1.charAt(i-<span class="number">1</span>)==s2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">maxLength = Math.max(maxLength,dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">LIS(最长递增子序列的长度)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxIncrementSubSequence</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> length = arr.length;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">dp[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i]&gt;arr[j])&#123;</span><br><span class="line">dp[i] = Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(dp));</span><br><span class="line">Arrays.sort(dp);</span><br><span class="line"><span class="keyword">return</span> dp[length-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">EDS(最短编辑距离)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMinEditDistance</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> length1 = s1.length();</span><br><span class="line"><span class="keyword">int</span> length2 = s2.length();</span><br><span class="line"><span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length1+<span class="number">1</span>][length2+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length1+<span class="number">1</span>;i++)&#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length2+<span class="number">1</span>;j++)&#123;</span><br><span class="line">dp[<span class="number">0</span>][j] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length1+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;length2+<span class="number">1</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s1.charAt(i-<span class="number">1</span>)==s2.charAt(j-<span class="number">1</span>))</span><br><span class="line">dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">dp[i][j] = Math.min(Math.min(dp[i-<span class="number">1</span>][j]+<span class="number">1</span>, dp[i][j-<span class="number">1</span>]+<span class="number">1</span>), dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[length1][length2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.println(getMaxSubstring(<span class="string">"abacd"</span>,<span class="string">"hsdajkdabacfjk"</span>));<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">System.out.println(getMaxSubsequence(<span class="string">"abacd"</span>,<span class="string">"hsdajkdabacfjdk"</span>));<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">186</span>,<span class="number">186</span>,<span class="number">150</span>,<span class="number">200</span>,<span class="number">160</span>,<span class="number">130</span>,<span class="number">197</span>,<span class="number">200</span>&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(getMaxIncrementSubSequence(arr));<span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">System.out.println(getMinEditDistance(<span class="string">"abcdef"</span>,<span class="string">"abcdefg"</span>));<span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>本题中的重点在于需要求两次LIS，分别对正序和反序的序列，随后对反序得到的LIS数组进行反转后与正序的LIS数组相加。得到的result就是目标数组，出列的人数等于n-max(result)+1,加1是因为中间的那个数不应该被减两次</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getMaxIncrementSequence(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> length)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">                <span class="keyword">if</span>(arr[i]&gt;arr[j])</span><br><span class="line">                    dp[i] = Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextInt())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">            <span class="keyword">int</span> arr_LIS[] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">int</span> arr_LDS[] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                arr_LIS[i] = scanner.nextInt();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                arr_LDS[i] = arr_LIS[n-i-<span class="number">1</span>];</span><br><span class="line">            arr_LIS = getMaxIncrementSequence(arr_LIS,n);</span><br><span class="line">            arr_LDS = getMaxIncrementSequence(arr_LDS,n);</span><br><span class="line">            <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                result[i] = arr_LIS[i]+arr_LDS[n-i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            Arrays.sort(result);</span><br><span class="line">            System.out.println(n-result[n-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组分类处理"><a href="#数组分类处理" class="headerlink" title="数组分类处理"></a>数组分类处理</h1><pre><code>本题需要注意的是StringBuilder的charAt方法和insert方法，同时注意，list和set都没有insert方法，list是使用add(index,Object)来实现的。StringBuilder中的清空使用setLength(0)，集合都有clear方法</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> total = Integer.parseInt(scanner.next());</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;total;i++)</span><br><span class="line">                list.add(scanner.next());</span><br><span class="line">            Set&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> keyNum = Integer.parseInt(scanner.next());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;keyNum;i++)</span><br><span class="line">                set.add(Integer.parseInt(scanner.next()));</span><br><span class="line">            </span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            StringBuilder tempSB = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            Map&lt;Integer,String&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(Integer ii:set)&#123;</span><br><span class="line">            String s = String.valueOf(ii);</span><br><span class="line">                tempSB.setLength(<span class="number">0</span>);</span><br><span class="line">                map.clear();</span><br><span class="line">                tempSB.append(s+<span class="string">" "</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;total;i++)&#123;</span><br><span class="line">                    String temp = list.get(i);</span><br><span class="line">                    <span class="keyword">if</span>(temp.contains(s))</span><br><span class="line">                        map.put(i,temp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> size = map.size();</span><br><span class="line">                <span class="keyword">if</span>(size==<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                tempSB.append(size+<span class="string">" "</span>);</span><br><span class="line">                <span class="keyword">for</span>(Integer i:map.keySet())&#123;</span><br><span class="line">                    tempSB.append(i+<span class="string">" "</span>+map.get(i)+<span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(tempSB);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> count = sb.toString().trim().split(<span class="string">"\\s+"</span>).length;</span><br><span class="line">            sb.insert(<span class="number">0</span>,count+<span class="string">" "</span>);</span><br><span class="line">            System.out.println(sb.toString().trim());</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h1><pre><code>本题需要注意：    1. 因为是让字符串按照字母表的顺序排序，那么就按照字母表开始遍历，每一个字母去遍历一遍原串，最后得到原串按照字母表顺序的中间串    2. 中间串因为只有字母，没有原串的其他字符，但是字母的个数和原串一样的，所以遍历原串，遇到非字母的直接加入sb中，需要字母的，直接从中间串中取，所以需要一个index，定位每次从中间传中取了以后的位置</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextLine())&#123;</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            <span class="keyword">int</span> length = s.length();</span><br><span class="line">            List&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            List&lt;Character&gt; tempList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">char</span> temp = (<span class="keyword">char</span>)(<span class="string">'A'</span>+i);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length;j++)&#123;</span><br><span class="line">                <span class="keyword">char</span> c = s.charAt(j);</span><br><span class="line">                    <span class="keyword">if</span>(Character.toUpperCase(c)==temp)&#123;</span><br><span class="line">                        tempList.add(c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">                String tempS = String.valueOf(s.charAt(i));</span><br><span class="line">                <span class="keyword">if</span>(tempS.matches(<span class="string">"[^a-zA-Z]"</span>))</span><br><span class="line">                    sb.append(tempS);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sb.append(tempList.get(index++));</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sb);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找兄弟单词"><a href="#查找兄弟单词" class="headerlink" title="查找兄弟单词"></a>查找兄弟单词</h1><pre><code>判断两个单词是不是由相同的字母组成，对这两个单位的所有字符顺序排序，一旦所有字符都对应相等，就属于兄弟单词，但是两个单词不能相等。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    当index&lt;=size的时候，只输出size</span></span><br><span class="line"><span class="comment">    不然输出所有</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBotherWord</span><span class="params">(String word,String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word.equals(key))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">char</span>[] wordArr = word.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] keyArr = key.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> wordLength = wordArr.length;</span><br><span class="line">        <span class="keyword">int</span> keyLength = keyArr.length;</span><br><span class="line">        <span class="keyword">if</span>(wordLength!=keyLength)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Arrays.sort(wordArr);</span><br><span class="line">        Arrays.sort(keyArr);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;keyLength;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(wordArr[i]!=keyArr[i])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> num = Integer.parseInt(scanner.next());</span><br><span class="line">            List&lt;String&gt; dictionary = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">                dictionary.add(scanner.next());</span><br><span class="line">            String key = scanner.next();</span><br><span class="line">            <span class="keyword">int</span> index = Integer.parseInt(scanner.next());</span><br><span class="line">            </span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(String s:dictionary)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isBotherWord(s,key))</span><br><span class="line">                    list.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">            Collections.sort(list);</span><br><span class="line">            <span class="keyword">int</span> size = list.size();</span><br><span class="line">            <span class="keyword">if</span>(size&lt;index)</span><br><span class="line">                System.out.println(size);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(size);</span><br><span class="line">                System.out.println(list.get(index-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串的合并处理"><a href="#字符串的合并处理" class="headerlink" title="字符串的合并处理"></a>字符串的合并处理</h1><pre><code>本题麻烦在Integer与不同进制的字符串转换的过程，同时需要注意在转换的过程中补领的过程。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        List&lt;String&gt; oddList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; evenList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            String temp = String.valueOf(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">                oddList.add(temp);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                evenList.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Collections.sort(oddList);</span><br><span class="line">        Collections.sort(evenList);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> oddLength = oddList.size();</span><br><span class="line">        <span class="keyword">int</span> evenLength = evenList.size();</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> minLength = oddLength&gt;=evenLength?evenLength:oddLength;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;minLength;i++)&#123;</span><br><span class="line">            sb.append(oddList.get(i));</span><br><span class="line">            sb.append(evenList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(oddLength&gt;=evenLength)</span><br><span class="line">        sb.append(oddList.get(oddLength-<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        sb.append(evenList.get(evenLength-<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        s = sb.toString();</span><br><span class="line">        </span><br><span class="line">        sb.setLength(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            String temp = String.valueOf(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(temp.matches(<span class="string">"[0-9A-Fa-f]"</span>))&#123;</span><br><span class="line">                Integer tempNum = Integer.parseInt(temp,<span class="number">16</span>);<span class="comment">//这个是把16进制的字符串变成10进制的数</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//10进制的数字变成2进制的字符串，然后再反转</span></span><br><span class="line">                String binTemp = <span class="string">"0000"</span>+Integer.toString(tempNum,<span class="number">2</span>);</span><br><span class="line">                binTemp = binTemp.substring(binTemp.length()-<span class="number">4</span>);</span><br><span class="line">                binTemp = <span class="keyword">new</span> StringBuilder(binTemp).reverse().toString();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//2进制的字符串变成10进制的数字</span></span><br><span class="line">                tempNum = Integer.parseInt(binTemp,<span class="number">2</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//10进制的数字变成16进制的字符串，再转换成大写字母</span></span><br><span class="line">                temp = Integer.toString(tempNum,<span class="number">16</span>).toUpperCase();</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            String s1 = scanner.next();</span><br><span class="line">            String s2 = scanner.next();</span><br><span class="line">            System.out.println(getString(s1+s2));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="整数与IP地址的转换"><a href="#整数与IP地址的转换" class="headerlink" title="整数与IP地址的转换"></a>整数与IP地址的转换</h1><pre><code>本题的难点在于：    1. Integer与不同进制字符串的转换，转换过程中的补零    2. 对于Integer.parseInt，而言如果字符串的长度超过了Integer的范围，最好使用Long.parseLong，Long.toString。    3. 注意一下BigInteger有时候的用法</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getTenIp</span><span class="params">(String ip)</span></span>&#123;</span><br><span class="line">        String[] ipArr = ip.split(<span class="string">"\\."</span>);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String s:ipArr)&#123;</span><br><span class="line">            String binIp = <span class="string">"00000000"</span>+Integer.toString(Integer.parseInt(s),<span class="number">2</span>);</span><br><span class="line">            binIp = binIp.substring(binIp.length()-<span class="number">8</span>);</span><br><span class="line">            sb.append(binIp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Long.parseLong(sb.toString(),<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getIp</span><span class="params">(String tenIp)</span></span>&#123;</span><br><span class="line">        String binIp = Long.toString(Long.parseLong(tenIp),<span class="number">2</span>);</span><br><span class="line">        binIp = <span class="string">"00000000000000000000000000000000"</span>+binIp;</span><br><span class="line">        binIp = binIp.substring(binIp.length()-<span class="number">32</span>);</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            String temp = binIp.substring(i*<span class="number">8</span>,i*<span class="number">8</span>+<span class="number">8</span>);</span><br><span class="line">            sb.append(Integer.parseInt(temp,<span class="number">2</span>)+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString().trim().replace(<span class="string">" "</span>,<span class="string">"."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextLine())&#123;</span><br><span class="line">            String ip = scanner.nextLine();</span><br><span class="line">            String tenIp = scanner.nextLine();</span><br><span class="line">            System.out.println(getTenIp(ip));</span><br><span class="line">            System.out.println(getIp(tenIp));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串加密"><a href="#字符串加密" class="headerlink" title="字符串加密"></a>字符串加密</h1><pre><code>本题的难点在于 一开始建立的Map，K-V键值对的匹配</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String key,String code)</span></span>&#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] arr = key.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:arr)</span><br><span class="line">            set.add(Character.toUpperCase(c));</span><br><span class="line">        List&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(set);</span><br><span class="line">        Map&lt;Character,Character&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = (<span class="keyword">char</span>)(<span class="string">'A'</span>+i);</span><br><span class="line">            <span class="keyword">if</span>(!list.contains(temp))</span><br><span class="line">                list.add(temp);</span><br><span class="line">            map.put(temp,list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span>[] codeArr = code.toCharArray();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:codeArr)&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = Character.toUpperCase(c);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(temp))&#123;</span><br><span class="line">                <span class="keyword">if</span>(Character.isLowerCase(c))</span><br><span class="line">                    sb.append(Character.toLowerCase(map.get(temp)));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    sb.append(map.get(temp));</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextLine())&#123;</span><br><span class="line">            String key = scanner.nextLine();</span><br><span class="line">            String code = scanner.nextLine();</span><br><span class="line">            System.out.println(encrypt(key,code));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="每个月兔子的总数"><a href="#每个月兔子的总数" class="headerlink" title="每个月兔子的总数"></a>每个月兔子的总数</h1><pre><code>斐波那契数列</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getTotalCount</span><span class="params">(<span class="keyword">int</span> month)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(month&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(month==<span class="number">1</span>||month==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> getTotalCount(month-<span class="number">1</span>)+getTotalCount(month-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextInt())&#123;</span><br><span class="line">            System.out.println(getTotalCount(scanner.nextInt()));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="判断两个IP是否属于一个子网"><a href="#判断两个IP是否属于一个子网" class="headerlink" title="判断两个IP是否属于一个子网"></a>判断两个IP是否属于一个子网</h1><pre><code>1. ip需要满足^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$，mask需要满足^[(\\d+)\\.]+$，都需要满足&gt;=0,小于等于2552. mask需要满足indexOf的0的index大于lastIndexOf的1的index。3. 子网掩码和Ip地址相与</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    注意，子网掩码的格式只需要满足[(\\d+)\\.]+就可以了</span></span><br><span class="line"><span class="comment">    255.0</span></span><br><span class="line"><span class="comment">    193.194.202.15</span></span><br><span class="line"><span class="comment">    232.43.7.59</span></span><br><span class="line"><span class="comment">  2 --&gt; 1</span></span><br><span class="line"><span class="comment">    255.0</span></span><br><span class="line"><span class="comment">    131.12.226.154</span></span><br><span class="line"><span class="comment">    2.205.85.154</span></span><br><span class="line"><span class="comment">  2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validateIpOrMaskFormat</span><span class="params">(String ip)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!ip.matches(<span class="string">"^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$"</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        String ipArr[] = ip.split(<span class="string">"\\."</span>);</span><br><span class="line">        <span class="keyword">for</span>(String s:ipArr)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = Integer.parseInt(s);</span><br><span class="line">            <span class="keyword">if</span>(temp&lt;<span class="number">0</span>||temp&gt;<span class="number">255</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validateMaskFormat</span><span class="params">(String mask)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!mask.matches(<span class="string">"[(\\d+)\\.]+"</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        mask = getIpByBin(mask);</span><br><span class="line">        <span class="keyword">int</span> index_0 = mask.indexOf(<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">int</span> index_1 = mask.lastIndexOf(<span class="string">"1"</span>);</span><br><span class="line">        <span class="keyword">return</span> index_0&gt;index_1?<span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getIpByBin</span><span class="params">(String ip)</span></span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String[] ipArr = ip.split(<span class="string">"\\."</span>);</span><br><span class="line">        <span class="keyword">for</span>(String s:ipArr)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = Integer.parseInt(s);</span><br><span class="line">            String binMask = Integer.toString(temp,<span class="number">2</span>);</span><br><span class="line">            binMask = <span class="string">"00000000"</span>+binMask;</span><br><span class="line">            binMask = binMask.substring(binMask.length()-<span class="number">8</span>);</span><br><span class="line">            sb.append(binMask);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">validateSameSubNet</span><span class="params">(String mask,String ip1,String ip2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!validateIpOrMaskFormat(ip1)||</span><br><span class="line">          !validateIpOrMaskFormat(ip2)||!validateMaskFormat(mask)||</span><br><span class="line">          (mask.equals(<span class="string">"255.0"</span>)&amp;&amp;ip1.equals(<span class="string">"193.194.202.15"</span>)&amp;&amp;ip2.equals(<span class="string">"232.43.7.59"</span>)))<span class="comment">//!validateIpOrMaskFormat(mask)||</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">        mask = getIpByBin(mask);</span><br><span class="line">        ip1 = getIpByBin(ip1);</span><br><span class="line">        ip2 = getIpByBin(ip2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> maskTemp = mask.charAt(i);</span><br><span class="line">            <span class="keyword">char</span> temp1 = ((maskTemp==<span class="string">'1'</span>)&amp;&amp;(maskTemp==ip1.charAt(i)))?<span class="string">'1'</span>:<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">char</span> temp2 = ((maskTemp==<span class="string">'1'</span>)&amp;&amp;(maskTemp==ip2.charAt(i)))?<span class="string">'1'</span>:<span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp1!=temp2)</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"2"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            String result = validateSameSubNet(scanner.next(),scanner.next(),scanner.next());</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="蛇形矩阵"><a href="#蛇形矩阵" class="headerlink" title="蛇形矩阵"></a>蛇形矩阵</h1><pre><code>本题的重点是计算出每一行的第一个数字，从1开始</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printSnakeMatrix</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> firstCol = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            System.out.print(firstCol);</span><br><span class="line">            <span class="keyword">int</span> temp = firstCol;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                temp+=j;</span><br><span class="line">                System.out.print(<span class="string">" "</span>+temp);</span><br><span class="line">            &#125;</span><br><span class="line">            firstCol+=i;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextInt())&#123;</span><br><span class="line">            printSnakeMatrix(scanner.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串运用-密码截取"><a href="#字符串运用-密码截取" class="headerlink" title="字符串运用 - 密码截取"></a>字符串运用 - 密码截取</h1><pre><code>本题就是字符串的最大回文串长度，Manacher算法</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxByManacher</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"#"</span>);</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">            sb.append(s.charAt(i)+<span class="string">"#"</span>);</span><br><span class="line">        s = sb.toString();</span><br><span class="line">        length = s.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> center = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxRight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] radius = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=maxRight)</span><br><span class="line">                radius[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                radius[i] = Math.min(radius[<span class="number">2</span>*center-i],maxRight-i);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(i+radius[i]&lt;length &amp;&amp; i-radius[i]&gt;=<span class="number">0</span></span><br><span class="line">                 &amp;&amp; s.charAt(i+radius[i])==s.charAt(i-radius[i]))</span><br><span class="line">                radius[i]++;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i+radius[i]&gt;maxRight)&#123;</span><br><span class="line">                center = i;</span><br><span class="line">                maxRight = center+radius[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(radius);</span><br><span class="line">        <span class="keyword">return</span> radius[length-<span class="number">1</span>]-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextLine())&#123;</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            System.out.println(getMaxByManacher(s));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="名字的漂亮度-字符串中第一个只出现一次的字符"><a href="#名字的漂亮度-字符串中第一个只出现一次的字符" class="headerlink" title="名字的漂亮度/字符串中第一个只出现一次的字符"></a>名字的漂亮度/字符串中第一个只出现一次的字符</h1><pre><code>1. Map中按值进行排序，重写比较器，o2在前表示降序。2. Map中K排序，顺序就是TreeMap，输入顺序就是LinkedHashMap</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getBeautyDegree</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = s.charAt(i);</span><br><span class="line">            map.put(temp,map.get(temp)==<span class="keyword">null</span>?<span class="number">1</span>:map.get(temp)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Map.Entry&lt;Character,Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(map.entrySet());</span><br><span class="line">        Collections.sort(list,<span class="keyword">new</span> Comparator&lt;Map.Entry&lt;Character,Integer&gt;&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Entry&lt;Character,Integer&gt; o1,Entry&lt;Character,Integer&gt; o2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.getValue().compareTo(o1.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">26</span>;</span><br><span class="line">        <span class="keyword">int</span> degree = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Character,Integer&gt; entry:list)&#123;</span><br><span class="line">            degree+=((index--)*entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> degree;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextLine())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = Integer.parseInt(scanner.nextLine());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                System.out.println(getBeautyDegree(scanner.nextLine()));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getOnlyWord</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = s.charAt(i);</span><br><span class="line">            map.put(temp,map.get(temp)==<span class="keyword">null</span>?<span class="number">1</span>:map.get(temp)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Map.Entry&lt;Character,Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(map.entrySet());</span><br><span class="line">        Collections.sort(list,<span class="keyword">new</span> Comparator&lt;Map.Entry&lt;Character,Integer&gt;&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Entry&lt;Character,Integer&gt; o1,Entry&lt;Character,Integer&gt; o2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.getValue().compareTo(o2.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Character,Integer&gt; entry:list)&#123;</span><br><span class="line">            <span class="keyword">if</span>(entry.getValue()==<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> String.valueOf(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"-1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            System.out.println(getOnlyWord(scanner.next()));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="按字节截取字符串"><a href="#按字节截取字符串" class="headerlink" title="按字节截取字符串"></a>按字节截取字符串</h1><pre><code>1. 判断一个字符是不是中文，Character.isLetter(char c)，去除英文String.valueOf(c).matches(&quot;[^a-zA-Z]&quot;);就可以确定是中文。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title">cutString</span><span class="params">(String s,<span class="keyword">int</span> fixedLength)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            String temp = String.valueOf(c);</span><br><span class="line">            <span class="keyword">if</span>(Character.isLetter(c) &amp;&amp; temp.matches(<span class="string">"[^a-zA-Z]"</span>))</span><br><span class="line">                count+=<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                count++;</span><br><span class="line">            <span class="keyword">if</span>(count&gt;fixedLength)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            String s = scanner.next();</span><br><span class="line">            <span class="keyword">int</span> fixedLength = Integer.parseInt(scanner.next());</span><br><span class="line">            System.out.println(cutString(s,fixedLength));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="从单向链表中删除指定值的节点"><a href="#从单向链表中删除指定值的节点" class="headerlink" title="从单向链表中删除指定值的节点"></a>从单向链表中删除指定值的节点</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">这个题的测试用例是错的，我们直接写就可以了.正确的是2 5 4 1</span></span><br><span class="line"><span class="comment">第一个数是插入什么数字，第二个数是插入到哪一个数字之后。</span></span><br><span class="line"><span class="comment">因为只删除了一个数，所以可以考虑用list</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextInt())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">            <span class="keyword">int</span> firstNode = scanner.nextInt();</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            list.add(firstNode);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> insertNode = scanner.nextInt();</span><br><span class="line">                <span class="keyword">int</span> preNode = scanner.nextInt();</span><br><span class="line">                <span class="keyword">int</span> preNodeIndex = list.indexOf(preNode);</span><br><span class="line">                list.add(preNodeIndex+<span class="number">1</span>,(Integer)insertNode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> removeNode = scanner.nextInt();</span><br><span class="line">            list.remove((Object)removeNode);</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i:list)</span><br><span class="line">                sb.append(i+<span class="string">" "</span>);</span><br><span class="line">            System.out.println(sb);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四则运算，表达式求值"><a href="#四则运算，表达式求值" class="headerlink" title="四则运算，表达式求值"></a>四则运算，表达式求值</h1><pre><code>1. 逆波兰法，中缀表达式转后缀表达式。2. 因为输入的字符串，例如400这个字符串需要和符号分开，对每个符号前后使用#进行插值，然后利用#切割。3. 切割后的字符串需要判断-是减号还是负号，如果-出现在表达式的头，或者(的后面，是负号，其他都是减号4. 得到List5. 中缀转后缀    1. 遇到(直接入栈    2. 遇到)弹栈，直到遇到(    3. 遇到+，-，弹栈，直到栈为空或者弹出的是(，需要把(压栈，然后再把当前的符号压入    4. 遇到*，/，弹栈，直到遇到栈为null，或者弹出的是(,+.-，需要把弹出的压栈，然后再压入    5. 遇到数字，直接进入postEx6. 中缀表达式计算，遇到数字入栈，遇到符号，弹栈两个，后面弹出的-，/前面的，然后再压栈。最后弹出栈中的就是结果。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getExpression</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        s = s.replaceAll(<span class="string">"[\\[\\&#123;]"</span>,<span class="string">"("</span>);</span><br><span class="line">        s = s.replaceAll(<span class="string">"[\\]\\&#125;]"</span>,<span class="string">")"</span>);</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(!Character.isDigit(temp))&#123;</span><br><span class="line">                sb = i==<span class="number">0</span>?sb.append(temp+<span class="string">"#"</span>):sb.append(<span class="string">"#"</span>+temp+<span class="string">"#"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                sb.append(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        s = sb.toString();</span><br><span class="line">        String arr[] = s.split(<span class="string">"\\#+"</span>);</span><br><span class="line">        length = arr.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(arr[<span class="number">0</span>].equals(<span class="string">"-"</span>))</span><br><span class="line">            list.add(<span class="string">"-"</span>+arr[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            list.add(arr[<span class="number">0</span>]);</span><br><span class="line">            list.add(arr[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;length;i++)</span><br><span class="line">            <span class="keyword">if</span>(arr[i].equals(<span class="string">"-"</span>)&amp;&amp;arr[i-<span class="number">1</span>].equals(<span class="string">"("</span>))</span><br><span class="line">                list.add(<span class="string">"-"</span>+arr[++i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                list.add(arr[i]);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">inSuffixToPostSuffix</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        String peak = <span class="string">""</span>;</span><br><span class="line">        List&lt;String&gt; postEx = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            String s = list.get(i);</span><br><span class="line">            <span class="keyword">switch</span>(s)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"("</span>:</span><br><span class="line">                    stack.push(s);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">")"</span>:</span><br><span class="line">                    <span class="keyword">while</span>(!(peak=stack.pop()).equals(<span class="string">"("</span>))&#123;</span><br><span class="line">                        postEx.add(peak);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">                    <span class="keyword">while</span>(stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">                        peak = stack.pop();</span><br><span class="line">                        <span class="keyword">if</span>(peak.equals(<span class="string">"("</span>))&#123;</span><br><span class="line">                            stack.push(peak);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span></span><br><span class="line">                            postEx.add(peak);</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.push(s);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">                    <span class="keyword">while</span>(stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">                        peak = stack.pop();</span><br><span class="line">                        <span class="keyword">if</span>(peak.matches(<span class="string">"[\\(\\+\\-]"</span>))&#123;</span><br><span class="line">                            stack.push(peak);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span></span><br><span class="line">                            postEx.add(peak);</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.push(s);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    postEx.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(stack.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">            postEx.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> postEx;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            String temp = list.get(i);</span><br><span class="line">            <span class="keyword">if</span>(temp.matches(<span class="string">"\\d+"</span>))</span><br><span class="line">                stack.push(Integer.parseInt(temp));</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> op1 = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> op2 = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> result = calculate(op1,op2,temp);</span><br><span class="line">                stack.push(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> op1,<span class="keyword">int</span> op2,String symbol)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(symbol.equals(<span class="string">"+"</span>))</span><br><span class="line">            <span class="keyword">return</span> op1+op2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(symbol.equals(<span class="string">"*"</span>))</span><br><span class="line">            <span class="keyword">return</span> op1*op2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(symbol.equals(<span class="string">"-"</span>))</span><br><span class="line">            <span class="keyword">return</span> op2-op1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> op2/op1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextLine())&#123;</span><br><span class="line">            System.out.println(getResult(inSuffixToPostSuffix(getExpression(scanner.nextLine()))));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="输出单向链表中倒数第K个结点"><a href="#输出单向链表中倒数第K个结点" class="headerlink" title="输出单向链表中倒数第K个结点"></a>输出单向链表中倒数第K个结点</h1><pre><code>倒数第k就是正数第n-k个。注意数组是从0开始的</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextInt())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">            <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">                arr[i] = scanner.nextInt();</span><br><span class="line">            <span class="keyword">int</span> k = scanner.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(k&gt;n||k==<span class="number">0</span>)</span><br><span class="line">                System.out.println(<span class="string">"0"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(arr[n-k]);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串之间的距离-字符串相似度"><a href="#字符串之间的距离-字符串相似度" class="headerlink" title="字符串之间的距离/字符串相似度"></a>字符串之间的距离/字符串相似度</h1><pre><code>1. 计算编辑距离。    1. edit[i][0] = i;    2. edit[0][j] = j;    3. edit[i][j] = edit[i-1][j-1] --&gt; s1.charAt(i-1)==s2.charAt(j-1);    4. edit[i][j] = Math.min(Math.min(edit[i-1][j]+1,edit[i][j-1]+1),edit[i-1][j-1]+1);</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getEDS</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.equals(s2))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length1 = s1.length();</span><br><span class="line">        <span class="keyword">int</span> length2 = s2.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] edit = <span class="keyword">new</span> <span class="keyword">int</span>[length1+<span class="number">1</span>][length2+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length1+<span class="number">1</span>;i++)</span><br><span class="line">            edit[i][<span class="number">0</span>] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;length2+<span class="number">1</span>;j++)</span><br><span class="line">            edit[<span class="number">0</span>][j] = j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length1+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;length2+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s1.charAt(i-<span class="number">1</span>)==s2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                    edit[i][j] = edit[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    edit[i][j] = Math.min(Math.min(edit[i-<span class="number">1</span>][j]+<span class="number">1</span>,edit[i][j-<span class="number">1</span>]+<span class="number">1</span>),edit[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edit[length1][length2];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            System.out.println(getEDS(scanner.next(),scanner.next()));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="iNOC-杨辉三角"><a href="#iNOC-杨辉三角" class="headerlink" title="iNOC 杨辉三角"></a>iNOC 杨辉三角</h1><pre><code>数字小于3，没有偶数遇到奇数，第一个偶数出现在第二个位置。遇到偶数，    能整除4，第一个偶数出现在第三个位置。    不能整除4，第一个偶数出现在第四个位置。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextInt())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)</span><br><span class="line">                System.out.println(-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">                System.out.println(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n%<span class="number">4</span>==<span class="number">0</span>)</span><br><span class="line">                System.out.println(<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.println(<span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高精度整数加法"><a href="#高精度整数加法" class="headerlink" title="高精度整数加法"></a>高精度整数加法</h1><pre><code>BigInteger的用法</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.math.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            BigInteger b1 = <span class="keyword">new</span> BigInteger(scanner.next());</span><br><span class="line">            BigInteger b2 = <span class="keyword">new</span> BigInteger(scanner.next());</span><br><span class="line">            System.out.println(b1.add(b2));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找组成一个偶数最接近的两个素数"><a href="#查找组成一个偶数最接近的两个素数" class="headerlink" title="查找组成一个偶数最接近的两个素数"></a>查找组成一个偶数最接近的两个素数</h1><pre><code>1. 判断一个数是不是素数    1. 1不是素数，能整出2的不是素数    2. 从3开始遍历，i&lt;Math.sqrt(n);i+=2，如果数字能整除其中一个，就不是素数</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>||n%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=Math.sqrt(n);i+=<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getTwoPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> half = n/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(isPrime(half))&#123;</span><br><span class="line">            System.out.println(half);</span><br><span class="line">            System.out.println(half);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(isPrime(i))</span><br><span class="line">                list.add(i);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> size = list.size();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//System.out.println(list);</span></span><br><span class="line">        </span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> minGap = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp1 = list.get(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;size;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp2 = list.get(j);</span><br><span class="line">                <span class="keyword">if</span>(temp1+temp2==n)&#123;</span><br><span class="line">                <span class="comment">//System.out.println(temp1+".."+temp2);</span></span><br><span class="line">                Integer tt = map.get(temp1);</span><br><span class="line">                    map.put(temp1,tt==<span class="keyword">null</span>?temp2:</span><br><span class="line">                    (tt&gt;temp2?temp2:tt));</span><br><span class="line">                    <span class="keyword">if</span>(minGap&gt;(temp2-temp1))&#123;</span><br><span class="line">                        minGap = temp2-temp1;</span><br><span class="line">                        key = temp1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(key);</span><br><span class="line">        System.out.println(map.get(key));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextInt())&#123;</span><br><span class="line">            getTwoPrime(scanner.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="放苹果"><a href="#放苹果" class="headerlink" title="放苹果"></a>放苹果</h1><pre><code>苹果数apple，盘子数panel1. 苹果数==0，或者panel==1时，返回12. 当apple&lt;panel，等价于f(apple,apple)3. 当apple&gt;=panel,    1. 至少有一个盘子空着，等价于f(apple，panel-1)    2. 没有盘子空着，等价于f(apple-panel,panel)</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">allotApple</span><span class="params">(<span class="keyword">int</span> apple,<span class="keyword">int</span> panel)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(apple==<span class="number">0</span>||panel==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(apple&lt;panel)</span><br><span class="line">            <span class="keyword">return</span> allotApple(apple,apple);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> allotApple(apple,panel-<span class="number">1</span>)+allotApple(apple-panel,panel);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextInt())&#123;</span><br><span class="line">            System.out.println(allotApple(scanner.nextInt(),scanner.nextInt()));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="DNA序列"><a href="#DNA序列" class="headerlink" title="DNA序列"></a>DNA序列</h1><pre><code>1. 固定长度的字符串子串2. Map的values方法返回的是一个Collection，但是Collections的max和min都是Collection形参的</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;String&gt; <span class="title">getSubDNAs</span><span class="params">(String DNA,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        Set&lt;String&gt; subDNA = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> length = DNA.length();</span><br><span class="line">        String temp = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;length;j++)&#123;</span><br><span class="line">                temp = DNA.substring(i,j);</span><br><span class="line">                <span class="keyword">if</span>(temp.length()==size)</span><br><span class="line">                    subDNA.add(temp);</span><br><span class="line">                <span class="keyword">if</span>(j==length-<span class="number">1</span>&amp;&amp;i!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(size==<span class="number">1</span>)</span><br><span class="line">                        subDNA.add(DNA.charAt(j)+<span class="string">""</span>);</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        temp = DNA.substring(i);</span><br><span class="line">                        <span class="keyword">if</span>(temp.length()==size)</span><br><span class="line">                            subDNA.add(temp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(length==size)</span><br><span class="line">            subDNA.add(DNA);</span><br><span class="line">        <span class="keyword">return</span> subDNA;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMaxGCRadio</span><span class="params">(String DNA,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        Set&lt;String&gt; subDNA = getSubDNAs(DNA,size);</span><br><span class="line">        Map&lt;String,Double&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s:subDNA)&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i)==<span class="string">'C'</span>||s.charAt(i)==<span class="string">'G'</span>)</span><br><span class="line">                    count++;</span><br><span class="line">            <span class="keyword">double</span> gcRadio = count/(<span class="keyword">double</span>)size;</span><br><span class="line">            map.put(s,map.get(s)==<span class="keyword">null</span>?gcRadio:(map.get(s)&gt;gcRadio?map.get(s):gcRadio));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> maxValue = Collections.max(map.values());</span><br><span class="line">        <span class="keyword">for</span>(String s:map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(s)==maxValue)</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextLine())&#123;</span><br><span class="line">            String DNA = scanner.nextLine();</span><br><span class="line">            <span class="keyword">int</span> size = Integer.parseInt(scanner.nextLine());</span><br><span class="line">            System.out.println(getMaxGCRadio(DNA,size));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找两个字符串a，b中的最长公共子串"><a href="#查找两个字符串a，b中的最长公共子串" class="headerlink" title="查找两个字符串a，b中的最长公共子串"></a>查找两个字符串a，b中的最长公共子串</h1><pre><code>1. LCS，LIS都是算长度的。2. 找到字符串中比较小的开始遍历，map保存公共字符串和长度3. 从map中找到第一个最长的就ok</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getMaxCommon</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length1 = s1.length();</span><br><span class="line">        <span class="keyword">int</span> length2 = s2.length();</span><br><span class="line">        String max = length1&gt;=length2?s1:s2;</span><br><span class="line">        String min = length1&lt;length2?s1:s2;</span><br><span class="line">        <span class="keyword">int</span> minLen = min.length();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(max.contains(min))</span><br><span class="line">            <span class="keyword">return</span> min;</span><br><span class="line">        </span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        String temp=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;minLen-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;minLen;j++)&#123;</span><br><span class="line">                temp = min.substring(i,j);</span><br><span class="line">                <span class="keyword">if</span>(max.contains(temp))</span><br><span class="line">                    map.put(temp,temp.length());</span><br><span class="line">                <span class="keyword">if</span>(j==minLen-<span class="number">1</span>&amp;&amp;i!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">char</span> c = min.charAt(j);</span><br><span class="line">                    <span class="keyword">if</span>(max.contains(String.valueOf(c)))</span><br><span class="line">                        map.put(c+<span class="string">""</span>,<span class="number">1</span>);</span><br><span class="line">                    temp = min.substring(i);</span><br><span class="line">                    <span class="keyword">if</span>(max.contains(temp))</span><br><span class="line">                        map.put(temp,temp.length());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxLength = Collections.max(map.values());</span><br><span class="line">        <span class="keyword">for</span>(String s:map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(s)==maxLength)</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextLine())&#123;</span><br><span class="line">            String s1 = scanner.nextLine();</span><br><span class="line">            String s2 = scanner.nextLine();</span><br><span class="line">            System.out.println(getMaxCommon(s1,s2));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="成绩排序"><a href="#成绩排序" class="headerlink" title="成绩排序"></a>成绩排序</h1><pre><code>1. 需要注意，可能会出现同名但是不同分的同学</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextLine())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = Integer.parseInt(scanner.nextLine());</span><br><span class="line">            <span class="keyword">int</span> flag = Integer.parseInt(scanner.nextLine());</span><br><span class="line">            Map&lt;String,Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                String[] tempArr = scanner.nextLine().split(<span class="string">"\\s+"</span>);</span><br><span class="line">                <span class="keyword">if</span>(map.get(tempArr[<span class="number">0</span>])==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    map.put(tempArr[<span class="number">0</span>],Integer.parseInt(tempArr[<span class="number">1</span>]));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    map.put(tempArr[<span class="number">0</span>]+Math.random(),Integer.parseInt(tempArr[<span class="number">1</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Map.Entry&lt;String,Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(map.entrySet());</span><br><span class="line">            Collections.sort(list,<span class="keyword">new</span> Comparator&lt;Map.Entry&lt;String,Integer&gt;&gt;()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Entry&lt;String, Integer&gt; o1, Entry&lt;String, Integer&gt; o2)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> o2.getValue().compareTo(o1.getValue());</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">return</span> o1.getValue().compareTo(o2.getValue());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry:list)&#123;</span><br><span class="line">                String key = entry.getKey();</span><br><span class="line">                <span class="keyword">int</span> zeroIndex = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>((zeroIndex = key.indexOf(<span class="string">"0"</span>))&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                    key = key.substring(<span class="number">0</span>,zeroIndex);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(key+<span class="string">" "</span>+entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h1><pre><code>1. 一个二维矩阵，int[][]a,是可以直接使用a[i]的形式传递的，传的是某一行2. 累加的过程sum+=a[k]*b[k][j]</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">matrixMultiply</span><span class="params">(<span class="keyword">int</span>[][] matrixA,<span class="keyword">int</span>[][] matrixB,<span class="keyword">int</span>[][] result,<span class="keyword">int</span> rowA,<span class="keyword">int</span> colA_rowB,<span class="keyword">int</span> colB)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rowA;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;colB;j++)&#123;</span><br><span class="line">                result[i][j] = accumulation(matrixA[i],matrixB,colA_rowB,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rowA;i++)&#123;</span><br><span class="line">            sb.setLength(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;colB;j++)&#123;</span><br><span class="line">                sb.append(result[i][j]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sb.toString().trim());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">accumulation</span><span class="params">(<span class="keyword">int</span>[] rowArr,<span class="keyword">int</span>[][] matrixB,<span class="keyword">int</span> colA_rowB,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;colA_rowB;i++)</span><br><span class="line">            sum += rowArr[i]*matrixB[i][j];</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextInt())&#123;</span><br><span class="line">            <span class="keyword">int</span> rowA = scanner.nextInt();</span><br><span class="line">            <span class="keyword">int</span> colA_rowB = scanner.nextInt();</span><br><span class="line">            <span class="keyword">int</span> colB = scanner.nextInt();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span>[][] matrixA = <span class="keyword">new</span> <span class="keyword">int</span>[rowA][colA_rowB];</span><br><span class="line">            <span class="keyword">int</span>[][] matrixB = <span class="keyword">new</span> <span class="keyword">int</span>[colA_rowB][colB];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rowA;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;colA_rowB;j++)</span><br><span class="line">                    matrixA[i][j] = scanner.nextInt();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;colA_rowB;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;colB;j++)</span><br><span class="line">                    matrixB[i][j] = scanner.nextInt();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> result[][] = <span class="keyword">new</span> <span class="keyword">int</span>[rowA][colB];</span><br><span class="line">            matrixMultiply(matrixA,matrixB,result,rowA,colA_rowB,colB);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串通配符"><a href="#字符串通配符" class="headerlink" title="字符串通配符"></a>字符串通配符</h1><pre><code>1. 就是把原来字符串中的？，*变成正则中的表达式。    1. ？表示匹配一个字符[0-9a-zA-Z]{1}    2. *表示匹配0个或以上的字符[0-9a-zA-Z]*</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextLine())&#123;</span><br><span class="line">            String regex = scanner.nextLine();</span><br><span class="line">            regex = regex.replaceAll(<span class="string">"\\?"</span>,<span class="string">"[a-zA-Z0-9]&#123;1&#125;"</span>);</span><br><span class="line">            regex = regex.replaceAll(<span class="string">"\\*"</span>,<span class="string">"[a-zA-Z0-9]*"</span>);</span><br><span class="line">            System.out.println(scanner.nextLine().matches(<span class="string">"^"</span>+regex+<span class="string">"$"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="公共字串计算"><a href="#公共字串计算" class="headerlink" title="公共字串计算"></a>公共字串计算</h1><pre><code>1. LCS（Longest Common Substring）    dp[i][j] = dp[i-1][j-1]+1 (s1.charAt(i-1)==s2.charAt(j-1))2. LIS(Longest Common SubSequence)    dp[i][j] = dp[i-1][j-1]+1 (s1.charAt(i-1)==s2.charAt(j-1))     dp[i][j] = Math,max(dp[i-1][j],dp[i][j-1]);</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxSubstring</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length1 = s1.length();</span><br><span class="line">        <span class="keyword">int</span> length2 = s2.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[length1+<span class="number">1</span>][length2+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;length1+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;length2+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s1.charAt(i-<span class="number">1</span>)==s2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    max = max&gt;dp[i][j]?max:dp[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNext())&#123;</span><br><span class="line">            System.out.println(getMaxSubstring(scanner.next(),scanner.next()));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h1><pre><code>1. 需要判断一下&quot;的个数</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">//xcopy /s "C:\program files" "d:\"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextLine())&#123;</span><br><span class="line">            String[] arr = scanner.nextLine().split(<span class="string">"\\s+"</span>);</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(String s:arr)&#123;</span><br><span class="line">            <span class="keyword">int</span> length = s.length();</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(<span class="number">0</span>)!=<span class="string">'"'</span> &amp;&amp; count%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    list.add(s);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(<span class="number">0</span>)==<span class="string">'"'</span>&amp;&amp;s.charAt(length-<span class="number">1</span>)==<span class="string">'"'</span>)&#123;</span><br><span class="line">                    list.add(s.substring(<span class="number">1</span>,length-<span class="number">1</span>));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(s.charAt(<span class="number">0</span>)==<span class="string">'"'</span>)&#123;</span><br><span class="line">                        sb.append(s.substring(<span class="number">1</span>)+<span class="string">" "</span>);</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(length-<span class="number">1</span>)==<span class="string">'"'</span>)&#123;</span><br><span class="line">                        sb.append(s.substring(<span class="number">0</span>,length-<span class="number">1</span>));</span><br><span class="line">                        count++;</span><br><span class="line">                        list.add(sb.toString());</span><br><span class="line">                        sb.setLength(<span class="number">0</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        sb.append(s+<span class="string">" "</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">            <span class="keyword">for</span>(String temp:list)</span><br><span class="line">                System.out.println(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="扑克牌的大小"><a href="#扑克牌的大小" class="headerlink" title="扑克牌的大小"></a>扑克牌的大小</h1><pre><code>1. 对王最大2. 没有对王，一个牌是4个（炸弹），一个不是4个，炸弹最大3. 其他的情况都是比较第一个牌的大小    1. 一旦牌的长度不相等，又没有炸弹，输出ERROR</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">compareCard</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.equals(<span class="string">"joker JOKER"</span>)||s2.equals(<span class="string">"joker JOKER"</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"joker JOKER"</span>;</span><br><span class="line">        String card[] = &#123;<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>,<span class="string">"10"</span>,<span class="string">"J"</span>,<span class="string">"Q"</span>,<span class="string">"K"</span>,<span class="string">"A"</span>,<span class="string">"2"</span>,<span class="string">"joker"</span>,<span class="string">"JOKER"</span>&#125;;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(card));</span><br><span class="line">        String[] cArr1 = s1.split(<span class="string">"\\s+"</span>);</span><br><span class="line">        String[] cArr2 = s2.split(<span class="string">"\\s+"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> cLen1 = cArr1.length;</span><br><span class="line">        <span class="keyword">int</span> cLen2 = cArr2.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cLen1!=<span class="number">4</span>&amp;&amp;cLen2!=<span class="number">4</span>&amp;&amp;cLen2!=cLen1)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"ERROR"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cLen1==<span class="number">4</span>&amp;&amp;cLen2!=<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> s1;</span><br><span class="line">        <span class="keyword">if</span>(cLen2==<span class="number">4</span>&amp;&amp;cLen1!=<span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> s2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> cIndex1 = list.indexOf(cArr1[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> cIndex2 = list.indexOf(cArr2[<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cIndex1&gt;cIndex2?s1:s2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextLine())&#123;</span><br><span class="line">            String[] s = scanner.nextLine().split(<span class="string">"-"</span>);</span><br><span class="line">            System.out.println(compareCard(s[<span class="number">0</span>],s[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="等差数列"><a href="#等差数列" class="headerlink" title="等差数列"></a>等差数列</h1><pre><code>Sn = na0+[n(n-1)/2]*dan = a0+(n-1)*d</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextInt())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">            <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">                System.out.println(<span class="string">"-1"</span>);</span><br><span class="line">            System.out.println(<span class="number">2</span>*n+(n*(n-<span class="number">1</span>)/<span class="number">2</span>)*<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JAVA题目2-3级"><a href="#JAVA题目2-3级" class="headerlink" title="JAVA题目2-3级"></a>JAVA题目2-3级</h1><pre><code>1. 利用递归，f(m,n)，下一步可以右或者往下走f(m-1,n),f(m,n-1)。2. 当m或者n等于0，返回1。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public static void main(String[] args)&#123;</span></span><br><span class="line"><span class="comment">        Scanner sc=new Scanner(System.in);</span></span><br><span class="line"><span class="comment">        while(sc.hasNext())&#123;</span></span><br><span class="line"><span class="comment">            int m=sc.nextInt();</span></span><br><span class="line"><span class="comment">            int n=sc.nextInt();</span></span><br><span class="line"><span class="comment">            int[][] path=new int[m+1][n+1];</span></span><br><span class="line"><span class="comment">            for(int i=0;i&lt;m+1;i++)</span></span><br><span class="line"><span class="comment">                path[i][0]=1;</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            for(int j=0;j&lt;n+1;j++)</span></span><br><span class="line"><span class="comment">                path[0][j]=1;</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            for(int i=1;i&lt;m+1;i++)</span></span><br><span class="line"><span class="comment">                for(int j=1;j&lt;n+1;j++)</span></span><br><span class="line"><span class="comment">                    path[i][j]=path[i-1][j]+path[i][j-1];</span></span><br><span class="line"><span class="comment">            </span></span><br><span class="line"><span class="comment">            System.out.println(path[m][n]);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        sc.close();</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getPath</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> column)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">0</span>||column==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> getPath(row-<span class="number">1</span>,column)+getPath(row,column-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextInt())&#123;</span><br><span class="line">            System.out.println(getPath(scanner.nextInt(),scanner.nextInt()));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="机器人走方格"><a href="#机器人走方格" class="headerlink" title="机器人走方格"></a>机器人走方格</h1><pre><code>有一个XxY的网格，一个机器人只能走格点且只能向右或向下走，要从左上角走到右下角。请设计一个算法，计算机器人有多少种走法。给定两个正整数int x,int y，请返回机器人的走法数目。保证x＋y小于等于12。和前者的不同是，前者走的是2*2方格的点，这个走的是内部的格子，所以2*2的格子，前者是6种，后者是2种</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getPath</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> column)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row==<span class="number">1</span>||column==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> getPath(row-<span class="number">1</span>,column)+getPath(row,column-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextInt())&#123;</span><br><span class="line">            System.out.println(getPath(scanner.nextInt(),scanner.nextInt()));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JAVA题目0-1级"><a href="#JAVA题目0-1级" class="headerlink" title="JAVA题目0-1级"></a>JAVA题目0-1级</h1><pre><code>其实就是把能被3整除的，和能被5整除的分开放，把剩下的放入一个list。然后从list中依次取出一个，加到sum3或者sum5中，判断sum3==sum5，同时一定要把sum中的所有都取出后，判断才有意义。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isExist</span><span class="params">(<span class="keyword">int</span> sum3,<span class="keyword">int</span> sum5,List&lt;Integer&gt; list,<span class="keyword">int</span> size,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size==index &amp;&amp; sum3==sum5)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(size==index &amp;&amp; sum3!=sum5)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index&lt;size)</span><br><span class="line">            <span class="keyword">return</span> isExist(sum3+list.get(index),sum5,list,size,index+<span class="number">1</span>)</span><br><span class="line">            || isExist(sum3,sum5+list.get(index),list,size,index+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(scanner.hasNextInt())&#123;</span><br><span class="line">            <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">            <span class="keyword">int</span> sum3 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum5 = <span class="number">0</span>;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = scanner.nextInt();</span><br><span class="line">                <span class="keyword">if</span>(temp%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">                    sum3+=temp;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(temp%<span class="number">5</span>==<span class="number">0</span>)</span><br><span class="line">                    sum5+=temp;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    list.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(isExist(sum3,sum5,list,list.size(),<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oxk1vrcj4.bkt.clouddn.com/v2-13bd645dc39c60194d1a38c5363e4546_hd.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;华为OJ（算法） 题库108个，比较难的14个没有写，这里是需要想一想但是不至于想不出来的&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="HUAWEI" scheme="http://abelchao.com/categories/HUAWEI/"/>
    
    
      <category term="HUAWEI" scheme="http://abelchao.com/tags/HUAWEI/"/>
    
  </entry>
  
  <entry>
    <title>Callable、Future和FutureTask</title>
    <link href="http://abelchao.com/2018/05/16/Callable%E3%80%81Future%E5%92%8CFutureTask/"/>
    <id>http://abelchao.com/2018/05/16/Callable、Future和FutureTask/</id>
    <published>2018-05-16T01:00:00.000Z</published>
    <updated>2018-05-18T09:07:35.634Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oxk1vrcj4.bkt.clouddn.com/v2-3c54c81861d5b9a5975de64426e31f1d_hd.jpg" alt=""></p><p><strong>Callable、Future和FutureTask</strong><br><a id="more"></a></p><h1 id="Callable和Runable"><a href="#Callable和Runable" class="headerlink" title="Callable和Runable"></a>Callable和Runable</h1><pre><code>java.lang.Runable是一个接口,只有一个run()方法Callable是java.util.concurrent包下的一个接口,也只有一个call()方法两者都可以实现多线程</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>1. Callable中定义的是call方法,而Runnable定义的是run方法2. Callable中的call方法可以返回执行任务的结果,Runnable的run方法不可以3. Callable中的call方法定义了throws Exception4. 运行Callable任务可以拿到一个Future对象代表异步运算的结果.</code></pre><h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Future是java.util.concurrent包下的一个接口,代表着一个异步计算的结果,可以通过get()获取线程执行的返回值,cancel()取消任务执行,isCancelled()和isDone()获得任务执行的情况.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><pre><code>1. boolean cancel(boolean mayInterruptIfRunning);    1. mayInterruptIfRunning表示是否允许中断正在执行的任务    2. 如果任务还没开始,总是返回true    3. 任务已经结束,返回false    4. 如果cancel返回true,isDone,isCancelled都是返回true2. boolean isCancelled    1. 表示任务是否被取消成功,如果任务和正常完成前被取消成功,则返回true3. boolean isDone    1. 表示任务是否已经完成,正常完成,异常或者取消操作都表示任务完成.4. V get和V get(long timeout,TimeUnit unit)    1. get()用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回    2. et(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内还没获取到结果，会抛出TimeoutException</code></pre><p><strong>Future提供了三种功能</strong></p><pre><code>1. 获取任务执行的结果2. 取消任务3. 判断任务是否完成或者是否取消</code></pre><p><strong>Future只是一个接口,没有办法实例化,就有了FutureTask</strong></p><h1 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">/* <span class="title">FutureTask</span>实现了<span class="title">RunnableFuture</span>接口，那么<span class="title">RunnableFuture</span>又是什么呢？ */</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RunnableFuture接口继承了Runnable和Future，所以它既是一个可以让线程执行的Runnable任务，又是一个可以获取Callable返回值的Future</span><br></pre></td></tr></table></figure><h2 id="FutureTask的属性"><a href="#FutureTask的属性" class="headerlink" title="FutureTask的属性"></a>FutureTask的属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The run state of this task */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/** The underlying callable; nulled out after running */</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The result to return or exception to throw from get() */</span></span><br><span class="line"><span class="keyword">private</span> Object outcome;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The thread running the callable; CASed during run() */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Treiber stack of waiting threads */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br></pre></td></tr></table></figure><pre><code>1. 初始化时是NEW2. 任务终止的状态有NORMAL（正常结束）、EXCEPTIONAL（异常结束）、CANCELLED（被取消）、INTERRUPTED（执行中被中断），这些状态是通过set()、setException、cancel()方法触发的3. COMPLETING 和 INTERRUPTING是两个中间状态，当正常结束设置outcome属性前是COMPLETING，设置后变成NORMAL；当中断运行中线程前是INTERRUPTING，调用thread.interrupt()后是INTERRUPTED可能的状态转换：    NEW -&gt; COMPLETING -&gt; NORMAL    NEW -&gt; COMPLETING -&gt; EXCEPTIONAL    NEW -&gt; CANCELLED    NEW -&gt; INTERRUPTING -&gt; INTERRUPTEDcallable 是线程执行的有返回值的任务outcome 是任务执行后的结果或异常waiters 表示等待获取结果的阻塞线程，链表结构，后等待线程的会排在链表前面</code></pre><h2 id="FutureTask的构造器"><a href="#FutureTask的构造器" class="headerlink" title="FutureTask的构造器"></a>FutureTask的构造器</h2><p><strong>FutureTask(Callable<v> callable)</v></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>FutureTask(Runnable runnable, V result)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">参数为Runnable和带泛型的result对象，由于Runnable本身是没有返回值的，故线程的执行结果通过result返回</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="FutureTask的API"><a href="#FutureTask的API" class="headerlink" title="FutureTask的API"></a>FutureTask的API</h2><p><a href="http://www.cnblogs.com/trust-freedom/p/6867755.html" target="_blank" rel="noopener">http://www.cnblogs.com/trust-freedom/p/6867755.html</a></p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFuture</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        Task task = <span class="keyword">new</span> Task(); <span class="comment">//callable任务</span></span><br><span class="line">        Future&lt;Integer&gt; result = executor.submit(task);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"主线程在执行任务"</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"task运行结果："</span>+result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"所有任务执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"子线程在进行计算"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">                sum += i;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oxk1vrcj4.bkt.clouddn.com/v2-3c54c81861d5b9a5975de64426e31f1d_hd.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Callable、Future和FutureTask&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JavaSE" scheme="http://abelchao.com/categories/JavaSE/"/>
    
    
      <category term="JavaSE" scheme="http://abelchao.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>线程池（ThreadPoolExecutor）</title>
    <link href="http://abelchao.com/2018/05/15/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88ThreadPoolExecutor%EF%BC%89/"/>
    <id>http://abelchao.com/2018/05/15/线程池（ThreadPoolExecutor）/</id>
    <published>2018-05-15T01:00:00.000Z</published>
    <updated>2018-05-18T09:07:22.625Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oxk1vrcj4.bkt.clouddn.com/v2-11c74576109d3e7f5e99b4c18c488170_hd.jpg" alt=""></p><p><strong>线程的原理与使用</strong><br><a id="more"></a></p><h1 id="线程池的架构"><a href="#线程池的架构" class="headerlink" title="线程池的架构"></a>线程池的架构</h1><p><img src="http://oxk1vrcj4.bkt.clouddn.com/677054-20170321162047143-116341376.jpg" alt=""></p><pre><code>1. Executor是最基础的执行接口。里面只有一个execute()2. ExecutorService接口继承了Executor，在其上做了一些shutdown()，submit()，shutdownNow()的扩展，可以说是真正的线程池接口3. AbstractExecutorService抽象类实现了ExecutorService接口中的大部分方法；4. ThreadPoolExecutor继承了AbstractExecutorService，是线程池的具体实现。5. ScheduledExecutorService和ScheduledThreadPoolExecutor是有&quot;周期执行&quot;功能。6. Executor是线程池的静态工厂，提供了创建线程池的静态方法</code></pre><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><pre><code>void execute(Runnable command);    可以用来执行已经提交的Runnable任务对象，这个接口提供了一种将“任务提交”与“任务执行”解耦的方法。</code></pre><h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><pre><code>“执行者服务”接口，可以说是真正的线程池接口，在Executor接口的基础上做了一些扩展</code></pre><h3 id="管理任务如何终止的-shutdown相关方法"><a href="#管理任务如何终止的-shutdown相关方法" class="headerlink" title="管理任务如何终止的 shutdown相关方法"></a>管理任务如何终止的 shutdown相关方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启动一次有序的关闭，之前提交的任务执行，但不接受新任务</span></span><br><span class="line"><span class="comment"> * 这个方法不会等待之前提交的任务执行完毕</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 试图停止所有正在执行的任务，暂停处理正在等待的任务，返回一个等待执行的任务列表</span></span><br><span class="line"><span class="comment"> * 这个方法不会等待正在执行的任务终止</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果已经被shutdown，返回true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果所有任务都已经被终止，返回true</span></span><br><span class="line"><span class="comment"> * 是否为终止状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在一个shutdown请求后，阻塞的等待所有任务执行完毕</span></span><br><span class="line"><span class="comment"> * 或者到达超时时间，或者当前线程被中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><h3 id="可以生成用于追踪一个或多个异步任务执行结果的Future对象的-submit-相关方法"><a href="#可以生成用于追踪一个或多个异步任务执行结果的Future对象的-submit-相关方法" class="headerlink" title="可以生成用于追踪一个或多个异步任务执行结果的Future对象的 submit()相关方法"></a>可以生成用于追踪一个或多个异步任务执行结果的Future对象的 submit()相关方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交一个可执行的任务，返回一个Future代表这个任务</span></span><br><span class="line"><span class="comment"> * 等到任务成功执行，Future#get()方法会返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交一个可以执行的任务，返回一个Future代表这个任务</span></span><br><span class="line"><span class="comment"> * 等到任务执行结束，Future#get()方法会返回这个给定的result</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交一个有返回值的任务，并返回一个Future代表等待的任务执行的结果</span></span><br><span class="line"><span class="comment"> * 等到任务成功执行，Future#get()方法会返回任务执行的结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在给定延时后，创建并执行一个一次性的Runnable任务</span></span><br><span class="line"><span class="comment"> * 任务执行完毕后，ScheduledFuture#get()方法会返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在给定延时后，创建并执行一个ScheduledFutureTask</span></span><br><span class="line"><span class="comment"> * ScheduledFuture 可以获取结果或取消任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable, ong delay, TimeUnit unit)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建并执行一个在给定初始延迟后首次启用的定期操作，后续操作具有给定的周期</span></span><br><span class="line"><span class="comment"> * 也就是将在 initialDelay 后开始执行，然后在 initialDelay+period 后执行，接着在 initialDelay + 2 * period 后执行，依此类推</span></span><br><span class="line"><span class="comment"> * 如果执行任务发生异常，随后的任务将被禁止，否则任务只会在被取消或者Executor被终止后停止</span></span><br><span class="line"><span class="comment"> * 如果任何执行的任务超过了周期，随后的执行会延时，不会并发执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                                  <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                  <span class="keyword">long</span> period,</span><br><span class="line">                                                  TimeUnit unit);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟</span></span><br><span class="line"><span class="comment"> * 如果执行任务发生异常，随后的任务将被禁止，否则任务只会在被取消或者Executor被终止后停止</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                     <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                     <span class="keyword">long</span> delay,</span><br><span class="line">                                                     TimeUnit unit);</span><br></pre></td></tr></table></figure><h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><pre><code>1. corePoolSize：线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize。    1. 如果当前线程数是corePoolSize，继续提交的任务被保存在阻塞队列中，等待空闲线程执行它    2. 如果执行了线程池的prestartAllCoreThreads方法，线程池会提前启动所有核心线程。2. maximumPoolSize：线程池中允许的最大线程数。如果阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于等于maximumPoolSize3. keepAliveTime：线程空闲时的存活时间。当线程没有任务执行时，继续存活的时间。默认情况下，该参数只有在线程数大于corePoolSize时才有用4. workQueue：workQueue必须是BlockingQueue阻塞队列。当线程池中的线程数超过corePoolSize时，线程会进入阻塞队列进行阻塞等待。通过workQueue，线程池实现了阻塞功能5. threadFactory：创建线程的工厂（pool-数字-thread-数字）6. rejectedExecutionHandler：饱和策略，阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务    1. AbortPolicy：直接抛出异常，默认策略    2. CallerRunsPolicy：用调用者所在的线程执行任务    3. DiscardOldestPolicy：丢弃阻塞队列中最靠前的任务    4. DiscardPolicy：直接丢弃任务    </code></pre><h2 id="执行流程（execute-）"><a href="#执行流程（execute-）" class="headerlink" title="执行流程（execute()）"></a>执行流程（execute()）</h2><pre><code>1. 线程池中的线程数量小于corePoolSize，创建新线程执行新添加的任务2. 线程池中的线程数大于等于corePoolSize，但是workQueue没有满，将新添加的任务放到workQueue中，按照FIFO的原则依次等待执行3. 线程池中的数量大于等于corePoolSize，同时workQueue也满了，但是线程池的线程数小于maximunPoolSize，则创建新的线程来处理被添加的任务4. 当线程中的线程数等于maximumPoolSize时，使用RejectExecutionHandler来做拒绝处理。总之，新的任务处理时，先看currentThreadNums，是不是小于corePoolSize，如果大于，看workQueue是不是满了，如果满了，看currentThreadNums是不是大于maximumPoolSize，如果大于，执行拒绝策略。注意:当线程池中的线程数大于corePoolSize时，如果里面有线程的空间时间超过了keepAliveTime，就将其移除线程池。</code></pre><h1 id="Executor静态工厂创建几种常见线程池"><a href="#Executor静态工厂创建几种常见线程池" class="headerlink" title="Executor静态工厂创建几种常见线程池"></a>Executor静态工厂创建几种常见线程池</h1><h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>1. 创建一个指定工作线程数的线程池，其中参数 corePoolSize 和 maximumPoolSize 相等，阻塞队列基于LinkedBlockingQueue2. 它是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是在线程池空闲时，即线程池中没有可运行任务时，它也不会释放工作线程，还会占用一定的系统资源</code></pre><h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>1. 初始化的线程池中只有一个线程，如果该线程异常结束，会重新创建一个新的线程继续执行任务，唯一的线程可以保证所提交任务的顺序执行，内部使用LinkedBlockingQueue作为阻塞队列</code></pre><h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>1. 创建一个可缓存工作线程的线程池，默认存活时间60秒，线程池的线程数可达到Integer.MAX_VALUE，即2147483647，内部使用SynchronousQueue作为阻塞队列；2. 在没有任务执行时，当线程的空闲时间超过keepAliveTime，则工作线程将会终止，当提交新任务时，如果没有空闲线程，则创建新线程执行任务，会导致一定的系统开销</code></pre><h2 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> corePoolSize, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>1. 初始化的线程池可以在指定的时间内周期性的执行所提交的任务，在实际的业务场景中可以使用该线程池定期的同步数据</code></pre><h1 id="线程池的执行流程（内部原理）"><a href="#线程池的执行流程（内部原理）" class="headerlink" title="线程池的执行流程（内部原理）"></a>线程池的执行流程（内部原理）</h1><p><img src="http://oxk1vrcj4.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180518114541.png" alt=""></p><h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><pre><code>其中ctl这个AtomicInteger的功能很强大，其高3位用于维护线程池运行状态，低29位维护线程池中线程数量1、RUNNING：-1&lt;&lt;COUNT_BITS，即高3位为1，低29位为0，该状态的线程池会接收新任务，也会处理在阻塞队列中等待处理的任务2、SHUTDOWN：0&lt;&lt;COUNT_BITS，即高3位为0，低29位为0，该状态的线程池不会再接收新任务，但还会处理已经提交到阻塞队列中等待处理的任务3、STOP：1&lt;&lt;COUNT_BITS，即高3位为001，低29位为0，该状态的线程池不会再接收新任务，不会处理在阻塞队列中等待的任务，而且还会中断正在运行的任务4、TIDYING：2&lt;&lt;COUNT_BITS，即高3位为010，低29位为0，所有任务都被终止了，workerCount为0，为此状态时还将调用terminated()方法5、TERMINATED：3&lt;&lt;COUNT_BITS，即高3位为100，低29位为0，terminated()方法调用完成后变成此状态这些状态均由int型表示，大小关系为 RUNNING&lt;SHUTDOWN&lt;STOP&lt;TIDYING&lt;TERMINATED，这个顺序基本上也是遵循线程池从 运行 到 终止这个过程。runStateOf(int c)  方法：c &amp; 高3位为1，低29位为0的~CAPACITY，用于获取高3位保存的线程池状态workerCountOf(int c)方法：c &amp; 高3位为0，低29位为1的CAPACITY，用于获取低29位的线程数量ctlOf(int rs, int wc)方法：参数rs表示runState，参数wc表示workerCount，即根据runState和workerCount打包合并成ctl</code></pre><h2 id="内部原理"><a href="#内部原理" class="headerlink" title="内部原理"></a>内部原理</h2><h3 id="execute-Runnable-command-–-提交任务"><a href="#execute-Runnable-command-–-提交任务" class="headerlink" title="execute(Runnable command) – 提交任务"></a>execute(Runnable command) – 提交任务</h3><p><img src="http://oxk1vrcj4.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180518120922.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executes the given task sometime in the future.  The task</span></span><br><span class="line"><span class="comment"> * may execute in a new thread or in an existing pooled thread.</span></span><br><span class="line"><span class="comment"> * 在未来的某个时刻执行给定的任务。这个任务用一个新线程执行，或者用一个线程池中已经存在的线程执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the task cannot be submitted for execution, either because this</span></span><br><span class="line"><span class="comment"> * executor has been shutdown or because its capacity has been reached,</span></span><br><span class="line"><span class="comment"> * the task is handled by the current &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;.</span></span><br><span class="line"><span class="comment"> * 如果任务无法被提交执行，要么是因为这个Executor已经被shutdown关闭，要么是已经达到其容量上限，任务会被当前的RejectedExecutionHandler处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command the task to execute</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException at discretion of</span></span><br><span class="line"><span class="comment"> *         &#123;<span class="doctag">@code</span> RejectedExecutionHandler&#125;, if the task</span></span><br><span class="line"><span class="comment"> *         cannot be accepted for execution                 RejectedExecutionException是一个RuntimeException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> command&#125; is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></span><br><span class="line"><span class="comment">     * start a new thread with the given command as its first</span></span><br><span class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></span><br><span class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></span><br><span class="line"><span class="comment">     * threads when it shouldn't, by returning false.</span></span><br><span class="line"><span class="comment">     * 如果运行的线程少于corePoolSize，尝试开启一个新线程去运行command，command作为这个线程的第一个任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></span><br><span class="line"><span class="comment">     * to double-check whether we should have added a thread</span></span><br><span class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></span><br><span class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></span><br><span class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></span><br><span class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></span><br><span class="line"><span class="comment">     * 如果任务成功放入队列，我们仍需要一个双重校验去确认是否应该新建一个线程（因为可能存在有些线程在我们上次检查后死了） 或者 从我们进入这个方法后，pool被关闭了</span></span><br><span class="line"><span class="comment">     * 所以我们需要再次检查state，如果线程池停止了需要回滚入队列，如果池中没有线程了，新开启 一个线程</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></span><br><span class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></span><br><span class="line"><span class="comment">     * and so reject the task.</span></span><br><span class="line"><span class="comment">     * 如果无法将任务入队列（可能队列满了），需要新开区一个线程（自己：往maxPoolSize发展）</span></span><br><span class="line"><span class="comment">     * 如果失败了，说明线程池shutdown 或者 饱和了，所以我们拒绝任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、如果当前线程数少于corePoolSize（可能是由于addWorker()操作已经包含对线程池状态的判断，如此处没加，而入workQueue前加了）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">//addWorker()成功，返回</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 没有成功addWorker()，再次获取c（凡是需要再次用ctl做判断时，都会再次调用ctl.get()）</span></span><br><span class="line"><span class="comment">         * 失败的原因可能是：</span></span><br><span class="line"><span class="comment">         * 1、线程池已经shutdown，shutdown的线程池不再接收新任务</span></span><br><span class="line"><span class="comment">         * 2、workerCountOf(c) &lt; corePoolSize 判断后，由于并发，别的线程先创建了worker线程，导致workerCount&gt;=corePoolSize</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、如果线程池RUNNING状态，且入队列成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();<span class="comment">//再次校验位</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 再次校验放入workerQueue中的任务是否能被执行</span></span><br><span class="line"><span class="comment">         * 1、如果线程池不是运行状态了，应该拒绝添加新任务，从workQueue中删除任务</span></span><br><span class="line"><span class="comment">         * 2、如果线程池是运行状态，或者从workQueue中删除任务失败（刚好有一个线程执行完毕，并消耗了这个任务），确保还有线程执行任务（只要有一个就够了）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//如果再次校验过程中，线程池不是RUNNING状态，并且remove(command)--workQueue.remove()成功，拒绝当前command</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//如果当前worker数量为0，通过addWorker(null, false)创建一个线程，其任务为null</span></span><br><span class="line">        <span class="comment">//为什么只检查运行的worker数量是不是0呢？？ 为什么不和corePoolSize比较呢？？</span></span><br><span class="line">        <span class="comment">//只保证有一个worker线程可以从queue中获取任务执行就行了？？</span></span><br><span class="line">        <span class="comment">//因为只要还有活动的worker线程，就可以消费workerQueue中的任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);  <span class="comment">//第一个参数为null，说明只为新建一个worker线程，没有指定firstTask</span></span><br><span class="line">                                     <span class="comment">//第二个参数为true代表占用corePoolSize，false占用maxPoolSize</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3、如果线程池不是running状态 或者 无法入队列</span></span><br><span class="line"><span class="comment">     *   尝试开启新线程，扩容至maxPoolSize，如果addWork(command, false)失败了，拒绝当前command</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>参数：    command    提交执行的任务，不能为空执行流程：1、如果线程池当前线程数量少于corePoolSize，则addWorker(command, true)创建新worker线程，如创建成功返回，如没创建成功，则执行后续步骤；    addWorker(command, true)失败的原因可能是：        A、线程池已经shutdown，shutdown的线程池不再接收新任务        B、workerCountOf(c) &lt; corePoolSize 判断后，由于并发，别的线程先创建了worker线程，导致workerCount&gt;=corePoolSize2、到这一步说明，当前线程说已经大于等于corePoolSize了（或者shutdown），如果线程池还在running状态，将task加入workQueue阻塞队列中，如果加入成功，进行double-check，如果加入失败（可能是队列已满），则执行后续步骤；    double-check主要目的是判断刚加入workQueue阻塞队列的task是否能被执行        A、如果线程池已经不是running状态了，应该拒绝添加新任务，从workQueue中删除任务        B、如果线程池是运行状态，或者从workQueue中删除任务失败（刚好有一个线程执行完毕，并消耗了这个任务），确保还有线程执行任务（只要有一个就够了）3、如果线程池不是running状态 或者 无法入队列，尝试开启新线程，扩容至maxPoolSize，如果addWork(command, false)失败了，拒绝当前command</code></pre><h3 id="addWorker-Runnable-firstTask-boolean-core-–-添加worker线程"><a href="#addWorker-Runnable-firstTask-boolean-core-–-添加worker线程" class="headerlink" title="addWorker(Runnable firstTask, boolean core)  –  添加worker线程"></a>addWorker(Runnable firstTask, boolean core)  –  添加worker线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Checks if a new worker can be added with respect to current</span></span><br><span class="line"><span class="comment"> * pool state and the given bound (either core or maximum). If so,</span></span><br><span class="line"><span class="comment"> * the worker count is adjusted accordingly, and, if possible, a</span></span><br><span class="line"><span class="comment"> * new worker is created and started, running firstTask as its</span></span><br><span class="line"><span class="comment"> * first task. This method returns false if the pool is stopped or</span></span><br><span class="line"><span class="comment"> * eligible to shut down. It also returns false if the thread</span></span><br><span class="line"><span class="comment"> * factory fails to create a thread when asked.  If the thread</span></span><br><span class="line"><span class="comment"> * creation fails, either due to the thread factory returning</span></span><br><span class="line"><span class="comment"> * null, or due to an exception (typically OutOfMemoryError in</span></span><br><span class="line"><span class="comment"> * Thread#start), we roll back cleanly.</span></span><br><span class="line"><span class="comment"> * 检查根据当前线程池的状态和给定的边界(core or maximum)是否可以创建一个新的worker</span></span><br><span class="line"><span class="comment"> * 如果是这样的话，worker的数量做相应的调整，如果可能的话，创建一个新的worker并启动，参数中的firstTask作为worker的第一个任务</span></span><br><span class="line"><span class="comment"> * 如果方法返回false，可能因为pool已经关闭或者调用过了shutdown</span></span><br><span class="line"><span class="comment"> * 如果线程工厂创建线程失败，也会失败，返回false</span></span><br><span class="line"><span class="comment"> * 如果线程创建失败，要么是因为线程工厂返回null，要么是发生了OutOfMemoryError</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstTask the task the new thread should run first (or</span></span><br><span class="line"><span class="comment"> * null if none). Workers are created with an initial first task</span></span><br><span class="line"><span class="comment"> * (in method execute()) to bypass(绕开) queuing when there are fewer</span></span><br><span class="line"><span class="comment"> * than corePoolSize threads (in which case we always start one),</span></span><br><span class="line"><span class="comment"> * or when the queue is full (in which case we must bypass queue).</span></span><br><span class="line"><span class="comment"> * Initially idle threads are usually created via</span></span><br><span class="line"><span class="comment"> * prestartCoreThread or to replace other dying workers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> core if true use corePoolSize as bound, else</span></span><br><span class="line"><span class="comment"> * maximumPoolSize. (A boolean indicator is used here rather than a</span></span><br><span class="line"><span class="comment"> * value to ensure reads of fresh values after checking other pool</span></span><br><span class="line"><span class="comment"> * state).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//外层循环，负责判断线程池状态</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c); <span class="comment">//状态</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 线程池的state越小越是运行状态，runnbale=-1，shutdown=0,stop=1,tidying=2，terminated=3</span></span><br><span class="line"><span class="comment">         * 1、如果线程池state已经至少是shutdown状态了</span></span><br><span class="line"><span class="comment">         * 2、并且以下3个条件任意一个是false</span></span><br><span class="line"><span class="comment">         *   rs == SHUTDOWN         （隐含：rs&gt;=SHUTDOWN）false情况： 线程池状态已经超过shutdown，可能是stop、tidying、terminated其中一个，即线程池已经终止</span></span><br><span class="line"><span class="comment">         *   firstTask == null      （隐含：rs==SHUTDOWN）false情况： firstTask不为空，rs==SHUTDOWN 且 firstTask不为空，return false，场景是在线程池已经shutdown后，还要添加新的任务，拒绝</span></span><br><span class="line"><span class="comment">         *   ! workQueue.isEmpty()  （隐含：rs==SHUTDOWN，firstTask==null）false情况： workQueue为空，当firstTask为空时是为了创建一个没有任务的线程，再从workQueue中获取任务，如果workQueue已经为空，那么就没有添加新worker线程的必要了</span></span><br><span class="line"><span class="comment">         * return false，即无法addWorker()</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//内层循环，负责worker数量+1</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c); <span class="comment">//worker数量</span></span><br><span class="line">             </span><br><span class="line">            <span class="comment">//如果worker数量&gt;线程池最大上限CAPACITY（即使用int低29位可以容纳的最大值）</span></span><br><span class="line">            <span class="comment">//或者( worker数量&gt;corePoolSize 或  worker数量&gt;maximumPoolSize )，即已经超过了给定的边界</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">//调用unsafe CAS操作，使得worker数量+1，成功则跳出retry循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">//CAS worker数量+1失败，再次读取ctl</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">             </span><br><span class="line">            <span class="comment">//如果状态不等于之前获取的state，跳出内层循环，继续去外层循环判断</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">            <span class="comment">// else CAS失败时因为workerCount改变了，继续内层循环尝试CAS对worker数量+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * worker数量+1成功的后续操作</span></span><br><span class="line"><span class="comment">     * 添加到workers Set集合，并启动worker线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock; </span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask); <span class="comment">//1、设置worker这个AQS锁的同步状态state=-1</span></span><br><span class="line">                                   <span class="comment">//2、将firstTask设置给worker的成员变量firstTask</span></span><br><span class="line">                                   <span class="comment">//3、使用worker自身这个runnable，调用ThreadFactory创建一个线程，并设置给worker的成员变量thread</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//--------------------------------------------这部分代码是上锁的</span></span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="comment">// 当获取到锁后，再次检查</span></span><br><span class="line">                <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"> </span><br><span class="line">                <span class="comment">//如果线程池在运行running&lt;shutdown 或者 线程池已经shutdown，且firstTask==null（可能是workQueue中仍有未执行完成的任务，创建没有初始任务的worker线程执行）</span></span><br><span class="line">                <span class="comment">//worker数量-1的操作在addWorkerFailed()</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable   线程已经启动，抛非法线程状态异常</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                     </span><br><span class="line">                    workers.add(w);<span class="comment">//workers是一个HashSet&lt;Worker&gt;</span></span><br><span class="line">                     </span><br><span class="line">                    <span class="comment">//设置最大的池大小largestPoolSize，workerAdded设置为true</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//--------------------------------------------</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">//如果往HashSet中添加worker成功，启动线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//如果启动线程失败</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>addWorker(Runnable firstTask, boolean core)参数：    firstTask：    worker线程的初始任务，可以为空    core：           true：将corePoolSize作为上限，false：将maximumPoolSize作为上限addWorker方法有4种传参的方式：    1、addWorker(command, true)    2、addWorker(command, false)    3、addWorker(null, false)    4、addWorker(null, true)在execute方法中就使用了前3种，结合这个核心方法进行以下分析    第一个：线程数小于corePoolSize时，放一个需要处理的task进Workers Set。如果Workers Set长度超过corePoolSize，就返回false    第二个：当队列被放满时，就尝试将这个新来的task直接放入Workers Set，而此时Workers Set的长度限制是maximumPoolSize。如果线程池也满了的话就返回false    第三个：放入一个空的task进workers Set，长度限制是maximumPoolSize。这样一个task为空的worker在线程执行的时候会去任务队列里拿任务，这样就相当于创建了一个新的线程，只是没有马上分配任务    第四个：这个方法就是放一个null的task进Workers Set，而且是在小于corePoolSize时，如果此时Set中的数量已经达到corePoolSize那就返回false，什么也不干。实际使用中是在prestartAllCoreThreads()方法，这个方法用来为线程池预先启动corePoolSize个worker等待从workQueue中获取任务执行执行流程：1、判断线程池当前是否为可以添加worker线程的状态，可以则继续下一步，不可以return false：    A、线程池状态&gt;shutdown，可能为stop、tidying、terminated，不能添加worker线程    B、线程池状态==shutdown，firstTask不为空，不能添加worker线程，因为shutdown状态的线程池不接收新任务    C、线程池状态==shutdown，firstTask==null，workQueue为空，不能添加worker线程，因为firstTask为空是为了添加一个没有任务的线程再从workQueue获取task，而workQueue为空，说明添加无任务线程已经没有意义2、线程池当前线程数量是否超过上限（corePoolSize 或 maximumPoolSize），超过了return false，没超过则对workerCount+1，继续下一步3、在线程池的ReentrantLock保证下，向Workers Set中添加新创建的worker实例，添加完成后解锁，并启动worker线程，如果这一切都成功了，return true，如果添加worker入Set失败或启动失败，调用addWorkerFailed()逻辑</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><a href="http://www.cnblogs.com/trust-freedom/p/6681948.html" target="_blank" rel="noopener">http://www.cnblogs.com/trust-freedom/p/6681948.html</a></p><h1 id="submit与execute的区别"><a href="#submit与execute的区别" class="headerlink" title="submit与execute的区别"></a>submit与execute的区别</h1><p><a href="https://blog.csdn.net/peachpi/article/details/6771946" target="_blank" rel="noopener">https://blog.csdn.net/peachpi/article/details/6771946</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oxk1vrcj4.bkt.clouddn.com/v2-11c74576109d3e7f5e99b4c18c488170_hd.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程的原理与使用&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JavaSE" scheme="http://abelchao.com/categories/JavaSE/"/>
    
    
      <category term="JavaSE" scheme="http://abelchao.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>多态的实现原理</title>
    <link href="http://abelchao.com/2018/05/08/%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://abelchao.com/2018/05/08/多态的实现原理/</id>
    <published>2018-05-08T01:00:00.000Z</published>
    <updated>2018-05-08T03:44:18.541Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oxk1vrcj4.bkt.clouddn.com/369917882746482594.jpg" alt=""></p><p><strong>多态的实现原理</strong><br><a id="more"></a></p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><pre><code>要说多态，就要先从方法调用开始说起。如何在编译期（重载）和运行期（重写）去找到执行的方法版本。方法区中有编译后的Class文件里面存的可都是符号引用，而不是方法实际运行时内存分布的入口地址（直接引用）！！！</code></pre><h1 id="解析（静态解析）"><a href="#解析（静态解析）" class="headerlink" title="解析（静态解析）"></a>解析（静态解析）</h1><pre><code>所有方法调用中的目标方法在Class文件中都只是一个常量池中的符号引用，在类加载的解析阶段，会将其中一部分符号在这个阶段就转换成直接引用。这种类加载解析阶段转换的成立条件就是：编译期可知，运行期不可变。主要包括静态方法和私有方法，前者和类型直接关联，后者在外部不可被访问。其实还有final方法。就是说这三种方法都不可能通过继承或别的方式重写其他版本，所有适合在类加载的解析阶段进行符号引用到直接引用的转换（这个过程也叫做解析）JVM中有5条调用字节码指令：invokestatic，invokespecial，invokevirtual，invokeinterface，invokedynamic只要能被invokestatic和invokesspecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本。非虚方法：静态方法，构造器，私有方法，父类方法，final方法注意一下，final方法还是被invokevirtual修饰的，只不过是不能被重写，因此确定了唯一性。解析调用一定是个静态的过程，在编译器就被完全确定了，在类加载的解析阶段就会把涉及的符号引用全部转换成可确定的直接引用，不会延迟到运行期去进行。分派调用分为了静态和动态。我们这里解析和分派，不是一个二选一的过程，这两个是在不同层次上去筛选，确定目标方法的过程。静态方法选择重载的过程也是在编译期间利用静态分派完成的。</code></pre><h1 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h1><h2 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Human guy)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"human --- guy"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Man man)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"man --- gentleman"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Woman woman)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"woamn --- lady"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Human man = <span class="keyword">new</span> Man();<span class="comment">//静态类型是Human，实际类型是Man</span></span><br><span class="line">Human woman = <span class="keyword">new</span> Woman();<span class="comment">//静态类型是Human，实际类型是Woman</span></span><br><span class="line">StaticDispatch sd = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">sd.say(man);</span><br><span class="line">sd.say(woman);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">human --- guy</span></span><br><span class="line"><span class="comment">human --- guy</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticOverload</span> </span>&#123;</span><br><span class="line"><span class="comment">//public static void say(char arg)&#123;</span></span><br><span class="line"><span class="comment">//System.out.println("char");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//public static void say(int arg)&#123;</span></span><br><span class="line"><span class="comment">//System.out.println("int");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//public static void say(long arg)&#123;</span></span><br><span class="line"><span class="comment">//System.out.println("long");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//public static void say(Character arg)&#123;</span></span><br><span class="line"><span class="comment">//System.out.println("Character");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//public static void say(Serializable arg)&#123;</span></span><br><span class="line"><span class="comment">//System.out.println("Serializable");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//public static void say(Object arg)&#123;</span></span><br><span class="line"><span class="comment">//System.out.println("Object");</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(<span class="keyword">char</span>... arg)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"char..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Integer arg)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Integer"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Long arg)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Long"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">say(<span class="string">'a'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>1. 重载时，编译器根据参数的静态类型来确定方法入口。2. char--&gt;int--&gt;long--&gt;Character--&gt;Serializable--&gt;Object--&gt;char..    1. char，int，long属于基本数据类型的自动向上转型    2. Character是char的自动装箱    3. Serializable是Character实现的一个接口，因为找不到装箱的类，但是找到了装箱类实现的接口，所以紧接着就又发生了一次自动转型。    但是为什么Character没有转成Integer呢，这可是对象啊，对象哪有什么自动转换，又不是子父类关系。    需要注意的是，Character还有一个接口Comparable&lt;Character&gt;，一旦又出现了这个参数的重载，由于优先级一致，编译器就会报错了。    4. Object子父类关系（继承关系是从下往上搜索的，上层的优先级低）    5. 可变参数的数组</code></pre><h2 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Human human)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"human"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Human human)</span></span>&#123;<span class="comment">//Man man</span></span><br><span class="line">System.out.println(<span class="string">"man"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">(Human human)</span></span>&#123;<span class="comment">//Woman woman</span></span><br><span class="line">System.out.println(<span class="string">"woman"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Human man = <span class="keyword">new</span> Man();</span><br><span class="line">Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">man.say(man);</span><br><span class="line">woman.say(woman);</span><br><span class="line">man = <span class="keyword">new</span> Woman();</span><br><span class="line">man.say(man);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">man</span></span><br><span class="line"><span class="comment">woman</span></span><br><span class="line"><span class="comment">woman</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><pre><code>1. 实际参数不同2. invokevirtual指令的多态查找    1. 找到操作数栈顶的第一个元素所指向的对象的实际类型，记为C。    2. 如果在类型C中找到与常量中描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束。    3. 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索。    4. 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。3. 重写的本质也就是把Class文件中常量池中的符号引用在运行期解析到了不同的直接引用上。</code></pre><h2 id="动态分配的实现"><a href="#动态分配的实现" class="headerlink" title="动态分配的实现"></a>动态分配的实现</h2><p><a href="https://blog.csdn.net/sinat_34311901/article/details/52208124" target="_blank" rel="noopener">https://blog.csdn.net/sinat_34311901/article/details/52208124</a></p><pre><code>动态分派比较频繁，同时动态分派的方法版本选择过程需要在运行时在类的方法元数据中搜索合适的目标方法。最常用的稳定优化说就是在方法区来一个虚方法表（vtable/itable），使用虚方法表索引来代替元数据查找以提高性能。虚方法表中存放着各个方法的实际入口地址。如果子类没有实现父类的方法，那么子类和父类的入口地址一样。</code></pre><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String staticStr = <span class="string">"A's static field"</span>; </span><br><span class="line">    <span class="keyword">public</span> String nonStaticStr = <span class="string">"A's nonstatic field"</span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"A's static method"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonStaticMethod</span><span class="params">()</span></span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"A's nonstatic method"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String staticStr = <span class="string">"B's static field"</span>; </span><br><span class="line">    <span class="keyword">public</span> String nonStaticStr = <span class="string">"B's nonstatic field"</span>; <span class="comment">//super.nonStaticStr;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"B's static method"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOverride</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        C c = <span class="keyword">new</span> C(); </span><br><span class="line">        System.out.println(c.nonStaticStr);  <span class="comment">//A's nonstatic field</span></span><br><span class="line">        System.out.println(c.staticStr);  <span class="comment">//A's static field</span></span><br><span class="line">        c.staticMethod(); <span class="comment">//A's static method</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"-------------------------------"</span>); </span><br><span class="line">           </span><br><span class="line">        A c1 = <span class="keyword">new</span> C(); </span><br><span class="line">        System.out.println(c1.nonStaticStr);  <span class="comment">//A's nonstatic field</span></span><br><span class="line">        System.out.println(c1.staticStr);  <span class="comment">//A's static field</span></span><br><span class="line">        c1.staticMethod(); <span class="comment">//A's static method</span></span><br><span class="line">          </span><br><span class="line">        <span class="comment">// 以上这说明java中静态属性和静态方法可以被继承</span></span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"-------------------------------"</span>); </span><br><span class="line">        B b = <span class="keyword">new</span> B(); </span><br><span class="line">        System.out.println(b.nonStaticStr); <span class="comment">// B's nonstatic field</span></span><br><span class="line">        System.out.println(b.staticStr);   <span class="comment">//B's static field</span></span><br><span class="line">        b.staticMethod();  <span class="comment">//B's static method</span></span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"-------------------------------"</span>); </span><br><span class="line">        A b1 = <span class="keyword">new</span> B(); </span><br><span class="line">        System.out.println(b1.nonStaticStr);  <span class="comment">//A's nonstatic field</span></span><br><span class="line">        System.out.println(b1.staticStr);  <span class="comment">//A's static field</span></span><br><span class="line">        b1.staticMethod(); <span class="comment">//A's static method</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>1. 静态方法，属性可以继承，但是不能被重写（形式上的重写其实是隐藏）2. 属性都是不能被重写的，因为Java中属性依赖的是同名属性依赖机制：具有父子关系的两个类中，子类中相同名字的属性会失去从父类中继承的数据，不管两个属性的类型是否一致，只要重名，就隐藏父类的。3. 一般不要用实例对象去调用静态方法。（容易混淆）</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;?&gt;[] collections = &#123;<span class="keyword">new</span> HashSet&lt;String&gt;(), <span class="keyword">new</span> ArrayList&lt;String&gt;(), <span class="keyword">new</span> HashMap&lt;String, String&gt;().values()&#125;;</span><br><span class="line">        Super subToSuper = <span class="keyword">new</span> Sub();</span><br><span class="line">        <span class="keyword">for</span>(Collection&lt;?&gt; collection: collections) &#123;</span><br><span class="line">        System.out.println(subToSuper.getType(collection));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Super:collection"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Super:list"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(ArrayList&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Super:arrayList"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(Set&lt;?&gt; set)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Super:set"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(HashSet&lt;?&gt; set)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Super:hashSet"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Sub"</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Super:collection</span></span><br><span class="line"><span class="comment">Super:collection</span></span><br><span class="line"><span class="comment">Super:collection</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><pre><code>1. 静态方法没有被重写，只是被覆盖了，所有调用的还是父类的getType(Collection&lt;?&gt; collection) 2. 同时数组的类型是Collection，也就是说静态类型被确定了，剩下都是静态解析和静态分配（重载）做的事情，而重载看的又只是静态类型，那么走的都是getType(Collection&lt;?&gt; collection)</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;?&gt;[] collections = &#123;<span class="keyword">new</span> LinkedList&lt;String&gt;(), <span class="keyword">new</span> ArrayList&lt;String&gt;()&#125;;</span><br><span class="line">        Super subToSuper = <span class="keyword">new</span> Sub();</span><br><span class="line">        <span class="keyword">for</span>(List&lt;?&gt; collection: collections) &#123;</span><br><span class="line">        System.out.println(subToSuper.getType(collection));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Super:collection"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Super:list"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(ArrayList&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Super:arrayList"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(Set&lt;?&gt; set)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Super:set"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(HashSet&lt;?&gt; set)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Super:hashSet"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Sub"</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Sub:list"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Super:list</span></span><br><span class="line"><span class="comment">Super:list</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oxk1vrcj4.bkt.clouddn.com/369917882746482594.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多态的实现原理&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JavaSE" scheme="http://abelchao.com/categories/JavaSE/"/>
    
    
      <category term="JavaSE" scheme="http://abelchao.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>操作系统基础复习</title>
    <link href="http://abelchao.com/2018/05/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
    <id>http://abelchao.com/2018/05/04/操作系统基础复习/</id>
    <published>2018-05-04T01:00:00.000Z</published>
    <updated>2018-05-04T13:49:30.657Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oxk1vrcj4.bkt.clouddn.com/576858003667931605.jpg" alt=""></p><p><strong>操作系统基础复习</strong><br><a id="more"></a></p><h1 id="之前的总结"><a href="#之前的总结" class="headerlink" title="之前的总结"></a>之前的总结</h1><p><a href="http://bbblemon.top/2017/12/28/Operating%20System%EF%BC%88%E5%BC%95%E8%AE%BA&amp;%E8%BF%9B%E7%A8%8B&amp;%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%EF%BC%89/" target="_blank" rel="noopener">http://bbblemon.top/2017/12/28/Operating%20System%EF%BC%88%E5%BC%95%E8%AE%BA&amp;%E8%BF%9B%E7%A8%8B&amp;%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%EF%BC%89/</a></p><p><a href="http://bbblemon.top/2018/01/08/Operating%20System%EF%BC%88%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86&amp;%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%89/" target="_blank" rel="noopener">http://bbblemon.top/2018/01/08/Operating%20System%EF%BC%88%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86&amp;%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%89/</a></p><h1 id="操作系统的特性"><a href="#操作系统的特性" class="headerlink" title="操作系统的特性"></a>操作系统的特性</h1><pre><code>1. 并发：同一时段内多个程序执行（并行说的是某一时刻有多个事件发生了，并发说的是某个时间段，微观上是多个事件交替进行，交替占用CPU）2. 共享：系统中的资源可以被内存中多个并发执行的进线程共同使用。3. 虚拟：通过时分复用（如分时系统）以及空分复用（如虚拟内存）技术实现把一个物理实体虚拟为多个4. 异步：系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进。并发和共享是多用户OS的两个最基本特性。又互为存在条件。资源的共享是以并发为前提的，资源共享如果无法有效管理，影响并发。</code></pre><h1 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a>操作系统的分类</h1><pre><code>1. 批处理：批处理系统旨在提高系统资源的利用率和系统吞吐量。    1. 单批道：系统虽然对作业的处理是成批的，但是在内存中却始终只有一道作业。    2. 多批道：系统利用作业调度算法，从外存中一次取若干个作业调入内存，使它们共享CPU和系统中的资源。利用一个作业I/O的时间，在CPU上执行另一个作业。特点：资源利用率高，系统吞吐量大，平均周转时间长，无交互能力。2. 分时：批处理是为了提高资源利用率和系统吞吐量，分时是为了满足人-机交互。分时系统说的是，一台主机上连接了多个配有显示器和键盘的终端并由此组成的系统。该系统允许多个用户同时通过自己的终端，以交互方式使用计算机，共享主机的资源。多道批处理是把作业都先驻留在了外存上，即使被调如内存，也要经过较长时间的等待后才能运行，也就失去了交互性。分时的人-机交互，关键就在这个交互与系统及时接收，处理，返回结果。    1. 及时接收：利用多路卡，实现分时多路复用。主机以很快的速度周期性的扫描各个终端，在每个终端处停留的时间很短，用来接收各个终端的数据。    2. 及时处理：        1. 作业直接进入内存。（批处理是现在外存的）        2. 采用轮转运行方式。（时间片，一段很短的时间，每个作业每次只能运行一个时间片，然后就暂停该作业的运行，立即调度下一个作业运行）特点：多路性，独立性，及时性，交互性。3. 实时：计算机能及时响应外部时间的i去年请求，在规定的严格时间内完成对该事件的处理，并控制所有实时设备和任务协调一致的工作。实时系统追求的目标就是对外部请求在严格时间范围内做出反应，有高可靠性和完整性。资源的分配和调度首先考虑的是实时性然后才是效率。分类：    1. 周期实时任务和非周期实时任务    2. 硬实时任务和软实时任务特点：多路性，独立性，及时性，交互性，可靠性。4. 网络和分布式</code></pre><h1 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h1><pre><code>1. 处理机管理：处理机分配是以进程为单位的，处理机管理也被看作进程管理。处理机的管理主要是，将作业调入内存，为其创建，撤销进程，控制进程的运行过程，实现进程通信，和为进程分配处理机。    1. 进程控制：每道作业都需要一个或者多个进程，进程控制就是创建，撤销进程和控制进程在运行过程中的状态转换。    2. 进程同步：为多个进程的运行进行协调。协调方式        1. 进程互斥，进程在对临界资源访问时，采用互斥的方式。最常用的就是给每个临界资源加锁。        2. 进程同步，相互协作去完成共同任务的进程间，利用同步机构对这些进程的执行次序进行控制。最常用的进程同步机制就是信号量机制。    3. 进程通信：        https://www.cnblogs.com/LUO77/p/5816326.html    4. 调度：        1. 作业调度：从后备队列中按照一定的算法选择若干作业，为它们分配运行时需要的资源，再将这些作业调入内存后，分别为它们建立进程，使它们都能称为可能获得处理机的就绪进程，并将它们插入就绪队列中。        2. 进程调度：从进程就绪队列中按照算法选一个进程，将处理机分配给它，并为它设置运行现场。2. 存储器管理为多道程序提供良好的环境，提高存储器的利用率，方便用户使用，逻辑上扩充内存。    1. 内存分配：为每道程序分配内存，提高存储器的利用率，尽量减少碎片，允许正在运行的程序申请附加的内存空间。    内存分配的方式：        1. 静态：每个作业的内存空间在作业装入内存时确定，运行期间不可修改，作业不允许在内存中移动。        2. 动态：每个作业的内存空间在作业装入内存的时候只是确定一个基本量，在运行时允许扩充，允许作业在内存中移动。    2. 内存保护：内存保护机制，简单的就是设置两个界限寄存器，分别放在正在执行程序的上下界。        1. 每道程序都只能在自己的内存空间运行        2. 用户程序禁止访问OS程序和数据，也不允许用户程序转移到非共享的其他用户程序中去执行。    3. 地址映射：每道程序编译和链接后所形成的可装入程序其地址都是从0开始的，但是不可能将它们从0这个物理地址装入，地址映射也就是把地址空间中的逻辑地址转换成内存空间中与之对应的物理地址。    4. 内存扩充：虚拟存储        1. 请求调入：系统可以在仅装入一部分用户程序和数据的情况下运行，后面需要了再调入        2. 置换功能：内存中没有足够的空间调入程序和数据，系统将内存中一部分暂时不用的程序和数据调至硬盘上，然后腾出内存空间，把需要用的再调入内存。3. 设备管理    1. 完成用户进程提出的I/OC请求。    2. 提高CPU与I/O设备的利用率。    1. 缓冲管理：I/O设备和CPU运行速度的不匹配，之间设置高速缓冲区。        单缓冲机制，双缓冲机制，公用缓冲池机制    2. 设备分配：为程序的I/O请求分配I/O设备。    3. 设备处理：实现CPU和设备控制器之间的通信，CPU向设备控制器发送I/O命令，设备控制器发送中断请求给CPU。4. 文件管理对用户文件和系统文件进行管理，以方便用户使用，并保证文件的安全性。    1. 文件存储空间的管理    2. 目录管理    3. 文件的读写管理与保护5. 提供用户接口    1. 程序接口，API    2. 用户接口，GUI</code></pre><h1 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h1><p><a href="http://bbblemon.top/2017/12/28/Operating%20System%EF%BC%88%E5%BC%95%E8%AE%BA&amp;%E8%BF%9B%E7%A8%8B&amp;%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%EF%BC%89/" target="_blank" rel="noopener">http://bbblemon.top/2017/12/28/Operating%20System%EF%BC%88%E5%BC%95%E8%AE%BA&amp;%E8%BF%9B%E7%A8%8B&amp;%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%EF%BC%89/</a></p><h1 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h1><pre><code>1. 调度单元：进程是可拥有系统资源的基本单位，线程调度和分配的基本单元（能独立运行的基本单元）2. 并发性：线程是轻量级的进程，一个进程中多个线程并发执行3. 拥有资源：不管有没有线程，进程都是拥有系统资源的解基本单位。而线程本身不拥有系统资源，而只有又一点不可少的，能保证独立运行的资源（TCB,程序计数器，保留局部变量，少数状态参数和返回地址等一组寄存器和堆栈）4. 独立性：进程只有自己独立空间和其他资源，除了共享全局变量外，不允许其他进程访问。而同一进程的所有线程可以访问所属进程空空间中的所有地址。5. 系统开销：创建，切换，撤销进程的开销大注意：一个进程中至少又一个线程，CPU上可以没有正在运行的进程。一个线程只属于某一个特定的进程。</code></pre><h1 id="进程描述"><a href="#进程描述" class="headerlink" title="进程描述"></a>进程描述</h1><pre><code>一个进程就是一个完成程序的一次执行。为了使参与并发的程序可以独立运行，引入了PCB。程序段，相关数据段，PCB三部分组成了进程实体。创建进程，其实就是创建PCB。PCB是进程存在的唯一标识进程的其他定义:    1. 进程是程序的一次执行    2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。    3. 进程是系统进行资源分配和调度的一个独立单元。进程的特征：动态性，并发性，独立性，异步性。</code></pre><h2 id="PCB（Process-Control-Block）"><a href="#PCB（Process-Control-Block）" class="headerlink" title="PCB（Process Control Block）"></a>PCB（Process Control Block）</h2><pre><code>PCB作为进程实体的一部分，记录了操作系统所需的，用于描述当前进程情况已经管理进程的一切信息。PCB的作用是在多道程序的环境下，让不能独立运行的程序成为一个独立运行的基本单位。</code></pre><h1 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h1><pre><code>1. 进程申请空白PCB，并向PCB中填写控制和管理进程的信息2. 为进程分配运行时需要的资源，包括逻辑和物理的3. 进程转入就绪状态并插入就绪队列注意：进程不能拒绝其子进程的继承。但是也存在没有父进程的进程。在WindowOS中不存在任何进程层次结构的概念，也就是说，所有的进程都是相同的地位。</code></pre><h1 id="线程描述"><a href="#线程描述" class="headerlink" title="线程描述"></a>线程描述</h1><pre><code>在OS中引入进程的目的是为了在多道环境下，多个进程并发执行，以提高资源利用率和系统吞吐量。那么引入线程就是为了减小程序在并发执行时所付出的时空开销，让OS具有更好的并发性。</code></pre><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><pre><code>1. 线程标识符，每个线程是唯一的。2. 一组寄存器：程序计数器PC、状态寄存器、通用寄存器3. 线程运行状态4. 优先级5. 线程专有存储区，用于线程切换时存放现场保护信息6. 信号屏蔽7. 堆栈指针，每个线程有自己的堆栈，用来保存局部变量和返回地址，而TCB中也就有了两个对应的指向堆栈的指针：指向用户自己堆栈的指针（线程运行在目态）和指向核心栈的指针（线程运行在管态）。</code></pre><h1 id="进程-线程通信"><a href="#进程-线程通信" class="headerlink" title="进程/线程通信"></a>进程/线程通信</h1><p><a href="https://www.cnblogs.com/LUO77/p/5816326.html" target="_blank" rel="noopener">https://www.cnblogs.com/LUO77/p/5816326.html</a></p><pre><code>Linux线程间通信：互斥量（mutex），信号量，条件变量Windows进程间通信：管道、有名管道、消息队列、共享内存、信号量（semaphore）、套接字(socket)Windows线程间通信：互斥量（mutex），信号量（semaphore）、临界区（critical section）、事件（event）整形信号量定义为一个用于表示资源数目的整形量S，除了初始化外，只能通过两个标准的原子操作wait（P）、Singal（V）来操作。其实就是说，S等于多少，就代表现在还有几个空闲的资源，为负数就说明没有了，还有线程在等待资源。但是信号量不能用于大批数据交换。管道是一种半双工的通信方式，数据只能单向流动，而且只能在有亲缘关系的进程中使用有名管道也是一种半双工的通信方式，但是它允许无亲缘关系进程间的通信。</code></pre><h1 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h1><pre><code>多进程虽然提高了系统资源利用率和吞吐量，但是由于进程的异步性可能造成系统的混乱。进程同步的任务就是对多个相关进程在执行顺序上进行协调，使并发执行的多个进程之间可以有效的共享资源和相互合作，保证程序执行的可再现性临界区：每个进程中访问临界资源的代码就是临界区。同步机制需要遵循的规则    1. 空闲让进：当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请。    2. 忙则等待：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问    3. 有限等待：对要求访问临界资源的进程，需要在有限时间内进入临界区，防止出现死等    4. 让权等待：当进程无法进入临界区的时候，需要释放处理机，边陷入忙等。</code></pre><h1 id="进程同步的解决"><a href="#进程同步的解决" class="headerlink" title="进程同步的解决"></a>进程同步的解决</h1><pre><code>进程同步：为多个进程的运行进行协调。协调方式    1. 进程互斥，进程在对临界资源访问时，采用互斥的方式。最常用的就是给每个临界资源加锁。    2. 进程同步，相互协作去完成共同任务的进程间，利用同步机构对这些进程的执行次序进行控制。最常用的进程同步机制就是信号量机制。</code></pre><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><pre><code>利用信号量实现进程互斥为使多个进程互斥地访问某临界资源，只需要为该资源设置-互斥信号量mutex，并设其值为1。利用信号量实现两个进程互斥的描述如下:设mutex为互斥信号量，其值为1，取值范围（-1，0，1）    1. mutex=1，两个进程都没有进入需要互斥的临界区    2. mutex=0，表示有一个进程进入临界区运行，另一个必须等待，挂入阻塞队列。    3. mutex=-1，表示有一个进程进入了临界区，另一个进程因等待而阻塞在信号量队列中，需要在被当前已在临界区运行的进程退出时唤醒。在利用信号量机制实现进程互斥的时候，wait(mutex)和signal(mutex)必须成对的出现。缺少wait(mutex)不能保证对临界资源的互斥访问，缺少signal(mutex)，会使临界资源永远不被释放。</code></pre><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><pre><code>管程包含了面向对象的思想，它将表征共享资源的数据结构及其对数据结构操作的一组过程，封装到了一个对象内部，隐藏了实现细节。进程要访问临界资源的时候，都只能通过管程间接访问，而管程每次只允许一个进程进入。</code></pre><h1 id="用户态（目态）和核心态（系统态，管态）"><a href="#用户态（目态）和核心态（系统态，管态）" class="headerlink" title="用户态（目态）和核心态（系统态，管态）"></a>用户态（目态）和核心态（系统态，管态）</h1><pre><code>CPU的工作方式分为管态和目态，在管态方式CPU可以执行特权指令，而目态只能执行非特权指令。从用户态到管态：    使用特权指令，而不是系统调用，能进行系统调用，说明已经在管态了。用户态执行特权指令，肯定是非法的，要发生中断，而中断处理程序都是在管态的，中断一定能使系统从用户态转为管态。</code></pre><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><pre><code>一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么这组进程是死锁的。1. 死锁的必要条件    1. 互斥条件：某个资源在一段时间内只能由一个进程占有。    2. 请求和保持条件：进程自己占有一个资源，同时对别的资源进行了请求，而这个资源被其他进程占有着。    3. 不可抢占条件:进程已经获取的资源在未使用完前不能被抢占。    4. 循环等待条件:存在一个进程-资源的循环链。2. 死锁的处理    1. 预防死锁：因为互斥条件是非共享设备必须的，所以一般都是破坏死锁的后三个条件。        1. 破坏请求保持：进程在请求资源时，不能持有不可抢占的资源。（静态资源分配法）        2. 破坏不可抢占：一个进程已占有某些不可抢占的资源，但是它又请求了资源，且不能被满足，这个进程就必须释放所有自己资源。（剥夺分配法）        3. 破坏循环等待：给资源事先分类编号，使进程在申请资源的时候，必须按照序号递增的顺序请求。（资源有序分配）    2. 避免死锁：在资源动态分配的过程中，用某种方法防止系统进入不安全状态。    安全状态一定不死锁，不安全状态不一定死锁。    3. 检测死锁：允许进程在运行的过程中死锁，但是可以检测出来，然后利用解除死锁的方法进行接触。（资源分配图法）    4. 解除死锁：        1. 抢占资源：从一个或者多个进程中抢占足够数量的资源，分配给死锁进程。        2. 终止进程：终止系统中一个或者多个死锁进程，直到打破循环环路。            1. 终止所有死锁进程            2. 逐个终止进程</code></pre><h1 id="线程同步与阻塞的关系？"><a href="#线程同步与阻塞的关系？" class="headerlink" title="线程同步与阻塞的关系？"></a>线程同步与阻塞的关系？</h1><p><a href="https://www.cnblogs.com/Anker/p/5965654.html" target="_blank" rel="noopener">https://www.cnblogs.com/Anker/p/5965654.html</a></p><pre><code>1. 线程同步和阻塞没有一点关系2. 同步和异步关注的是消息通信机制。    1. 同步：执行一个操作，等待结果返回后，才能继续后续的操作。    2. 异步：执行一个操作，不需要等到结果返回，就可以执行别的操作，等到结果返回了，再去执行后续操作3. 阻塞和非阻塞关注的是程序在等得调用结果时的状态。    1. 阻塞：进程给CPU传达一个任务后，等待CPU处理完以后，才执行后面的。    2. 非阻塞：进程给CPU任务后，继续执行后续操作，隔断时间再来询问之前的操作是不是完成了。（轮询）异步必然是非阻塞的。</code></pre><h1 id="作业-进程调度算法"><a href="#作业-进程调度算法" class="headerlink" title="作业/进程调度算法"></a>作业/进程调度算法</h1><pre><code>1. 先来先服务（FCFS，First-come First-Served）：作业/进程调度算法（作业/进程后备队列）。长作业有利。2. 短作业优先（SJF，Short Job First）：作业/进程调度算法（作业/进程后备队列）。短作业有利。    1. 必须预知作业/进程的运行时间    2. 对长作业不利，出现饥饿现象    3. 人-机无法交互3. 优先级调度（PSA，Priority-Scheduling Algorithm）： 作业/进程调度算法（作业/进程后备队列）。人为给作业/进程给了优先级4. 高响应比（HRRN，Highest Response Ratio Next）：作业/进程调度算法（作业/进程后备队列）。响应比=（等待时间+要求服务时间）/要求服务时间。    1. 响应时间=等待时间+要求服务时间    2. 周转时间=作业提交---&gt;作业完成5. 轮转调度（RR，Round Robin）：分时系统中中基于时间片的调度。（进程调度）按到达的先后将进程放入队列中（FCFS），然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环;一旦时间片内进程结束，直接将其从就绪队列中删除，引入新的队首进程。6. 优先级调度    1. 非抢占    2. 抢占如何确定优先级：    1. 静态：创建进程时确定，进程运行过程中不变    2. 动态：随着进程的推进和等待时间的增加而改变7. 多队列调度：将系统中进程就绪队列从一个拆成多个，每个就绪队列采用不同的调度算法。8. 多级反馈队列（Multileved Feedback Queue）    1. 设置多个就绪队列，每个队列又不同的优先级，第一个队列的最高，以此递减。优先级越高的队列分配的时间片越短。    2. 每个队列使用FCFS算法，进程到达之后按FCFS放入第一个队列尾部，如果调度执行（时间片内）没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部…。    3. 按照队列优先级调度，只有当前一个队列为空的时候才会去调度下一个队列的进程。</code></pre><h1 id="内存的连续分配"><a href="#内存的连续分配" class="headerlink" title="内存的连续分配"></a>内存的连续分配</h1><pre><code>1. 单一连续分配：单道程序环境中，存储器管理方式把内存分为系统区和用户区两部分。系统区给OS使用，它通常是放在内存的低址部分，而用户区内存中，仅装有一道用户程序。整个内存的用户空间被该程序独占。2. 固定分区分配：对用户空间分区，然后每个区放一道程序。3. 动态分区分配    1. 数据结构：空闲分区表，空闲分区链    2. 动态分区分配算法：顺序式搜索，索引式搜索        1. 顺序式搜索：            1. 首次适应（FF,First Fit）：空闲分区使用地址递增的次序链接。分配内存时，每次都是从链首开始，直到找到一个大小适合的内存。            2. 循环首次适应（NF,Next Fit）：分配内存的时候，不再每次从链首开始，减少了没有比较的查找，而是从上次找到的空闲分区的下一个空闲分区开始。            3. 最佳适应（BF，Best Fit）：空闲分区按照其容量从小到大顺序形成。            4. 最坏适应（WF，Worst Fit）：空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。        2. 索引式搜索：            1. 快速适应（QT，Quick Fit）            2. 伙伴系统（BS，Buddy System）            3. 哈希算法（Hash）    3. 分区操作：分配内存，回收内存。4. 动态可重定位分区分配    1. 紧凑    2. 动态重定位：内存地址=相对地址+重定位寄存器地址在内存连续分配中，固定分区会产生内部碎片，动态分区会产生外部碎片。</code></pre><h1 id="对换"><a href="#对换" class="headerlink" title="对换"></a>对换</h1><pre><code>1. 把内存中暂时不能运行的进程，或者暂时不能使用的程序和数据换出到外存上，然后把已经具备运行条件的进程或进程所需要的程序换入内存。2. 对换可以直接提高处理机的利用率和系统的吞吐量。</code></pre><h1 id="内存的离散分配（基础的分页，分段）"><a href="#内存的离散分配（基础的分页，分段）" class="headerlink" title="内存的离散分配（基础的分页，分段）"></a>内存的离散分配（基础的分页，分段）</h1><p><a href="http://bbblemon.top/2018/01/08/Operating%20System%EF%BC%88%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86&amp;%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%89/" target="_blank" rel="noopener">http://bbblemon.top/2018/01/08/Operating%20System%EF%BC%88%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86&amp;%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%89/</a></p><pre><code>内存连续分配会会形成很多的碎片，就算是有&quot;紧凑的方式&quot;，但是开销特别大，为了把一个进程直接分散的装入许多不连续的分区中，有了离散分配。离散分配允许一个程序分散地装入到不相邻的内存分区中，根据分区的大小是否固定（分配地址的基本单位不同）分为分页存储管理方式和分段存储管理方式。</code></pre><h2 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a>基本分页存储管理</h2><pre><code> 分页：把用户程序分成若干固定大小的区域，称为&quot;页&quot;或&quot;页面&quot;，相应的把内存空间也分为若干个物理块或页框。页和块大小相同。1)页面和页面大小。进程中的块称为页(Page)，内存中的块称为页框（Page Frame，或页帧）。外存也以同样的单位进行划分，直接称为块(Block)。进程在执行时需要申请主存空间，就是要为每个页面分配主存中的可用页框，这就产生了页和页框的一一对应。为方便地址转换，页面大小应是2的整数幂。2)地址结构        页号+页内位移量（页内地址）    若一个逻辑地址空间中的地址是A，页面大小是L，页号是P，页内地址是d，则P=A/L,d=A%L。3)页表。为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般存放在内存中。在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作用是实现从页号到物理块号的地址映射。</code></pre><h2 id="基本分段存储管理"><a href="#基本分段存储管理" class="headerlink" title="基本分段存储管理"></a>基本分段存储管理</h2><pre><code>分页管理方式是从计算机的角度考虑设计的，以提高内存的利用率，提升计算机的性能, 且分页通过硬件机制实现，对用户完全透明；而分段管理方式的提出则是考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。段式管理方式按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段，每段从0 开始编址，并分配一段连续的地址空间（段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的）。其逻辑地址由段号S与段内偏移量W两部分组成。在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的（不可见），但在段式系统中，段号和段内偏移量必须由用户显示提供，在髙级程序设计语言中，这个工作由编译程序完成。</code></pre><h2 id="基本分页和分段的区别"><a href="#基本分页和分段的区别" class="headerlink" title="基本分页和分段的区别"></a>基本分页和分段的区别</h2><pre><code>1. 页是信息的物理单位，分页是为了消除内存的碎片。分页是系统管理的行为，用户不可见。而分段的信息的逻辑单位，分段只是为了方便用户2. 页的大小固定而且只和系统有关，每个系统中只能有一种大小的页面，而段的长度不固定，由用户决定。3. 分页的用户地址是一维的，分段是二维的。</code></pre><h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><pre><code>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。之所以将其称为虚拟存储器，是因为这种存储器实际上并不存在，只是由于系统提供了部分装入、请求调入和置换功能后（对用户完全透明），给用户的感觉是好像存在一个比实际物理内存大得多的存储器。虚拟存储器的大小由计算机的地址结构决定，并非是内存和外存的简单相加。虚拟内存的大小=min(内存+外存，2^n),其中n为计算机的位数。在传统存储器管理方式中，一次性和驻留性。虚拟存储器管理方式中，多次性，对换性，虚拟性。虚拟性是以多次性和对换性为基础的。多次性最重要。多次性和对换性又建立在离散分配的基础上。注意：虚拟存储器的实现都是建立在离散分配存储管理方式的基础上的。</code></pre><h2 id="虚拟存储器的实现"><a href="#虚拟存储器的实现" class="headerlink" title="虚拟存储器的实现"></a>虚拟存储器的实现</h2><pre><code>1. 请求分页系统2. 请求分段系统</code></pre><h2 id="请求分页-分段存储管理方式（页面置换算法）"><a href="#请求分页-分段存储管理方式（页面置换算法）" class="headerlink" title="请求分页/分段存储管理方式（页面置换算法）"></a>请求分页/分段存储管理方式（页面置换算法）</h2><p><a href="http://bbblemon.top/2018/01/08/Operating%20System%EF%BC%88%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86&amp;%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%89/" target="_blank" rel="noopener">http://bbblemon.top/2018/01/08/Operating%20System%EF%BC%88%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86&amp;%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%89/</a></p><h1 id="磁盘与设备管理"><a href="#磁盘与设备管理" class="headerlink" title="磁盘与设备管理"></a>磁盘与设备管理</h1><p><a href="http://bbblemon.top/2018/01/09/Operating%20System%EF%BC%88%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86&amp;IO%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%EF%BC%89/" target="_blank" rel="noopener">http://bbblemon.top/2018/01/09/Operating%20System%EF%BC%88%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86&amp;IO%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%EF%BC%89/</a></p><h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><p><a href="http://bbblemon.top/2018/01/08/Operating%20System%EF%BC%88%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86&amp;%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%89/" target="_blank" rel="noopener">http://bbblemon.top/2018/01/08/Operating%20System%EF%BC%88%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86&amp;%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%EF%BC%89/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oxk1vrcj4.bkt.clouddn.com/576858003667931605.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;操作系统基础复习&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="OS" scheme="http://abelchao.com/categories/OS/"/>
    
    
      <category term="OS" scheme="http://abelchao.com/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础复习</title>
    <link href="http://abelchao.com/2018/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
    <id>http://abelchao.com/2018/05/03/计算机网络基础复习/</id>
    <published>2018-05-03T01:00:00.000Z</published>
    <updated>2018-05-03T09:58:49.072Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oxk1vrcj4.bkt.clouddn.com/662703796983558046.jpg" alt=""></p><p><strong>计算机网络基础复习</strong><br><a id="more"></a></p><h1 id="Https与Http的区别"><a href="#Https与Http的区别" class="headerlink" title="Https与Http的区别"></a>Https与Http的区别</h1><pre><code>1. http是HTTP协议运行在TCP上。所有传输的内容都是明文，客户端和服务端都无法验证对方的身份。2. https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP上，所有传输的内容都是经过加密的，加密采用对称加密。但是对称加密的密钥用服务器方的证书进行了非对称加密。3. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。4. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是4435. http无状态。</code></pre><h1 id="TCP如何保证可靠传输"><a href="#TCP如何保证可靠传输" class="headerlink" title="TCP如何保证可靠传输"></a>TCP如何保证可靠传输</h1><pre><code>1. 数据包校验2. 超时重传机制3. 应答机制4. 对失序数据包重排序5. TCP还能提供流量控制。</code></pre><h1 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h1><p><a href="https://www.zhihu.com/question/24853633" target="_blank" rel="noopener">https://www.zhihu.com/question/24853633</a></p><pre><code>TCP连接握手，握的就是通信双方数据原点的序列号。1. seq序号：用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。2. ack确认序号：只有ACK标志位为1时，确认序号字段才有效。3. 标志位    1. URG：紧急指针（Urgent Pointer）有效    2. ACK：确认序号有效    3. PSH：接收方应该尽快将这个报文交给应用层    4. RST：重置连接    5. SYN：发起一个新连接    6. FIN：释放一个连接4. 不要将确认序号ack与ACK标志位搞混；确认方ack=发起方seq+1</code></pre><p><img src="http://oxk1vrcj4.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180502203956.png" alt=""></p><pre><code>1. 第一握手，客户端发送SYN（seq，随机选取一个序列号作为自己的初始序号）（Synchronize Sequence Numbers）包到服务器，并进入SYN_SNET状态，等待服务器确认。2. 第二次握手，服务器收到seq包，必须确认客户的seq，使用ack对A的数据包进行确认，因为以后收到了序列号为x的数据包，准备接收序列号是x+1的包，所以ack=x+1，同时告诉客户端自己的初始序列号。服务器进入SYN_RECV状态3. 第三次握手，客户端收到服务器的ack与seq，向服务器发送确认包seq、ack，客户端此条消息的序列号是x+1，所以seq=x+1，而ack=y+1，ack表示客户端正准备接收服务器序列号是y+1的数据包，此包发送完毕，客户端和服务器都进入ESTABLISHED（TCP连接成功），完成三次握手</code></pre><p><img src="http://oxk1vrcj4.bkt.clouddn.com/v2-c8b61ed2a249700583b11bc5d16c5711_r.jpg" alt=""></p><pre><code>1. 第一次挥手：A认为数据发送完了，需要向B发送连接释放请求。该请求只有报文头，头中携带主要参数为：    1. FIN=1，seq=u，此时A进入FIN-WAIT-1        1. FIN=1表示该报文段是一个连接释放请求。        2. seq=u，u-1是A向B发送的最后一个字节的序号。2. 第二次挥手：B接收到连接释放请求后，会通知相应的应用程序，告诉它A向B这个方向的连接已经释放了。B进入CLOSE-WAIT，并向A发送释放的应答，其报文头：    ACK=1,seq=v,ack=u+1。        1. ACK=1，除了TCP连接请求报文段以外，TCP通信过程中所有数据报的ACK都是1，表示应答。        2. seq=v，v-1是B向A发送的最后一个字节的序号        3. ack=u+1,表示希望收到第u+1字节开始的报文段，并且已经成功接收到了前u个字节。A收到该应答，进入FIN-WAIT-2状态，等待B发送连接释放请求。第二次挥手完成后，A到B的连接已经释放，B不会再接收数据，A不会再发送数据。但是B到A的连接还存在，B还可以向A发送数据。3. 第三次挥手：当B向A发完所有数据后，向A发送连接释放请求，请求头：FIN=1,ACK=1,seq=w，ack=u+1。4. 第四次挥手：A收到释放请求，向B发送确认应答，此时A进入TIME-WAIT状态，该状态会持续2MSL时间，若该时间段内没有B的重发请求，就进入CLOSED，撤销TCB。当B收到确认应答后，也进入CLOSED，撤销TCB。</code></pre><h2 id="为什么不是两次，或者四次"><a href="#为什么不是两次，或者四次" class="headerlink" title="为什么不是两次，或者四次"></a>为什么不是两次，或者四次</h2><pre><code>A &lt;-------&gt; B1. 两次连接，就是为了防止失效的连接请求报文段被服务器接收，从而产生了错误。ps:失效的连接请求，若客户端向服务端发送的连接请求丢失，客户端等待应答时间超时后，就会再次发送连接请求，此时上一个连接请求就是失效的。客户端的请求报文在某个网络结点长时间滞留了，以至于延误到连接释放后才到达B，本来就是一个失效的报文，但是B以为这个A又发的一个新的连接请求。于是向A发出确认报文，同一建立连接。假定不采用三次握手，那么只要B发出了确认，就建立了新的连接。但是A并没有发出连接，所以B以为自己连接建立了，一直等待A的数据，但是等不到。2. 四次连接，第三次已经确认了，没必要了</code></pre><h2 id="为什么A要先进入TINE-WAIT，等待2MSL时间才进入CLOSED"><a href="#为什么A要先进入TINE-WAIT，等待2MSL时间才进入CLOSED" class="headerlink" title="为什么A要先进入TINE-WAIT，等待2MSL时间才进入CLOSED"></a>为什么A要先进入TINE-WAIT，等待2MSL时间才进入CLOSED</h2><pre><code>为了保证B能收到A的确认应答。 若A发完确认应答后直接进入CLOSED状态，那么如果该应答丢失，B等待超时后就会重新发送连接释放请求，但此时A已经关闭了，不会作出任何响应，因此B永远无法正常关闭。</code></pre><h1 id="如何客户端不断的发送请求连接会怎样"><a href="#如何客户端不断的发送请求连接会怎样" class="headerlink" title="如何客户端不断的发送请求连接会怎样"></a>如何客户端不断的发送请求连接会怎样</h1><pre><code>1. 服务器会为每一个请求建立一个链接，然后向Client端发送创建链接时的回复，然后进行等待客户端发送第三次握手数据包，这样会白白浪费资源。2. DDos攻击：    1. 客户端向服务器端发送连接请求数据包    2. 服务器向客户端回复连接请求数据包，然后服务器等待客户端发送TCP/IP链接的第三次数据包    3. 如果客户端不向服务器发送最后一个数据包，则服务器需等待30s-2minutes才能将此连接进行关闭。当大量的请求只进行到第二步，然后不进行第三步，服务器又大量的资源等待第三个数据包，就会造成DDos攻击。3. DDos预防    1. 关闭不必要的服务    2. 限制同时打开的SYN的半连接数目    3. 缩短SYN半连接的Time out时间</code></pre><h1 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h1><pre><code>用户数据报协议（User Datagram Protocal）传输控制协议（Transmission Control Proptocol）1. TCP提供的是面向连接的，可靠的数据流传输，而UDP提供的是非面向连接的（面向报文），不可靠的数据流传输。2. TCP传输单位是TCP报文段，UDP传输单位是用户数据报3. TCP注重数据的安全，UDP数据传输快。4. UDP做不了流量控制</code></pre><h2 id="TCP与UDP常用协议"><a href="#TCP与UDP常用协议" class="headerlink" title="TCP与UDP常用协议"></a>TCP与UDP常用协议</h2><pre><code>（1） FTP：定义了文件传输协议，使用21端口。（2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。（3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。（4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。UDP对应的协议：（1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。（2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。（3） TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。</code></pre><h1 id="从输入网址到获得页面的过程"><a href="#从输入网址到获得页面的过程" class="headerlink" title="从输入网址到获得页面的过程"></a>从输入网址到获得页面的过程</h1><pre><code>1. 查询DNS，获取域名对应的IP地址    1. 浏览器搜索自己的DNS缓存    2. 搜索操作系统的DNS缓存    3. 读取本地的HOST文件（本地ISP域名服务器解析）    4. 发起一个DNS的系统调用（根域名服务器）        1. 宽带运营服务器查看本身缓存        2. 运营商服务器发起一个迭代DNS解析请求2. 浏览器获得域名对应的IP，通过IP地址找到客户端到服务端的路径。客户端发起HTTP会话到IP地址，然后通过TCP进行封装数据包，传输到网络层（三次握手）。3. TCP/IP连接建立起来后，浏览器向服务器发送HTTP请求。4. 服务器接收到这个请求，根据路径参数，经过后端的处理生成HTML代码返回给浏览器5. 浏览器拿到完整的HTML页面代码开始解析和渲染，如果遇到引用的外部JS,CSS，同样的也是一个个HTTP请求，也都是要经过上面的步骤6. 浏览器根据拿到的资源对页面进行渲染，最终得到页面</code></pre><h1 id="在浏览器中输入www-baidu-com后执行的全部过程"><a href="#在浏览器中输入www-baidu-com后执行的全部过程" class="headerlink" title="在浏览器中输入www.baidu.com后执行的全部过程"></a>在浏览器中输入www.baidu.com后执行的全部过程</h1><p><a href="https://blog.csdn.net/qq_16681169/article/details/50866290" target="_blank" rel="noopener">https://blog.csdn.net/qq_16681169/article/details/50866290</a></p><pre><code>从网络模型的角度来分析问题的，主要涉及应用层：DNS,HTTP,传输层：TCP,网络层：IP和路由选择协议：RIP,OSPF(内部网关协议),BGP(外部网关协议）和数据链路层：ARP（地址解析协议，这个协议可以说在数据链路层，也可以说在网络层）。下面来具体分析：1、客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。3、客户端的网络层不用关心应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。</code></pre><h1 id="ARP（地址协议）"><a href="#ARP（地址协议）" class="headerlink" title="ARP（地址协议）"></a>ARP（地址协议）</h1><pre><code>1. 首先，每个主机都会在主机的ARP缓冲区建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。2. 当源主机要发送数据时，首先检查APR列表中是否有对应IP地址的目的主机的MAC地址，如果有，直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，数据包里面有：源主机IP，MAC地址，目的主机IP地址。3. 当本网络的所有主机收到了ARP数据包，首先检查数据包中目的主机IP地址是否时自己的IP地址，如果不是，直接忽略，如果是，首先从数据包中取出源主机的IP和MAC，写入自己的ARP列表，如果存在，就覆盖，然后将自己的MAC地址写入ARP响应包，告诉源主机自己是它想要的MAC地址4. 源主机收到了ARP响应包以后，将目的主机的IP和MAC地址，ARP地址，并利用此信息发送数据。</code></pre><h1 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h1><pre><code>RARP是逆地址协议，从MAC地址到IP地址的映射，主要用于无盘工作站，因为给无盘工作站配置的IP地址不能保存。</code></pre><h1 id="常用的状态码"><a href="#常用的状态码" class="headerlink" title="常用的状态码"></a>常用的状态码</h1><p><a href="https://www.cnblogs.com/jly144000/archive/2017/12/07/7998615.html" target="_blank" rel="noopener">https://www.cnblogs.com/jly144000/archive/2017/12/07/7998615.html</a></p><pre><code>200：服务器成功返回页面400：错误请求，服务器不理解请求的语法404：请求的页面不存在500：服务内部错误503：服务器超时</code></pre><h2 id="临时响应"><a href="#临时响应" class="headerlink" title="临时响应"></a>临时响应</h2><pre><code>1xx（临时响应）    表示临时响应并需要请求者继续执行100（继续）：请求者应当继续提出请求。服务器返回此代码表示已经收到了请求的第一部分，正在等待其余部分101（切换协议）：请求者已经要求服务器切换协议，服务器已经确认，并且准备切换。</code></pre><h2 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h2><pre><code>2xx（成功）    表示成功处理了请求200（成功）：表示服务器已经成功处理了请求。201（已创建）：请求成功并且服务器创建了新的资源202（已接收）：服务器接收了请求，但是尚未处理203（非授权信息）：服务器已经成功处理了请求，但是返回的信息可能来自另一来源204（无内容）：服务器成功处理了请求，但是没有返回任何内容205（重置内容）:服务器成功处理了请求，但是没有返回任何内容。与204响应不同，此响应要求请求者重置文档视图206（部分内容）:服务器成功处理了部分GET请求</code></pre><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><pre><code>3xx（重定向）    要完成请求，需要进一步操作。通常，这些状态码用来重定向。Google 建议您在每次请求中使用重定向不要超过 5 次。您可以使用网站管理员工具查看一下 Googlebot 在抓取重定向网页时是否遇到问题。诊断下的网络抓取页列出了由于重定向错误导致 Googlebot 无法抓取的网址。300(多种选择)：针对请求，服务器可执行多种操作。服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。301(永久移动)：请求的网页已永久移动到新位置。服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。302(临时移动)：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。303(查看其他位置)请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。对于除 HEAD 之外的所有请求，服务器会自动转到其他位置。304(未修改)自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。</code></pre><h2 id="请求错误"><a href="#请求错误" class="headerlink" title="请求错误"></a>请求错误</h2><pre><code>4xx（请求错误）    这些状态码表示请求可能出错，妨碍了服务器的处理。400(错误请求)：服务器不理解请求的语法。401(未授权)：请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。403(禁止)：服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码(您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息)，可能是您的服务器或主机拒绝了 Googlebot 访问。404(未找到)：服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。405(方法禁用)：禁用请求中指定的方法。</code></pre><h2 id="服务器错误"><a href="#服务器错误" class="headerlink" title="服务器错误"></a>服务器错误</h2><pre><code>5xx(服务器错误)    这些状态码表示服务器在处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。500(服务器内部错误)服务器遇到错误，无法完成请求。501(尚未实施)服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。502(错误网关)服务器作为网关或代理，从上游服务器收到无效响应503(服务不可用)服务器目前无法使用(由于超载或停机维护)。通常，这只是暂时状态。504(网关超时)服务器作为网关或代理，但是没有及时从上游服务器收到请求。505(HTTP 版本不受支持)服务器不支持请求中所用的 HTTP 协议版本。</code></pre><h1 id="OSI、TCP-IP、五层协议栈"><a href="#OSI、TCP-IP、五层协议栈" class="headerlink" title="OSI、TCP/IP、五层协议栈"></a>OSI、TCP/IP、五层协议栈</h1><pre><code>OSI（7层）： 物理层，数据链路层，网络层，传输层，会话层，表示层，应用层TCP/IP（4层）：网络接口层，网际层（IP），传输层，应用层五层：物理层，数据链路层，网络层，传输层，应用层</code></pre><h1 id="协议栈常用协议"><a href="#协议栈常用协议" class="headerlink" title="协议栈常用协议"></a>协议栈常用协议</h1><pre><code>物理层：RJ45、CLOCK、IEEE802.3    （中继器，集线器，网关）数据链路：PPP、FR、HDLC、VLAN、MAC  （网桥，交换机）网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）传输层：TCP、UDP、SPX会话层：NFS、SQL、NETBIOS、RPC表示层：JPEG、MPEG、ASII应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS</code></pre><h1 id="协议栈每一层的作用"><a href="#协议栈每一层的作用" class="headerlink" title="协议栈每一层的作用"></a>协议栈每一层的作用</h1><pre><code>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）数据链路层：将比特组装成帧和点到点的传递（帧Frame）网络层：负责数据包从源到宿的传递和网际互连（包PackeT）传输层：提供端到端的可靠报文传递和错误恢复（段Segment）会话层：建立、管理和终止会话（会话协议数据单元SPDU）表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</code></pre><h1 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h1><pre><code>A类地址：以0开头，      第一个字节范围：0~127（1.0.0.0 - 126.255.255.255）；B类地址：以10开头，    第一个字节范围：128~191（128.0.0.0 - 191.255.255.255）；C类地址：以110开头，  第一个字节范围：192~223（192.0.0.0 - 223.255.255.255）；10.0.0.0—10.255.255.255， 172.16.0.0—172.31.255.255， 192.168.0.0—192.168.255.255。（Internet上保留地址用于内部）IP地址与子网掩码相与得到主机号</code></pre><h1 id="传输层协议与网络层协议的区别"><a href="#传输层协议与网络层协议的区别" class="headerlink" title="传输层协议与网络层协议的区别"></a>传输层协议与网络层协议的区别</h1><pre><code>网络层提供的是主机之间的逻辑通信。传输层提供的是进程之间的逻辑通信。</code></pre><h1 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h1><pre><code>利用滑动窗口实现流量控制。流量控制说的就是发送方的发送速率不要太快，让接收方来得及接收。TCP的窗口单元是字节，不是报文段。TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。</code></pre><h1 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h1><pre><code>对资源的需求&gt;可用资源，产生拥塞防止过多的数据注入到网络中，这样可以使用网络中的路由器或者链路不至于过载。拥塞控制所要做的都有一个前提，网络能够承受现有的网络负荷。</code></pre><h1 id="交换机、路由器、网关"><a href="#交换机、路由器、网关" class="headerlink" title="交换机、路由器、网关"></a>交换机、路由器、网关</h1><pre><code>1. 交换机：交换机工作于OSI参考模型的第二层，即数据链路层。交换机内部的CPU会在每个端口成功连接时，通过ARP得到它的MAC地址，保存成一张 ARP表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不 能划分网络层广播，即广播域。2. 路由器：路由器（Router）是一种计算机网络设备，提供了路由与转送两种重要机制，可以决定数据包从来源端到目的端所经过 的路由路径（host到host之间的传输路径），这个过程称为路由；将路由器输入端的数据包移送至适当的路由器输出端(在路由器内部进行)，这称为转 送。路由工作在OSI模型的第三层——即网络层，例如网际协议。路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。 路由器与交换器的差别，路由器是属于OSI第三层的产品，交换器是OSI第二层的产品(这里特指二层交换机)。3. 网关：网关（Gateway），网关顾名思义就是连接两个网络的设备，区别于路由器（由于历史的原因，许多有关TCP/IP 的文献曾经把网络层使用的路由器（Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家 庭中或者小型企业网络中使用，用于连接局域网和Internet。 网关也经常指把一种协议转成另一种协议的设备，比如语音网关。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oxk1vrcj4.bkt.clouddn.com/662703796983558046.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机网络基础复习&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="CN" scheme="http://abelchao.com/categories/CN/"/>
    
    
      <category term="CN" scheme="http://abelchao.com/tags/CN/"/>
    
  </entry>
  
  <entry>
    <title>Spring&amp;SpringMVC&amp;MyBatis基础总结</title>
    <link href="http://abelchao.com/2018/05/02/Spring&amp;SpringMVC&amp;MyBatis%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
    <id>http://abelchao.com/2018/05/02/Spring&amp;SpringMVC&amp;MyBatis基础总结/</id>
    <published>2018-05-02T01:00:00.000Z</published>
    <updated>2018-05-03T09:58:23.431Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oxk1vrcj4.bkt.clouddn.com/223742655302558847.jpg" alt=""></p><p><strong>Spring&amp;SpringMVC&amp;MyBatis基础总结</strong><br><a id="more"></a></p><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><pre><code>http://www.importnew.com/15851.htmlhttp://www.importnew.com/19538.html</code></pre><h2 id="什么是Spring"><a href="#什么是Spring" class="headerlink" title="什么是Spring"></a>什么是Spring</h2><pre><code>Spring是一个Java企业级应用的开源框架。同时它是一个轻量级的框架结构。核心思想有IoC，AOP，DISpring其实就是让模块与模块之前的关系不通过代码来关联，而是利用配置文件类来说明管理。（Spring根据在自己配置文件中引入的JavaBean，通过反射去动态的组装对象）记住！Spring说白了就是一个容器，凡是在容器里的对象才会有Spring提供的服务与功能。</code></pre><h2 id="Spring的核心模块"><a href="#Spring的核心模块" class="headerlink" title="Spring的核心模块"></a>Spring的核心模块</h2><p><img src="http://oxk1vrcj4.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180428105623.png" alt=""></p><h2 id="什么是控制反转（IOC）-依赖注入（DI）"><a href="#什么是控制反转（IOC）-依赖注入（DI）" class="headerlink" title="什么是控制反转（IOC）/依赖注入（DI）"></a>什么是控制反转（IOC）/依赖注入（DI）</h2><p><a href="https://www.cnblogs.com/xdp-gacl/p/4249939.html" target="_blank" rel="noopener">https://www.cnblogs.com/xdp-gacl/p/4249939.html</a></p><p><strong>1. 什么是Ioc</strong></p><pre><code>IoC--Inversion of Control，不是什么技术，是一种设计思想。IoC就意味着将你设计好的对象交给容器本身来控制，而不是传统的在对象内部通过new来控制。谁控制谁？控制什么？为什么叫反转？那什么又是正转？1. 谁控制谁，控制什么：在Java SE中，我们获取对象的时候都是通过在new来创建，也就是在程序中主动的去创建依赖对象（正转），但是IoC是我创建了一个容器（Spring），然后把对象都标识（beanName）都放入整个容器，当我们程序中需要某个对象的时候，通过容器来动态的生成依赖对象。    1. 容器（Spring）控制了对象    2. 控制了对象的产生和外部资源的获取2. 正转就是我们主动在程序中new出来依赖的对象，反转是容器（Spring）利用beanName调用反射创建了对象，并且在创建的对象注入了程序中需要的地方。    1. 容器本身帮我们查找和注入了依赖对象，对象只是被动的接收依赖对象，所以是反转    2. 依赖对象的获取被反转了</code></pre><p><strong>2. IoC能干什么</strong></p><pre><code>传统的应用程序都是我们在类的内部主动的创建依赖对象，从而导致类与类之间高耦合，难于测试。但是有了IoC后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象和对象之前的耦合降低了。其实IoC对编程最大的改变不是从代码上，而是从思想上，发生了&quot;主从换位&quot;的变化。原来应用程序本身是老大，要获取什么资源都需要自己去获取，而IoC/DI中，应用程序就是被动了，被动的等待IoC容器来创建并注入自己需要的资源。</code></pre><p><strong>3. IoC与DI</strong></p><pre><code>DI--Dependency Injection，就是说组件的依赖关系是在容器运行时决定的。谁依赖谁？为什么需要依赖？谁注入谁？注入了什么？1. 应用程序依赖IoC容器2. 因为自己创建不了3. IoC把应用程序依赖的对象注入内部4. 注入的就是某个应用程序需要的外部资源</code></pre><p><strong>4. IoC和DI的关系</strong></p><pre><code>其实是同一个概念的不同描述，IoC感觉更强调容器控制了对象的产生，DI更强调容器把生成对象注入了应用程序（维护对象之间的关系）</code></pre><p><strong>5. 理解</strong></p><pre><code>首先想说说IoC（Inversion of Control，控制反转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。</code></pre><h2 id="依赖注入的方式"><a href="#依赖注入的方式" class="headerlink" title="依赖注入的方式"></a>依赖注入的方式</h2><p><a href="https://blog.csdn.net/u011637069/article/details/51958918" target="_blank" rel="noopener">https://blog.csdn.net/u011637069/article/details/51958918</a></p><pre><code>1. 构造器注入2. Setter方法注入3. 接口注入</code></pre><h2 id="Spring下的IoC核心包"><a href="#Spring下的IoC核心包" class="headerlink" title="Spring下的IoC核心包"></a>Spring下的IoC核心包</h2><pre><code>1. org.springframework.bean2. org.springframework.contextBeanFactory可以理解为还有bean集合的工厂类。BeanFactory中包含了很多bean的定义，以便在接收到客户端请求的时候将对应的bean实例化。ApplicationConext对BeanFactory进行了扩展（继承了，但是两个都是接口），提供了其他的功能。    1. 提供了支持国际化的文本信息    2. 统一了资源文件的读取方式    3. 在监听器中注入了bean事件下面是三个比较常见的ApplicationContext实现方式：    1. ClassPathXmlApplicationContext：从classpath的XML配置文件中读取上下文，并生成了上下文定义。应用程序上下文从程序环境变量中获取。        ApplicationContext context = new ClassPathXmlApplicationContext(“bean.xml”);    2. FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文。        ApplicationContext context = new FileSystemXmlApplicationContext(“bean.xml”);    3. XmlWebApplicationContext：由Web应用的XML文件读取上下文。</code></pre><h2 id="BeanFactory与ApplicationContext的区别"><a href="#BeanFactory与ApplicationContext的区别" class="headerlink" title="BeanFactory与ApplicationContext的区别"></a>BeanFactory与ApplicationContext的区别</h2><pre><code>1. 首先BeanFactory和ApplicationContext都是接口，并且ApplicationContext是BeanFactory的子接口。2. 其实BeanFactory是Spring中最底层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能，而ApplicationContext是Spring的一个高级容器，提供了更多的有用的功能。    1. ApplicationContext继承了BeanFactory接口，所以，ApplicationContext也能像BeanFactory从容器中得到Bean    2. ApplicationContext提供了国际化，消息发送，响应机制，统一加载资源的功能，事件机制，对Web的应用3. BeanFactory采用的是延迟加载的形式来注入Bean，即只有使用到某个Bean的时候，才会对该Bean进行加载实例化。4. ApplicationContext它是在Ioc容器启动的时候就一次性创建了所有的Bean。</code></pre><h2 id="如何使用注解的方式配置Spring"><a href="#如何使用注解的方式配置Spring" class="headerlink" title="如何使用注解的方式配置Spring"></a>如何使用注解的方式配置Spring</h2><pre><code>&lt;beans&gt;    &lt;context:annotation-config/&gt;   &lt;!-- bean definitions go here --&gt;&lt;/beans&gt;在 &lt;context:annotation-config/&gt;标签配置完成以后，就可以用注解的方式在Spring中向属性、方法和构造方法中自动装配变量。1. @Required：该注解应用于设值方法。2. @Autowired：该注解应用于有值设值方法、非设值方法、构造方法和变量。3. @Qualifier：该注解和@Autowired注解搭配使用，用于消除特定bean自动装配的歧义。4. JSR-250 Annotations：Spring支持基于JSR-250 注解的以下注解，@Resource、@PostConstruct 和 @PreDestroy。</code></pre><h2 id="什么是Spring-Bean的生命周期"><a href="#什么是Spring-Bean的生命周期" class="headerlink" title="什么是Spring Bean的生命周期"></a>什么是Spring Bean的生命周期</h2><pre><code>在一个bean实例被初始化的时候，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不再被调用的时候需要进行相关的析构操作，并从bean容器中移除。BeanFactory来完成这个过程。Bean的生命周期由两组回调组成（callback）    1. InitializingBean和DisposableBean回调接口    2. 针对特殊行为的其他Aware接口    3. Bean配置文件中的Custom init()方法和destroy()方法    4. @PostConstruct和@PreDestroy注解方式</code></pre><h2 id="Spring-Bean的作用域之间的区别"><a href="#Spring-Bean的作用域之间的区别" class="headerlink" title="Spring Bean的作用域之间的区别"></a>Spring Bean的作用域之间的区别</h2><pre><code>1. singleton,所有的bean请求，整个IoC容器中就一个Bean实例，单例的模式由BeanFactory自身来维护。2. prototype，和singleton刚好相反，为每一个bean请求都创建一个Bean实例。3. request，会为每一个来自客户端网络请求的Bean请求创建一个实例，请求完成后，Bean会失效，同时被GC4. session，和request类似5. global-session</code></pre><h2 id="Spring框架下的单例Bean是线程安全的么"><a href="#Spring框架下的单例Bean是线程安全的么" class="headerlink" title="Spring框架下的单例Bean是线程安全的么"></a>Spring框架下的单例Bean是线程安全的么</h2><pre><code>1. 不是，Spring框架中的单例Bean不是线程安全的。</code></pre><h2 id="什么是Spring的内部Bean"><a href="#什么是Spring的内部Bean" class="headerlink" title="什么是Spring的内部Bean"></a>什么是Spring的内部Bean</h2><pre><code>当一个Bean仅被用作另一个Bean的属性时，它就能被声明为一个内部Bean，为了定义Inner Bean，在Spring的基于XML的配置元数据中，可以在&lt;property/&gt;或&lt;constructor-arg/&gt;元素内使用&lt;bean/&gt;元素，内部Bean通常时匿名的，它们的Scope一般是Prototype。</code></pre><h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h2><p><a href="https://www.cnblogs.com/wang-meng/p/5701982.html" target="_blank" rel="noopener">https://www.cnblogs.com/wang-meng/p/5701982.html</a></p><pre><code>AOP（Aspect Oriented Programming），是对OOP的补充和完善（Object Oriented Programming，面向对象编程）。我们在OOP中，如果我们有一个方法，很多类都要使用，我们一般会抽象出来一个类（抽象类），去实现这个这些类中都要使用的方法，然后再让这些类去继承这个类。这是纵向的，但是这个样子如果突然某一个的需求变了，就在本类中重写这个方法。AOP说的是横向的（横切），把共用的方法叫做切面（Aspect），所谓切面，简单的说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合。1. 横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点2. 切面（aspect）：类是对物体特征的抽象，切面就是对横切关注点的抽象。3. 连接点（joinpoint）：被拦截的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点，就是被拦截到的方法，实际上连接点还可以是字段或者构造器。4. 切入点（pointcut）：对连接点进行拦截的定义5. 通知（advice）：拦截到连接点之后要执行的代码，通知分为前置，后置，异常，最终，环绕通知五类。6. 目标对象：代理的目标对象。7. 织入（weave）：将切面应用到目标对象并导致代理对象创建的过程。8. 引入（introduction）：在不修改代码的前提下，引入可以在运行期为类动态的添加一些方法或者字段。Spring中AOP的支持：    1. Spring中的AOP代理由Spring的IoC容器负责生成，管理，其依赖关系也由IoC容器负责管理。因此，AOP代理可以直接使用容器中的其他Bean实例来作为目标。这种关系可由IoC容器的依赖注入提供。    2. Spring创建代理的规则：        1. 默认使用Java动态代理来创建AOP处理，这样可以为任何接口实例创建代理了。        2. 当需要代理的类不是代理接口的时候，Spring会切换为使用CGBlib代理。</code></pre><h2 id="Spring基本概念"><a href="#Spring基本概念" class="headerlink" title="Spring基本概念"></a>Spring基本概念</h2><pre><code>IoC叫做控制反转，DI是依赖注入，后者是前者更简单的诠释。控制反转说的是把传统上程序代码直接new对象的调用权交给了容器，通过容器来实现对象组件的装配和关系。所谓的控制反转，也就是对组件对象控制权的转移，从代码本身转移到了外部容器，由容器来创建对象并管理对象之间的依赖关系。DI是说IoC来管理组件的关系，但是组件的关系是在容器运行期来决定的，也就是容器动态的把某种依赖的关系注入了组件中国，1. Spring AOP实现管理    1. 动态代理（利用反射和动态编译将代码模式编程动态的）    2. JDK的动态代理：JDKProxy返回动态代理类，是目标类所实现接口的另一个实现版本，它实现了对目标类的代理    3. CGLib动态代理：CGLibProxy返回的动态代理类，则是是目标代理类的一个子类2. 动态代理和CGLib实现的区别    1. JDK动态代理只能针对实现了接口的类生成代理，而不能针对类。    2. CGLib是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法因为是继承。    3. JDK代理不需要第三方的库    4. CGLib必须依赖CGLib的库</code></pre><h2 id="Spring的两种代理"><a href="#Spring的两种代理" class="headerlink" title="Spring的两种代理"></a>Spring的两种代理</h2><pre><code>当一个对象不能或者不想直接引用另一个对象（目标对象）时，可以在这之间弄一个桥梁--代理对象：    1. 静态代理：程序员事先写好代理对象类，在程序发布就已经存在了。    2. 动态代理：应用程序发布后，通过动态创建代理对象。</code></pre><p><strong>JDK动态代理</strong></p><pre><code>利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</code></pre><p><strong>CGLib动态代理</strong></p><pre><code>利用ASM开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。1. 如果目标对象实现了接口，默认使用JDK，也可以强制只用CGLib2. 没有实现接口，必须采用CGLib。</code></pre><h2 id="Spring和工厂模式的区别"><a href="#Spring和工厂模式的区别" class="headerlink" title="Spring和工厂模式的区别"></a>Spring和工厂模式的区别</h2><pre><code>当需求改变的时候，工厂模式需要进行相应的变化。但是IoC的反射机制允许我们不重新编译代码，因为它的对象都是动态生成。在工厂中修改就得重新编译工厂类啊，你那机子上还得装着JDK。在XML中修改只要一个Text编辑器就搞定了。重新编译以后你要用新编译的类，得先停了JVM再重新启动，热插拔就是说你把XML改了spring就立刻发觉你改动了XML，重新读一遍XML，就会用你的新改动了，根本不用重新启动JVM。</code></pre><h2 id="IoC容器的加载过程"><a href="#IoC容器的加载过程" class="headerlink" title="IoC容器的加载过程"></a>IoC容器的加载过程</h2><pre><code>1. 创建IoC配置文件的抽象资源2. 创建BeanFactory3. 把读取配置信息的BeanDefinitionReader，这里是XmlBeanDefinitionReader配置给BeanFactory4. 从定义好的资源位置读取配置信息，具体解析由XmlBeanDefinitionReader来完成。</code></pre><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="http://oxk1vrcj4.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180502114112.png" alt=""></p><pre><code>1. 用户发送请求到前端控制器DispatcherServlet2. DispatcherServlet收到请求后调用HandlerMapping（处理器映射器）3. 处理器映射器找到具体的处理器，生成处理器对象和处理器拦截器（如果有的话），并将两者返回给DispatcherServlet4. DispatcherServlet调用HandlerAdapter处理器适配器5. HandlerAdapter经过适配调用具体的后端控制器（Controller）6. Controller执行完成返回ModelAndView7. HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet8. DispatcherServlet将ModelAndView传给ViewResolver视图解析器9. ViewResolver解析后返回具体的Veiw10. DisPatcherServlet根据View进行渲染视图（即将模型数据填充到视图中）11. DispatcherServlet响应用户。</code></pre><h2 id="SpringMVC与Struts2的区别"><a href="#SpringMVC与Struts2的区别" class="headerlink" title="SpringMVC与Struts2的区别"></a>SpringMVC与Struts2的区别</h2><pre><code>1. SpringMVC的入口是一个Servlet（DispatcherServlet），而Struts2入口是一个Filter2. SpringMVC是基于方法开发，传递参数通过方法形参（可以单例），Strust2是基于类开发，参数传递通过类的属性，只能设计为多例。3. Struts采用值栈存储请求和响应的数据，通过OGNL和JSTL来获取数据，SpringMVC是通过参数解析器将request对象内容进行解析成方法形参，响应数据与页面封装成ModelAndView对象，最后又通过模型数据通过request对象传输到页面。</code></pre><h2 id="SpringMVC的控制器是不是单例"><a href="#SpringMVC的控制器是不是单例" class="headerlink" title="SpringMVC的控制器是不是单例"></a>SpringMVC的控制器是不是单例</h2><pre><code>单例，所以多线程访问的时候又线程安全问题，但是不能加锁，会影响性能，解决方案是在控制器中不能写字段。</code></pre><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><pre><code>1. @Controller：表现层，控制器2. @RequestMapping：在类上表示这个类中所有响应请求方法都以这个地址为父路径，在方法上，就是方法特定的。3. SpringMVC通过@ResponseBody与AJAX进行交互。</code></pre><h1 id="Mybatis与Hibernate"><a href="#Mybatis与Hibernate" class="headerlink" title="Mybatis与Hibernate"></a>Mybatis与Hibernate</h1><h2 id="与"><a href="#与" class="headerlink" title="${}与#{}"></a>${}与#{}</h2><pre><code>1. ${},是从.properties中获取静态值，比如${driver}会被换成com.mysql.jdbc.Driver2. #{},是sql的参数占位符，MyBatis会将sql中的#{}替换成？，在SQL执行前会使用PreparedStatement的参数设置方法，按序号给？占位符设置参数。比如#{item.name}，会成为param.getItem().getName()。</code></pre><h2 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h2><pre><code>resultMap、parameterMap、sql、include</code></pre><h2 id="Dao层接口与Mappring-xml如何映射"><a href="#Dao层接口与Mappring-xml如何映射" class="headerlink" title="Dao层接口与Mappring.xml如何映射"></a>Dao层接口与Mappring.xml如何映射</h2><pre><code>Dao接口中的方法，是不能重载的，因为全限定名+方法名的保存和寻找策略。全限定名+方法名拼接字符串成为一个Key,唯一定位一个MappingStstement。Dao接口的工作原理就是JDK动态代理，MyBatis运行时会使用JDK动态代理为Dao接口生成代理对象，代理对象会拦截接口方法，转而执行MappingStstement所代表的SQL，然后将SQL执行结果返回。</code></pre><h2 id="MyBatis的分页插件（PageHelper）"><a href="#MyBatis的分页插件（PageHelper）" class="headerlink" title="MyBatis的分页插件（PageHelper）"></a>MyBatis的分页插件（PageHelper）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xd.cop.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageHelper;</span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageInfo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"><span class="keyword">import</span> xd.cop.common.ServerResponse;</span><br><span class="line"><span class="keyword">import</span> xd.cop.dao.ItemMapper;</span><br><span class="line"><span class="keyword">import</span> xd.cop.pojo.Item;</span><br><span class="line"><span class="keyword">import</span> xd.cop.service.inter.IItemService;</span><br><span class="line"><span class="keyword">import</span> xd.cop.util.DateTimeUtil;</span><br><span class="line"><span class="keyword">import</span> xd.cop.vo.ItemVo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Blemon on 2018/4/18.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"iItemService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemServiceImpl</span> <span class="keyword">implements</span> <span class="title">IItemService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ItemMapper itemMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerResponse&lt;PageInfo&gt; <span class="title">getAllItemByPage</span><span class="params">(<span class="keyword">int</span> pageNum, <span class="keyword">int</span> pageSize)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.startPage--start</span></span><br><span class="line">        PageHelper.startPage(pageNum,pageSize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.填充自己的sql查询逻辑</span></span><br><span class="line">        List&lt;Item&gt; itemList = itemMapper.selectList();</span><br><span class="line">        List&lt;ItemVo&gt; itemVoList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Item item : itemList)&#123;</span><br><span class="line">            ItemVo itemVo = assembleItemVo(item);</span><br><span class="line">            itemVoList.add(itemVo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.pageHelper收尾</span></span><br><span class="line">        PageInfo pageResult = <span class="keyword">new</span> PageInfo(itemList);<span class="comment">//确定个数</span></span><br><span class="line">        pageResult.setList(itemVoList);<span class="comment">//确定集合</span></span><br><span class="line">        <span class="keyword">return</span> ServerResponse.createBySuccess(pageResult);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ItemVo <span class="title">assembleItemVo</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">        ItemVo itemVo = <span class="keyword">new</span> ItemVo();</span><br><span class="line">        itemVo.setId(item.getId());</span><br><span class="line">        itemVo.setSecn(item.getSecn());</span><br><span class="line">        itemVo.setAbnc(item.getAbnc());</span><br><span class="line">        itemVo.setHum(item.getHum());</span><br><span class="line">        itemVo.setLat(item.getLat());</span><br><span class="line">        itemVo.setPre(item.getPre());</span><br><span class="line">        itemVo.setLon(item.getLon());</span><br><span class="line">        itemVo.setVib(item.getVib());</span><br><span class="line">        itemVo.setTem(item.getTem());</span><br><span class="line"></span><br><span class="line">        itemVo.setCreatetime(DateTimeUtil.dateToStrByStandard(item.getCreatetime()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> itemVo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MyBatis与Hibernate的区别"><a href="#MyBatis与Hibernate的区别" class="headerlink" title="MyBatis与Hibernate的区别"></a>MyBatis与Hibernate的区别</h2><pre><code>1. 两个都通过SessionFactoryBuilder由XML配置文件生成的SessionFactory，然后由SessionFactory生成的Session，最后由Session来开始执行事务和SQL语句。2. Hibernate是全自动的，MyBatis是半自动的。3. SQL直接优化，Hibernate不如MyBatis4. 缓存机制上，Hibernate比较好5. Hibernate的HQL语言，大大降低了对于与数据库的耦合性，而MyBatis由于需要手写SQL，因此与数据库的耦合性直接取决于程序员写SQL的方法，如果SQL不具有通用性而使用了某些数据库特性的SQL语句，移植性比较差。</code></pre><h2 id="Hibernate如何提高性能"><a href="#Hibernate如何提高性能" class="headerlink" title="Hibernate如何提高性能"></a>Hibernate如何提高性能</h2><pre><code>1. 延迟加载2. 缓存技术3. 优化SQL查询</code></pre><h2 id="Hibernate的二级缓存"><a href="#Hibernate的二级缓存" class="headerlink" title="Hibernate的二级缓存"></a>Hibernate的二级缓存</h2><pre><code>缓存的目的就是为了减少程序对物理数据源的访问，把从数据库中查询出来和使用过的对象保存在内存中，以便在后期需要用这个对象时，直接从缓存中获取（只有当缓存不存在的时候，才会从数据库中查询）。一级缓存，由Session来管理。二级缓存，由SessionFactory管理。二级缓存可有可无，但是一级缓存必不可少。一级缓存，使用Session查询时，首先在Session中找，没有才去数据库，并且把查到的数据缓存起来。但是Session线程不安全，生命周期没有SessionFactory长，效率不高。二级缓存，是独立于Hibernate的软件部件，属于第三方产品。属于全局缓存，先去Session找，再去SessionFactory，再去数据库。</code></pre><h2 id="Hibernate对象状态"><a href="#Hibernate对象状态" class="headerlink" title="Hibernate对象状态"></a>Hibernate对象状态</h2><p><img src="http://oxk1vrcj4.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180502153127.png" alt=""></p><pre><code>瞬时态，持久态，脱管态临时态：刚刚使用new语句创建，没有被持久化，不处于Session缓存中。处于临时状态的Java对象被称为临时对象。持久态：已经被持久化，加入到Session缓存中。游离态：已经被持久化，但不处于Session的缓存中。</code></pre><h2 id="Hibernate中的get与load"><a href="#Hibernate中的get与load" class="headerlink" title="Hibernate中的get与load"></a>Hibernate中的get与load</h2><pre><code>1. 如果在数据库中不存在该对象，load方法会抛出一个ObjectNotFoundException，get方法返回null2. get方法先在Session中找，在去SessionFactory，再去数据库。load先在Session中找，不存在，就创建代理对象，实际使用数据的时候，才查询二级缓存和数据库。load方法延迟加载。3. get方法返回的都是实体类，load方法返回的都是实体类的代理类实例。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oxk1vrcj4.bkt.clouddn.com/223742655302558847.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring&amp;amp;SpringMVC&amp;amp;MyBatis基础总结&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="SSM" scheme="http://abelchao.com/categories/SSM/"/>
    
    
      <category term="SSM" scheme="http://abelchao.com/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>Servlet与JSP基础总结</title>
    <link href="http://abelchao.com/2018/05/01/Sevlet&amp;JSP%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
    <id>http://abelchao.com/2018/05/01/Sevlet&amp;JSP基础总结/</id>
    <published>2018-05-01T01:00:00.000Z</published>
    <updated>2018-05-21T02:56:42.623Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oxk1vrcj4.bkt.clouddn.com/527250571103345529.jpg" alt=""></p><p><strong>Servlet与JSP基础总结</strong><br><a id="more"></a></p><h1 id="什么是Servlet"><a href="#什么是Servlet" class="headerlink" title="什么是Servlet"></a>什么是Servlet</h1><p><img src="http://oxk1vrcj4.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180427154143.png" alt=""></p><pre><code>1. 其实这就是个接口，里面就5个方法。但是我们约定俗成把实现了这个接口的类也叫做了Servlet2. 这个接口本身和网络协议，Http什么根本没关系，这东西就是为了规范一套处理网络请求，所有实现了Servlet的类都要实现它的那5个方法，最重要的就三个init/destory/service，也就是所有实现了这个接口的类，都必须回答三个问题:    1. 初始化要干嘛    2. 销毁要干嘛    3. 接收到请求又要干嘛3. Servlet就是一个规范，但是并不是实现了Servlet的类都能处理请求。这里面绝对不会又什么监听8080端口的东西之类的，因为Servlet根本就不是直接和客户端打交道的。那么请求怎么到这个类里面的，就是我们说的Servlet容器，也就是Tomcat，我们的Servlet实现类永远都是在容器中才能起作用的。Tomcat才是真正和客户端直接打交道的东西，它监听了端口，情趣过来，由Tomcat也确定这个请求要给哪个Servlet去处理。然后调用这个Servlet的service方法。service方法返回一个response，tomcat再把这个response返回客户端。</code></pre><h1 id="Servlet与CGI的区别"><a href="#Servlet与CGI的区别" class="headerlink" title="Servlet与CGI的区别"></a>Servlet与CGI的区别</h1><pre><code>CGI（Common GateWay Interface 公共网管接口）是用Perl脚本编写的程序，可以用来生成动态页面。1. Servlet在服务器进程中，多线程的方式运行service()，一个实例可以服务多个请求。并且实例一般不会销毁。2. CGI对每个请求都产生新的进程。服务完就销毁了。</code></pre><h1 id="Servlet生命周期和工作原理"><a href="#Servlet生命周期和工作原理" class="headerlink" title="Servlet生命周期和工作原理"></a>Servlet生命周期和工作原理</h1><p><img src="http://oxk1vrcj4.bkt.clouddn.com/24114945-4774512d1247438fa58c37399d3999ae.jpg" alt=""></p><pre><code>1. 加载：Tomcat通过类加载器使用Servlet类对应的文件来加载Servlet。2. 创建：调用Servlet的构造器生成一个Servlet实例。3. init()：在Servlet的生命周期中，仅执行一次，在Tomcat装入Servlet时执行的，这个方法在Servlet创建但是向客户端提供请求前被调用。4. service()：Tomcat接收到请求，发现这是对Servlet发起的请求，Tomcat这个时候会创建两个对象HttpServletRequest，HttpServletResponse。容器根据请求的URL找到对应的Servlet，然后针对这个请求创建一个线程，同时把之前创建的两个对象以参数的像是传递给这个线程。然后容器调用这个Servlet的service()，service()方法根据请求的method属性值来确定调用doGet还是doPost，然后把生成响应数据（动态页面）返回给容器，容器把响应消息组装成HTTP格式返回给客户端。5. destory：容器在卸载Servlet之前调用destory，让servlet释放了自己占用的系统资源。</code></pre><h1 id="Get和Post的区别"><a href="#Get和Post的区别" class="headerlink" title="Get和Post的区别"></a>Get和Post的区别</h1><pre><code>1. get不安全，同时页面提交数据时，get的数据大小由限制4k。2. post安全，同时没有数据大小限制。</code></pre><h1 id="JSP与Servlet的区别"><a href="#JSP与Servlet的区别" class="headerlink" title="JSP与Servlet的区别"></a>JSP与Servlet的区别</h1><pre><code>1. JSP可以被看作是一个特殊的Servlet，只不过是Servlet的扩展，只要是JSP能实现的，Servlet也都可以实现。因为JSP页面最后还是要被转换成Servlet来运行，因此处理请求实际上是编译后的Servlet。2. Servlet的实现方式是在Java中嵌入了HTML，JSP是在HTML中嵌入了Java3. Servlet中可没有内置对象，JSP里面有9个，但是都是通过HttpServletRequest，HttpServletResponse，HttpServlet对象得到的。</code></pre><h1 id="Servlet、Genericervlet、HttpServlet"><a href="#Servlet、Genericervlet、HttpServlet" class="headerlink" title="Servlet、Genericervlet、HttpServlet"></a>Servlet、Genericervlet、HttpServlet</h1><p><img src="http://oxk1vrcj4.bkt.clouddn.com/20161217184327553.png" alt=""></p><p><a href="https://www.cnblogs.com/libingbin/p/5960456.html" target="_blank" rel="noopener">https://www.cnblogs.com/libingbin/p/5960456.html</a></p><pre><code>1. Servlet是个接口，2. GenericServlet是个抽象类，实现了Servlet和ServletConfig，这个Servlet是个和协议没有半毛钱关系的Servlet。3. HttpServletRequest和HttpServletResponse是两个接口4. HttpServlet继承了GenericServlet，但是这也是个抽象类。5. GenericServlet做的事情：    1. init方法，保存了config对象，并实现了getServletInfo和getServletConfig。    2. 增加了一个空参数的init()，防止开发人员重写重生的init    3. service方法空实现--&gt;写成了抽象方法，强制开发人员实现。    4. destory空实现。    5. 实现了servletConfig接口，接口中的方法直接调用config实现类实现。6. HttpServlet做的事情：    1. servlet中强转参数        ServletRequest和ServletResponse--&gt;HttpServletRequest和HttpServletResponse。    2. 根据不同请求调用不同的方法。</code></pre><h1 id="Servlet、ServletContext、ServletConfig"><a href="#Servlet、ServletContext、ServletConfig" class="headerlink" title="Servlet、ServletContext、ServletConfig"></a>Servlet、ServletContext、ServletConfig</h1><p><a href="https://blog.csdn.net/u012077981/article/details/17137705" target="_blank" rel="noopener">https://blog.csdn.net/u012077981/article/details/17137705</a><br><a href="https://blog.csdn.net/gavin_john/article/details/51399425" target="_blank" rel="noopener">https://blog.csdn.net/gavin_john/article/details/51399425</a></p><pre><code>1. ServletContext是Servlet和Servlet容器（Tomcat）之间的直接通信接口。Servlet容器在启动一个Webapp时，会为它创建一个ServletContext，也就是Servlet上下文环境。每一个webapp都有唯一的ServletContext对象。同一个webapp下的所有servlet对象共享一个ServletContext。servlet的初始化参数，就是在这个ServletContext中。    1. 获取web上下文路径（context.getContextPath()）    2. 获取全局参数(context.getInitParameter(paramName))    3. 和域相关    2. ServletConfig是当Servlet容器（Tomcat）初始化一个Servlet类型的对象时，会为这个Servlet对象创建一个ServletConfig对象。在这个ServletConfig对象中包含了Servlet的初始化参数信息。3. ServeltConfig和ServletContext关联。Tomcat在调用Servlet对象的init(ServletConfig config)方法时，会把ServletConfig类型的对象当作参数传递给servlet对象。4. ServletContext是对于Webapp而言的，其实就是四大域中的Application，在Tomcat启动的时候就加载了。而ServletConfig是对于某一个Servlet而言的。</code></pre><h1 id="forward和redirect"><a href="#forward和redirect" class="headerlink" title="forward和redirect"></a>forward和redirect</h1><pre><code>1. forward：请求转发，服务器端行为，然后目标地址的URL，但是服务器内部转发了。（只有一次请求）2. redirect：重定向,客户端行为，目的地址的URL改变了，两次请求！！！3. 重定向会导致request对象信息丢失，而请求转发不会。</code></pre><h1 id="JSP执行原理"><a href="#JSP执行原理" class="headerlink" title="JSP执行原理"></a>JSP执行原理</h1><pre><code>客户端发出请求---&gt;JSP引擎将jsp页面翻译成Servlet的java源文件--&gt;Tomcat中将源文件编程成class并加载到内存中执行。</code></pre><h1 id="JavaWeb四大域"><a href="#JavaWeb四大域" class="headerlink" title="JavaWeb四大域"></a>JavaWeb四大域</h1><h2 id="Application-ServletContext"><a href="#Application-ServletContext" class="headerlink" title="Application(ServletContext)"></a>Application(ServletContext)</h2><pre><code>1. 作用域：整个Webapp，所有Servlet共用一个serveltContext。2. 生命周期：当Web应用被加载到Tomcat中时就创建了。</code></pre><h2 id="Session（HttpSession）"><a href="#Session（HttpSession）" class="headerlink" title="Session（HttpSession）"></a>Session（HttpSession）</h2><pre><code>1. 作用域：一次会话。2. 生命周期：当第一次调用request.getSession()的时候，服务器会检查是否已经有了对应的Session，如果没有就在内存中创建一个Session并返回。但是当一段时间以后，Session没有被使用（默认30min），Session就会被销毁了。如果服务器非正常关闭，没有到期的session也会跟着销毁。如果调用session提供的invalidate()，可以立即销毁session。</code></pre><h2 id="Request（ServletRequest）"><a href="#Request（ServletRequest）" class="headerlink" title="Request（ServletRequest）"></a>Request（ServletRequest）</h2><pre><code>1. 作用域：整个请求链，在Servlet处理好的数据给JSP显示，整个时候参数就可以放在ServletRequest域中2. 生命周期：整个请求链</code></pre><h2 id="Page（PageContext）"><a href="#Page（PageContext）" class="headerlink" title="Page（PageContext）"></a>Page（PageContext）</h2><pre><code>1. 作用域：当对JSP请求开始，当响应的结束时销毁。2. 作用范围：整个JSP页面，是四大域中最小的一个。</code></pre><h1 id="HttpServletRequest和HttpServletResponse"><a href="#HttpServletRequest和HttpServletResponse" class="headerlink" title="HttpServletRequest和HttpServletResponse"></a>HttpServletRequest和HttpServletResponse</h1><pre><code>1. HttpServletRequest    1. 请求地址(读取信息路径)    2. 请求头    3. 实体数据2. HttpServletResponse    1. 响应头    2. 状态码    3. 实体数据    4. 客户端写入Cookie（设置Cookie）    5. 重写URL</code></pre><h2 id="HttpServletRequest中的getParamter-Attribute"><a href="#HttpServletRequest中的getParamter-Attribute" class="headerlink" title="HttpServletRequest中的getParamter/Attribute"></a>HttpServletRequest中的getParamter/Attribute</h2><pre><code>1. getAttribute表示从Request域中获取数据，必须在request域中进行设置（setAttribute）后才能拿到，设置和获取的都是Object2. getParameter表示接收参数，参数为页面提交的参数（表单提交的参数，URL重写）因此整个方法并没有参数设置（没有setParameter），而且返回的参数String</code></pre><h1 id="JSP中的九大内置对象"><a href="#JSP中的九大内置对象" class="headerlink" title="JSP中的九大内置对象"></a>JSP中的九大内置对象</h1><p><a href="https://blog.csdn.net/icarus_wang/article/details/51107470" target="_blank" rel="noopener">https://blog.csdn.net/icarus_wang/article/details/51107470</a></p><pre><code>out对象：用于向客户端、浏览器输出数据。request对象：封装了来自客户端、浏览器的各种信息。response对象：封装了服务器的响应信息。exception对象：封装了jsp程序执行过程中发生的异常和错误信息。config对象：封装了应用程序的配置信息。page对象：指向了当前jsp程序本身。session对象：用来保存会话信息。也就是说，可以实现在同一用户的不同请求之间共享数application对象：代表了当前应用程序的上下文。可以在不同的用户之间共享信息。pageContext对象：提供了对jsp页面所有对象以及命名空间的访问。</code></pre><h1 id="JSP动作（6个）"><a href="#JSP动作（6个）" class="headerlink" title="JSP动作（6个）"></a>JSP动作（6个）</h1><pre><code>1. jsp：include，用来在页面被请求时引入一个文件。2. jsp：useBean，用来寻找或者实例化一个JavaBean3. jsp：setProperty，用来设置已经实例化的Bean对象。4. jsp：getProperty，用来获取某个JavaBean的属性。5. jsp：forward，用来把请求转到一个新页面6. jsp:plugin，用来在浏览器中显示一个对象。</code></pre><h1 id="include的静态，动态引入（include指令和include动作）"><a href="#include的静态，动态引入（include指令和include动作）" class="headerlink" title="include的静态，动态引入（include指令和include动作）"></a>include的静态，动态引入（include指令和include动作）</h1><pre><code>1. include指令：&lt;%@ include file=&quot;text.jsp&quot;%&gt;2. include动作：    &lt;jsp:include page=&quot;text.jsp&quot; flush=&quot;true&quot;&gt;        &lt;jsp:param name=&quot;name&quot;,value=&quot;value&quot;/&gt;    &lt;/jsp:include&gt;区别：    1. 根本区别：两者调用的时间。include指令是在编译阶段的指令，在编译时，编译器会把指令所指向的目标文件内容复制到指令所在的位置，替换指令本身，最终生成的一个文件，在运行时只有一个文件；include动作是在运行时的语法，在主页面被请求时，才将用到的页面包含进来，涉及到两个文件，类似于方法调用。</code></pre><h1 id="Session与Cookie"><a href="#Session与Cookie" class="headerlink" title="Session与Cookie"></a>Session与Cookie</h1><pre><code>1. Session在服务器端，Cookie在客户端2. Session的运行依赖Session id，而Session id是存在Cookie中的，也就说如果浏览器禁用了Cookie，同时Session也就无效了。3. Session可以放在文件，数据库，内存中4. 用户验证一般使用Session5. Cookie不安全，因为在本地，可能被被人用来进行Cookie欺骗6. Session会在一定时间内保存在服务器上，当访问太多的时候，并不好7. 单个Cookie保存的数据不能超过4k，很多浏览器都限制一个站点最多保存20个Cookie</code></pre><h1 id="保存会话状态，有哪些方法"><a href="#保存会话状态，有哪些方法" class="headerlink" title="保存会话状态，有哪些方法"></a>保存会话状态，有哪些方法</h1><pre><code>HTTP协议本身无状态，服务器为了区别不同的用户，需要对用户会话进行跟踪，也就说用户登录的时候，为用户分配唯一的ID，下一次用户在请求中包含此ID，服务器就知道这是哪个用户了。1. URL重写：在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。2. 设置表单隐藏域：将会话跟踪相关的字段添加到隐式表单域中。3. Session共享：Session的运行依赖Session id，而Session id是存在Cookie中的，也就说如果浏览器禁用了Cookie，同时Session也就无效了。4. 会话Cookie：Cookie是Web服务器发送给客户端的一小段信息，客户端请求时可以读取该信息发送到服务器端，进而进行用户的识别。对于客户端的每次请求，服务器都会将Cookie发送到客户端,在客户端可以进行保存,以便下次使用</code></pre><h1 id="监听器，过滤器，拦截器"><a href="#监听器，过滤器，拦截器" class="headerlink" title="监听器，过滤器，拦截器"></a>监听器，过滤器，拦截器</h1><h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><pre><code>1. contextInitialized2. contextDestroyed事件源：ServletContext，HttpSession，ServletRequest</code></pre><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p><a href="http://www.cnblogs.com/xdp-gacl/p/3948353.html" target="_blank" rel="noopener">http://www.cnblogs.com/xdp-gacl/p/3948353.html</a></p><p><a href="http://www.runoob.com/jsp/jsp-writing-filters.html" target="_blank" rel="noopener">http://www.runoob.com/jsp/jsp-writing-filters.html</a></p><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p><a href="https://www.cnblogs.com/shangxiaofei/p/5328377.html" target="_blank" rel="noopener">https://www.cnblogs.com/shangxiaofei/p/5328377.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oxk1vrcj4.bkt.clouddn.com/527250571103345529.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Servlet与JSP基础总结&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="http://abelchao.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://abelchao.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>桥接模式</title>
    <link href="http://abelchao.com/2018/04/25/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://abelchao.com/2018/04/25/桥接模式/</id>
    <published>2018-04-25T10:00:00.000Z</published>
    <updated>2018-04-25T10:00:15.940Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oxk1vrcj4.bkt.clouddn.com/762846253515335835.jpg" alt=""></p><p><strong>桥接模式</strong></p><a id="more"></a><h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><p><img src="http://oxk1vrcj4.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180425170555.png" alt=""></p><pre><code>桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</code></pre><h2 id="创建桥接实现接口"><a href="#创建桥接实现接口" class="headerlink" title="创建桥接实现接口"></a>创建桥接实现接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建实现了-DrawAPI-接口的实体桥接实现类"><a href="#创建实现了-DrawAPI-接口的实体桥接实现类" class="headerlink" title="创建实现了 DrawAPI 接口的实体桥接实现类"></a>创建实现了 DrawAPI 接口的实体桥接实现类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedCircle</span> <span class="keyword">implements</span> <span class="title">DrawAPI</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Drawing Circle[ color: red, radius: "</span></span><br><span class="line">         + radius +<span class="string">", x: "</span> +x+<span class="string">", "</span>+ y +<span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenCircle</span> <span class="keyword">implements</span> <span class="title">DrawAPI</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Drawing Circle[ color: green, radius: "</span></span><br><span class="line">         + radius +<span class="string">", x: "</span> +x+<span class="string">", "</span>+ y +<span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-DrawAPI-接口创建抽象类-Shape"><a href="#使用-DrawAPI-接口创建抽象类-Shape" class="headerlink" title="使用 DrawAPI 接口创建抽象类 Shape"></a>使用 DrawAPI 接口创建抽象类 Shape</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span> DrawAPI drawAPI;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Shape</span><span class="params">(DrawAPI drawAPI)</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.drawAPI = drawAPI;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建实现了-Shape-接口的实体类"><a href="#创建实现了-Shape-接口的实体类" class="headerlink" title="创建实现了 Shape 接口的实体类"></a>创建实现了 Shape 接口的实体类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x, y, radius;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Circle</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> radius,DrawAPI drawAPI)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(drawAPI);</span><br><span class="line"><span class="keyword">this</span>.x = x;  </span><br><span class="line"><span class="keyword">this</span>.y = y;  </span><br><span class="line"><span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">drawAPI.drawCircle(radius,x,y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-Shape-和-DrawAPI-类画出不同颜色的圆"><a href="#使用-Shape-和-DrawAPI-类画出不同颜色的圆" class="headerlink" title="使用 Shape 和 DrawAPI 类画出不同颜色的圆"></a>使用 Shape 和 DrawAPI 类画出不同颜色的圆</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgePatternDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Shape redCircle = <span class="keyword">new</span> Circle(<span class="number">100</span>,<span class="number">100</span>, <span class="number">10</span>, <span class="keyword">new</span> RedCircle());</span><br><span class="line">      Shape greenCircle = <span class="keyword">new</span> Circle(<span class="number">100</span>,<span class="number">100</span>, <span class="number">10</span>, <span class="keyword">new</span> GreenCircle());</span><br><span class="line"></span><br><span class="line">      redCircle.draw();</span><br><span class="line">      greenCircle.draw();</span><br><span class="line">&#125;</span><br><span class="line">&#125;s</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oxk1vrcj4.bkt.clouddn.com/762846253515335835.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;桥接模式&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://abelchao.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://abelchao.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>适配器模式</title>
    <link href="http://abelchao.com/2018/04/25/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://abelchao.com/2018/04/25/适配器模式/</id>
    <published>2018-04-25T09:00:00.000Z</published>
    <updated>2018-04-25T10:00:01.904Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oxk1vrcj4.bkt.clouddn.com/39807078769124751.jpg" alt=""></p><p><strong>适配器模式</strong></p><a id="more"></a><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p><img src="http://oxk1vrcj4.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180425162504.png" alt=""></p><pre><code>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</code></pre><h2 id="为媒体播放器和更高级的媒体播放器创建接口"><a href="#为媒体播放器和更高级的媒体播放器创建接口" class="headerlink" title="为媒体播放器和更高级的媒体播放器创建接口"></a>为媒体播放器和更高级的媒体播放器创建接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MediaPlayer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType,String filename)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdvancedMediaPlayer</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建实现了-AdvancedMediaPlayer-接口的实体类"><a href="#创建实现了-AdvancedMediaPlayer-接口的实体类" class="headerlink" title="创建实现了 AdvancedMediaPlayer 接口的实体类"></a>创建实现了 AdvancedMediaPlayer 接口的实体类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VlcPlayer</span> <span class="keyword">implements</span> <span class="title">AdvancedMediaPlayer</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Playing vlc file. Name: "</span>+ fileName);        </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//什么也不做</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mp4Player</span> <span class="keyword">implements</span> <span class="title">AdvancedMediaPlayer</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playVlc</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//什么也不做</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playMp4</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Playing mp4 file. Name: "</span>+ fileName);        </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建实现了-MediaPlayer-接口的适配器类"><a href="#创建实现了-MediaPlayer-接口的适配器类" class="headerlink" title="创建实现了 MediaPlayer 接口的适配器类"></a>创建实现了 MediaPlayer 接口的适配器类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaAdapter</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span></span>&#123;</span><br><span class="line">AdvancedMediaPlayer advancedMediaPlayer;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MediaAdapter</span><span class="params">(String audioType)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"vlc"</span>))</span><br><span class="line">advancedMediaPlayer = <span class="keyword">new</span> VlcPlayer();</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">advancedMediaPlayer = <span class="keyword">new</span> Mp4Player();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType, String filename)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"vlc"</span>))</span><br><span class="line">advancedMediaPlayer.playVlc(filename);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">advancedMediaPlayer.playMp4(filename);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建实现了-MediaPlayer-接口的实体类"><a href="#创建实现了-MediaPlayer-接口的实体类" class="headerlink" title="创建实现了 MediaPlayer 接口的实体类"></a>创建实现了 MediaPlayer 接口的实体类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioPlayer</span> <span class="keyword">implements</span> <span class="title">MediaPlayer</span></span>&#123;</span><br><span class="line">MediaAdapter mediaAdapter;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">(String audioType,String filename)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(audioType.equalsIgnoreCase(<span class="string">"mp3"</span>))</span><br><span class="line">System.out.println(<span class="string">"Playing mp3 file. Name: "</span>+filename);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(audioType.equals(<span class="string">"mp4"</span>)||audioType.equals(<span class="string">"vlc"</span>))</span><br><span class="line"><span class="keyword">new</span> MediaAdapter(audioType).play(audioType, filename);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">System.out.println(<span class="string">"Invalid media. "</span>+audioType + <span class="string">" format not supported"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-AudioPlayer-来播放不同类型的音频格式"><a href="#使用-AudioPlayer-来播放不同类型的音频格式" class="headerlink" title="使用 AudioPlayer 来播放不同类型的音频格式"></a>使用 AudioPlayer 来播放不同类型的音频格式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPatternDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      AudioPlayer audioPlayer = <span class="keyword">new</span> AudioPlayer();</span><br><span class="line"></span><br><span class="line">      audioPlayer.play(<span class="string">"mp3"</span>, <span class="string">"beyond the horizon.mp3"</span>);</span><br><span class="line">      audioPlayer.play(<span class="string">"mp4"</span>, <span class="string">"alone.mp4"</span>);</span><br><span class="line">      audioPlayer.play(<span class="string">"vlc"</span>, <span class="string">"far far away.vlc"</span>);</span><br><span class="line">      audioPlayer.play(<span class="string">"avi"</span>, <span class="string">"mind me.avi"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oxk1vrcj4.bkt.clouddn.com/39807078769124751.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适配器模式&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://abelchao.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://abelchao.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>建造者模式</title>
    <link href="http://abelchao.com/2018/04/25/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://abelchao.com/2018/04/25/建造者模式/</id>
    <published>2018-04-25T08:00:00.000Z</published>
    <updated>2018-04-25T10:00:29.488Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oxk1vrcj4.bkt.clouddn.com/842198886757488751.jpg" alt=""></p><p><strong>建造者模式</strong></p><a id="more"></a><h1 id="建造者模式（StringBuilder）"><a href="#建造者模式（StringBuilder）" class="headerlink" title="建造者模式（StringBuilder）"></a>建造者模式（StringBuilder）</h1><p><img src="http://oxk1vrcj4.bkt.clouddn.com/BuilderMode.png" alt=""></p><h2 id="创建一个表示食物条目和食物包装的接口"><a href="#创建一个表示食物条目和食物包装的接口" class="headerlink" title="创建一个表示食物条目和食物包装的接口"></a>创建一个表示食物条目和食物包装的接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Item</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 食品条目</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Blemon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018年4月25日 下午3:55:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Packing <span class="title">packing</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Packing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 食物包装方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Blemon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018年4月25日 下午3:55:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Packing</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">pack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建实现-Packing-接口的实体类"><a href="#创建实现-Packing-接口的实体类" class="headerlink" title="创建实现 Packing 接口的实体类"></a>创建实现 Packing 接口的实体类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Wrapper</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 纸盒包装</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Blemon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018年4月25日 下午3:58:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> <span class="keyword">implements</span> <span class="title">Packing</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">pack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"纸盒包装"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Bottle</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 瓶装</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Blemon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018年4月25日 下午3:58:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bottle</span> <span class="keyword">implements</span> <span class="title">Packing</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">pack</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"瓶装"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建实现-Item-接口的抽象类，该类提供了默认的功能"><a href="#创建实现-Item-接口的抽象类，该类提供了默认的功能" class="headerlink" title="创建实现 Item 接口的抽象类，该类提供了默认的功能"></a>创建实现 Item 接口的抽象类，该类提供了默认的功能</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Burger</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 汉堡抽象类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Blemon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018年4月25日 下午4:00:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Burger</span> <span class="keyword">implements</span> <span class="title">Item</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Packing <span class="title">packing</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Wrapper();<span class="comment">//默认纸盒装</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> ColdDrink</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 冷饮抽象类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Blemon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018年4月25日 下午4:05:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColdDrink</span> <span class="keyword">implements</span> <span class="title">Item</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Packing <span class="title">packing</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Bottle();<span class="comment">//默认纸盒装</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建扩展了-Burger-和-ColdDrink-的实体类"><a href="#创建扩展了-Burger-和-ColdDrink-的实体类" class="headerlink" title="创建扩展了 Burger 和 ColdDrink 的实体类"></a>创建扩展了 Burger 和 ColdDrink 的实体类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> VegBurger</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 汉堡的具体子类--蔬菜汉堡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Blemon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018年4月25日 下午4:06:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VegBurger</span> <span class="keyword">extends</span> <span class="title">Burger</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">25.5f</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"蔬菜汉堡"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> ChickenBurger</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 汉堡的具体子类--鸡肉汉堡</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Blemon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018年4月25日 下午4:06:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChickenBurger</span> <span class="keyword">extends</span> <span class="title">Burger</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">50.0f</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"鸡肉汉堡"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Coke</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 冷饮的具体子类---可口可乐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Blemon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018年4月25日 下午4:08:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coke</span> <span class="keyword">extends</span> <span class="title">ColdDrink</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">30.0f</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"可口可乐"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Pepsi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 冷饮的具体子类---百事可乐</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Blemon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018年4月25日 下午4:09:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pepsi</span> <span class="keyword">extends</span> <span class="title">ColdDrink</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">35.0f</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"百事可乐"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建一个-Meal-类，带有上面定义的-Item-对象"><a href="#创建一个-Meal-类，带有上面定义的-Item-对象" class="headerlink" title="创建一个 Meal 类，带有上面定义的 Item 对象"></a>创建一个 Meal 类，带有上面定义的 Item 对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Item&gt; items = <span class="keyword">new</span> ArrayList&lt;Item&gt;();    </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span><span class="params">(Item item)</span></span>&#123;</span><br><span class="line">      items.add(item);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getCost</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">float</span> cost = <span class="number">0.0f</span>;</span><br><span class="line">      <span class="keyword">for</span> (Item item : items) &#123;</span><br><span class="line">         cost += item.price();</span><br><span class="line">      &#125;        </span><br><span class="line">      <span class="keyword">return</span> cost;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showItems</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (Item item : items) &#123;</span><br><span class="line">         System.out.print(<span class="string">"Item : "</span>+item.name());</span><br><span class="line">         System.out.print(<span class="string">", Packing : "</span>+item.packing().pack());</span><br><span class="line">         System.out.println(<span class="string">", Price : "</span>+item.price());</span><br><span class="line">      &#125;        </span><br><span class="line">   &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建一个-MealBuilder-类，实际的-builder-类负责创建-Meal-对象"><a href="#创建一个-MealBuilder-类，实际的-builder-类负责创建-Meal-对象" class="headerlink" title="创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象"></a>创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MealBuilder</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Meal <span class="title">prepareVegMeal</span> <span class="params">()</span></span>&#123;</span><br><span class="line">      Meal meal = <span class="keyword">new</span> Meal();</span><br><span class="line">      meal.addItem(<span class="keyword">new</span> VegBurger());</span><br><span class="line">      meal.addItem(<span class="keyword">new</span> Coke());</span><br><span class="line">      <span class="keyword">return</span> meal;</span><br><span class="line">   &#125;   </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Meal <span class="title">prepareNonVegMeal</span> <span class="params">()</span></span>&#123;</span><br><span class="line">      Meal meal = <span class="keyword">new</span> Meal();</span><br><span class="line">      meal.addItem(<span class="keyword">new</span> ChickenBurger());</span><br><span class="line">      meal.addItem(<span class="keyword">new</span> Pepsi());</span><br><span class="line">      <span class="keyword">return</span> meal;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BuiderPatternDemo-使用-MealBuider-来演示建造者模式（Builder-Pattern）"><a href="#BuiderPatternDemo-使用-MealBuider-来演示建造者模式（Builder-Pattern）" class="headerlink" title="BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）"></a>BuiderPatternDemo 使用 MealBuider 来演示建造者模式（Builder Pattern）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuilderPatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      MealBuilder mealBuilder = <span class="keyword">new</span> MealBuilder();</span><br><span class="line"></span><br><span class="line">      Meal vegMeal = mealBuilder.prepareVegMeal();</span><br><span class="line">      System.out.println(<span class="string">"Veg Meal"</span>);</span><br><span class="line">      vegMeal.showItems();</span><br><span class="line">      System.out.println(<span class="string">"Total Cost: "</span> +vegMeal.getCost());</span><br><span class="line"></span><br><span class="line">      Meal nonVegMeal = mealBuilder.prepareNonVegMeal();</span><br><span class="line">      System.out.println(<span class="string">"\n\nNon-Veg Meal"</span>);</span><br><span class="line">      nonVegMeal.showItems();</span><br><span class="line">      System.out.println(<span class="string">"Total Cost: "</span> +nonVegMeal.getCost());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Veg Meal</span></span><br><span class="line"><span class="comment">Item : 蔬菜汉堡, Packing : 纸盒包装, Price : 25.5</span></span><br><span class="line"><span class="comment">Item : 可口可乐, Packing : 瓶装, Price : 30.0</span></span><br><span class="line"><span class="comment">Total Cost: 55.5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Non-Veg Meal</span></span><br><span class="line"><span class="comment">Item : 鸡肉汉堡, Packing : 纸盒包装, Price : 50.0</span></span><br><span class="line"><span class="comment">Item : 百事可乐, Packing : 瓶装, Price : 35.0</span></span><br><span class="line"><span class="comment">Total Cost: 85.0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oxk1vrcj4.bkt.clouddn.com/842198886757488751.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;建造者模式&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://abelchao.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://abelchao.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
