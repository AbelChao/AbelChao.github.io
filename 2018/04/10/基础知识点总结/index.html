<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=1.0.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=1.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=1.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=1.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=1.0.0" color="#222">





  <meta name="keywords" content="JavaSE," />





  <link rel="alternate" href="/atom.xml" title="AbelChao" type="application/atom+xml" />






<meta name="description" content="基础知识点总结">
<meta name="keywords" content="JavaSE">
<meta property="og:type" content="article">
<meta property="og:title" content="基础知识点总结">
<meta property="og:url" content="http://abelchao.com/2018/04/10/基础知识点总结/index.html">
<meta property="og:site_name" content="AbelChao">
<meta property="og:description" content="基础知识点总结">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://oxk1vrcj4.bkt.clouddn.com/7abf27c6813a84967441aba4fadf146e_r.jpg">
<meta property="og:image" content="http://oxk1vrcj4.bkt.clouddn.com/20150309140927553.jpg">
<meta property="og:image" content="http://oxk1vrcj4.bkt.clouddn.com/764863-20160620202714522-1795796503.png">
<meta property="og:image" content="http://oxk1vrcj4.bkt.clouddn.com/UC%E6%88%AA%E5%9B%BE20170409172233.png">
<meta property="og:updated_time" content="2018-04-26T09:44:54.887Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="基础知识点总结">
<meta name="twitter:description" content="基础知识点总结">
<meta name="twitter:image" content="http://oxk1vrcj4.bkt.clouddn.com/7abf27c6813a84967441aba4fadf146e_r.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '1.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://abelchao.com/2018/04/10/基础知识点总结/"/>





  <title>基础知识点总结 | AbelChao</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d2f22ab3792c739378f3bddbb46e5c5d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/AbelChao"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>
	<header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AbelChao</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">超超白</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>
	

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://abelchao.com/2018/04/10/基础知识点总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="AbelChao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AbelChao">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">基础知识点总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-10T09:00:00+08:00">
                2018-04-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">Post modified&#58;</span>
              
              <time title="Post modified" itemprop="dateModified" datetime="2018-04-26T17:44:54+08:00">
                2018-04-26
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaSE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaSE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><img src="http://oxk1vrcj4.bkt.clouddn.com/7abf27c6813a84967441aba4fadf146e_r.jpg" alt=""></p>
<p><strong>基础知识点总结</strong><br><a id="more"></a></p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><pre><code>http://bbblemon.top/2017/12/06/Java%E9%9D%A2%E8%AF%95%EF%BC%88%E6%9D%82%EF%BC%89/

http://bbblemon.top/2017/12/13/Java%E9%9D%A2%E8%AF%95%EF%BC%88%E6%9D%82-2%EF%BC%89/

http://bbblemon.top/2017/12/14/Java%E9%9D%A2%E8%AF%95%EF%BC%88200-Questions%EF%BC%89/

http://bbblemon.top/2018/01/18/Java%E9%9D%A2%E8%AF%95%EF%BC%88JavaWeb%EF%BC%89/

http://bbblemon.top/2017/12/25/Java%E5%88%B7%E9%A2%98%EF%BC%88%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98%EF%BC%89/

http://bbblemon.top/2017/12/11/Java%E9%9D%A2%E8%AF%95%EF%BC%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-%E5%9F%BA%E7%A1%80%EF%BC%89/
</code></pre><h2 id="三个基本特性"><a href="#三个基本特性" class="headerlink" title="三个基本特性"></a>三个基本特性</h2><pre><code>1. 继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被子类（派生类）。继承可以传递。
2. 封装：把数据和操作数据的方法绑定起来，点对数据的访问只能通过已定义的接口。封装就是为了隐藏一切可以隐藏的东西，只向外界提供最简单的编程接口。
3. 多态:父类引用指向子类实例。
</code></pre><h2 id="六原则一法则"><a href="#六原则一法则" class="headerlink" title="六原则一法则"></a>六原则一法则</h2><pre><code>1. 单一职责:一个类只做它该做的事情（高内聚）。
2. 开放封闭：软件实体应当对外扩展开放，对修改关闭。
    1. 抽象，一个系统中如果没有抽象类或者接口，整个系统就没有扩展点。
    2. 封装可变，将系统中的各种可变因素封装到一个继承结构中。
3. 里氏替换：任何时候都可以使用子类型替换父类型。
4. 依赖倒置：面向接口编程。
5. 合成聚和复用：优先使用聚合和合成关系复用代码。
6. 接口隔离:接口小而专，不能大而全

1. 迪米特法则：一个对象应该对其他对象有尽可能少的了解。
</code></pre><h2 id="平台无关性"><a href="#平台无关性" class="headerlink" title="平台无关性"></a>平台无关性</h2><pre><code>Java的平台无关性是因为JVM有很多种，但是不同的JVM都可以解释同一种字节码(.class)文件，所以成就了Java的平台无关性。
</code></pre><h2 id="javac和java"><a href="#javac和java" class="headerlink" title="javac和java"></a>javac和java</h2><pre><code>1. javac是编译命令，将.java源文件编译成.class字节码文件。例如，javac hello.java--&gt;hello.class。
2. java是运行字节码文件，利用JVM对字节码进行解释和运行。例如:java hello（注意一样，后面不写.class）
</code></pre><h2 id="String-args"><a href="#String-args" class="headerlink" title="String[] args"></a>String[] args</h2><pre><code>String[] args，是为了方便将外面的数据引入到main方法里。
（https://blog.csdn.net/lin434406218/article/details/52612064）
</code></pre><h2 id="public-static-void-main-String-args"><a href="#public-static-void-main-String-args" class="headerlink" title="public static void main(String[] args){}"></a>public static void main(String[] args){}</h2><pre><code>1. public和static可以互换位置
2. main(String[] args)可以被定义位final
3. 可以使用synchronized来修饰main(String[] args)
</code></pre><h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><pre><code>1. 父类静态（类）变量，父类静态块。
2. 子类静态（类）变量，子类静态块。
3. 父类非静态（成员）变量，父类构造块，父类构造器。
4. 子类非静态（成员）变量，子类构造块，子类构造器。
5. 成员变量、构造块、构造器也就是只有在new这个关键字出现后才会调用，也就是说必须要有实例对象被创建的时候才会调用。如果只是声明，不会静态块也不会调用。
6. 声明永远不调用资源！！！（包括静态块）
7. 静态资源只有在类被使用加载的时候才会被调用一次，但是成员资源却是每次新的实例被生成的时候就会被调用。

（http://bbblemon.top/2018/03/31/Java%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/）
（http://bbblemon.top/2018/03/25/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/）
（http://bbblemon.top/2017/10/10/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/）
</code></pre><h2 id="this-super-this-super"><a href="#this-super-this-super" class="headerlink" title="this/super/this()/super()"></a>this/super/this()/super()</h2><pre><code>1. this/super只能用在非静态环境下。
2. this()和super()只能用在构造器中，就是为了调用父类或者自己别的构造器。
3. this()和super()都必须在构造器的第一行使用，也就是说这两个在一个构造器中只能出现一个。
3. this指的是对象实例，也就是new的是谁，this就代指谁！！!这一点在多态中很容易迷糊。
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Blemon</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		A a = <span class="keyword">new</span> B();</span><br><span class="line">		System.out.println(a.value);</span><br><span class="line">		System.out.println(a.getValue());</span><br><span class="line">		<span class="comment">//静态A--&gt;静态B--&gt;构造A--&gt;A的构造器--&gt;setValue(v)--&gt;value = 10--&gt;10</span></span><br><span class="line">		<span class="comment">//（这里就是调用了setValue()但是这个方法在子类中重写了,那么在父类中如果不用super.setValue()，那么自动是this.setValue(),</span></span><br><span class="line">		<span class="comment">//而这个this，也就是我们说的new了谁，那么new了B，就调用B的东西。可是如果子类没有重写，那么子类就会往上找，从而调到父类的方法）。</span></span><br><span class="line">		<span class="comment">//执行到这里，A的的构造器执行完了（为什么？因为其实每次最先进去的是子类的构造器，但是无奈子类的第一行默认是super(),除非改了这个，不然永远是先进入父类）</span></span><br><span class="line">		<span class="comment">//B的构造器开始执行</span></span><br><span class="line">		<span class="comment">//--&gt;B的构造器--&gt;setValue(getValue()-3);</span></span><br><span class="line">		<span class="comment">//getValue()子类没有，往上找，--&gt;value++ --&gt; value = 11; --&gt;return 11(try..catch..finally的缓存机制) </span></span><br><span class="line">		<span class="comment">//--&gt;this.setValue(value); --&gt; super.setValue(value*2); --&gt;value = 22; --&gt; 打印22 --&gt;getValue()-3=11-3=8</span></span><br><span class="line">		<span class="comment">//setValue(getValue()-3);--&gt;setValue(8);--&gt;super.setValue(8*2);--&gt;value=16</span></span><br><span class="line">		<span class="comment">//System.out.println(a.getValue());</span></span><br><span class="line">		<span class="comment">//a.getValue()--&gt;value++ --value = 17 --&gt; return 17(try..catch..finally的缓存机制) </span></span><br><span class="line">		<span class="comment">//this.setValue(value); --&gt; super.setValue(value*2); --&gt;value=34</span></span><br><span class="line">		<span class="comment">//System.out.println(value); --&gt;34</span></span><br><span class="line">		<span class="comment">//System.out.println(a.getValue()); --&gt;17</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//静态A--&gt;静态B--&gt;构造A--&gt;A的构造器--&gt;10--&gt;构造B--&gt;B的构造器--&gt;22--&gt;16--&gt;34--&gt;17</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">		<span class="keyword">protected</span> <span class="keyword">int</span> value;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"A的构造器"</span>);</span><br><span class="line">			setValue(v);</span><br><span class="line">			System.out.println(value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">static</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"静态A"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">"构造A"</span>);</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.value = value;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				value++;</span><br><span class="line">				<span class="keyword">return</span> value;</span><br><span class="line">			&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">				<span class="keyword">this</span>.setValue(value);</span><br><span class="line">				System.out.println(value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">		<span class="keyword">static</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"静态B"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">"构造B"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">super</span>(<span class="number">5</span>);</span><br><span class="line">			System.out.println(<span class="string">"B的构造器"</span>);	</span><br><span class="line">			setValue(getValue()-<span class="number">3</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">			<span class="keyword">super</span>.setValue(value*<span class="number">2</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;<span class="comment">//a是点不出来这个方法的</span></span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	静态A</span></span><br><span class="line"><span class="comment">	静态B</span></span><br><span class="line"><span class="comment">	构造A</span></span><br><span class="line"><span class="comment">	A的构造器</span></span><br><span class="line"><span class="comment">	10</span></span><br><span class="line"><span class="comment">	构造B</span></span><br><span class="line"><span class="comment">	B的构造器</span></span><br><span class="line"><span class="comment">	22</span></span><br><span class="line"><span class="comment">	16</span></span><br><span class="line"><span class="comment">	34</span></span><br><span class="line"><span class="comment">	17</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="多态的实现原理"><a href="#多态的实现原理" class="headerlink" title="多态的实现原理"></a>多态的实现原理</h2><pre><code>补一个专题
https://blog.csdn.net/sinat_34311901/article/details/52208124

https://blog.csdn.net/huangrunqing/article/details/51996424
</code></pre><h2 id="重写和重载"><a href="#重写和重载" class="headerlink" title="重写和重载"></a>重写和重载</h2><pre><code>http://bbblemon.top/2017/10/11/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89/

http://bbblemon.top/2017/12/04/Java%E9%9D%A2%E8%AF%95%EF%BC%88%E5%87%A0%E4%B8%AA%E6%AF%94%E8%BE%83%EF%BC%89/

1. 重载是编译时多态的体现，重写时运行时多态的体现
2. 重载是在同一个类中，重写是在子父类中
3. 重载的判断只有方法名一致，形参列表不同，其他的包括返回值，访问修饰符都不能用作判断重载的条件
4. 重写的判断有个原则：两同两小一大
    1. 方法名和形参列表一致
    2. 返回值和抛出的异常小于被重写的方法
    3. 访问修饰符大于被重写的方法
5. 注意一下，一个类实现一个接口，就是重写那个接口的方法，不过是接口中的方法默认是public abstract的，但是jdk1.8以后，接口中可以开始定义静态方法和default的方法，但是必须要有方法体，也就是{}!!!
6. 一旦父类的返回值是一个基本数据类型，那么子类的返回值必须一致！！不然编译不通过，编译器无法区分这两个方法（方法名一样）。
</code></pre><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><pre><code>1. 访问修饰符：public、protected、default、private。
    1. protected和private不能修饰外部类和接口
    2. 不可修饰局部变量

2. static
    1. 不可修饰局部变量，不可修饰外部类和接口。
    2. 被static修饰的东西在方法区中！！！属于这个类的资源，不属于某一个实例。
    3. 为某特定的数据类型和对象分配单一的存储空间，而与创建对象的个数无关。
    4. 实现某个方法或者属性，直接与类进行绑定，而不是对象。
    5. 静态块，只有在类被记载的时候执行一次。

3. final
    1. 类不可继承，方法不可重写，变量的引用（地址）不可变（引用指向那个地址的内容是可以改变的）
    2. 被final修饰的成员变量和类变量必须在声明的时候就初始化，但是被final修饰的局部变量可以先不初始化。

4. abstract
    1. 不可与final、static、private合用
    2. 只修饰方法和类、接口
    3. 修饰方法，方法必须以;结尾，不可有方法体。
    4. 有abstract方法的类必须是抽象类

5. transient
    1. 反序列（Seriziable）

6. volatile
    1. 可见性
    2. 非原子性
    3. 防重排

7. synchronized/lock
</code></pre><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><pre><code>http://bbblemon.top/2018/03/25/Java%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/

1. 标识符只能由字母，数字，&amp;，_,组成，第一个字符不能是数字。
2. break，跳出当前所在循环（如果是多次循环，只跳出一层），continue，结束当次循环，continue后面的语句不再执行，直接进入下一次循环。
3. break利用循环外的标识符来跳出多次循环！！！
4. instanceof：对象 instanceof 类名 返回true/false，就是用来判断左边这个对象是不是后面这个类的一个实例。注意，如果对象时null，那么也会返回false。
</code></pre><h2 id="一个Java文件定义多个类"><a href="#一个Java文件定义多个类" class="headerlink" title="一个Java文件定义多个类"></a>一个Java文件定义多个类</h2><pre><code>一个Java文件中可以有多个类，但是只能有一个类被public修饰，同时这个public类必须和我们的文件名一致，但是如果这个.java文件中没有public类，那么这个类叫什么并不重要。

有几个class就回生成几个.class文件（这里需要注意一下，内部类生成后的表现方式 Outter$Inner.class）
</code></pre><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><pre><code>1. 构造器只能被访问修饰符修饰
2. 必须和类名一致。（不是所有的类都有构造器的，匿名内部类）
3. 构造器没有返回值。
4. 编译器在程序员不写构造器的时候会生成一个无参的，但是一旦写了构造器，那么默认的这个无参构造器就没了，一旦父类没有无参构造，子类就必须在自己构造器的第一行显示的调用父类的某个构造器。
5. 构造器就是为了完成对象的初始化。
6. 构造器无法被继承。
7. 默认构造器的访问修饰符，只和类的访问修饰符一致。
8. 构造器可以重载。
</code></pre><h2 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h2><pre><code>http://bbblemon.top/2017/10/11/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89/

1. 接口和抽象类都不可以实例化
2. 接口的实现类和抽象类的子类都只有在重写了其所有的抽象方法以后，才可以被实例化。
3. 可以多实现，但是不可以多继承。
4. JDK1.7以前，接口中只能有声明，不能有方法实现，变量都必须是public static final的，方法都只能是public abstract的，但是1.8以后，接口中也可以有方法实现，有被static和defalut修饰的方法，这两个修饰的方法必须有方法体！！！
5. 1.7 以前接口中可不能有main方法，但是抽象类中可以有。
6. 接口中方法不能被private和protected修饰！！！
7. 1.8以后的方法可以被abstract、default、static修饰。三个不可以共用！！！
8. 标识接口：Clonable、Serializable
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AInter</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SS = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">public</span> String tt = <span class="string">""</span>;<span class="comment">//默认了</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"ss"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">s</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">dd</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tt</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Clone"><a href="#Clone" class="headerlink" title="Clone()"></a>Clone()</h2><pre><code>System.arraycopy()&gt;Object.clone()&gt;Arrays.copy()&gt;for

浅复制与深复制
</code></pre><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><pre><code>Class.forName(&quot;类的路径&quot;);
类名.Class
实例.getClass().

http://bbblemon.top/2017/10/11/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89/

Java创建对象的四种方式：
1. new
2. 反射
3. 反序列话
4. clone()
</code></pre><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><pre><code>1. 静态内部类、成员内部类、局部内部类，匿名内部类。
2. 静态内部类，当成是一个静态方法，不能访问外部类中非静态的成员和方法。但是本身内部可以定义非静态的东西。
3. 成员内部类，当成是成员方法，但是成员方法是可以直接调用静态方法的，这个调用关系是由加载顺序决定的。但是成员内部类中，因为只有外部类被实例化以后，这个类才能被实例化，所以它虽然可以像成员方法一样使用外部类的所有资源，但是本身内部却不可以定义静态资源！！！
4. 局部内部类，当成是局部变量，也就是说这个类不能被访问修饰符修饰，也不能被static修饰，同时只能访问在方法中定义的final变量。
5. 匿名内部类，没有类名的内部类，这个类很特殊，不能使用关键字class，extends，implements，没有构造器，必须继承其他类或者实现其他接口。
正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。
    1. 没有构造器
    2. 不能定义静态资源（类，方法，变量）
    3. 不能被访问修饰符和static修饰
    4. 只能创建匿名内部类的一个实例。
    5. 一个匿名内部类一定是在new的后面，这个匿名内部类必须继承一个父类或者实现一个接口。
    6. 属于局部内部类。

https://www.cnblogs.com/hasse/p/5020519.html
http://bbblemon.top/2017/10/12/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AD%EF%BC%89/
</code></pre><h2 id="this-super-this-super-1"><a href="#this-super-this-super-1" class="headerlink" title="this/super/this()/super()"></a>this/super/this()/super()</h2><pre><code>http://bbblemon.top/2018/03/31/Java%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/
</code></pre><h2 id="final-finally-finalize"><a href="#final-finally-finalize" class="headerlink" title="final/finally/finalize"></a>final/finally/finalize</h2><pre><code>1. final
    1. 属性/变量：指向不可变，但是指向地址中的内容可以变。
    2. 方法：不可重写
    3. 类：不可继承。（实现CharSquenece接口的String、StringBuilder、StringBuffer、Math、基本数据类型包装类，这些类都继承子Number，ClassLoader可以被继承，System，Void，Class&lt;T&gt;）
    4. 内联（inline）:调用一个声明位final的方法时，将方法主体插入到调用处，而不是方法调用，这样可以提高程序的效率。

2. finally
    1. 只要不是System.exit(0)和在进入try块前出现异常，finally块一定会执行。
    2. finally中对变量的修改也是分为值传递和引用传递的。同时注意引用传递的时候那个重点。
    3. finally中一旦存在的return，一定会覆盖在try和catch中的return语句。

3. finalize
    1. 这是个Object方法，当一个对象通过可达性分析到不了GC Roots，那么这个对象就面临被GC，被第一次标记。当GCor开始准备释放这个对象占用的内存时，会先在判断这个对象是否可以调用其finalize方法，如果这个对象重写了Object的这个方法并在方法内实现了重新被引用，同时finalize是被第一次调用，那么对象就会被放入F-Queue，并免于被回收，但是一旦没有重写，或者虽然重写了但是这个是第二次被调用，那么直接就被标记第二次，在下一次GC的时候，直接回收。
</code></pre><h2 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h2><pre><code>1. 对象的初始值都是null，基本数据类型的各不相同
2. 数组中的初始化是看数组本身放的是什么
3. 只有成员变量和类变量才有默认的初始值，局部变量是没有这个东西的。
</code></pre><h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><pre><code>Swicth语句中的多用于分支选择，在使用Switch（exp）的时候，这个exp只能是byte、short/char、int以及对应的包装类，但是在JDK1.7之后，这个里面可以写String了。

同时case后面的可以是常量数值，也可以是常量计算式，还可以是final修饰的变量（final变量在编译时的常量），但是不能时有变量的东西。

为什么Switch开始支持了String?
本质上说，swicth对String的支持，其实就是对int的匹配。因为是通过对case后面的对象调用了hashCode()方法，得到了一个int类型的hash值，然后用这个hash值来唯一标识这个case。当exp中的String调用hashCode方法得到的hash值可以与case匹配时，那么直接调用exp的equals方法进行二次匹配。

为什么需要二次匹配，这个就不用说了，hashCode和equals方法的联系。

注意:
    1. Swicth语句，最好在每一个case的后面写一个break，一旦没有，那么swicth就会从入口，一直执行下去，直到结束或者遇到break。
    2. defalult也是一样的，当没有case被匹配的时候，就走这个了。
</code></pre><h2 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h2><pre><code>http://bbblemon.top/2018/03/31/Java%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/

1. 基本数据类型的传递都是值传递，就是把实参的值复制了一份给了形参。
2. 引用传递，就是把对象的地址复制了一份给了形参。让形参一开始的时候也指向和实参一样的地址。但是当形参的指向地址改变后，对形参的任何操作也就不会再影响到我们实参指向的地址，这一点再try..catch..finally中也很常见。
3. 也就是说值传递不能改变实参的任何，引用传递可以改变实参的内容，但是不能改变实参指向的地址。
</code></pre><h2 id="equals、hashCode、"><a href="#equals、hashCode、" class="headerlink" title="equals、hashCode、=="></a>equals、hashCode、==</h2><pre><code>其实要说明白equals和==的区别很简单，==号永远比较的是两个栈中的变量是否指向了同一个堆中的地址。
而equals方法，很简单，这个是个Object类的方法，直接去看Object中的源码，就会发现，其实这个方法本身和==没有任何区别，只不过是因为我们很多类中，我们比较的并不是比较两个引用是否指向了同一个地址，而是比较两个地址中的内容是否一致，这个时候因为Object是所有类的父类，其他类都可以重写这个方法，从而完成比较。

但是对于使用到hash算法的一些类而言，比如HashMap，Hashtable，HashSet等等，由于类本部本身的构造，需要利用对象的hash值和hash表的长度来确定对象在表中的角标，尤其是HashMap中那种数组+链表转红黑树的结构，第一步就是利用hash值和table长度来计算的元素初始位置。

hashCode方法也是在Object方法中的，如果不重写这个方法，Object类中hashCode方法返回的是对象在内存中的地址转换成的一个int值，所以任何对象的hashCode()都不会相同的。

其实equals方法，和hashCode方法其实都是用来比较对象是否一致的，但是为什么总是一起重写呢。

这其实就是为了涉及hash算法的类中的一个要求，比如说HashMap，如果每次都是调用equals方法去遍历hash表比较，效率会特别慢，所以也就有了这种数组+链表转红黑树的结构，利用key的hashCode快速定位对象在表中地址，然后利用equals方法进行链上对象的比较，很快。

注意一下，上面之所有计算的对象会出现hashCode值一样，是因为重写了hashCode这个方法，才出现了hash冲突！！！不然是不可能出现hash中途的。

1. equals一致，hashCode一致。
2. hashCode一致，equals不一定一致。
</code></pre><h2 id="i-与-i"><a href="#i-与-i" class="headerlink" title="i++与++i"></a>i++与++i</h2><pre><code>这个其实就是Java的一个中间缓存机制。

i++，先运算，后自加
++i，先自加，后运算
</code></pre><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><pre><code>http://bbblemon.top/2018/03/31/Java%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/

泛型只是在编译的时候保证了类型，但是在运行时，是不存在这个东西的。

1. ?:任意类型，如果没有明确，那么就是Object以及任意的Java类了。
2. ? extends E:向下限定，E及其子类
3. ? super E:向上限定，E及其父类

注意：泛型就是里面的东西如果是点对点 就算是继承关系也不行！！！List&lt;Object&gt;就是Object对象，不能是Object的其他子类！！！
</code></pre><h2 id="round、ceil、floor、DecimalFormat、BigInteger"><a href="#round、ceil、floor、DecimalFormat、BigInteger" class="headerlink" title="round、ceil、floor、DecimalFormat、BigInteger"></a>round、ceil、floor、DecimalFormat、BigInteger</h2><pre><code>1. round、ceil、floor都是在Math下的静态方法。
2. round，当前值+0.5向下取整。
3. ceil，向上取整。（大于等于）
4. floor，向下取整。（小于等于）
5. DecimalFormat(&quot;0.0&quot;)，用来限定位数的：df.format(double);java.text.*;
6. BigInteger(String s)，没有无参构造。 b1.add(b2);用于超大数相加：java.math.*;
7. round方法返回是int和long，但是ceil和floor返回的是double，所以ceil和floor在0.0这个点，会保留原始的负号，但是round不会。
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	    System.out.println(Math.ceil(-<span class="number">0.1</span>));<span class="comment">//-0.0</span></span><br><span class="line">	    System.out.println(Math.floor(<span class="number">0.1</span>));<span class="comment">//0.0</span></span><br><span class="line">		System.out.println(Math.floor(-<span class="number">0.0</span>));<span class="comment">//-0.0</span></span><br><span class="line">		System.out.println(Math.floor(<span class="number">0.0</span>));<span class="comment">//0.0</span></span><br><span class="line">	    System.out.println(Math.round(-<span class="number">0.1</span>));<span class="comment">//0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><pre><code>补一个专题
https://www.cnblogs.com/chenssy/p/6379280.html
http://www.importnew.com/27863.html
http://www.importnew.com/17394.html
http://www.importnew.com/19745.html

1. 没有保证原子性。加锁和synchronized保证了原子性
2. 可见性
    当一个变量被volatile修饰后，表示线程本地内存无效，当一个线程修改了共享变量后，他会立刻被更新到主存，当其他线程读取共享变量时，它会直接从主存中读取。
    synchronized和lock也都保证了可见性。
3. 有序性（禁止指令重排序）
    在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序它不会影响单线程的运行结果，但是对多线程会有影响。
    Java提供volatile来保证一定的有序性。最著名的例子就是单例模式里面的DCL（双重检查锁）
</code></pre><h1 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h1><h2 id="基本数据类型和其包装类"><a href="#基本数据类型和其包装类" class="headerlink" title="基本数据类型和其包装类"></a>基本数据类型和其包装类</h2><pre><code>http://bbblemon.top/2018/03/31/Java%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/

1. byte--&gt;short/char--&gt;int--&gt;long--&gt;float--&gt;double
2. 1--&gt;2/2--&gt;4--&gt;8--&gt;4--&gt;8
3. char类型是一个单一的 16 位 Unicode 字符；最小值是 \u0000（即为0）最大值是 \uffff（即为65,535）
4. 基本数据类型和包装类使用==号比较的时候，会自动向上转型，同时变成值的比较。
5. 包装类的赋值，都是ValueOf进行了装箱。
6. 包装类的赋值，不存在自动向上转型。
7. 基本类型的==，存在向上转型。
8. int以下的short和byte、char进行+=/*运算的时候会自动上升为int型，所有如果还想回到原来的类型，必须强转。但是+=，-=，*=,/=的时候，不需要强转，自己会转换。
    short s = 1;s=s+1（报错）
    s=(short)s+1 / s+=1（正确）
9. 因为Integer中cache数组的存在，Integer的赋值，在-128到127之间不会装箱，也就是不会生成新的对象。
10. 基本数据类型的包装类都是不可变类。
11. 包装类的equals方法均不提供类型转换。
12. 小数的默认类型是double，如果直接写float = 0.0，编译报错
13. &apos;a&apos;是97，&apos;A&apos;是65
14. 基本数据类型也属于Object，Object o = 2；正确。
15. boolean不能和其他的7个基本数据类型转换
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		Integer I = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">long</span> l = <span class="number">0</span>;</span><br><span class="line">		Long L = <span class="number">0l</span>;</span><br><span class="line">		Double D = <span class="number">0</span>d;<span class="comment">//这个d不可省略</span></span><br><span class="line">		<span class="keyword">double</span> d = <span class="number">0</span>;</span><br><span class="line">		System.out.println(i==I);<span class="comment">//true</span></span><br><span class="line">		System.out.println(d==D);<span class="comment">//true</span></span><br><span class="line">		System.out.println(i==d);<span class="comment">//true</span></span><br><span class="line">		System.out.println(D==i);<span class="comment">//true</span></span><br><span class="line">		</span><br><span class="line">		Integer m = <span class="number">127</span>;</span><br><span class="line">		Integer n = <span class="number">127</span>;</span><br><span class="line">		</span><br><span class="line">		Integer m_2 = <span class="number">128</span>;</span><br><span class="line">		Integer n_2 = <span class="number">128</span>;</span><br><span class="line">		</span><br><span class="line">		Integer m_3 = -<span class="number">128</span>;</span><br><span class="line">		Integer n_3 = -<span class="number">128</span>;</span><br><span class="line">		</span><br><span class="line">		Integer m_4 = -<span class="number">129</span>;</span><br><span class="line">		Integer n_4 = -<span class="number">129</span>;</span><br><span class="line">		</span><br><span class="line">		System.out.println(m==n);<span class="comment">//true</span></span><br><span class="line">		System.out.println(m_2==n_2);<span class="comment">//false</span></span><br><span class="line">		System.out.println(m_3==n_3);<span class="comment">//true</span></span><br><span class="line">		System.out.println(m_4==n_4);<span class="comment">//false</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		Integer I = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">long</span> l = <span class="number">0</span>;</span><br><span class="line">		Long L = <span class="number">0l</span>;</span><br><span class="line">		Double D = <span class="number">0</span>d;<span class="comment">//这个d不可省略</span></span><br><span class="line">		<span class="keyword">double</span> d = <span class="number">0</span>;</span><br><span class="line">		System.out.println(D.equals(d));<span class="comment">//true</span></span><br><span class="line">		System.out.println(D.equals(l));<span class="comment">//false，但是D==l返回true</span></span><br><span class="line">		<span class="comment">//System.out.println(I==L);不同类型的包装类直接==会编译错误</span></span><br><span class="line">		System.out.println(I.equals(L));<span class="comment">//false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="int和Integer的区别"><a href="#int和Integer的区别" class="headerlink" title="int和Integer的区别"></a>int和Integer的区别</h2><pre><code>1. 一个是基本数据类型，一个是类。
2. 默认值不一样
3. Integer变量必须实例化后才能使用，int不需要。
4. Integer在[-128,127]这个范围内的数字不进行装箱。
5. Integer是对象，用一个引用指向这个对象，而int是基本类型，直接存储数据。
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)&#123;</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="强制转换与包装类的equals方法"><a href="#强制转换与包装类的equals方法" class="headerlink" title="强制转换与包装类的equals方法"></a>强制转换与包装类的equals方法</h2><pre><code>1. 基本数据类型和包装类进行==比较的时候，包装类被拆箱成为基本数据类型以后再比较，这个样子，因为基本数据类型的==存在自动向上转型的原因，所以这种比较也存再转型。
2. 包装类调用equals的时候，会先比较类型，是不是一个类，不是一个类，直接返回false，是一个类再及进行值的比较。
3. 两个Integer==比较，比较的就是物理地址了，这个时候，只要有一方是new出来的，直接返回false，不然利用valueOf进行比较。
4. 包装类调用equals方法，但是传入的是一个基本数据类型，会对基本数据类型先进行装箱，装箱结束后吗，比较类型，类型不一致，直接返回false
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xd.out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">int</span> a=<span class="number">257</span>;</span><br><span class="line">	    Integer b=<span class="number">257</span>;</span><br><span class="line">	    Integer c=<span class="number">257</span>;</span><br><span class="line">	    Integer d=<span class="keyword">new</span> Integer(a);</span><br><span class="line">	    Integer d1=<span class="keyword">new</span> Integer(a);</span><br><span class="line"></span><br><span class="line">	    Integer b2=<span class="number">57</span>;</span><br><span class="line">	    Integer c2=<span class="number">57</span>;</span><br><span class="line"></span><br><span class="line">	    System.out.println(a==b);<span class="comment">//true</span></span><br><span class="line">	    System.out.println(b==c);<span class="comment">//false</span></span><br><span class="line">	    System.out.println(b2==c2);<span class="comment">//true</span></span><br><span class="line">	    System.out.println(a==d);<span class="comment">//true</span></span><br><span class="line">	    System.out.println(b==d);<span class="comment">//false</span></span><br><span class="line">	    System.out.println(d==d1);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">	    <span class="comment">//System.out.println(a.equals(b));  编译出错，基本型不能调用equals()</span></span><br><span class="line">	    System.out.println(b.equals(<span class="number">257.0</span>));  <span class="comment">//false</span></span><br><span class="line">	    System.out.println(b.equals(c));       <span class="comment">//true</span></span><br><span class="line">	    System.out.println(b.equals(a));      <span class="comment">//true</span></span><br><span class="line">	    System.out.println(b.equals(d));    <span class="comment">//true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><pre><code>http://bbblemon.top/2018/03/31/Java%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/
</code></pre><h2 id="String、StringBuilder、StringBuffer"><a href="#String、StringBuilder、StringBuffer" class="headerlink" title="String、StringBuilder、StringBuffer"></a>String、StringBuilder、StringBuffer</h2><pre><code>1. 三个类都是final的
2. 三个类都实现了CharSequenece接口
3. StringBuilder线程不安全，StringBuffer线程安全
4. String是不可变类，但是StringBuffer/StringBuilder可变。

http://bbblemon.top/2018/03/26/Java%E5%9F%BA%E7%A1%80%E7%B1%BBAPI/
http://www.cnblogs.com/jiangwz/p/7171162.html
</code></pre><h2 id="String与Integer，Double，Long的进制转换"><a href="#String与Integer，Double，Long的进制转换" class="headerlink" title="String与Integer，Double，Long的进制转换"></a>String与Integer，Double，Long的进制转换</h2><pre><code>1. 10进制字符串--&gt;二进制字符串。
    int key = Integer.parseInt(s);
    String bin = Integer.toString(key,2);//.toBinaryString(key)

2. 二进制字符串变成10进制数字
    Integer key  = Integer.parseInt(s,2);

3. int key = Integer.parseInt(String s,int radix)：这个方法是将一个字符串变成一个10进制的数字。radix是把String看成几进制的串。

4. String s = Integer.toString(Integer i,int radix)：这个方法是把一个10进制的数字变成制定进制的字符串。    
</code></pre><h2 id="String的intern（不好理解）"><a href="#String的intern（不好理解）" class="headerlink" title="String的intern（不好理解）"></a>String的intern（不好理解）</h2><pre><code>http://bbblemon.top/2018/03/26/Java%E5%9F%BA%E7%A1%80%E7%B1%BBAPI/
https://www.cnblogs.com/Kidezyq/p/8040338.html
http://www.cnblogs.com/wxgblogs/p/5635099.html
https://blog.csdn.net/qq_38663729/article/details/78056959
之前总结很全面

1. String s =  new String(&quot;100&quot;);//会在常量池和堆中都生成100，但是返回堆中地址。
2. String s = new String(&quot;1&quot;)+new String(&quot;00&quot;);//会在常量池产生1，00，堆中产生1，00，100。
3. s.intern只有在常量池中没有的时候，把堆中的s的引用复制一份给池，然后指向池才会改变s的引用地址。如果池中有了，那么调用了这个方法，不会把堆中地址进行复制，同时也就返回的是堆中地址！！！
4. 因为JDK7中常量池在堆中了而不是在永久代，所以常量池中放的是引用，而不是一个复制的对象本身了。
</code></pre><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><pre><code>数组是一个对象！！！

http://bbblemon.top/2017/10/12/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%83%EF%BC%89/

1. Arrays.sort
2. Arrays.asList ---&gt; fast-fail
</code></pre><h2 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h2><pre><code>http://bbblemon.top/2018/03/26/Java%E5%9F%BA%E7%A1%80%E7%B1%BBAPI/
https://blog.csdn.net/qq_38663729/article/details/78056959
</code></pre><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><pre><code>http://bbblemon.top/2017/10/13/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%85%AB%EF%BC%89/

http://bbblemon.top/2017/12/04/Java%E9%9D%A2%E8%AF%95%EF%BC%88%E5%BC%82%E5%B8%B8%E6%A1%86%E6%9E%B6%EF%BC%89/
</code></pre><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><pre><code>http://bbblemon.top/2018/04/02/%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/

Throwable接口有两个实现，Error和Exception，Exception由分为CheckedException和RuntimeException。
1. Error是在运行时发生的错误，改错误不可恢复，由于这属于JVM级别的错误。因此这种错误会导致程序终止执行。此外，编译器不会检查Error
2. CheckedException是编译时一定要处理的异常，主要就是IO异常和SQL异常。
3. RuntimeException是运行时异常，编译器没有强制对其进行捕捉。
</code></pre><h2 id="throw和throws"><a href="#throw和throws" class="headerlink" title="throw和throws"></a>throw和throws</h2><pre><code>1. throws在使用时应处于方法签名之后使用。可以抛出多种异常并用英文字符&quot;,&quot;隔开。
2. 一旦时checkedException，要么时try..catch..finally，要么时再次throws交给上一层。
3. 子类抛出的异常种类小于等于父类。
4. throw抛出的是一个对象。
5. 使用throws关键字声明的方法表示此方法不处理异常，而交给方法调用处进行处理。
6. throw关键字作用是抛出一个异常，抛出的时候是抛出的是一个异常类的实例化对象
7. throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常。
8. throw以后，要么本类要处理，要么往调用处抛出
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用<span class="keyword">throws</span>关键字声明的方法表示此方法不处理异常，而交给方法调用处进行处理。</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> <span class="keyword">throws</span> Exception</span>&#123;    <span class="comment">// 定义除法操作，如果有异常，则交给被调用处处理</span></span><br><span class="line">        <span class="keyword">int</span> temp = i / j ;    <span class="comment">// 计算，但是此处有可能出现异常</span></span><br><span class="line">        <span class="keyword">return</span> temp ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsDemo01</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Math m = <span class="keyword">new</span> Math() ;        <span class="comment">// 实例化Math类对象</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"除法操作："</span> + m.div(<span class="number">10</span>,<span class="number">2</span>)) ;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace() ;    <span class="comment">// 打印异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">如果在主方法的声明也使用了<span class="keyword">throws</span>关键字呢，那么是不是意味着主方法也可以不处理异常。</span><br><span class="line"></span><br><span class="line">在本程序中，主方法不处理任何异常，而交给JAVA中最大头JVM，所以如果在主方法使用了<span class="keyword">throws</span>关键字，则表示一切异常</span><br><span class="line"></span><br><span class="line">交给JVM进行处理。默认处理方式也是JVM完成。</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> <span class="keyword">throws</span> Exception</span>&#123;    <span class="comment">// 定义除法操作，如果有异常，则交给被调用处处理</span></span><br><span class="line">        <span class="keyword">int</span> temp = i / j ;    <span class="comment">// 计算，但是此处有可能出现异常</span></span><br><span class="line">        <span class="keyword">return</span> temp ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsDemo02</span></span>&#123;</span><br><span class="line">    <span class="comment">// 在主方法中的所有异常都可以不使用try...catch进行处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Math m = <span class="keyword">new</span> Math() ;        <span class="comment">// 实例化Math类对象</span></span><br><span class="line">        System.out.println(<span class="string">"除法操作："</span> + m.div(<span class="number">10</span>,<span class="number">0</span>)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.ArithmeticException: / by zero</span><br><span class="line">	at methoud.Math.div(ThisDemo06.java:<span class="number">4</span>)</span><br><span class="line">	at methoud.ThisDemo06.main(ThisDemo06.java:<span class="number">12</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">//		try &#123;</span></span><br><span class="line"><span class="comment">//			throw new Exception("Demo");</span></span><br><span class="line"><span class="comment">//		&#125; catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">//			System.out.println("...");</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Demo"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			fun();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"有异常"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try..catch..finally"></a>try..catch..finally</h2><pre><code>http://bbblemon.top/2018/04/02/%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/

1. try..catch,try..finally,try..catch..finally
2. 如果在try和catch中有return而finally中没有，finally一定是在return前执行。
    1. 如果返回的变量是基本数据类型，finally中对变量的修改就和值传递一样，对返回值无影响。
    2. 如果返回的变量是引用，finally中对引用地址内容的修改会影响到返回值，但是直接改变了引用的对象，不会影响原来的返回值。（引用传递的特殊性）
3. 如果finally中存在return语句，finally中的return总会覆盖前面的return
4. 一旦异常处理了，那么异常处理后方法中的语句还是会顺序执行。
</code></pre><h2 id="finally什么时候不执行"><a href="#finally什么时候不执行" class="headerlink" title="finally什么时候不执行"></a>finally什么时候不执行</h2><pre><code>1. 进去try块前就出现异常
2. 进入finally之前，出现了System.exit(0)
</code></pre><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><pre><code>http://bbblemon.top/2018/03/26/Java%E5%9F%BA%E7%A1%80%E7%B1%BBAPI/
</code></pre><h2 id="序列化-外部序列化与反序列化（针对对象）"><a href="#序列化-外部序列化与反序列化（针对对象）" class="headerlink" title="序列化/外部序列化与反序列化（针对对象）"></a>序列化/外部序列化与反序列化（针对对象）</h2><pre><code>Java提供了两种对象持久化的方式，分别是序列化和外部序列化。

序列化，将一个对象以一连串的字符描述的过程，用于解决对象流进行读写操作时所引发的问题。
序列化，可以将对象的状态写在流里进行网络传输，或者保存到文件、数据库等系统里，并在需要的时候把流读取出来重新构造一个相同的对象。

1. 什么时候需要使用序列化
    1. 需要通过网络来发送对象，或者对象的状态需要被持久化到数据库或者文件中。（Java远程方法调用RMI/对JavaBeans进行序列化）
    2. 序列化能实现深复制，即可以复制引用的对象。

2. 什么是序列化，外部序列化
    1. 序列化就是为了让对象在网络传输的过程中比较方便，同时解决对象流进行读写时所引发的问题。把一个对象的状态变成字节序列（写入流）进行传输，需要使用的时候再通过序列ID进行反序列化得到对象。
    2. 外部序列化和序列化主要的区别就是序列化是内置的API，只需要实现Serializable接口，而外部序列化（Externalizable）接口中的读写方法必须由开发人员来实现。

3. 如何实现序列化
    1. 实现Serializable接口
        1. 该接口只是一个可序列化的标志，并没有包含实际的属性和方法。
        2. 如果不在实现序列化接口的类中添加readObject()和writeObject()方法，则采用默认的序列化机制。如果添加了，还想用默认的序列化机制，则在这两个方法中调用defaultReadObject()/defaultWriteObject()
    2. 实现ExternalSerializable
        1. 自己需要对序列化的内容进行控制

4. 如何控制序列化的时候只序列化部分属性
    1. 实现ExternalSerializable
    2. 对不需要序列化的属性使用transient修饰

5. serialVersionID是干什么的
    1. 和序列化对应的就是反序列化，这个转换的过程中，serialVersionID起着很重要的作用，每个类都有一个特定的serialVersionID，在反序列化的时候，通过serialVersionID来判定类的兼容性，如果待序列化的对象与目标对象的serialVersionID不同，那么反序列化的时候会抛出InvalidClassException异常。
    2. 序列化的类中必须显式的定义serialVersionID（static final），如果不写，序列化的时候会默认计算一个，但是计算的这个在不同OS中的编译器序列化和反序列的算法不同，导致一个OS中序列化的对象，无法在另一个OS中反序列化。

6. 什么是反序列化
    1. 将流变成了对象
    2. 实现Serializable接口的对象在反序列化的时候不需要对象所在类的构造方法，完全基于字节。
    3. 实现Externalizable接口的对象在反序列化的时候会调用构造方法。

7. 序列化的特点
    1. 对象的类名、属性都会被序列化，方法不会被序列化
    2. 被static和transient修饰的属性不可序列化
    3. 一个类能被序列化，那么这个类的子类也可以
    4. serialVersionID必须显式定义。
    5. 反序列化时必须要有序列化对象时的字节码(.class)文件。
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">private</span> String word;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setI</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.i = value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWord</span><span class="params">(String value)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.word = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Main m = <span class="keyword">new</span> Main</span><br><span class="line">m.setI(<span class="number">22</span>);m.setWord(<span class="string">"ss"</span>);</span><br><span class="line">m对象序列化</span><br><span class="line">另一个JVM中反序列化</span><br><span class="line">m.i = <span class="number">0</span><span class="comment">//static修饰没有被序列化，但是属性还是存在的，默认是0</span></span><br><span class="line">m.word = <span class="string">"ss"</span><span class="comment">//序列化了</span></span><br></pre></td></tr></table></figure>
<h2 id="Socket（重点，后面复习计算机网络的时候细看）"><a href="#Socket（重点，后面复习计算机网络的时候细看）" class="headerlink" title="Socket（重点，后面复习计算机网络的时候细看）"></a>Socket（重点，后面复习计算机网络的时候细看）</h2><pre><code>Socket是进制通讯的一种方式，也就是调用这个网络库的一些API实现分布在不同主机的相关进程之间的数据交换。

1. IP：依照TCP/IP协议分配给本地主机的网络地址。两个进程需要通讯，任一进程必须要知道对方的位置。
2. Port：用来辨识本地通讯地址，一个本地的进程在通讯的时候都会占用一个端口号，不同的进程端口号不同
3. 连接：两个进程间的通讯链路
4. 半相关：网络中用一个三元组（协议，本地地址，本地端口）可以在全局唯一的标识一个进程。
5. 全相关：一个完整的网间进程通信需要由两个进程组成，并且只能使用同一种高层协议。也就是说，不可能通信的一端用TCP协议，而另一端用UDP协议。因此一个完整的网间通信需要一个五元组来标识：
（协议，本地地址，本地端口号，远地地址，远地端口号）

C/S架构：客户端向服务端发出服务请求，服务器接收到请求后，提供相应的服务。
1. 首先，建立网络的起因是网络中软硬件资源、运算能力和信息不均等，需要共享，从而造就拥有众多资源的主机提供服务，资源较少的客户请求服务这一非对等作用
2. 其次，网间进程通信完全是异步的，相互通信的进程间既不存在父子关系，又不共享内存缓冲区，因此需要一种机制为希望通信的进程间建立联系，为二者的数据交换提供同步，这就是基于客户/服务器模式的TCP/IP。

服务端：
    1. 打开通信通道并告知本地主机，改进程愿意在某一个端口上接收可恶请求。（FTP 21 Nginx 80）
    2. 等待客户端到达该端口
    3. 接收到客户端的请求，出清请求并发送应答信息。接收到并发服务请求时，要激活一新进程来处理这个客户请求（UNIX fork，exec）。
    4. 返回2
    5. 关闭服务器

客户端：
    1. 打开通信通道，并连接到服务器所在主机的特定端口
    2. 向服务器发服务请求报文，等待并接收应答；继续提出请求
    3. 请求结束手关闭通信通道。

就是两个进程，跨计算机，他俩需要通讯的话，需要通过网络对接起来。这就是 socket 的作用。
打个比方吧，两个进程在两个计算机上，需要有一个进程做被动方，叫做服务器。
另一个做主动方，叫做客户端。他们位于某个计算机上，叫做主机 host ，在网络上有自己的 ip 地址。
一个计算机上可以有多个进程作为服务器，但是 ip 每个机器只有一个，所以通过不同的 port 数字加以区分。
因此，服务器程序需要绑定在本机的某个端口号上。客户端需要声明自己连接哪个地址的那个端口。
两个进程通过网络建立起通讯渠道，然后就可以通过 recv send 来收发一些信息，完成通讯。
所以 socket 就是指代承载这种通讯的系统资源的标识。


https://www.cnblogs.com/yiwangzhibujian/p/7107785.html
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Server</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Blemon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018年4月10日 下午4:58:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> port = <span class="number">55533</span>;<span class="comment">//指定端口</span></span><br><span class="line">			ServerSocket server = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">			Socket client = <span class="keyword">null</span>;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            System.out.println(<span class="string">"***服务器即将启动，等待客户端的连接***"</span>);</span><br><span class="line">			<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">				client = server.accept();<span class="comment">//建立连接</span></span><br><span class="line">				Thread serverThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> ServerThread(client));<span class="comment">//开启线程</span></span><br><span class="line">				serverThread.start();</span><br><span class="line">				System.out.println(<span class="string">"服务器端被连接过的次数："</span>+count++);</span><br><span class="line">                System.out.println(<span class="string">"当前客户端的IP为："</span>+client.getInetAddress().getHostAddress());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> ServerThread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Blemon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018年4月10日 下午4:59:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	Socket socket = <span class="keyword">null</span>;	<span class="comment">//本线程相关的Socket</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(Socket socket)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.socket = socket;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			InputStream input = socket.getInputStream();<span class="comment">//得到输入流，建立byte缓冲区</span></span><br><span class="line">			<span class="keyword">byte</span>[] buffers = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">			<span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">			StringBuffer sb = <span class="keyword">new</span> StringBuffer();			<span class="comment">//拿到数据</span></span><br><span class="line">			<span class="keyword">while</span> ((len = input.read(buffers)) != -<span class="number">1</span>)&#123;</span><br><span class="line">				sb.append(<span class="keyword">new</span> String(buffers,<span class="number">0</span>,len,<span class="string">"UTF-8"</span>));</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(sb);</span><br><span class="line">			System.out.println(<span class="string">"------------------------------"</span>);</span><br><span class="line">			socket.shutdownInput();<span class="comment">//关闭输入流</span></span><br><span class="line">			</span><br><span class="line">			OutputStream output = socket.getOutputStream();<span class="comment">//输出</span></span><br><span class="line">			output.write(<span class="string">"received success"</span>.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">			</span><br><span class="line">			input.close();</span><br><span class="line">			output.close();</span><br><span class="line">			socket.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Blemon</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2018年4月10日 下午5:00:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			String host = <span class="string">"103.46.128.47"</span>;<span class="comment">//127.0.0.1</span></span><br><span class="line">			<span class="keyword">int</span> port = <span class="number">19816</span>;<span class="comment">//55533</span></span><br><span class="line">			Socket socket = <span class="keyword">new</span> Socket(host,port);<span class="comment">//指定主机和端口</span></span><br><span class="line">			OutputStream output = socket.getOutputStream();</span><br><span class="line">			String s = socket.getInetAddress().getHostAddress()+<span class="string">":send message"</span>;</span><br><span class="line">			output.write(s.getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">			socket.shutdownOutput();<span class="comment">//可以适当的关闭一下输出流,也就是告知服务端我们的数据发送完毕了</span></span><br><span class="line">			</span><br><span class="line">			InputStream input = socket.getInputStream();<span class="comment">//开启输入流接收数据</span></span><br><span class="line">			<span class="keyword">byte</span>[] buffers = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">			<span class="keyword">int</span> len = -<span class="number">1</span>;</span><br><span class="line">			StringBuffer sb = <span class="keyword">new</span> StringBuffer();<span class="comment">//拿到数据</span></span><br><span class="line">			<span class="keyword">while</span> ((len = input.read(buffers)) != -<span class="number">1</span>)&#123;</span><br><span class="line">				sb.append(<span class="keyword">new</span> String(buffers,<span class="number">0</span>,len,<span class="string">"UTF-8"</span>));</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(sb);</span><br><span class="line">			</span><br><span class="line">			input.close();</span><br><span class="line">			output.close();</span><br><span class="line">			socket.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><pre><code>http://ifeve.com/java-nio-all/

NIO（Nonblocking IO）出现前，Java是通过传统的Socket来实现基本的网络通信功能的。
但是Socket编程的时候，就会出现阻塞。当要处理多个连接时，就需要采用多线程的方式，由于每个线程有拥有自己的栈空间，而且由于阻塞会导致大量线程进行上下文切换，使得程序的运行变得异常的缓慢。

NIO的三大组件Selector、Channel、Buffer
Selector实现了用一个线程来管理多个通道（采用了复用和解复用的方式使得一个线程能够管理多个通道，即可以把多个流合并成一个流，或者把一个流分成多个流的方式），实现的时候把需要处理的Channel中的IO事件注册给Selector。

Selector对所有注册的Channel进行轮询访问，一旦轮询到一个Channel有注册事件发生，就通过传回Key的方式来通知开发人员对Channel数据进行读写。（Key由SelectionKey类表示，封装一个特定Channel和特定的Selector之间的关系）

这种通过轮询的方式在处理多线程请求时不需要上下文的切换。

1. BIO 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情就会造成不必要的线程开销，当然可以通过线程池机制改善。
2. NIO 同步非阻塞，服务器实现模式为一个请求一个线程，客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。
3. AIO 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。
</code></pre><h2 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h2><h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><h2 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h2><pre><code>http://bbblemon.top/2017/10/13/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B9%9D%EF%BC%89/

http://bbblemon.top/2017/12/01/Java%E9%9D%A2%E8%AF%95%EF%BC%88%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%89/
</code></pre><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><pre><code>http://bbblemon.top/2017/10/16/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B9%9D%EF%BC%89/

http://bbblemon.top/2017/10/16/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/

1. ArrayList的扩容
    1. int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);扩容容量 = 原始容量+原始容量/2
    2. 默认初始容量是10
    3. 构造器有可以直接设置初始容量的
    4. 没有阈值因子，都是elementData[]这个满了以后才扩容。

2. Vector的扩容
    1. 默认初始容量是10，扩容和capacityIncrement（增长因子）有关，也是elementData[]存储数据。
        1. int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity);
        2. capacityIncrement默认是0，但是有构造器可以设置，当capacityIncrement是0的时候，扩容容量是原来的2倍，否则比原来大capacityIncrement多。

3. ArrayList与LinkedList有什么区别
    1. 两个都是线程不安全的，都实现List接口，继承了AbstractList。
    2. ArrayList是动态数组，LinkedList是双向链表
    3. ArrayList可以快速随机访问，但是增删慢，因为要移动角标；LinkedList随机访问慢，但是增删快。
    4. LinkedList比ArrayList更消耗内存，因为LinkedList中的每个Node都存储了前后节点的引用。

4. ArrayList与Vector有什么区别
    1. 前者线程不安全，后者是在前者的基础上每个方式加了synchronized
    2. 扩容机制不同，但是默认初始值一致
    3. Vector有子类，Stack，也是线程安全的
    4. Vector废了，就算是真的需要同步的时候，也用的是JUC下的CopyOnWriteArrayList
    5. ArrayList因为没有同步，快。
    6. 两个都是动态数组，都支持快速随机访问
    7. ArrayList支持序列化，Vector不支持
    8. ArrayList不支持Enumeration，Vector支持

5. Array和ArrayList
    1. Array可以容纳基本数据类型和对象，但是ArrayList只能放对象
    2. Array可以指定大小，而ArrayList大小是规定的，只能扩容或者再构造的时候设定。
</code></pre><h2 id="ArrayList核心API"><a href="#ArrayList核心API" class="headerlink" title="ArrayList核心API"></a>ArrayList核心API</h2><pre><code>1. public boolean add(E e) ：一直返回的都是true
2. public void add(int index, E element)：把index位置上的对象往后挪
3. public int indexOf(Object o)：返回当前查询对象的角标，Object是null/对象时，返回再List中第一次出现的值，否则返回-1
4. public boolean contains(Object o)：调用的时indexOf方法
5. public E get(int index)：返回当前对象
6. public E set(int index, E element)：返回被替换前这个index位置上的值。
7. public void clear()：清空集合。
8. public boolean addAll(Collection&lt;? extends E&gt; c)
9. public boolean addAll(int index, Collection&lt;? extends E&gt; c) ：这两个方法的返回值是看我们的c的长度，因为方法内部直接会将c先转成数组，
    1. Object[] a = c.toArray();int numNew = a.length;return numNew！=0;
    2. ensureCapacityInternal(size + numNew);
    3. System.arraycopy(a, 0, elementData, size, numNew);
10. public E remove(int index)：返回的是被移除的旧值
11. public boolean remove(Object o)：当前对象是否在List中，返回是否删除成功，不在的话返回false，删除的是第一次出现的当前对象。
</code></pre><h2 id="List的遍历与删除"><a href="#List的遍历与删除" class="headerlink" title="List的遍历与删除"></a>List的遍历与删除</h2><pre><code>1. 遍历也就是简单for，增强for，迭代器
2. 删除的话比较讲究，我们要用index删除的话，必须从后往前删，但是这么做没有意义，那还不如直接调用clear()
3. 有时候会遇到必须要固定删除某一个位置上的，这个时候需要注意，必须每次都重新计算List的长度。
</code></pre><h2 id="ArrayList与LinkedList与Vector"><a href="#ArrayList与LinkedList与Vector" class="headerlink" title="ArrayList与LinkedList与Vector"></a>ArrayList与LinkedList与Vector</h2><pre><code>http://bbblemon.top/2017/10/14/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89/

http://bbblemon.top/2017/10/13/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%EF%BC%89/

http://bbblemon.top/2017/10/16/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89/
</code></pre><h2 id="asList、subList、toArray"><a href="#asList、subList、toArray" class="headerlink" title="asList、subList、toArray"></a>asList、subList、toArray</h2><h3 id="asList"><a href="#asList" class="headerlink" title="asList"></a>asList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"varargs"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span> include</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">import</span> <span class="title">java</span>.<span class="title">util</span>.*</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Integer arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">		List&lt;Integer&gt; list = Arrays.asList(arr);</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		list.set(<span class="number">0</span>, <span class="number">77</span>);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">		arr[<span class="number">5</span>] = <span class="number">100</span>;</span><br><span class="line">		System.out.println(list);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	[1, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="comment">	[77, 2, 3, 4, 5, 6]</span></span><br><span class="line"><span class="comment">	[77, 2, 3, 4, 5, 100]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<pre><code>1.  public static &lt;T&gt; List&lt;T&gt; asList(T... a)
    1.  asList是把一个数组变成了一个集合，但是我们知道集合中的泛型内容可是不能是基本数据类型，所以这个数组中放的必须是对象。
    2.  asList被调用后，直接得到的ArrayList是一个Arrays中的一个内部类（Arrays$ArrayList），这个内部类并没有实现add与remove方法，所以直接改变这个List的长度，会出现异常。java.lang.UnsupportedOperationException
    3.  Arrays$ArrayList继承了AbstractList，所以当我们调用add与remove方法时，调用的时AbtractList的，这两个方法在Abstract中都是直接抛出java.lang.UnsupportedOperationException。
    4.  其实List&lt;Integer&gt; list = Arrays.asList(arr);就把arr与list连接起来了，其实是把我们数组的引用给了list，所以可以同步查看。（当arr和list改变的时候，另一方不可变，比如set(index,Object)，但是不可改变list的长度）
2. 如何利用这个方法把数组转成正真的List
    ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(arr));
</code></pre><h3 id="subList"><a href="#subList" class="headerlink" title="subList"></a>subList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</span><br><span class="line">        subListRangeCheck(fromIndex, toIndex, size);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SubList(<span class="keyword">this</span>, <span class="number">0</span>, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SubList</span> <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Integer arr[] = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">332</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">43</span>,<span class="number">4324</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">53</span>,<span class="number">23</span>,<span class="number">432</span>&#125;;</span><br><span class="line">		ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(arr));</span><br><span class="line">		List&lt;Integer&gt; sub = list.subList(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">		System.out.println(sub);</span><br><span class="line">		sub.add(<span class="number">100</span>);</span><br><span class="line">		System.out.println(sub);</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		</span><br><span class="line">		list.add(<span class="number">111</span>);</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//System.out.println(sub); //编译不错，但是运行时会出错</span></span><br><span class="line">		</span><br><span class="line">		list.subList(<span class="number">0</span>, <span class="number">5</span>).clear();</span><br><span class="line">		System.out.println(list);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	[3, 4, 6, 2, 332]</span></span><br><span class="line"><span class="comment">	[3, 4, 6, 2, 332, 100]</span></span><br><span class="line"><span class="comment">	[3, 4, 6, 2, 332, 100, 3, 1, 43, 4324, 5, 4, 12, 53, 23, 432]</span></span><br><span class="line"><span class="comment">	[3, 4, 6, 2, 332, 100, 3, 1, 43, 4324, 5, 4, 12, 53, 23, 432, 111]</span></span><br><span class="line"><span class="comment">	[100, 3, 1, 43, 4324, 5, 4, 12, 53, 23, 432, 111]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<pre><code>1. public List&lt;E&gt; subList(int fromIndex, int toIndex)
    1. 该方法返回的是父list的一个视图，从fromIndex（包含），到toIndex（不包含）。fromIndex=toIndex 表示子list为空.
    2. 父子list做的非结构性修改（non-structural changes）都会影响到彼此：所谓的“非结构性修改”，是指不涉及到list的大小改变的修改。相反，结构性修改，指改变了list大小的修改。
    3. 对于结构性修改，子list的所有操作都会反映到父list上。但父list的修改将会导致返回的子list失效。java.util.ConcurrentModificationException
2. 如何删除list中的某段数据：
    1. list.subList(from, to).clear();
</code></pre><h3 id="toArray"><a href="#toArray" class="headerlink" title="toArray"></a>toArray</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Integer arr[] = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">332</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">43</span>,<span class="number">4324</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">53</span>,<span class="number">23</span>,<span class="number">432</span>&#125;;</span><br><span class="line">		ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(arr));</span><br><span class="line">		</span><br><span class="line">		arr = (Integer[]) list.toArray();<span class="comment">//编译不报错，运行时报错，类转换异常。</span></span><br><span class="line">		System.out.println(list);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	Exception in thread "main" java.lang.ClassCastException: [Ljava.lang.Object; cannot be cast to [Ljava.lang.Integer;</span></span><br><span class="line"><span class="comment">		at xdd.list.ArrayListTest.main(ArrayListTest.java:9)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">			list.add(i);</span><br><span class="line">		Integer[] arr = <span class="keyword">new</span> Integer[]&#123;&#125;;</span><br><span class="line">		list.toArray(arr);</span><br><span class="line">		System.out.println(arr.length);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	没有定长 输出为0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">正确转换</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line">			list.add(i);</span><br><span class="line">		Integer[] arr = <span class="keyword">new</span> Integer[list.size()];</span><br><span class="line">		list.toArray(arr);</span><br><span class="line">		System.out.println(arr.length);</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">20</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<pre><code>1.  public Object[] toArray()
2.  public &lt;T&gt; T[] toArray(T[] a) : return a;
</code></pre><h2 id="Iterator和Iterable"><a href="#Iterator和Iterable" class="headerlink" title="Iterator和Iterable"></a>Iterator和Iterable</h2><pre><code>http://bbblemon.top/2017/10/16/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89/

http://bbblemon.top/2017/12/01/Java%E9%9D%A2%E8%AF%95%EF%BC%88%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%EF%BC%89/

https://blog.csdn.net/lipengcn/article/details/51700153

https://www.cnblogs.com/nbedk/p/6557341.html

1. 对于我们的Collection、List、Set为什么会直接去实现Iterable而不是Iterator？
Iterator接口中的核心方法next()，hasNext()，remove()，都是依赖当前位置。如果这些集合直接实现Iterator接口，则势必导致集合对象中包含当前迭代位置的数据(指针)。当集合在不同方法间进行传递的时候，由于当前迭代位置不可知，所以next()的结果也不可知。除非再为Iterator接口添加一个reset()方法，用来重置当前迭代位置。 而当实现Iterable则不然，每次调用都返回一个从头开始的迭代器，各个迭代器之间互不影响。
</code></pre><h2 id="fast-fail"><a href="#fast-fail" class="headerlink" title="fast-fail"></a>fast-fail</h2><pre><code>http://bbblemon.top/2017/10/17/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%89/

https://www.cnblogs.com/ccgjava/p/6347425.html?utm_source=itdadao&amp;utm_medium=referral

1. 为什么会发生fast-fail
modCount 不等于 expectedModCount，也就是迭代对象的改变值不等于当前对象的改变值，换句话说，也就是在我们迭代的过程了对集合进行了结构性的改变，所以导致抛出异常。

在某一时刻，“线程a”创建了arrayList的Iterator。
此时“节点A”仍然存在于arrayList中，创建arrayList时，expectedModCount = modCount(假设它们此时的值为N)。
在“线程a”在遍历arrayList过程中的某一时刻，“线程b”执行了，并且“线程b”删除了arrayList中的“节点A”。
“线程b”执行remove()进行删除操作时，在remove()中执行了“modCount++”，此时modCount变成了N+1！

“线程a”接着遍历，当它执行到next()函数时，调用checkForComodification()比较“expectedModCount”和“modCount”的大小；
而“expectedModCount=N”，“modCount=N+1”,这样，便抛出ConcurrentModificationException异常，产生fail-fast事件。
</code></pre><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><pre><code>http://bbblemon.top/2017/10/17/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%EF%BC%89/

http://bbblemon.top/2017/10/18/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%89/

1. HashMap与Hashtable有什么区别？
    1. 底层实现HashMap是数组+链表+转红黑树（6，8）；Hashtable是数组+链表
    2. HashMap线程不安全，Hashtable线程安全（所有方法加了synchronized）
    3. 基类HashMap是Map接口，Hashtable是Dictionary（抽象类，实现了枚举）但是也实现了Map接口。
    4. HashMap用于Key与Value同时为null，Hashtable不允许
    5. HashMap初始容量16，负载因子0.75，2倍扩容，Hashtable初始容量11，负载因子0.75，扩容是2倍+1
    6. HashMap使用Iterator遍历，而Hashtable因为Dictionary实现了Enumeration的原因，所以可以使用枚举迭代。
    7. 计算Entry在table中的位置时，HashMap使用了当前Key的HashCode值高低16位取余作为Key的hash，而Hashtable是直接使用了Key的hashCode
    8. HashMap没有了contains方法，改成了containsKey与containsValue。但是在Hashtable中这三个方法时都有的，不过contains==containsValue，一个东西。

2. HashMap中如何在table[]中定位Node?
    1. (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
    2. if ((p = tab[i = (n - 1) &amp; hash]) == null)
    3. 此处通过（n - 1） &amp; hash 计算出的值作为tab的下标i，并另p表示tab[i]，也就是该链表第一个节点的位置。并判断p是否为null。\

3. 为什么扩容的时候最好是原来的2倍？（定位快和扩容角标号计算）
    1. 我们在计算对象在table[]的位置时，本身应该使用hash%(length-1)，但是由于我们表长总是2的次幂，也就说当length是2的次幂时，我们hash&amp;(length-1)与hash%(length-1)是一致的。但是&amp;要比扩容快的多。
    2. 一旦扩容以后，表长转成2进制，比原来多出一个1，这个时候进行&amp;的时候，原来旧表中的对象，在新表中的位置要不和原来一样，要不就是在原表位置+原表长度的位置上。
    3. （JDK1.7的时候需要重新计算）也就是说我们不需要在rehash的时候重新计算原来key的hash，只需要看hash值新增的那一位是0还是1就可以了。

4. Hashtable中如何在table[]中定位Node？
    1. int hash = key.hashCode();
    2. index = (hash &amp; 0x7FFFFFFF) % tab.length

5. HashMap中put方法的执行顺序？
    http://bbblemon.top/2017/12/28/Java%E9%9D%A2%E8%AF%95%EF%BC%88HashMap&amp;TreeMap&amp;%E7%BA%A2%E9%BB%91%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89/

6. HashMap与WeakHashMap的区别
    1. WeakHashMap的key采用的是&quot;弱引用&quot;的方式，只要WeakHashMap中的key不再被外部引用，它就可以被GC。
    2. HashMap的key是&quot;强引用&quot;的方式，当HashMap中的key没有被外部引用时，只有当这个Key从HashMap中被删除以后，才可以被GC。

7. 如何实现HashMap的同步
    1. Map map = Collections.synchronizedMap(new HashMap&lt;&gt;());

8. 别人知道了源码，故意构造相同的hash的字符进行怎么办
    1. 限制post和get的参数个数，越少越好
    2. 限制post数据包大小
    3. WAF

9. HashMap与ConcurrentHashMap区别
    1. 前者在java.util.*下，线程不安全；ConcurrentHashMap在java.util.concurrent.*包下，线程安全
    2. ConcurrentHashMap把整个Hash桶（table[]）进行了分段（Segment），也就是将整个大的数组分成了几个小的片段segment，而且每个小的片段segment上面都有锁存在，那么在插入元素的时候就需要先找到应该插入到哪一个片段segment，然后再在整个片段上面进行插入，而且还需要获得segment锁。
    3. ConcurrentHashMap让锁的粒度更精细一些，并发性能更好。

10. ConcurrentHashMap如何实现线程安全？
    1. Hashtable在并发环境下表现出效率低下是因为所有访问Hashtable的线程都必须竞争同一把锁，而ConcurrentHashMap使用的就是锁分段技术，先将table[]分成segment，然后给每个segment配一把锁，当一个线程占用访问其中的一个锁时，其他segment的数据可以被别的线程访问。
    2. get操作高效是因为整个get过程不需要加锁，除非读到的值是null才会加锁重读。get方法里将所有使用的共享变量都定义成volatile，让这些变量保持可见性。
    3. put方法首先需要定位到Segment，然后在Segment里进行插入操作，第一步是判断是否对Segment里的HashEntry数据进行扩容，第二步时定位添加元素位置然后放在HashEntry数据里。
</code></pre><h2 id="Map的核心API与迭代"><a href="#Map的核心API与迭代" class="headerlink" title="Map的核心API与迭代"></a>Map的核心API与迭代</h2><pre><code>1. public V put(K key, V value)：返回这个Key对应的之前的Value，如果之前没有Key，那么一定返回的是null
2. public V get(Object key)
3. public boolean containsKey(Object key)
4. public boolean containsValue(Object value)
5. public V replace(K key, V value)：返回oldValue，如果这个Key不存在，返回null
6. public Collection&lt;V&gt; values()：返回map的值的集合（去重的）！！！Collection
7. public V remove(Object key)：返回oldValue或者null
8. public void putAll(Map&lt;? extends K, ? extends V&gt; m)
</code></pre><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="HashMap数据结构"><a href="#HashMap数据结构" class="headerlink" title="HashMap数据结构"></a>HashMap数据结构</h3><pre><code>http://bbblemon.top/2017/10/15/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89/

1. public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
implements Map&lt;K,V&gt;, Cloneable, Serializable 

2. transient Node&lt;K,V&gt;[] table;

3. static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;

4. Map.Entry&lt;K,V&gt;：Map&lt;K,V&gt;接口中的内部接口Entry&lt;K,V&gt;
</code></pre><h3 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h3><pre><code>http://bbblemon.top/2017/12/28/Java%E9%9D%A2%E8%AF%95%EF%BC%88HashMap&amp;TreeMap&amp;%E7%BA%A2%E9%BB%91%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89/

http://bbblemon.top/2017/10/16/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89/

http://bbblemon.top/2017/10/15/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89/
</code></pre><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><pre><code>http://bbblemon.top/2017/10/15/JavaSE%E5%9F%BA%E7%A1%80%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89/
</code></pre><h2 id="Collection和Collections核心方法"><a href="#Collection和Collections核心方法" class="headerlink" title="Collection和Collections核心方法"></a>Collection和Collections核心方法</h2><pre><code>http://bbblemon.top/2017/12/25/Java%E5%88%B7%E9%A2%98%EF%BC%88%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98%EF%BC%89/

1. public static void reverse(List&lt;?&gt; list)
2. public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)
3. public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)
4. public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T max(Collection&lt;? extends T&gt; coll)
5.  public static &lt;T extends Object &amp; Comparable&lt;? super T&gt;&gt; T min(Collection&lt;? extends T&gt; coll)
</code></pre><h2 id="线程安全的集合（java-util-）"><a href="#线程安全的集合（java-util-）" class="headerlink" title="线程安全的集合（java.util.*）"></a>线程安全的集合（java.util.*）</h2><pre><code>1. Hashtable,Vector,Properties,Stack
</code></pre><h2 id="Comparable和Comparator"><a href="#Comparable和Comparator" class="headerlink" title="Comparable和Comparator"></a>Comparable和Comparator</h2><pre><code>1. Comparator位于包java.util下，而Comparable位于包java.lang
2. Comparable里面是 public int compareTo(T o);
3. Comparator里面是int compare(T o1, T o2);
</code></pre><h1 id="线程（重点-OS-amp-Java）"><a href="#线程（重点-OS-amp-Java）" class="headerlink" title="线程（重点 OS &amp; Java）"></a>线程（重点 OS &amp; Java）</h1><pre><code>http://bbblemon.top/2017/12/28/Operating%20System%EF%BC%88%E5%BC%95%E8%AE%BA&amp;%E8%BF%9B%E7%A8%8B&amp;%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%EF%BC%89/
</code></pre><h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><pre><code>1. 进程是系统可拥有资源的基本单元，线程是处理机调度和分配的基本单元（能独立运行的基本单元）
2. 并发性：线程是轻量级的进程，一个进程中的多个线程可以并发执行。
3. 拥有资源：进程可以拥有资源，而线程本身并不拥有系统资源，而是仅有一点必不可少、能保证独立运行的资源（TCB、程序计数器、保留局部变量、少数状态参数和返回地址等一组寄存器和堆栈）。
4. 线程除了有自己的资源外，还共享了自己所属进程的资源。属于同一进程的所有线程都具有相同的地址空间，线程可以访问这个地址上的每一个虚地址！！！同时可以访问：已打开的文件、定时器、信号量机构等内存空间和进程所申请到的I/O设备等
5. 独立性：每个进程都有自己独立的地址空间和其他资源，除了共享全局变量外，不允许其他进程的访问。而同一进程的所有线程都可以访问所属进程空间中的所有地址。
6. 系统开销：创建、切换、撤销进程的开销比较大。

注意：一个进程中至少有一个线程，CPU上可以没有运行的进程；一个线程只能属于某一个特定的进程；
</code></pre><h2 id="为什么使用多线程"><a href="#为什么使用多线程" class="headerlink" title="为什么使用多线程"></a>为什么使用多线程</h2><pre><code>1. 多核CPU的使用
2. 线程的切换和创建开销更小。
3. 多线程可以减少程序执行的时间
</code></pre><h2 id="线程异步与同步"><a href="#线程异步与同步" class="headerlink" title="线程异步与同步"></a>线程异步与同步</h2><pre><code>1. 同步：一个请求发出后，必须要等到响应才能执行下面的程序。
2. 异步：一个请求发出后，不需要等到响应就可以执行下面的程序。
</code></pre><h2 id="如何实现同步"><a href="#如何实现同步" class="headerlink" title="如何实现同步"></a>如何实现同步</h2><pre><code>必须要获得每一个线程对象的锁。获得它可以保证在同一时刻只有一个线程能够进入临界区（访问互斥资源的代码块），并且在这个锁被释放前，其他线程不能再进入到这个临界区。如果其他线程还想要获得该对象的锁，只能进入等待队列等待。只有当拥有该对象锁的线程退出临界区，锁才会被释放，等待队列中优先级最最高的线程才能获得该锁，从而进入共享代码区。
</code></pre><h2 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h2><p><img src="http://oxk1vrcj4.bkt.clouddn.com/20150309140927553.jpg" alt=""></p>
<pre><code>1、新建状态（New）：新创建了一个线程对象。
2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。
3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。
4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：
    （一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)
    （二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
    （三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）
5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。
</code></pre><h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><pre><code>1. 继承Thread类，重写run函数
2. 实现Runnable接口
3. 实现Callable接口

简单区别:
1. 实现Runnable接口可以避免Java单继承带来的局限性，代码能够被多个线程共享，代码与数据是独立的，适合多个相同程序代码的线程区处理同一资源。
2. 继承Thread类和实现Runnable方法启动线程都是使用start方法，然后JVM虚拟机将此线程放到就绪队列中，如果有处理机可用，则执行run方法
3. 实现Callable接口要实现call方法，并且线程执行完毕后会有返回值。其他两种都没有返回值。
4. 不管是继承Thread还是实现Runnable，最终还是通过Thread对象的API来控制线程。
5. Thread类中的run方法是一个空方法。
</code></pre><h3 id="Thread与Runnable的区别"><a href="#Thread与Runnable的区别" class="headerlink" title="Thread与Runnable的区别"></a>Thread与Runnable的区别</h3><pre><code>1. 为什么用实现的方式好？
    1. 当一个类需要被修改或者是加强的时候，我们才会使用Thread
    2. 使用实现Runnable这种方式可以方便资源共享（synchronized(this)加锁代码块），可以实现多个Thread，共用一个实现Runnable的对象。
    3. 实现了Runnable可以让类去继承别的类。
</code></pre><h3 id="Callable与Future"><a href="#Callable与Future" class="headerlink" title="Callable与Future"></a>Callable与Future</h3><pre><code>https://www.cnblogs.com/MOBIN/p/6185387.html

https://blog.csdn.net/javazejian/article/details/50896505

1. Callable的执行流程？
    1. Callable是个泛型参数化接口，并能返回线程的执行结果，且能在无法正常计算时抛出异常
    2. Callable并不像Runnable那样通过Thread的start方法就能启动实现类的run方法，所以它通常利用ExecutorService的submit方法去启动call方法自执行任务，而ExecutorService的submit又返回一个Future类型的结果，因此Callable通常也与Future一起使用。
    3. 利用FutureTask封装Callable再由Thread去启动
2. Callable和Future？

3. Future的get方法？

4. Runnable和Callable的区别？
    1. Callable可以再任务结束后提供一个返回值，Runnable没有这个功能。
    2. Callable中的call()方法，可以在无法实现正常计算的时候抛出异常，而run方法不可以。
    3. 运行Callable可以拿到一个Future对象，Future对象表示异步计算的结果，它提供了检查计算是否完成的方法。
    4. 由于线程属于异步计算模型，因此无法从别的线程中得到函数的返回值，在这种情况下，就可以使用Future来监控目标线程调用call方法的情况，当调用Future的get方法获取结果时，当前线程就会阻塞，直到call方法结束返回结果。
</code></pre><h2 id="start与run"><a href="#start与run" class="headerlink" title="start与run"></a>start与run</h2><pre><code>1. start方法用来启动一个线程，run方法定义线程执行的主要任务
2. 别的线程调用了另一个线程的start方法，就让这个方法从ready--&gt;runnable，等待处理机调度。一旦这个线程拿到了CPU的时间片，那么就CPU就开始执行这个线程中run方法中定义的方法体。run方法执行完成后，线程就会被终止。
3. 如果直接调用这个线程对象的run方法，就还是只有原来的那个线程，并不会开启线程，就和调用一个普通的方法没有任何区别，程序在原线程上顺序执行。
就是说使用start可以异步的调用run方法，但是直接调用却是同步调用。
</code></pre><h2 id="什么是锁（多线程同步实现方法有哪些）"><a href="#什么是锁（多线程同步实现方法有哪些）" class="headerlink" title="什么是锁（多线程同步实现方法有哪些）"></a>什么是锁（多线程同步实现方法有哪些）</h2><pre><code>当多个线程同时需要对同一个资源进行访问的时候，那么可能会出现混乱，如果当多个线程要改动这个资源里面的顺序时，会导致某些线程对数据的修改丢失（volatile说的是修改后的可见性），所以需要使用同步机制来解决这个问题。
也就是加锁。

1. sunchronized，对象锁，每个对象有一个锁。
2. Lock接口，ReentrantLock（可重入互斥锁）。
</code></pre><h2 id="synchronized用在代码块和方法上有什么区别"><a href="#synchronized用在代码块和方法上有什么区别" class="headerlink" title="synchronized用在代码块和方法上有什么区别"></a>synchronized用在代码块和方法上有什么区别</h2><pre><code>1. synchronized用在代码块中锁住的是调用这个代码块的对象(this),也可以选择锁住任何一个对象
2. synchronized用在方法是锁住的调用这个方法的对象
3. synchronized用在代码块可以减少锁的粒度，从而提高并发性
4. 无论是用在代码块还是方法上，都是获取了某个对象（调用方法的对象和某个加锁对象）的锁，但是每个对象只有一个锁，所以利用synchronized实现同步的时候需要很大的系统开销，甚至造成死锁，所以一般不要做无谓的同步。
</code></pre><h2 id="synchronized与static-synchronized的区别"><a href="#synchronized与static-synchronized的区别" class="headerlink" title="synchronized与static synchronized的区别"></a>synchronized与static synchronized的区别</h2><pre><code>1. synchronized是对某个类的某个实例对象进行加锁，防止其他线程访问这个类的这个实例中其他的synchronized方法（块），但是同一个类的不同实例就没有这个约束了。
2. static synchronized是对某个类的所有实例都加锁了，不管别的线程有多少的实例对象，都不能访问已经加锁的方法。
</code></pre><h2 id="synchronized的缺陷"><a href="#synchronized的缺陷" class="headerlink" title="synchronized的缺陷"></a>synchronized的缺陷</h2><pre><code>1. 效率问题，就是说当一个线程占有了某个对象的锁时，其他线程无法访问，虽然这个样子防止了多个线程同时对某个资源进行写操作时引起的问题，但是如果这些别的线程也都只是进行读操作的时候，这个synchronized就比较无力了。
2. Lock就可以做到，当别的线程只是读操作的时候，可以多个线程同时访问一个资源。而且Lock可以知道线程是否已经拿到了锁，这个是synchronzied无法做到的。但是Lock必须手动去释放锁，不然可能死锁，这个和synchronzied不同。
</code></pre><h2 id="synchronized的底层实现"><a href="#synchronized的底层实现" class="headerlink" title="synchronized的底层实现"></a>synchronized的底层实现</h2><pre><code>进入时，执行monitorenter，将计数器+1，释放锁时，monitorexit，计数器-1。
当一个线程判断计数器是0时，则当前锁空闲，可以占用，反之，等待。

Synchronized是一种对象锁，对象锁是一种重量锁（monitor）,Synchronized的锁机制会根据线程竞争情况在运行时会有偏向锁，自旋锁等。
</code></pre><h2 id="sleep与wait"><a href="#sleep与wait" class="headerlink" title="sleep与wait"></a>sleep与wait</h2><pre><code>http://www.cnblogs.com/skywang12345/p/3479224.html

1. sleep是Thread的方法，让当前线程睡眠，但是并没有释放锁。（没有线程通信）
2. wait是Object的方法，让CPU当先执行的线程等待（不是哪个线程对象调用了就让哪个线程等待了），线程进入等待对象，等待别的线程调用notify，notifyAll唤醒（从等待队列进入了锁池，一旦拿到了锁，就进入可运行状态）。（有线程通信）
3. wait方法的必须放在同步控制方法或者同步语句块中使用，而sleep()可以在任何地方使用。
4. sleep与wait都会抛出受检异常（InterruptException），但是notify，notifyAll不会。
</code></pre><h2 id="sleep与yield"><a href="#sleep与yield" class="headerlink" title="sleep与yield"></a>sleep与yield</h2><pre><code>yield是让当前运行的线程进入可运行状态（有点像当前线程在CPU上的某个时间片被用完了）
1. sleep()方法给其他线程运行机会时，不会考虑线程的优先级，因此会给低优先级的线程以运行的机会。而yield方法只会给相同优先级或更高优先级的线程以运行的机会。
2. 线程执行sleep方法后会转入阻塞状态，而yield是进入了可执行态。
3. sleep抛出了受检异常，而yield没有
</code></pre><h2 id="死锁（OS，银行家算法）"><a href="#死锁（OS，银行家算法）" class="headerlink" title="死锁（OS，银行家算法）"></a>死锁（OS，银行家算法）</h2><pre><code>比如有两个线程A，B，和两个对象a,b。现在A正在调用a,调用a之后A想调用b。B正在使用b,调用完b，之后想调动a。于是A,B 两个线程分别抱着a,b的锁不放开，互相等对方放开锁，然后自己就可以执行下一步。于是程序就发生了死锁。
</code></pre><h2 id="如何保证线程安全"><a href="#如何保证线程安全" class="headerlink" title="如何保证线程安全"></a>如何保证线程安全</h2><pre><code>1. 对变量使用volatile。
2. 对程序段进行加锁。
</code></pre><h2 id="多线程共用一个数据变量需要注意什么"><a href="#多线程共用一个数据变量需要注意什么" class="headerlink" title="多线程共用一个数据变量需要注意什么"></a>多线程共用一个数据变量需要注意什么</h2><pre><code>1. ThreadLocal是JDK引入的一种机制，它用于解决线程之间共享变量，使用ThreadLocal声明的变量，即使实在线程中属于静态成员，针对每个线程而言，这个变量也是独立的。
2. volatile是每次被线程访问，都强迫线程从主内存中重读该变量的最新值，而当该变量发生修改的时候，也会强迫线程将最新值刷新进入主内存。
</code></pre><h2 id="Volatile如何保证内存可见性"><a href="#Volatile如何保证内存可见性" class="headerlink" title="Volatile如何保证内存可见性"></a>Volatile如何保证内存可见性</h2><pre><code>https://www.jianshu.com/p/195ae7c77afe

http://www.importnew.com/27002.html

http://www.importnew.com/24082.html

在JVM中，有主内存和工作内存的概念，每个线程对应一个工作内存，并共享主内存数据，
1. 对于普通变量：读操作会优先读取工作内存的数据，如果工作内存不存在，则从主内存中拷贝一份数据到工作内存，写操作只会修改工作内存中的副本数据，这种情况下，其他线程就无法读取变脸的最新值。
2. 对于volatile变量：读操作时JVM会把工作内存中对应的值设置为无效，要求线程从主内存中读取数据，写操作JVM也会把工作内存中对应的数据刷新到主内存中，这种情况下，其他线程就可以读取变量的最新值。

volatile变量的内存可见性，是基于内存屏蔽实现的，内存屏蔽也就是一个CPU指令。在程序运行的时候，为了提高执行性能，编译器和处理器会对指令进行重排序，JVM为了保证不同的编译器和CPU上有相同的结果，通过插入特定类型的内存屏蔽来禁止特定类型的编译器重排序和处理器重排序，插入一条内存屏蔽会告诉编译器和CPU，不管什么指令都不能和这条内存屏蔽指令重排序。

处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。

如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。

但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的。

1. volatile只保证了可见性和防止了指令重排序，并没有保证原子性。
2. volatile修饰的变量只是保证了每次读取时都从主存中读，每次修改时，都将修改后的值重新写入了主存。
3. 在synchronized修饰的方法体或者常量（final）不需要使用volatile。
4. 由于使用了volatile屏蔽掉了JVM中必要的代码优化，所以在效率上比较低，因此一定在必要的时候才能使用该关键字。
</code></pre><h2 id="Volatile如何禁止指令重排序"><a href="#Volatile如何禁止指令重排序" class="headerlink" title="Volatile如何禁止指令重排序"></a>Volatile如何禁止指令重排序</h2><pre><code>1. 编译器重排序：编译器在不改变单线程语义的前提下，为了提高程序的运行速度，可以对字节码进行重新排序。

2. 指令重排序：就是JVM给CPU发送的指令前面加一个lock。
</code></pre><h2 id="volatile和synchronized的区别"><a href="#volatile和synchronized的区别" class="headerlink" title="volatile和synchronized的区别"></a>volatile和synchronized的区别</h2><pre><code>1. volatile不会进行加锁操作。
2. volatile变量作用类似于同步变量读写操作。
3. volatile不如synchronized安全。
4. volatile无法同时保证内存可见性和原子性，加锁（synchronized）不但保证了可见性而且保证了原子性。
</code></pre><h2 id="Synchronized与lock"><a href="#Synchronized与lock" class="headerlink" title="Synchronized与lock"></a>Synchronized与lock</h2><pre><code>1. （用法）synchronized（隐式锁）：在需要同步的对象中加入此控制，synchronized可以加在方法上，也可以加在特定的代码块中，括号中表示需要锁的对象。
2. （用法）Lock（显式锁）：需要显式指定起始和终止位置，一般使用ReentrantLock类作为锁，线程中需要使用一个ReentrantLock类作为对象才能保证锁生效。且在加锁和解锁处需要通过lock和unlock显示指出。所以一般会在finally块中写unlock防止死锁。
3. （性能）synchronized是托管给JVM执行的，而Lock是Java写的控制锁代码。（JDK1.5）synchronized是一个重量级的锁，需要调用操作接口，导致有可能加锁消耗的系统时间比加锁以外的时间还多。（JDK1.6）synchronized出现了很多锁，所以性能上提高了。
4. （机制）synchronized原始采用CPU悲观锁机制，即线程获得的是独占锁，独占锁以为着其他线程只能依靠阻塞来等待线程释放锁。Lock用的是乐观锁，也就是每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功。乐观锁的机制其实就是CAS。
</code></pre><h2 id="synchronized和ReentrantLock-CAS-的区别"><a href="#synchronized和ReentrantLock-CAS-的区别" class="headerlink" title="synchronized和ReentrantLock(CAS)的区别"></a>synchronized和ReentrantLock(CAS)的区别</h2><pre><code>1. 可重入性/互斥：两个都是可重入/互斥的，区别不大
2. 锁的实现：synchronized是依赖JVM实现的，而ReenTrantLock是JDK实现，是实现了Lock的类，说白了类似一于OS来控制实现和自己写代码实现。
3. 性能：1.6以前区别比较大，1.6以后就没有撒区别的了。
4. 功能：synchronized使用简单，而且编译器去保证锁的加入和释放，而ReentrantLock必须自己显式的加载和释放锁。但是ReentrantLock的粒度小。
5. Reentrant可以指定式公平锁还是非公平锁，但是synchronized都是非公平锁。（公平非公平是看释放锁以后等待队列中的线程是不是按照等待时间的长短来得到锁）
6. ReentrantLock提供了Condition类，用来实现分组唤醒需要唤醒的线程。
7. ReentrantLock提供了一种能够终端等待锁的线程的机制（lock.lockInterruptibly）。
</code></pre><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><pre><code>简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个开地址法实现的Thread.ThreadLocalMap，把数据进行隔离，数据不共享，自然没有线程安全的问题。

Entry中的Key是一个ThreadLocal实例，Value是一个线程持有对象。Entry的作用就是，为其属主线程建立起一个ThreadLocal实例与一个线程持有对象之间的对应关系。

Entry对Key是弱引用，对Value是强引用。
</code></pre><h2 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h2><pre><code>就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程，不需要自己创建，使用完了放回线程池而不是销毁，从而减少创建和销毁对象的开销。

1. 线程管理（ThreadPool）：用于创建并管理线程池，包括创建线程，销毁线程池，添加新任务。
2. 工作线程（PoolWoker）：线程中线程在没有任务时处于等待状态，可以循环的执行任务。
3. 任务接口（Task）:每个任务必须实现的接口，以供工作线程调度任务的执行。
4. 任务队列（TaskQueue）：用于存放没有处理的任务。
</code></pre><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><pre><code>GCor就是一个守护线程的例子
</code></pre><h2 id="JUC包"><a href="#JUC包" class="headerlink" title="JUC包"></a>JUC包</h2><h2 id="JUC包下的线程安全集合"><a href="#JUC包下的线程安全集合" class="headerlink" title="JUC包下的线程安全集合"></a>JUC包下的线程安全集合</h2><h2 id="CopyOnWriteArrayList（线程安全的ArrayList）"><a href="#CopyOnWriteArrayList（线程安全的ArrayList）" class="headerlink" title="CopyOnWriteArrayList（线程安全的ArrayList）"></a>CopyOnWriteArrayList（线程安全的ArrayList）</h2><pre><code>http://www.cnblogs.com/skywang12345/p/3498483.html
</code></pre><h3 id="CopyOnWriteArrayList的数据结构"><a href="#CopyOnWriteArrayList的数据结构" class="headerlink" title="CopyOnWriteArrayList的数据结构"></a>CopyOnWriteArrayList的数据结构</h3><pre><code>1. public class CopyOnWriteArrayList&lt;E&gt;
implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable

2. final transient ReentrantLock lock = new ReentrantLock();

3. private transient volatile Object[] array;

4. CopyOnWriteArrayList的&quot;动态数组&quot;机制，内部的transient volatile array[]来保存数据，增删改都是会先拿到ReentrantLock锁，然后加锁，拿到array[]后，将array[]的引用赋值给方法内部的局部数组，接着得到原数组长度，进行数组复制（Arrays.copyof(oldArray,oldLength+1)）得到新的数组，数组修改后，将新数组的引用由返回给array，最后释放锁。
其实这个东西因为在修改数组的过程中，都是拿锁，复制数组以创建新的数组，然后又赋值，所以比较慢，但是如果只是随机访问的话，和ArrayList没什么大的区别。

5. CopyOnWriteArrayList的&quot;线程安全&quot;机制，通过volatile和互斥锁来实现。
    1. volatile保证了array[]的可见性和防止了指令重排序。
    2. ReentrantLock（互斥锁，独占锁），增删改数组的时候，都要先那到锁，修改完毕后再把数据更新到array[]数组，然后再释放锁
</code></pre><h3 id="CopyOnWriteArrayList部分源码"><a href="#CopyOnWriteArrayList部分源码" class="headerlink" title="CopyOnWriteArrayList部分源码"></a>CopyOnWriteArrayList部分源码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">       <span class="keyword">return</span> array;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Sets the array.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">       array = a;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line">           <span class="keyword">int</span> len = elements.length;</span><br><span class="line">           Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">           newElements[len] = e;</span><br><span class="line">           setArray(newElements);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line">           <span class="keyword">int</span> len = elements.length;</span><br><span class="line">           <span class="keyword">if</span> (index &gt; len || index &lt; <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index+</span><br><span class="line">                                                   <span class="string">", Size: "</span>+len);</span><br><span class="line">           Object[] newElements;</span><br><span class="line">           <span class="keyword">int</span> numMoved = len - index;</span><br><span class="line">           <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">               newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               newElements = <span class="keyword">new</span> Object[len + <span class="number">1</span>];</span><br><span class="line">               System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">               System.arraycopy(elements, index, newElements, index + <span class="number">1</span>,</span><br><span class="line">                                numMoved);</span><br><span class="line">           &#125;</span><br><span class="line">           newElements[index] = element;</span><br><span class="line">           setArray(newElements);</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line">           <span class="keyword">int</span> len = elements.length;</span><br><span class="line">           E oldValue = get(elements, index);</span><br><span class="line">           <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">               setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">               System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">               System.arraycopy(elements, index + <span class="number">1</span>, newElements, index,</span><br><span class="line">                                numMoved);</span><br><span class="line">               setArray(newElements);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> oldValue;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Object[] elements = getArray();</span><br><span class="line">           E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">               <span class="keyword">int</span> len = elements.length;</span><br><span class="line">               Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">               newElements[index] = element;</span><br><span class="line">               setArray(newElements);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">               setArray(elements);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> oldValue;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> (E) a[index];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(E e, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">       Object[] elements = getArray();</span><br><span class="line">       <span class="keyword">return</span> indexOf(e, elements, index, elements.length);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o, Object[] elements,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> index, <span class="keyword">int</span> fence)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; fence; i++)</span><br><span class="line">               <span class="keyword">if</span> (elements[i] == <span class="keyword">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; fence; i++)</span><br><span class="line">               <span class="keyword">if</span> (o.equals(elements[i]))</span><br><span class="line">                   <span class="keyword">return</span> i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><pre><code>http://www.cnblogs.com/skywang12345/p/3498537.html

https://www.cnblogs.com/study-everyday/p/6430462.html

https://blog.csdn.net/fouy_yun/article/details/77816587

https://segmentfault.com/a/1190000009001468

https://blog.csdn.net/fjse51/article/details/55260493
</code></pre><h3 id="ConcurrentHashMap的数据结构（JDK1-7）"><a href="#ConcurrentHashMap的数据结构（JDK1-7）" class="headerlink" title="ConcurrentHashMap的数据结构（JDK1.7）"></a>ConcurrentHashMap的数据结构（JDK1.7）</h3><p><img src="http://oxk1vrcj4.bkt.clouddn.com/764863-20160620202714522-1795796503.png" alt=""></p>
<pre><code>1. public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
implements ConcurrentMap&lt;K,V&gt;, Serializable 

2. Segment是ConcurrentHashMap中的内部类，它就是ConcurrentHashMap中&quot;锁分段&quot;对应的数据结构。一个ConcurrentHashMap中有多个Segment对象，因为ConcurrentMap中有一个Segment数组。

3. Segment继承自ReentrantLock，所以Segment本质上就是一个可重入的互斥锁

4. HashEntry也是ConcurrentHashMap的内部类，是个单向链表结构，存储Key-Value对。Segment和HashEntry是组合关系，Segment中存在HashEntry数组成员。

5. static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt;

6. transient volatile Node&lt;K,V&gt;[] table;

7. private transient volatile Node&lt;K,V&gt;[] nextTable;


在JDK1.6中，ConcurrentHashMap将数据分成一段一段存储，给每一段数据配一把锁，当一个线程获得锁互斥访问一个段数据时，其他段的数据也可被其他线程访问；每个Segment拥有一把可重入锁，因此ConcurrentHashMap的分段锁数目即为Segment数组长度（16）。ConcurrentHashMap结构：每一个segment都是一个HashEntry&lt;K,V&gt;[] table， table中的每一个元素本质上都是一个HashEntry的单向队列（单向链表实现）。每一个segment都是一个HashEntry&lt;K,V&gt;[] table， table中的每一个元素本质上都是一个HashEntry的单向队列。

当一个线程访问Node/键值对数据时，必须获得与它对应的segment锁，其他线程可以访问其他Segment中的数据（锁分离）；
</code></pre><h3 id="ConcurrentHashMap的数据结构（JDK1-8）"><a href="#ConcurrentHashMap的数据结构（JDK1-8）" class="headerlink" title="ConcurrentHashMap的数据结构（JDK1.8）"></a>ConcurrentHashMap的数据结构（JDK1.8）</h3><p><img src="http://oxk1vrcj4.bkt.clouddn.com/UC%E6%88%AA%E5%9B%BE20170409172233.png" alt=""></p>
<pre><code>JDK1.8的实现已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作（CAS+Synchronized），整个看起来就像是优化过且线程安全的HashMap，虽然在JDK1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧版本

1. ConcurrentHashMap底层数据结构与HashMap相同，仍然采用table数组+链表+红黑树结构；
2. 一个线程进行put/remove操作时，对桶（链表 or 红黑树）加上synchronized独占锁；
3. ConcurrentHashMap采用CAS算法保证线程安全；
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table：键值对桶数组</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable： rehash扩容时用到的新键值对数组</span><br><span class="line">	</span><br><span class="line">	private transient volatile long baseCount：&lt;span id = "jump1"&gt;&lt;/span&gt;记录当前键值对总数，通过CAS更新，对所有线程可见</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl</span><br><span class="line">	</span><br><span class="line">	sizeCtl表示键值对总数阈值，通过CAS更新, 对所有线程可见</span><br><span class="line">	</span><br><span class="line">	当sizeCtl &lt; <span class="number">0</span>时，表示多个线程在等待扩容；</span><br><span class="line">	</span><br><span class="line">	当sizeCtl = <span class="number">0</span>时，默认值；</span><br><span class="line">	</span><br><span class="line">	当sizeCtl &gt; <span class="number">0</span>时，表示扩容的阈值；</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellBusy：自旋锁；</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells: counter cell表，长度总为<span class="number">2</span>的幂次；</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;：在<span class="title">JDK1</span>.8中，<span class="title">Segment</span>类仅仅在序列化和反序列化时发挥作用；</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">	<span class="title">static</span> <span class="title">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">	    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">	    <span class="keyword">final</span> K key;</span><br><span class="line">	    <span class="comment">// 键值对的value和next均为volatile类型</span></span><br><span class="line">	    <span class="keyword">volatile</span> V val;</span><br><span class="line">	    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">	    ...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ConcurrentHashMap部分源码（JDK1-8）"><a href="#ConcurrentHashMap部分源码（JDK1-8）" class="headerlink" title="ConcurrentHashMap部分源码（JDK1.8）"></a>ConcurrentHashMap部分源码（JDK1.8）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不断CAS探测，如果其他线程正在修改tab，CAS尝试失败，直到成功为止</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 空表，对tab进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * CAS探测空桶</span></span><br><span class="line"><span class="comment">         * 计算key所在bucket表中数组索引: i = (n - 1) &amp; hash)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// CAS添加新键值对</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检测到tab[i]桶正在进行rehash,</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 对桶的首元素上锁独占</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 桶中键值对组织形式是链表</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="comment">// 查找到对应键值对，更新值</span></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 桶中没有对应键值对，插入到链表尾部</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 桶中键值对组织形式是红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查桶中键值对总数</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 链表转换为红黑树</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新baseCount</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> (f) &#123;&#125;操作通过对桶的首元素 = 链表表头 Or 红黑树根节点加锁，从而实现对整个桶进行加锁，有锁分离思想的体现；</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get方法通过CAS保证键值对的原子性，当tab[i]被锁住，CAS失败并不断重试，保证get不会出错；</span><br></pre></td></tr></table></figure>
<h4 id="table原子操作"><a href="#table原子操作" class="headerlink" title="table原子操作"></a>table原子操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">获取tab[i]：tabAt</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function">Node&lt;K,V&gt; <span class="title">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE);</span><br><span class="line">&#125;</span><br><span class="line">tabAt方法原子读取table[i]；调用Unsafe对象的getObjectVolatile方法获取tab[i]，由于对<span class="keyword">volatile</span>写操作happen-before于<span class="keyword">volatile</span>读操作，因此其他线程对table的修改均对get读取可见；</span><br><span class="line">((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE)计算i元素的地址</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CAS算法更新键值对：casTabAt</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">casTabAt通过compareAndSwapObject方法比较tabp[i]和v是否相等，相等就用c更新tab[i];</span><br><span class="line"></span><br><span class="line">更新键值对：setTabAt</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">void</span> <span class="title">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i, Node&lt;K,V&gt; v)</span> </span>&#123;</span><br><span class="line">    U.putObjectVolatile(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, v);</span><br><span class="line">&#125;</span><br><span class="line">仅在<span class="keyword">synchronized</span>同步块中被调用，更新键值对；</span><br></pre></td></tr></table></figure>
<h3 id="JDK1-7和JDK1-8的区别"><a href="#JDK1-7和JDK1-8的区别" class="headerlink" title="JDK1.7和JDK1.8的区别"></a>JDK1.7和JDK1.8的区别</h3><pre><code>1. JDK1.8的实现降低锁的粒度，JDK1.7版本锁的粒度也是基于Segment的，包含了一个HashEntry数组，而JDK1.8锁的粒度是HashEntry（Node）
2. JDK1.8的数据结构变简单了，使用synchronized来进行同步，不再需要分段锁的概念
3. JDK1.8使用红黑树来优化了链表
4. JDK1.8为什么使用synchronized和ReentrantLock
    1. 因为锁的粒度降低了，synchronized并不比ReentrantLock差
    2. 大量数据操作下，对于JVM的内存压力，基于API的ReentrantLock会开销更多的内存。
5. 定位节点的hash算法被简化了。
6. JDK1.7使用锁分段技术，每个Segment有一个ReentrantLock，而JDK1.8取消了Segment这个数据结构，直接使用Node&lt;K,V&gt; table[]来存储键值对，JDK1.8中，一个线程每次对一个桶（链表 or 红黑树）进行加锁，其他线程仍然可以访问其他桶。
</code></pre><h3 id="ConcurrentHashMap的并发度是什么"><a href="#ConcurrentHashMap的并发度是什么" class="headerlink" title="ConcurrentHashMap的并发度是什么"></a>ConcurrentHashMap的并发度是什么</h3><pre><code>1. 对于JDK1.7而言，就是Segment数组的大小，默认是16，这意味着最多同时有16条线程操作ConcurrentHashMap，这也就是JDK1.7时候ConcurrentHashMap对Hashtable的最大优势，Hashtable能同时有两条线程获取Hashtable中的数据吗？

2. 对于JDK1.8而言，因为没有了Segment这个数据结构，都是数组+链表+红黑树，但是再putVal这种操作中，还是使用synchronized+CAS算法对桶（链表/红黑书）进行了加锁，一个桶一个锁。
</code></pre><h2 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h2><pre><code>1. 悲观锁比如synchronized锁，为确保其他线程不会干扰当前线程工作，因此挂起其他需要锁的线程，等待持有锁的线程释放；

2. 乐观锁总是假设没有冲突发生去做操作，如果检测到冲突就失败重试，知道成功为止；
</code></pre><h2 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h2><pre><code>AbstractQueuedSychronizer（抽象队列同步器）。如果说JUC的基础是CAS，那么AQS就是JUC的核心，AQS以双向队列的形式连接所有的Entry。
</code></pre><h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><pre><code>http://ifeve.com/compare-and-swap/

http://www.cnblogs.com/Mainz/p/3546347.html?utm_source=tuicool&amp;utm_medium=referral

CAS的全称叫“Compare And Swap”，也就是比较与交换，他的主要操作思想是： 
首先它具有三个操作数，a、内存位置V，预期值A和新值B。如果在执行过程中，发现内存中的值V与预期值A相匹配，那么他会将V更新为新值A。如果预期值A和内存中的值V不相匹配，那么处理器就不会执行任何操作。CAS算法就是我再技术点中说的“无锁定算法”，因为线程不必再等待锁定，只要执行CAS操作就可以，会在预期中完成。

1. CAS(Compare And Swap)：CAS算法包含三个参数CAS(V, E, N)，判断预期值E和内存旧值是否相同(Compare)，如果相等用新值N覆盖旧值V(Swap)，否则失败；

2. 当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，其他线程失败（失败线程不会被阻塞，而是被告知“失败”，可以继续尝试）；

3. CAS在硬件层面可以被编译为机器指令执行，因此性能高于基于锁占有方式实现线程安全；
</code></pre><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><pre><code>Java内存模型。
1. 可见性（任务内存和主内存的关系，Volatile）
2. happens-before，先行发生原则，定义了操作A必然先行发生于B操作的一些规则，比如同一个线程内控制流前面的代码一定先行发生于控制流后面的代码，一个unlock的方法一定发生在lock操作的后面等等，如果符合这些规则，则不需要额外的同步操作，如果某段代码不符合所有的happens-before规则，则这段代码一定是非线程安全的。
</code></pre><h2 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h2><h2 id="ReadWriteLock是什么"><a href="#ReadWriteLock是什么" class="headerlink" title="ReadWriteLock是什么"></a>ReadWriteLock是什么</h2><h2 id="Java中如何获取到线程dump文件"><a href="#Java中如何获取到线程dump文件" class="headerlink" title="Java中如何获取到线程dump文件"></a>Java中如何获取到线程dump文件</h2><h1 id="Java-8新特性"><a href="#Java-8新特性" class="headerlink" title="Java 8新特性"></a>Java 8新特性</h1><pre><code>1. HashMap/ConcurrentHashMap底层实现变了。

2. JVM中元空间取代了永久代。
    1. 元空间并不在JVM中了，而使用的是本地内存
    2. 默认情况下，元空间的大小仅受本地内存限制
    3. 可以通过-XX： MetaspaceSize指定元空间大小

3. 接口中可以有default的方法实体和static的方法实体

4. java.time包

5. Lambda表达式:允许将函数作为参数进行传递。
</code></pre>
      
    </div>
    
    
    
	
	<div>
      
        
      
	</div>
	
    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>Donate comment here</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="AbelChao WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:</strong>
    AbelChao
  </li>
  <li class="post-copyright-link">
    <strong>Post link:</strong>
    <a href="http://abelchao.com/2018/04/10/基础知识点总结/" title="基础知识点总结">http://abelchao.com/2018/04/10/基础知识点总结/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice: </strong>
    All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> unless stating additionally.
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaSE/" rel="tag"><i class="fa fa-tag"></i> JavaSE</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/08/华为OJ（六）/" rel="next" title="华为OJ（六）">
                <i class="fa fa-chevron-left"></i> 华为OJ（六）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/23/深入了解JVM/" rel="prev" title="深入了解JVM">
                深入了解JVM <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='//bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          
  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMTI2OS83ODE4"></div>
    </div>
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="AbelChao" />
            
              <p class="site-author-name" itemprop="name">AbelChao</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">115</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/AbelChao" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.facebook.com/" target="_blank" title="Facebook">
                    
                      <i class="fa fa-fw fa-facebook-square"></i>Facebook</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.douban.com/" target="_blank" title="Douban">
                    
                      <i class="fa fa-fw fa-rocket"></i>Douban</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/explore" target="_blank" title="ZhiHu">
                    
                      <i class="fa fa-fw fa-plane"></i>ZhiHu</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="http://weibo.com/" target="_blank" title="WeiBo">
                    
                      <i class="fa fa-fw fa-weibo"></i>WeiBo</a>
                </span>
              
            
          </div>

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-globe"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.github.com" title="Github" target="_blank">Github</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://weibo.com/" title="WeiBo" target="_blank">WeiBo</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基本概念"><span class="nav-number">1.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#三个基本特性"><span class="nav-number">1.1.</span> <span class="nav-text">三个基本特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六原则一法则"><span class="nav-number">1.2.</span> <span class="nav-text">六原则一法则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#平台无关性"><span class="nav-number">1.3.</span> <span class="nav-text">平台无关性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#javac和java"><span class="nav-number">1.4.</span> <span class="nav-text">javac和java</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String-args"><span class="nav-number">1.5.</span> <span class="nav-text">String[] args</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#public-static-void-main-String-args"><span class="nav-number">1.6.</span> <span class="nav-text">public static void main(String[] args){}</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#执行顺序"><span class="nav-number">1.7.</span> <span class="nav-text">执行顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this-super-this-super"><span class="nav-number">1.8.</span> <span class="nav-text">this/super/this()/super()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态的实现原理"><span class="nav-number">1.9.</span> <span class="nav-text">多态的实现原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重写和重载"><span class="nav-number">1.10.</span> <span class="nav-text">重写和重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#修饰符"><span class="nav-number">1.11.</span> <span class="nav-text">修饰符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关键字"><span class="nav-number">1.12.</span> <span class="nav-text">关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个Java文件定义多个类"><span class="nav-number">1.13.</span> <span class="nav-text">一个Java文件定义多个类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#构造器"><span class="nav-number">1.14.</span> <span class="nav-text">构造器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口和抽象类"><span class="nav-number">1.15.</span> <span class="nav-text">接口和抽象类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Clone"><span class="nav-number">1.16.</span> <span class="nav-text">Clone()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反射机制"><span class="nav-number">1.17.</span> <span class="nav-text">反射机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内部类"><span class="nav-number">1.18.</span> <span class="nav-text">内部类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this-super-this-super-1"><span class="nav-number">1.19.</span> <span class="nav-text">this/super/this()/super()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#final-finally-finalize"><span class="nav-number">1.20.</span> <span class="nav-text">final/finally/finalize</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始值"><span class="nav-number">1.21.</span> <span class="nav-text">初始值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Switch"><span class="nav-number">1.22.</span> <span class="nav-text">Switch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#值传递与引用传递"><span class="nav-number">1.23.</span> <span class="nav-text">值传递与引用传递</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#equals、hashCode、"><span class="nav-number">1.24.</span> <span class="nav-text">equals、hashCode、==</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#i-与-i"><span class="nav-number">1.25.</span> <span class="nav-text">i++与++i</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型通配符"><span class="nav-number">1.26.</span> <span class="nav-text">泛型通配符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#round、ceil、floor、DecimalFormat、BigInteger"><span class="nav-number">1.27.</span> <span class="nav-text">round、ceil、floor、DecimalFormat、BigInteger</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Volatile"><span class="nav-number">1.28.</span> <span class="nav-text">Volatile</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#核心API"><span class="nav-number">2.</span> <span class="nav-text">核心API</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本数据类型和其包装类"><span class="nav-number">2.1.</span> <span class="nav-text">基本数据类型和其包装类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#int和Integer的区别"><span class="nav-number">2.2.</span> <span class="nav-text">int和Integer的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#强制转换与包装类的equals方法"><span class="nav-number">2.3.</span> <span class="nav-text">强制转换与包装类的equals方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运算符优先级"><span class="nav-number">2.4.</span> <span class="nav-text">运算符优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String、StringBuilder、StringBuffer"><span class="nav-number">2.5.</span> <span class="nav-text">String、StringBuilder、StringBuffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String与Integer，Double，Long的进制转换"><span class="nav-number">2.6.</span> <span class="nav-text">String与Integer，Double，Long的进制转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String的intern（不好理解）"><span class="nav-number">2.7.</span> <span class="nav-text">String的intern（不好理解）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">2.8.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正则"><span class="nav-number">2.9.</span> <span class="nav-text">正则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#异常"><span class="nav-number">3.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#架构"><span class="nav-number">3.1.</span> <span class="nav-text">架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#throw和throws"><span class="nav-number">3.2.</span> <span class="nav-text">throw和throws</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#try-catch-finally"><span class="nav-number">3.3.</span> <span class="nav-text">try..catch..finally</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#finally什么时候不执行"><span class="nav-number">3.4.</span> <span class="nav-text">finally什么时候不执行</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IO"><span class="nav-number">4.</span> <span class="nav-text">IO</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分类"><span class="nav-number">4.1.</span> <span class="nav-text">分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#序列化-外部序列化与反序列化（针对对象）"><span class="nav-number">4.2.</span> <span class="nav-text">序列化/外部序列化与反序列化（针对对象）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Socket（重点，后面复习计算机网络的时候细看）"><span class="nav-number">4.3.</span> <span class="nav-text">Socket（重点，后面复习计算机网络的时候细看）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NIO"><span class="nav-number">4.4.</span> <span class="nav-text">NIO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#File类"><span class="nav-number">4.5.</span> <span class="nav-text">File类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#集合框架"><span class="nav-number">5.</span> <span class="nav-text">集合框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#架构-1"><span class="nav-number">5.1.</span> <span class="nav-text">架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List"><span class="nav-number">5.2.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList核心API"><span class="nav-number">5.3.</span> <span class="nav-text">ArrayList核心API</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List的遍历与删除"><span class="nav-number">5.4.</span> <span class="nav-text">List的遍历与删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList与LinkedList与Vector"><span class="nav-number">5.5.</span> <span class="nav-text">ArrayList与LinkedList与Vector</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#asList、subList、toArray"><span class="nav-number">5.6.</span> <span class="nav-text">asList、subList、toArray</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#asList"><span class="nav-number">5.6.1.</span> <span class="nav-text">asList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#subList"><span class="nav-number">5.6.2.</span> <span class="nav-text">subList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#toArray"><span class="nav-number">5.6.3.</span> <span class="nav-text">toArray</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Iterator和Iterable"><span class="nav-number">5.7.</span> <span class="nav-text">Iterator和Iterable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fast-fail"><span class="nav-number">5.8.</span> <span class="nav-text">fast-fail</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map"><span class="nav-number">5.9.</span> <span class="nav-text">Map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map的核心API与迭代"><span class="nav-number">5.10.</span> <span class="nav-text">Map的核心API与迭代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap"><span class="nav-number">5.11.</span> <span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap数据结构"><span class="nav-number">5.11.1.</span> <span class="nav-text">HashMap数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap源码分析"><span class="nav-number">5.11.2.</span> <span class="nav-text">HashMap源码分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set"><span class="nav-number">5.12.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection和Collections核心方法"><span class="nav-number">5.13.</span> <span class="nav-text">Collection和Collections核心方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程安全的集合（java-util-）"><span class="nav-number">5.14.</span> <span class="nav-text">线程安全的集合（java.util.*）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Comparable和Comparator"><span class="nav-number">5.15.</span> <span class="nav-text">Comparable和Comparator</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#线程（重点-OS-amp-Java）"><span class="nav-number">6.</span> <span class="nav-text">线程（重点 OS &amp; Java）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#线程和进程"><span class="nav-number">6.1.</span> <span class="nav-text">线程和进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么使用多线程"><span class="nav-number">6.2.</span> <span class="nav-text">为什么使用多线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程异步与同步"><span class="nav-number">6.3.</span> <span class="nav-text">线程异步与同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何实现同步"><span class="nav-number">6.4.</span> <span class="nav-text">如何实现同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程状态转换"><span class="nav-number">6.5.</span> <span class="nav-text">线程状态转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的实现方式"><span class="nav-number">6.6.</span> <span class="nav-text">线程的实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Thread与Runnable的区别"><span class="nav-number">6.6.1.</span> <span class="nav-text">Thread与Runnable的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Callable与Future"><span class="nav-number">6.6.2.</span> <span class="nav-text">Callable与Future</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#start与run"><span class="nav-number">6.7.</span> <span class="nav-text">start与run</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是锁（多线程同步实现方法有哪些）"><span class="nav-number">6.8.</span> <span class="nav-text">什么是锁（多线程同步实现方法有哪些）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized用在代码块和方法上有什么区别"><span class="nav-number">6.9.</span> <span class="nav-text">synchronized用在代码块和方法上有什么区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized与static-synchronized的区别"><span class="nav-number">6.10.</span> <span class="nav-text">synchronized与static synchronized的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized的缺陷"><span class="nav-number">6.11.</span> <span class="nav-text">synchronized的缺陷</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized的底层实现"><span class="nav-number">6.12.</span> <span class="nav-text">synchronized的底层实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sleep与wait"><span class="nav-number">6.13.</span> <span class="nav-text">sleep与wait</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sleep与yield"><span class="nav-number">6.14.</span> <span class="nav-text">sleep与yield</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁（OS，银行家算法）"><span class="nav-number">6.15.</span> <span class="nav-text">死锁（OS，银行家算法）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何保证线程安全"><span class="nav-number">6.16.</span> <span class="nav-text">如何保证线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程共用一个数据变量需要注意什么"><span class="nav-number">6.17.</span> <span class="nav-text">多线程共用一个数据变量需要注意什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Volatile如何保证内存可见性"><span class="nav-number">6.18.</span> <span class="nav-text">Volatile如何保证内存可见性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Volatile如何禁止指令重排序"><span class="nav-number">6.19.</span> <span class="nav-text">Volatile如何禁止指令重排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile和synchronized的区别"><span class="nav-number">6.20.</span> <span class="nav-text">volatile和synchronized的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Synchronized与lock"><span class="nav-number">6.21.</span> <span class="nav-text">Synchronized与lock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized和ReentrantLock-CAS-的区别"><span class="nav-number">6.22.</span> <span class="nav-text">synchronized和ReentrantLock(CAS)的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">6.23.</span> <span class="nav-text">ThreadLocal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是线程池"><span class="nav-number">6.24.</span> <span class="nav-text">什么是线程池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#守护线程"><span class="nav-number">6.25.</span> <span class="nav-text">守护线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JUC包"><span class="nav-number">6.26.</span> <span class="nav-text">JUC包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JUC包下的线程安全集合"><span class="nav-number">6.27.</span> <span class="nav-text">JUC包下的线程安全集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CopyOnWriteArrayList（线程安全的ArrayList）"><span class="nav-number">6.28.</span> <span class="nav-text">CopyOnWriteArrayList（线程安全的ArrayList）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CopyOnWriteArrayList的数据结构"><span class="nav-number">6.28.1.</span> <span class="nav-text">CopyOnWriteArrayList的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CopyOnWriteArrayList部分源码"><span class="nav-number">6.28.2.</span> <span class="nav-text">CopyOnWriteArrayList部分源码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-number">6.29.</span> <span class="nav-text">ConcurrentHashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap的数据结构（JDK1-7）"><span class="nav-number">6.29.1.</span> <span class="nav-text">ConcurrentHashMap的数据结构（JDK1.7）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap的数据结构（JDK1-8）"><span class="nav-number">6.29.2.</span> <span class="nav-text">ConcurrentHashMap的数据结构（JDK1.8）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap部分源码（JDK1-8）"><span class="nav-number">6.29.3.</span> <span class="nav-text">ConcurrentHashMap部分源码（JDK1.8）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#table原子操作"><span class="nav-number">6.29.3.1.</span> <span class="nav-text">table原子操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK1-7和JDK1-8的区别"><span class="nav-number">6.29.4.</span> <span class="nav-text">JDK1.7和JDK1.8的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ConcurrentHashMap的并发度是什么"><span class="nav-number">6.29.5.</span> <span class="nav-text">ConcurrentHashMap的并发度是什么</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#乐观锁与悲观锁"><span class="nav-number">6.30.</span> <span class="nav-text">乐观锁与悲观锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是AQS"><span class="nav-number">6.31.</span> <span class="nav-text">什么是AQS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是CAS"><span class="nav-number">6.32.</span> <span class="nav-text">什么是CAS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JMM"><span class="nav-number">6.33.</span> <span class="nav-text">JMM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier和CountDownLatch的区别"><span class="nav-number">6.34.</span> <span class="nav-text">CyclicBarrier和CountDownLatch的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReadWriteLock是什么"><span class="nav-number">6.35.</span> <span class="nav-text">ReadWriteLock是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中如何获取到线程dump文件"><span class="nav-number">6.36.</span> <span class="nav-text">Java中如何获取到线程dump文件</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-8新特性"><span class="nav-number">7.</span> <span class="nav-text">Java 8新特性</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AbelChao</span>

  
</div>


  <div class="powered-by">Powered By - Lemon_B</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">小小方 &mdash; <a class="theme-link" target="_blank" href="https://github.com/AbelChao" text-decoration=none>myGitHub</a></div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=1.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=1.0.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=1.0.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=1.0.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=1.0.0"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  
</body>
</html>
